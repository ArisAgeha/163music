/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/lib/loader.js!./src/css/app.scss":
/*!*********************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/lib/loader.js!./src/css/app.scss ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var escape = __webpack_require__(/*! ../../node_modules/css-loader/lib/url/escape.js */ \"./node_modules/css-loader/lib/url/escape.js\");\nexports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"@-webkit-keyframes circling {\\n  0% {\\n    -webkit-transform: rotate(0deg);\\n    transform: rotate(0deg); }\\n  to {\\n    -webkit-transform: rotate(1turn);\\n    transform: rotate(1turn); } }\\n\\n@keyframes circling {\\n  0% {\\n    -webkit-transform: rotate(0deg);\\n    transform: rotate(0deg); }\\n  to {\\n    -webkit-transform: rotate(1turn);\\n    transform: rotate(1turn); } }\\n\\n.icon {\\n  width: 1em;\\n  height: 1em;\\n  vertical-align: -0.15em;\\n  fill: currentColor;\\n  overflow: hidden; }\\n\\n* {\\n  border: 0;\\n  margin: 0;\\n  box-sizing: border-box; }\\n\\nul, ol {\\n  padding: 0;\\n  margin: 0; }\\n\\nli {\\n  list-style: none; }\\n\\na {\\n  text-decoration: none;\\n  color: inherit; }\\n\\ninput {\\n  outline: none;\\n  color: #555555;\\n  background-color: #f2f4f5; }\\n\\n@font-face {\\n  font-family: 'core_sans';\\n  src: url(\" + escape(__webpack_require__(/*! ../font/core_sans.woff2 */ \"./src/font/core_sans.woff2\")) + \"); }\\n\\nbody {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  right: 0;\\n  bottom: 0;\\n  font-size: 14px;\\n  line-height: 1.428;\\n  font-family: core_sans,\\\"Avenir Next\\\",\\\"Helvetica Neue\\\",Helvetica,Arial,\\\"PingFang SC\\\",\\\"Source Han Sans SC\\\",\\\"Hiragino Sans GB\\\",\\\"Microsoft YaHei\\\",\\\"WenQuanYi MicroHei\\\",sans-serif;\\n  display: flex;\\n  flex-direction: column; }\\n\\nheader {\\n  height: 105px; }\\n  header .title {\\n    height: 65px;\\n    background-color: #9c27b0;\\n    display: flex;\\n    justify-content: flex-start;\\n    align-items: center;\\n    font-size: 20px;\\n    color: white;\\n    padding: 0 20px; }\\n    header .title .logo {\\n      font-size: 40px;\\n      margin-right: 20px; }\\n    header .title .selfLogo {\\n      font-size: 18px; }\\n  header .tabPanel {\\n    display: flex;\\n    justify-content: space-around;\\n    align-items: center;\\n    height: 40px;\\n    background-color: #feffff; }\\n    header .tabPanel div {\\n      height: 100%;\\n      line-height: 40px;\\n      width: 75px;\\n      text-align: center;\\n      position: relative; }\\n    header .tabPanel .active {\\n      color: #9c27b0; }\\n    header .tabPanel .active::after {\\n      content: '';\\n      width: 100%;\\n      border-bottom: 3px solid #9c27b0;\\n      display: inline-block;\\n      position: absolute;\\n      bottom: 0;\\n      left: 0; }\\n\\nmain {\\n  height: 77%;\\n  background-color: #f2f4f5;\\n  overflow: auto;\\n  flex: 1; }\\n  main .discovery-main {\\n    display: none;\\n    flex-direction: column; }\\n    main .discovery-main .recommandList,\\n    main .discovery-main .recommandSongs {\\n      display: flex;\\n      flex-direction: column; }\\n      main .discovery-main .recommandList .introduction,\\n      main .discovery-main .recommandSongs .introduction {\\n        margin: 15px 0;\\n        font-size: 16px;\\n        position: relative;\\n        padding-left: 15px;\\n        vertical-align: middle; }\\n      main .discovery-main .recommandList .introduction::before,\\n      main .discovery-main .recommandSongs .introduction::before {\\n        content: '';\\n        height: 70%;\\n        border-left: 3px solid #9c27b0;\\n        display: inline-block;\\n        position: absolute;\\n        top: 15%;\\n        left: 0; }\\n      main .discovery-main .recommandList .exhibition,\\n      main .discovery-main .recommandSongs .exhibition {\\n        display: flex;\\n        justify-content: space-between;\\n        flex-wrap: wrap; }\\n        main .discovery-main .recommandList .exhibition .item,\\n        main .discovery-main .recommandSongs .exhibition .item {\\n          width: 32.8%;\\n          padding-bottom: 20px; }\\n          main .discovery-main .recommandList .exhibition .item .itemCover,\\n          main .discovery-main .recommandSongs .exhibition .item .itemCover {\\n            width: 100%;\\n            padding-bottom: 100%;\\n            position: relative;\\n            overflow: hidden; }\\n            main .discovery-main .recommandList .exhibition .item .itemCover img,\\n            main .discovery-main .recommandSongs .exhibition .item .itemCover img {\\n              height: 100%;\\n              min-width: 100%;\\n              position: absolute;\\n              top: 0;\\n              right: 0; }\\n          main .discovery-main .recommandList .exhibition .item .itemName,\\n          main .discovery-main .recommandSongs .exhibition .item .itemName {\\n            -webkit-line-clamp: 2;\\n            -webkit-box-orient: vertical;\\n            font-size: 12px;\\n            line-height: 1.2;\\n            display: -webkit-box;\\n            overflow: hidden;\\n            padding: 6px 2px 0 6px; }\\n    main .discovery-main .recommandSongs .exhibition .item {\\n      width: 49.0%; }\\n  main .discovery-main.show {\\n    display: flex; }\\n  main .user-main {\\n    min-height: 100%;\\n    display: none; }\\n    main .user-main .loginPanel {\\n      width: 100%;\\n      display: none;\\n      flex-direction: column;\\n      justify-content: flex-start;\\n      align-items: center; }\\n      main .user-main .loginPanel .login-username {\\n        width: 90%;\\n        padding-top: 40px;\\n        padding-bottom: 20px; }\\n      main .user-main .loginPanel .login-password {\\n        width: 90%; }\\n      main .user-main .loginPanel input {\\n        width: 100%;\\n        height: 24px;\\n        font-size: 14px;\\n        border-bottom: 1px solid #e6e9f0;\\n        color: black; }\\n      main .user-main .loginPanel .controlPanel {\\n        width: 90%;\\n        margin-top: 30px; }\\n        main .user-main .loginPanel .controlPanel div {\\n          width: 100%;\\n          border-radius: 999px;\\n          background-color: #9c27b0;\\n          height: 40px;\\n          margin: 20px 0;\\n          text-align: center;\\n          line-height: 40px;\\n          color: white;\\n          font-size: 16px; }\\n      main .user-main .loginPanel p {\\n        width: 70%;\\n        color: red; }\\n    main .user-main .userPanel {\\n      display: none;\\n      margin: 0 10px;\\n      width: 100%; }\\n      main .user-main .userPanel .myCollection {\\n        width: 100%; }\\n      main .user-main .userPanel .myCollection > li {\\n        display: flex;\\n        justify-content: space-between;\\n        align-items: center;\\n        width: 100%;\\n        border-bottom: 1px solid #e6e9f0; }\\n        main .user-main .userPanel .myCollection > li .collectionInformation {\\n          height: 55px;\\n          display: flex;\\n          align-items: center; }\\n          main .user-main .userPanel .myCollection > li .collectionInformation .cover {\\n            width: 55px;\\n            height: 100%;\\n            margin-right: 5px;\\n            display: flex;\\n            align-items: center; }\\n            main .user-main .userPanel .myCollection > li .collectionInformation .cover img {\\n              background-size: cover;\\n              background-repeat: no-repeat;\\n              height: 45px;\\n              weight: 45px; }\\n        main .user-main .userPanel .myCollection > li .deleteCollection {\\n          font-size: 16px; }\\n  main .user-main.show {\\n    display: flex; }\\n    main .user-main.show .loginPanel.show {\\n      display: flex; }\\n    main .user-main.show .userPanel.show {\\n      display: flex; }\\n  main .search-main {\\n    display: none;\\n    flex-direction: column;\\n    align-items: center;\\n    margin-top: 30px;\\n    min-height: 100%; }\\n    main .search-main input {\\n      font-size: 16px;\\n      height: 30px;\\n      width: 90%;\\n      border-bottom: 1px solid #e6e9f0; }\\n    main .search-main ol {\\n      width: 90%;\\n      display: flex;\\n      flex-direction: column; }\\n      main .search-main ol li {\\n        display: flex;\\n        flex-direction: column;\\n        border-bottom: 1px solid #e6e9f0;\\n        justify-content: center;\\n        height: 45px; }\\n        main .search-main ol li .songName {\\n          font-size: 16px; }\\n        main .search-main ol li .imformation {\\n          color: #555555;\\n          font-size: 10px; }\\n  main .search-main.show {\\n    display: flex; }\\n\\nfooter {\\n  height: 55px; }\\n  footer .musicplayer {\\n    display: flex;\\n    justify-content: space-between;\\n    align-items: center;\\n    margin-left: 10px;\\n    margin-right: 10px;\\n    height: 55px; }\\n    footer .musicplayer .songInformation {\\n      height: 45px;\\n      width: 80%;\\n      display: flex;\\n      align-items: center; }\\n      footer .musicplayer .songInformation .cover {\\n        height: 40px;\\n        width: 40px;\\n        background-color: #ddd;\\n        margin-right: 10px; }\\n      footer .musicplayer .songInformation .songInformation-text .artist {\\n        color: gray;\\n        font-size: 12px; }\\n      footer .musicplayer .songInformation .songInformation-text div {\\n        vertical-align: middle; }\\n    footer .musicplayer .songController {\\n      display: flex;\\n      align-items: center;\\n      min-width: 80px;\\n      height: 45px;\\n      justify-content: space-between;\\n      color: #4c4c4c;\\n      margin-right: 5px; }\\n      footer .musicplayer .songController .toggleButton {\\n        width: 30px;\\n        font-size: 30px; }\\n        footer .musicplayer .songController .toggleButton div {\\n          display: none; }\\n        footer .musicplayer .songController .toggleButton div.show {\\n          display: flex; }\\n      footer .musicplayer .songController .toplaylistButton {\\n        height: 30px;\\n        width: 30px;\\n        font-size: 30px;\\n        display: flex; }\\n  footer .toplaylistWrapper {\\n    display: none;\\n    position: fixed;\\n    top: 0;\\n    bottom: 0;\\n    left: 0;\\n    right: 0;\\n    z-index: 3;\\n    flex-direction: column; }\\n    footer .toplaylistWrapper .shadowArea {\\n      flex: 1;\\n      background-color: rgba(0, 0, 0, 0.6); }\\n    footer .toplaylistWrapper .toplaylist {\\n      padding: 0 10px;\\n      max-height: 66%;\\n      min-height: 100px;\\n      background-color: white;\\n      border-top: 4px solid gray;\\n      overflow: auto; }\\n      footer .toplaylistWrapper .toplaylist li {\\n        height: 50px;\\n        display: flex;\\n        align-items: center;\\n        justify-content: space-between;\\n        border-bottom: 1px solid #e6e9f0;\\n        font-size: 16px; }\\n        footer .toplaylistWrapper .toplaylist li .playingHint {\\n          display: none; }\\n        footer .toplaylistWrapper .toplaylist li .split, footer .toplaylistWrapper .toplaylist li .toplay-artist {\\n          font-size: 12px;\\n          color: gray; }\\n        footer .toplaylistWrapper .toplaylist li .toplay-deleteButton {\\n          font-size: 14px; }\\n      footer .toplaylistWrapper .toplaylist li.playing .playingHint {\\n        display: inline; }\\n      footer .toplaylistWrapper .toplaylist li.playing .playingHint, footer .toplaylistWrapper .toplaylist li.playing .toplay-songName, footer .toplaylistWrapper .toplaylist li.playing .split, footer .toplaylistWrapper .toplaylist li.playing .toplay-artist {\\n        color: #9c27b0; }\\n  footer .toplaylistWrapper.show {\\n    display: flex; }\\n\\n.collectionViewer {\\n  width: 100%;\\n  position: fixed;\\n  top: 0;\\n  right: 0;\\n  left: 0;\\n  bottom: 55px;\\n  background-color: #f2f4f5;\\n  display: none;\\n  flex-direction: column; }\\n  .collectionViewer .collectionHead {\\n    height: 50px;\\n    display: flex;\\n    align-items: center;\\n    justify-content: flex-start;\\n    color: #fff;\\n    padding: 0 15px;\\n    background-color: rgba(0, 0, 0, 0.4); }\\n    .collectionViewer .collectionHead svg {\\n      font-size: 25px;\\n      margin-right: 15px; }\\n    .collectionViewer .collectionHead .pageName {\\n      font-size: 16px; }\\n  .collectionViewer .collectionTheme {\\n    height: 180px;\\n    width: 100%;\\n    padding: 0 15px;\\n    display: flex;\\n    align-items: center;\\n    position: relative; }\\n    .collectionViewer .collectionTheme .cover {\\n      height: 150px;\\n      width: 150px;\\n      margin-right: 15px;\\n      z-index: 1; }\\n      .collectionViewer .collectionTheme .cover img {\\n        background-size: cover;\\n        background-repeat: no-repeat;\\n        height: 100%;\\n        weight: 100%; }\\n    .collectionViewer .collectionTheme .collectionTitle {\\n      color: #fff;\\n      font-size: 16px;\\n      height: 150px;\\n      padding-top: 20px;\\n      z-index: 1; }\\n    .collectionViewer .collectionTheme .background {\\n      position: absolute;\\n      left: 0;\\n      bottom: 0;\\n      right: 0;\\n      top: 0;\\n      background-image: url(\" + escape(__webpack_require__(/*! ../img/1.png */ \"./src/img/1.png\")) + \");\\n      background-position: 50%;\\n      background-repeat: no-repeat;\\n      filter: blur(20px);\\n      -webkit-filter: blur(20px);\\n      transform: scale(1.5);\\n      background-size: cover;\\n      z-index: -1; }\\n  .collectionViewer .collectionList {\\n    background-color: #f2f4f5;\\n    padding: 0 15px;\\n    z-index: 1;\\n    flex: 1; }\\n    .collectionViewer .collectionList .playAllWrapper {\\n      display: flex;\\n      align-items: center;\\n      justify-content: flex-start;\\n      height: 45px;\\n      border-bottom: 1px solid #e6e9f0; }\\n      .collectionViewer .collectionList .playAllWrapper .playAllButton {\\n        font-size: 18px;\\n        padding-right: 15px; }\\n      .collectionViewer .collectionList .playAllWrapper .playAllText {\\n        font-size: 16px; }\\n    .collectionViewer .collectionList .songList {\\n      width: 100%; }\\n      .collectionViewer .collectionList .songList li {\\n        display: flex;\\n        flex-direction: column;\\n        border-bottom: 1px solid #e6e9f0;\\n        justify-content: center;\\n        height: 55px; }\\n        .collectionViewer .collectionList .songList li .songName {\\n          font-size: 16px; }\\n        .collectionViewer .collectionList .songList li .imformation {\\n          color: #555555;\\n          font-size: 10px; }\\n\\n.collectionViewer.show {\\n  display: flex; }\\n\\n.playController {\\n  display: none;\\n  flex-direction: column;\\n  position: fixed;\\n  padding: 5px 10px;\\n  top: 0;\\n  left: 0;\\n  right: 0;\\n  bottom: 0;\\n  z-index: 2; }\\n  .playController .background {\\n    background-image: url(\" + escape(__webpack_require__(/*! ../img/1.png */ \"./src/img/1.png\")) + \");\\n    background-position: 50%;\\n    background-repeat: no-repeat;\\n    filter: blur(40px);\\n    transform: scale(1.5);\\n    background-size: cover;\\n    position: absolute;\\n    z-index: -1;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    bottom: 0; }\\n  .playController .head {\\n    height: 60px;\\n    display: flex;\\n    justify-content: flex-start;\\n    align-items: center;\\n    background-color: rgba(0, 0, 0, 0.4);\\n    margin: -5px -10px;\\n    padding: 5px 10px;\\n    border-bottom: 1px solid rgba(230, 233, 240, 0.1); }\\n    .playController .head .returnButton {\\n      height: 40px;\\n      width: 40px;\\n      display: flex;\\n      justify-content: center;\\n      align-items: center;\\n      font-size: 25px;\\n      color: #fff; }\\n    .playController .head .songInformation {\\n      display: flex;\\n      height: 50px;\\n      flex-direction: column;\\n      justify-content: center;\\n      padding-left: 10px;\\n      flex: 1; }\\n      .playController .head .songInformation .songName {\\n        width: 60%;\\n        overflow: hidden;\\n        white-space: nowrap;\\n        text-overflow: ellipsis;\\n        font-size: 18px;\\n        color: #fff; }\\n      .playController .head .songInformation .artist {\\n        width: 60%;\\n        overflow: hidden;\\n        white-space: nowrap;\\n        text-overflow: ellipsis;\\n        font-size: 14px;\\n        color: #bbbbbb; }\\n  .playController .discWrapper {\\n    flex: 1;\\n    display: flex;\\n    width: 100%;\\n    justify-content: center;\\n    align-items: center; }\\n    .playController .discWrapper .disc {\\n      width: 250px;\\n      height: 250px;\\n      background-image: url(\" + escape(__webpack_require__(/*! ../img/dist.png */ \"./src/img/dist.png\")) + \");\\n      background-size: cover;\\n      background-repeat: no-repeat;\\n      z-index: -1;\\n      overflow: hidden;\\n      position: relative; }\\n      @media (min-width: 414px) {\\n        .playController .discWrapper .disc {\\n          width: 350px;\\n          height: 350px; } }\\n      @media (min-width: 360px) {\\n        .playController .discWrapper .disc {\\n          width: 300px;\\n          height: 300px; } }\\n      .playController .discWrapper .disc .coverWrapper {\\n        width: 250px;\\n        height: 250px;\\n        border-radius: 50%;\\n        overflow: hidden;\\n        position: relative;\\n        transform: scale(0.65); }\\n        @media (min-width: 414px) {\\n          .playController .discWrapper .disc .coverWrapper {\\n            width: 350px;\\n            height: 350px; } }\\n        @media (min-width: 360px) {\\n          .playController .discWrapper .disc .coverWrapper {\\n            width: 300px;\\n            height: 300px; } }\\n        .playController .discWrapper .disc .coverWrapper .cover {\\n          position: absolute;\\n          background-size: contain;\\n          height: 100%;\\n          width: 100%; }\\n      .playController .discWrapper .disc .disc-light {\\n        width: 250px;\\n        height: 250px;\\n        top: 0;\\n        left: 0;\\n        background-image: url(\" + escape(__webpack_require__(/*! ../img/dist-light.png */ \"./src/img/dist-light.png\")) + \");\\n        background-size: cover;\\n        background-repeat: no-repeat;\\n        position: absolute;\\n        z-index: -1; }\\n        @media (min-width: 414px) {\\n          .playController .discWrapper .disc .disc-light {\\n            width: 350px;\\n            height: 350px; } }\\n        @media (min-width: 360px) {\\n          .playController .discWrapper .disc .disc-light {\\n            width: 300px;\\n            height: 300px; } }\\n    .playController .discWrapper .disc.playing {\\n      animation: circling 20s infinite linear;\\n      -webkit-animation: circling 20s infinite linear; }\\n  .playController .controlPanel {\\n    height: 100px;\\n    display: flex;\\n    flex-direction: column;\\n    padding: 0 10px;\\n    justify-content: space-around; }\\n    .playController .controlPanel .progressBar {\\n      width: 100%;\\n      height: 3px;\\n      position: relative; }\\n      .playController .controlPanel .progressBar .totalBar {\\n        height: 3px;\\n        background-color: #fff;\\n        position: absolute;\\n        width: 100%; }\\n      .playController .controlPanel .progressBar .currentBar {\\n        height: 3px;\\n        background-color: #9c27b0;\\n        position: absolute;\\n        width: 40%; }\\n      .playController .controlPanel .progressBar .currentBar::before,\\n      .playController .controlPanel .progressBar .currentBar::after {\\n        content: '';\\n        height: 15px;\\n        width: 15px;\\n        border-radius: 100%;\\n        display: inline-block;\\n        background-color: #fff;\\n        position: absolute;\\n        right: -6px;\\n        top: -6px; }\\n      .playController .controlPanel .progressBar .currentBar::after {\\n        background-color: #9c27b0;\\n        transform: scale(0.4); }\\n    .playController .controlPanel .controlButton {\\n      display: flex;\\n      justify-content: space-between;\\n      font-size: 25px;\\n      color: #fff;\\n      align-items: center; }\\n      .playController .controlPanel .controlButton .addToCollection,\\n      .playController .controlPanel .controlButton .listMenu {\\n        font-size: 25px; }\\n      .playController .controlPanel .controlButton .nextSong,\\n      .playController .controlPanel .controlButton .prevSong {\\n        font-size: 35px; }\\n      .playController .controlPanel .controlButton .toggle {\\n        font-size: 45px; }\\n      .playController .controlPanel .controlButton .toggle > svg {\\n        display: none; }\\n      .playController .controlPanel .controlButton .toggle > svg.show {\\n        display: inline; }\\n\\n.playController.show {\\n  display: flex; }\\n\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY3NzL2FwcC5zY3NzP2E2MzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHNEQUF1RCxRQUFRLHNDQUFzQyw4QkFBOEIsRUFBRSxRQUFRLHVDQUF1QywrQkFBK0IsRUFBRSxFQUFFLHlCQUF5QixRQUFRLHNDQUFzQyw4QkFBOEIsRUFBRSxRQUFRLHVDQUF1QywrQkFBK0IsRUFBRSxFQUFFLFdBQVcsZUFBZSxnQkFBZ0IsNEJBQTRCLHVCQUF1QixxQkFBcUIsRUFBRSxPQUFPLGNBQWMsY0FBYywyQkFBMkIsRUFBRSxZQUFZLGVBQWUsY0FBYyxFQUFFLFFBQVEscUJBQXFCLEVBQUUsT0FBTywwQkFBMEIsbUJBQW1CLEVBQUUsV0FBVyxrQkFBa0IsbUJBQW1CLDhCQUE4QixFQUFFLGdCQUFnQiw2QkFBNkIsK0dBQWlFLEVBQUUsVUFBVSx1QkFBdUIsV0FBVyxZQUFZLGFBQWEsY0FBYyxvQkFBb0IsdUJBQXVCLGdNQUFnTSxrQkFBa0IsMkJBQTJCLEVBQUUsWUFBWSxrQkFBa0IsRUFBRSxtQkFBbUIsbUJBQW1CLGdDQUFnQyxvQkFBb0Isa0NBQWtDLDBCQUEwQixzQkFBc0IsbUJBQW1CLHNCQUFzQixFQUFFLDJCQUEyQix3QkFBd0IsMkJBQTJCLEVBQUUsK0JBQStCLHdCQUF3QixFQUFFLHNCQUFzQixvQkFBb0Isb0NBQW9DLDBCQUEwQixtQkFBbUIsZ0NBQWdDLEVBQUUsNEJBQTRCLHFCQUFxQiwwQkFBMEIsb0JBQW9CLDJCQUEyQiwyQkFBMkIsRUFBRSxnQ0FBZ0MsdUJBQXVCLEVBQUUsdUNBQXVDLG9CQUFvQixvQkFBb0IseUNBQXlDLDhCQUE4QiwyQkFBMkIsa0JBQWtCLGdCQUFnQixFQUFFLFVBQVUsZ0JBQWdCLDhCQUE4QixtQkFBbUIsWUFBWSxFQUFFLDBCQUEwQixvQkFBb0IsNkJBQTZCLEVBQUUsc0ZBQXNGLHNCQUFzQiwrQkFBK0IsRUFBRSxzSEFBc0gseUJBQXlCLDBC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b0JBQW9CLDJCQUEyQixFQUFFLDhEQUE4RCxzQkFBc0IsaUNBQWlDLDZCQUE2QixzQkFBc0IsRUFBRSxnRUFBZ0Usc0JBQXNCLG9DQUFvQyw2QkFBNkIscUJBQXFCLEVBQUUsOElBQThJLHNCQUFzQix1QkFBdUIsc0JBQXNCLDhCQUE4QixnQ0FBZ0MsaUNBQWlDLDZCQUE2QixzQkFBc0Isb0JBQW9CLEVBQUUsdUVBQXVFLG9DQUFvQyxnQ0FBZ0MsRUFBRSxvREFBb0Qsc0JBQXNCLHVDQUF1Qyx3QkFBd0Isb0JBQW9CLDRCQUE0QixFQUFFLHNJQUFzSSwwQkFBMEIsRUFBRSwrSEFBK0gsMEJBQTBCLEVBQUUsOERBQThELDBCQUEwQixFQUFFLG9FQUFvRSx3QkFBd0IsRUFBRSx5RUFBeUUsMEJBQTBCLEVBQUUsMEJBQTBCLGtCQUFrQixFQUFFOztBQUVwb21CIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL3NyYy9jc3MvYXBwLnNjc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZXNjYXBlID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi91cmwvZXNjYXBlLmpzXCIpO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJALXdlYmtpdC1rZXlmcmFtZXMgY2lyY2xpbmcge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxcbiAgdG8ge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDF0dXJuKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMXR1cm4pOyB9IH1cXG5cXG5Aa2V5ZnJhbWVzIGNpcmNsaW5nIHtcXG4gIDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH1cXG4gIHRvIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgxdHVybik7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDF0dXJuKTsgfSB9XFxuXFxuLmljb24ge1xcbiAgd2lkdGg6IDFlbTtcXG4gIGhlaWdodDogMWVtO1xcbiAgdmVydGljYWwtYWxpZ246IC0wLjE1ZW07XFxuICBmaWxsOiBjdXJyZW50Q29sb3I7XFxuICBvdmVyZmxvdzogaGlkZGVuOyB9XFxuXFxuKiB7XFxuICBib3JkZXI6IDA7XFxuICBtYXJnaW46IDA7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9XFxuXFxudWwsIG9sIHtcXG4gIHBhZGRpbmc6IDA7XFxuICBtYXJnaW46IDA7IH1cXG5cXG5saSB7XFxuICBsaXN0LXN0eWxlOiBub25lOyB9XFxuXFxuYSB7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICBjb2xvcjogaW5oZXJpdDsgfVxcblxcbmlucHV0IHtcXG4gIG91dGxpbmU6IG5vbmU7XFxuICBjb2xvcjogIzU1NTU1NTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmMmY0ZjU7IH1cXG5cXG5AZm9udC1mYWNlIHtcXG4gIGZvbnQtZmFtaWx5OiAnY29yZV9zYW5zJztcXG4gIHNyYzogdXJsKFwiICsgZXNjYXBlKHJlcXVpcmUoXCIuLi9mb250L2NvcmVfc2Fucy53b2ZmMlwiKSkgKyBcIik7IH1cXG5cXG5ib2R5IHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIGJvdHRvbTogMDtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGxpbmUtaGVpZ2h0OiAxLjQyODtcXG4gIGZvbnQtZmFtaWx5OiBjb3JlX3NhbnMsXFxcIkF2ZW5pciBOZXh0XFxcIixcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLEhlbHZldGljYSxBcmlhbCxcXFwiUGluZ0ZhbmcgU0NcXFwiLFxcXCJTb3VyY2UgSGFuIFNhbnMgU0NcXFwiLFxcXCJIaXJhZ2lubyBTYW5zIEdCXFxcIixcXFwiTWljcm9zb2Z0IFlhSGVpXFxcIixcXFwiV2VuUXVhbllpIE1pY3JvSGVpXFxcIixzYW5zLXNlcmlmO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IH1cXG5cXG5oZWFkZXIge1xcbiAgaGVpZ2h0OiAxMDVweDsgfVxcbiAgaGVhZGVyIC50aXRsZSB7XFxuICAgIGhlaWdodDogNjVweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzljMjdiMDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBmb250LXNpemU6IDIwcHg7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG4gICAgcGFkZGluZzogMCAyMHB4OyB9XFxuICAgIGhlYWRlciAudGl0bGUgLmxvZ28ge1xcbiAgICAgIGZvbnQtc2l6ZTogNDBweDtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDIwcHg7IH1cXG4gICAgaGVhZGVyIC50aXRsZSAuc2VsZkxvZ28ge1xcbiAgICAgIGZvbnQtc2l6ZTogMThweDsgfVxcbiAgaGVhZGVyIC50YWJQYW5lbCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBoZWlnaHQ6IDQwcHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZWZmZmY7IH1cXG4gICAgaGVhZGVyIC50YWJQYW5lbCBkaXYge1xcbiAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICBsaW5lLWhlaWdodDogNDBweDtcXG4gICAgICB3aWR0aDogNzVweDtcXG4gICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICAgIGhlYWRlciAudGFiUGFuZWwgLmFjdGl2ZSB7XFxuICAgICAgY29sb3I6ICM5YzI3YjA7IH1cXG4gICAgaGVhZGVyIC50YWJQYW5lbCAuYWN0aXZlOjphZnRlciB7XFxuICAgICAgY29udGVudDogJyc7XFxuICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgYm9yZGVyLWJvdHRvbTogM3B4IHNvbGlkICM5YzI3YjA7XFxuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICBib3R0b206IDA7XFxuICAgICAgbGVmdDogMDsgfVxcblxcbm1haW4ge1xcbiAgaGVpZ2h0OiA3NyU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjJmNGY1O1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxuICBmbGV4OiAxOyB9XFxuICBtYWluIC5kaXNjb3ZlcnktbWFpbiB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IH1cXG4gICAgbWFpbiAuZGlzY292ZXJ5LW1haW4gLnJlY29tbWFuZExpc3QsXFxuICAgIG1haW4gLmRpc2NvdmVyeS1tYWluIC5yZWNvbW1hbmRTb25ncyB7XFxuICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyB9XFxuICAgICAgbWFpbiAuZGlzY292ZXJ5LW1haW4gLnJlY29tbWFuZExpc3QgLmludHJvZHVjdGlvbixcXG4gICAgICBtYWluIC5kaXNjb3ZlcnktbWFpbiAucmVjb21tYW5kU29uZ3MgLmludHJvZHVjdGlvbiB7XFxuICAgICAgICBtYXJnaW46IDE1cHggMDtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgIHBhZGRpbmctbGVmdDogMTVweDtcXG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH1cXG4gICAgICBtYWluIC5kaXNjb3ZlcnktbWFpbiAucmVjb21tYW5kTGlzdCAuaW50cm9kdWN0aW9uOjpiZWZvcmUsXFxuICAgICAgbWFpbiAuZGlzY292ZXJ5LW1haW4gLnJlY29tbWFuZFNvbmdzIC5pbnRyb2R1Y3Rpb246OmJlZm9yZSB7XFxuICAgICAgICBjb250ZW50OiAnJztcXG4gICAgICAgIGhlaWdodDogNzAlO1xcbiAgICAgICAgYm9yZGVyLWxlZnQ6IDNweCBzb2xpZCAjOWMyN2IwO1xcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgdG9wOiAxNSU7XFxuICAgICAgICBsZWZ0OiAwOyB9XFxuICAgICAgbWFpbiAuZGlzY292ZXJ5LW1haW4gLnJlY29tbWFuZExpc3QgLmV4aGliaXRpb24sXFxuICAgICAgbWFpbiAuZGlzY292ZXJ5LW1haW4gLnJlY29tbWFuZFNvbmdzIC5leGhpYml0aW9uIHtcXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgICAgICBmbGV4LXdyYXA6IHdyYXA7IH1cXG4gICAgICAgIG1haW4gLmRpc2NvdmVyeS1tYWluIC5yZWNvbW1hbmRMaXN0IC5leGhpYml0aW9uIC5pdGVtLFxcbiAgICAgICAgbWFpbiAuZGlzY292ZXJ5LW1haW4gLnJlY29tbWFuZFNvbmdzIC5leGhpYml0aW9uIC5pdGVtIHtcXG4gICAgICAgICAgd2lkdGg6IDMyLjglO1xcbiAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogMjBweDsgfVxcbiAgICAgICAgICBtYWluIC5kaXNjb3ZlcnktbWFpbiAucmVjb21tYW5kTGlzdCAuZXhoaWJpdGlvbiAuaXRlbSAuaXRlbUNvdmVyLFxcbiAgICAgICAgICBtYWluIC5kaXNjb3ZlcnktbWFpbiAucmVjb21tYW5kU29uZ3MgLmV4aGliaXRpb24gLml0ZW0gLml0ZW1Db3ZlciB7XFxuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206IDEwMCU7XFxuICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47IH1cXG4gICAgICAgICAgICBtYWluIC5kaXNjb3ZlcnktbWFpbiAucmVjb21tYW5kTGlzdCAuZXhoaWJpdGlvbiAuaXRlbSAuaXRlbUNvdmVyIGltZyxcXG4gICAgICAgICAgICBtYWluIC5kaXNjb3ZlcnktbWFpbiAucmVjb21tYW5kU29uZ3MgLmV4aGliaXRpb24gLml0ZW0gLml0ZW1Db3ZlciBpbWcge1xcbiAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICAgICAgICAgICAgbWluLXdpZHRoOiAxMDAlO1xcbiAgICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgICAgICAgdG9wOiAwO1xcbiAgICAgICAgICAgICAgcmlnaHQ6IDA7IH1cXG4gICAgICAgICAgbWFpbiAuZGlzY292ZXJ5LW1haW4gLnJlY29tbWFuZExpc3QgLmV4aGliaXRpb24gLml0ZW0gLml0ZW1OYW1lLFxcbiAgICAgICAgICBtYWluIC5kaXNjb3ZlcnktbWFpbiAucmVjb21tYW5kU29uZ3MgLmV4aGliaXRpb24gLml0ZW0gLml0ZW1OYW1lIHtcXG4gICAgICAgICAgICAtd2Via2l0LWxpbmUtY2xhbXA6IDI7XFxuICAgICAgICAgICAgLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcXG4gICAgICAgICAgICBmb250LXNpemU6IDEycHg7XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEuMjtcXG4gICAgICAgICAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcXG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgICAgICAgIHBhZGRpbmc6IDZweCAycHggMCA2cHg7IH1cXG4gICAgbWFpbiAuZGlzY292ZXJ5LW1haW4gLnJlY29tbWFuZFNvbmdzIC5leGhpYml0aW9uIC5pdGVtIHtcXG4gICAgICB3aWR0aDogNDkuMCU7IH1cXG4gIG1haW4gLmRpc2NvdmVyeS1tYWluLnNob3cge1xcbiAgICBkaXNwbGF5OiBmbGV4OyB9XFxuICBtYWluIC51c2VyLW1haW4ge1xcbiAgICBtaW4taGVpZ2h0OiAxMDAlO1xcbiAgICBkaXNwbGF5OiBub25lOyB9XFxuICAgIG1haW4gLnVzZXItbWFpbiAubG9naW5QYW5lbCB7XFxuICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgZGlzcGxheTogbm9uZTtcXG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyOyB9XFxuICAgICAgbWFpbiAudXNlci1tYWluIC5sb2dpblBhbmVsIC5sb2dpbi11c2VybmFtZSB7XFxuICAgICAgICB3aWR0aDogOTAlO1xcbiAgICAgICAgcGFkZGluZy10b3A6IDQwcHg7XFxuICAgICAgICBwYWRkaW5nLWJvdHRvbTogMjBweDsgfVxcbiAgICAgIG1haW4gLnVzZXItbWFpbiAubG9naW5QYW5lbCAubG9naW4tcGFzc3dvcmQge1xcbiAgICAgICAgd2lkdGg6IDkwJTsgfVxcbiAgICAgIG1haW4gLnVzZXItbWFpbiAubG9naW5QYW5lbCBpbnB1dCB7XFxuICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgIGhlaWdodDogMjRweDtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZTZlOWYwO1xcbiAgICAgICAgY29sb3I6IGJsYWNrOyB9XFxuICAgICAgbWFpbiAudXNlci1tYWluIC5sb2dpblBhbmVsIC5jb250cm9sUGFuZWwge1xcbiAgICAgICAgd2lkdGg6IDkwJTtcXG4gICAgICAgIG1hcmdpbi10b3A6IDMwcHg7IH1cXG4gICAgICAgIG1haW4gLnVzZXItbWFpbiAubG9naW5QYW5lbCAuY29udHJvbFBhbmVsIGRpdiB7XFxuICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiA5OTlweDtcXG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzljMjdiMDtcXG4gICAgICAgICAgaGVpZ2h0OiA0MHB4O1xcbiAgICAgICAgICBtYXJnaW46IDIwcHggMDtcXG4gICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogNDBweDtcXG4gICAgICAgICAgY29sb3I6IHdoaXRlO1xcbiAgICAgICAgICBmb250LXNpemU6IDE2cHg7IH1cXG4gICAgICBtYWluIC51c2VyLW1haW4gLmxvZ2luUGFuZWwgcCB7XFxuICAgICAgICB3aWR0aDogNzAlO1xcbiAgICAgICAgY29sb3I6IHJlZDsgfVxcbiAgICBtYWluIC51c2VyLW1haW4gLnVzZXJQYW5lbCB7XFxuICAgICAgZGlzcGxheTogbm9uZTtcXG4gICAgICBtYXJnaW46IDAgMTBweDtcXG4gICAgICB3aWR0aDogMTAwJTsgfVxcbiAgICAgIG1haW4gLnVzZXItbWFpbiAudXNlclBhbmVsIC5teUNvbGxlY3Rpb24ge1xcbiAgICAgICAgd2lkdGg6IDEwMCU7IH1cXG4gICAgICBtYWluIC51c2VyLW1haW4gLnVzZXJQYW5lbCAubXlDb2xsZWN0aW9uID4gbGkge1xcbiAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZTZlOWYwOyB9XFxuICAgICAgICBtYWluIC51c2VyLW1haW4gLnVzZXJQYW5lbCAubXlDb2xsZWN0aW9uID4gbGkgLmNvbGxlY3Rpb25JbmZvcm1hdGlvbiB7XFxuICAgICAgICAgIGhlaWdodDogNTVweDtcXG4gICAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjsgfVxcbiAgICAgICAgICBtYWluIC51c2VyLW1haW4gLnVzZXJQYW5lbCAubXlDb2xsZWN0aW9uID4gbGkgLmNvbGxlY3Rpb25JbmZvcm1hdGlvbiAuY292ZXIge1xcbiAgICAgICAgICAgIHdpZHRoOiA1NXB4O1xcbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcXG4gICAgICAgICAgICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7IH1cXG4gICAgICAgICAgICBtYWluIC51c2VyLW1haW4gLnVzZXJQYW5lbCAubXlDb2xsZWN0aW9uID4gbGkgLmNvbGxlY3Rpb25JbmZvcm1hdGlvbiAuY292ZXIgaW1nIHtcXG4gICAgICAgICAgICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgICAgICAgICAgICAgaGVpZ2h0OiA0NXB4O1xcbiAgICAgICAgICAgICAgd2VpZ2h0OiA0NXB4OyB9XFxuICAgICAgICBtYWluIC51c2VyLW1haW4gLnVzZXJQYW5lbCAubXlDb2xsZWN0aW9uID4gbGkgLmRlbGV0ZUNvbGxlY3Rpb24ge1xcbiAgICAgICAgICBmb250LXNpemU6IDE2cHg7IH1cXG4gIG1haW4gLnVzZXItbWFpbi5zaG93IHtcXG4gICAgZGlzcGxheTogZmxleDsgfVxcbiAgICBtYWluIC51c2VyLW1haW4uc2hvdyAubG9naW5QYW5lbC5zaG93IHtcXG4gICAgICBkaXNwbGF5OiBmbGV4OyB9XFxuICAgIG1haW4gLnVzZXItbWFpbi5zaG93IC51c2VyUGFuZWwuc2hvdyB7XFxuICAgICAgZGlzcGxheTogZmxleDsgfVxcbiAgbWFpbiAuc2VhcmNoLW1haW4ge1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBtYXJnaW4tdG9wOiAzMHB4O1xcbiAgICBtaW4taGVpZ2h0OiAxMDAlOyB9XFxuICAgIG1haW4gLnNlYXJjaC1tYWluIGlucHV0IHtcXG4gICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgaGVpZ2h0OiAzMHB4O1xcbiAgICAgIHdpZHRoOiA5MCU7XFxuICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlNmU5ZjA7IH1cXG4gICAgbWFpbiAuc2VhcmNoLW1haW4gb2wge1xcbiAgICAgIHdpZHRoOiA5MCU7XFxuICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyB9XFxuICAgICAgbWFpbiAuc2VhcmNoLW1haW4gb2wgbGkge1xcbiAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2U2ZTlmMDtcXG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICAgICAgaGVpZ2h0OiA0NXB4OyB9XFxuICAgICAgICBtYWluIC5zZWFyY2gtbWFpbiBvbCBsaSAuc29uZ05hbWUge1xcbiAgICAgICAgICBmb250LXNpemU6IDE2cHg7IH1cXG4gICAgICAgIG1haW4gLnNlYXJjaC1tYWluIG9sIGxpIC5pbWZvcm1hdGlvbiB7XFxuICAgICAgICAgIGNvbG9yOiAjNTU1NTU1O1xcbiAgICAgICAgICBmb250LXNpemU6IDEwcHg7IH1cXG4gIG1haW4gLnNlYXJjaC1tYWluLnNob3cge1xcbiAgICBkaXNwbGF5OiBmbGV4OyB9XFxuXFxuZm9vdGVyIHtcXG4gIGhlaWdodDogNTVweDsgfVxcbiAgZm9vdGVyIC5tdXNpY3BsYXllciB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxuICAgIG1hcmdpbi1yaWdodDogMTBweDtcXG4gICAgaGVpZ2h0OiA1NXB4OyB9XFxuICAgIGZvb3RlciAubXVzaWNwbGF5ZXIgLnNvbmdJbmZvcm1hdGlvbiB7XFxuICAgICAgaGVpZ2h0OiA0NXB4O1xcbiAgICAgIHdpZHRoOiA4MCU7XFxuICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyOyB9XFxuICAgICAgZm9vdGVyIC5tdXNpY3BsYXllciAuc29uZ0luZm9ybWF0aW9uIC5jb3ZlciB7XFxuICAgICAgICBoZWlnaHQ6IDQwcHg7XFxuICAgICAgICB3aWR0aDogNDBweDtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNkZGQ7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDEwcHg7IH1cXG4gICAgICBmb290ZXIgLm11c2ljcGxheWVyIC5zb25nSW5mb3JtYXRpb24gLnNvbmdJbmZvcm1hdGlvbi10ZXh0IC5hcnRpc3Qge1xcbiAgICAgICAgY29sb3I6IGdyYXk7XFxuICAgICAgICBmb250LXNpemU6IDEycHg7IH1cXG4gICAgICBmb290ZXIgLm11c2ljcGxheWVyIC5zb25nSW5mb3JtYXRpb24gLnNvbmdJbmZvcm1hdGlvbi10ZXh0IGRpdiB7XFxuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9XFxuICAgIGZvb3RlciAubXVzaWNwbGF5ZXIgLnNvbmdDb250cm9sbGVyIHtcXG4gICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgbWluLXdpZHRoOiA4MHB4O1xcbiAgICAgIGhlaWdodDogNDVweDtcXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgICAgY29sb3I6ICM0YzRjNGM7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiA1cHg7IH1cXG4gICAgICBmb290ZXIgLm11c2ljcGxheWVyIC5zb25nQ29udHJvbGxlciAudG9nZ2xlQnV0dG9uIHtcXG4gICAgICAgIHdpZHRoOiAzMHB4O1xcbiAgICAgICAgZm9udC1zaXplOiAzMHB4OyB9XFxuICAgICAgICBmb290ZXIgLm11c2ljcGxheWVyIC5zb25nQ29udHJvbGxlciAudG9nZ2xlQnV0dG9uIGRpdiB7XFxuICAgICAgICAgIGRpc3BsYXk6IG5vbmU7IH1cXG4gICAgICAgIGZvb3RlciAubXVzaWNwbGF5ZXIgLnNvbmdDb250cm9sbGVyIC50b2dnbGVCdXR0b24gZGl2LnNob3cge1xcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4OyB9XFxuICAgICAgZm9vdGVyIC5tdXNpY3BsYXllciAuc29uZ0NvbnRyb2xsZXIgLnRvcGxheWxpc3RCdXR0b24ge1xcbiAgICAgICAgaGVpZ2h0OiAzMHB4O1xcbiAgICAgICAgd2lkdGg6IDMwcHg7XFxuICAgICAgICBmb250LXNpemU6IDMwcHg7XFxuICAgICAgICBkaXNwbGF5OiBmbGV4OyB9XFxuICBmb290ZXIgLnRvcGxheWxpc3RXcmFwcGVyIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB0b3A6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIHotaW5kZXg6IDM7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IH1cXG4gICAgZm9vdGVyIC50b3BsYXlsaXN0V3JhcHBlciAuc2hhZG93QXJlYSB7XFxuICAgICAgZmxleDogMTtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNik7IH1cXG4gICAgZm9vdGVyIC50b3BsYXlsaXN0V3JhcHBlciAudG9wbGF5bGlzdCB7XFxuICAgICAgcGFkZGluZzogMCAxMHB4O1xcbiAgICAgIG1heC1oZWlnaHQ6IDY2JTtcXG4gICAgICBtaW4taGVpZ2h0OiAxMDBweDtcXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gICAgICBib3JkZXItdG9wOiA0cHggc29saWQgZ3JheTtcXG4gICAgICBvdmVyZmxvdzogYXV0bzsgfVxcbiAgICAgIGZvb3RlciAudG9wbGF5bGlzdFdyYXBwZXIgLnRvcGxheWxpc3QgbGkge1xcbiAgICAgICAgaGVpZ2h0OiA1MHB4O1xcbiAgICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2U2ZTlmMDtcXG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDsgfVxcbiAgICAgICAgZm9vdGVyIC50b3BsYXlsaXN0V3JhcHBlciAudG9wbGF5bGlzdCBsaSAucGxheWluZ0hpbnQge1xcbiAgICAgICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAgICAgICBmb290ZXIgLnRvcGxheWxpc3RXcmFwcGVyIC50b3BsYXlsaXN0IGxpIC5zcGxpdCwgZm9vdGVyIC50b3BsYXlsaXN0V3JhcHBlciAudG9wbGF5bGlzdCBsaSAudG9wbGF5LWFydGlzdCB7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgICAgICAgY29sb3I6IGdyYXk7IH1cXG4gICAgICAgIGZvb3RlciAudG9wbGF5bGlzdFdyYXBwZXIgLnRvcGxheWxpc3QgbGkgLnRvcGxheS1kZWxldGVCdXR0b24ge1xcbiAgICAgICAgICBmb250LXNpemU6IDE0cHg7IH1cXG4gICAgICBmb290ZXIgLnRvcGxheWxpc3RXcmFwcGVyIC50b3BsYXlsaXN0IGxpLnBsYXlpbmcgLnBsYXlpbmdIaW50IHtcXG4gICAgICAgIGRpc3BsYXk6IGlubGluZTsgfVxcbiAgICAgIGZvb3RlciAudG9wbGF5bGlzdFdyYXBwZXIgLnRvcGxheWxpc3QgbGkucGxheWluZyAucGxheWluZ0hpbnQsIGZvb3RlciAudG9wbGF5bGlzdFdyYXBwZXIgLnRvcGxheWxpc3QgbGkucGxheWluZyAudG9wbGF5LXNvbmdOYW1lLCBmb290ZXIgLnRvcGxheWxpc3RXcmFwcGVyIC50b3BsYXlsaXN0IGxpLnBsYXlpbmcgLnNwbGl0LCBmb290ZXIgLnRvcGxheWxpc3RXcmFwcGVyIC50b3BsYXlsaXN0IGxpLnBsYXlpbmcgLnRvcGxheS1hcnRpc3Qge1xcbiAgICAgICAgY29sb3I6ICM5YzI3YjA7IH1cXG4gIGZvb3RlciAudG9wbGF5bGlzdFdyYXBwZXIuc2hvdyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7IH1cXG5cXG4uY29sbGVjdGlvblZpZXdlciB7XFxuICB3aWR0aDogMTAwJTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgbGVmdDogMDtcXG4gIGJvdHRvbTogNTVweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmMmY0ZjU7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsgfVxcbiAgLmNvbGxlY3Rpb25WaWV3ZXIgLmNvbGxlY3Rpb25IZWFkIHtcXG4gICAgaGVpZ2h0OiA1MHB4O1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgICBwYWRkaW5nOiAwIDE1cHg7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC40KTsgfVxcbiAgICAuY29sbGVjdGlvblZpZXdlciAuY29sbGVjdGlvbkhlYWQgc3ZnIHtcXG4gICAgICBmb250LXNpemU6IDI1cHg7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAxNXB4OyB9XFxuICAgIC5jb2xsZWN0aW9uVmlld2VyIC5jb2xsZWN0aW9uSGVhZCAucGFnZU5hbWUge1xcbiAgICAgIGZvbnQtc2l6ZTogMTZweDsgfVxcbiAgLmNvbGxlY3Rpb25WaWV3ZXIgLmNvbGxlY3Rpb25UaGVtZSB7XFxuICAgIGhlaWdodDogMTgwcHg7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBwYWRkaW5nOiAwIDE1cHg7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcbiAgICAuY29sbGVjdGlvblZpZXdlciAuY29sbGVjdGlvblRoZW1lIC5jb3ZlciB7XFxuICAgICAgaGVpZ2h0OiAxNTBweDtcXG4gICAgICB3aWR0aDogMTUwcHg7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiAxNXB4O1xcbiAgICAgIHotaW5kZXg6IDE7IH1cXG4gICAgICAuY29sbGVjdGlvblZpZXdlciAuY29sbGVjdGlvblRoZW1lIC5jb3ZlciBpbWcge1xcbiAgICAgICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gICAgICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgICAgICB3ZWlnaHQ6IDEwMCU7IH1cXG4gICAgLmNvbGxlY3Rpb25WaWV3ZXIgLmNvbGxlY3Rpb25UaGVtZSAuY29sbGVjdGlvblRpdGxlIHtcXG4gICAgICBjb2xvcjogI2ZmZjtcXG4gICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgaGVpZ2h0OiAxNTBweDtcXG4gICAgICBwYWRkaW5nLXRvcDogMjBweDtcXG4gICAgICB6LWluZGV4OiAxOyB9XFxuICAgIC5jb2xsZWN0aW9uVmlld2VyIC5jb2xsZWN0aW9uVGhlbWUgLmJhY2tncm91bmQge1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICBsZWZ0OiAwO1xcbiAgICAgIGJvdHRvbTogMDtcXG4gICAgICByaWdodDogMDtcXG4gICAgICB0b3A6IDA7XFxuICAgICAgYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiICsgZXNjYXBlKHJlcXVpcmUoXCIuLi9pbWcvMS5wbmdcIikpICsgXCIpO1xcbiAgICAgIGJhY2tncm91bmQtcG9zaXRpb246IDUwJTtcXG4gICAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgICAgIGZpbHRlcjogYmx1cigyMHB4KTtcXG4gICAgICAtd2Via2l0LWZpbHRlcjogYmx1cigyMHB4KTtcXG4gICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuNSk7XFxuICAgICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gICAgICB6LWluZGV4OiAtMTsgfVxcbiAgLmNvbGxlY3Rpb25WaWV3ZXIgLmNvbGxlY3Rpb25MaXN0IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2YyZjRmNTtcXG4gICAgcGFkZGluZzogMCAxNXB4O1xcbiAgICB6LWluZGV4OiAxO1xcbiAgICBmbGV4OiAxOyB9XFxuICAgIC5jb2xsZWN0aW9uVmlld2VyIC5jb2xsZWN0aW9uTGlzdCAucGxheUFsbFdyYXBwZXIge1xcbiAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICAgICAgaGVpZ2h0OiA0NXB4O1xcbiAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZTZlOWYwOyB9XFxuICAgICAgLmNvbGxlY3Rpb25WaWV3ZXIgLmNvbGxlY3Rpb25MaXN0IC5wbGF5QWxsV3JhcHBlciAucGxheUFsbEJ1dHRvbiB7XFxuICAgICAgICBmb250LXNpemU6IDE4cHg7XFxuICAgICAgICBwYWRkaW5nLXJpZ2h0OiAxNXB4OyB9XFxuICAgICAgLmNvbGxlY3Rpb25WaWV3ZXIgLmNvbGxlY3Rpb25MaXN0IC5wbGF5QWxsV3JhcHBlciAucGxheUFsbFRleHQge1xcbiAgICAgICAgZm9udC1zaXplOiAxNnB4OyB9XFxuICAgIC5jb2xsZWN0aW9uVmlld2VyIC5jb2xsZWN0aW9uTGlzdCAuc29uZ0xpc3Qge1xcbiAgICAgIHdpZHRoOiAxMDAlOyB9XFxuICAgICAgLmNvbGxlY3Rpb25WaWV3ZXIgLmNvbGxlY3Rpb25MaXN0IC5zb25nTGlzdCBsaSB7XFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZTZlOWYwO1xcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgICAgICBoZWlnaHQ6IDU1cHg7IH1cXG4gICAgICAgIC5jb2xsZWN0aW9uVmlld2VyIC5jb2xsZWN0aW9uTGlzdCAuc29uZ0xpc3QgbGkgLnNvbmdOYW1lIHtcXG4gICAgICAgICAgZm9udC1zaXplOiAxNnB4OyB9XFxuICAgICAgICAuY29sbGVjdGlvblZpZXdlciAuY29sbGVjdGlvbkxpc3QgLnNvbmdMaXN0IGxpIC5pbWZvcm1hdGlvbiB7XFxuICAgICAgICAgIGNvbG9yOiAjNTU1NTU1O1xcbiAgICAgICAgICBmb250LXNpemU6IDEwcHg7IH1cXG5cXG4uY29sbGVjdGlvblZpZXdlci5zaG93IHtcXG4gIGRpc3BsYXk6IGZsZXg7IH1cXG5cXG4ucGxheUNvbnRyb2xsZXIge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICBwYWRkaW5nOiA1cHggMTBweDtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICByaWdodDogMDtcXG4gIGJvdHRvbTogMDtcXG4gIHotaW5kZXg6IDI7IH1cXG4gIC5wbGF5Q29udHJvbGxlciAuYmFja2dyb3VuZCB7XFxuICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi4vaW1nLzEucG5nXCIpKSArIFwiKTtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogNTAlO1xcbiAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgICBmaWx0ZXI6IGJsdXIoNDBweCk7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMS41KTtcXG4gICAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB6LWluZGV4OiAtMTtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwOyB9XFxuICAucGxheUNvbnRyb2xsZXIgLmhlYWQge1xcbiAgICBoZWlnaHQ6IDYwcHg7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjQpO1xcbiAgICBtYXJnaW46IC01cHggLTEwcHg7XFxuICAgIHBhZGRpbmc6IDVweCAxMHB4O1xcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgyMzAsIDIzMywgMjQwLCAwLjEpOyB9XFxuICAgIC5wbGF5Q29udHJvbGxlciAuaGVhZCAucmV0dXJuQnV0dG9uIHtcXG4gICAgICBoZWlnaHQ6IDQwcHg7XFxuICAgICAgd2lkdGg6IDQwcHg7XFxuICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgIGZvbnQtc2l6ZTogMjVweDtcXG4gICAgICBjb2xvcjogI2ZmZjsgfVxcbiAgICAucGxheUNvbnRyb2xsZXIgLmhlYWQgLnNvbmdJbmZvcm1hdGlvbiB7XFxuICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICBoZWlnaHQ6IDUwcHg7XFxuICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgICBwYWRkaW5nLWxlZnQ6IDEwcHg7XFxuICAgICAgZmxleDogMTsgfVxcbiAgICAgIC5wbGF5Q29udHJvbGxlciAuaGVhZCAuc29uZ0luZm9ybWF0aW9uIC5zb25nTmFtZSB7XFxuICAgICAgICB3aWR0aDogNjAlO1xcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXG4gICAgICAgIGZvbnQtc2l6ZTogMThweDtcXG4gICAgICAgIGNvbG9yOiAjZmZmOyB9XFxuICAgICAgLnBsYXlDb250cm9sbGVyIC5oZWFkIC5zb25nSW5mb3JtYXRpb24gLmFydGlzdCB7XFxuICAgICAgICB3aWR0aDogNjAlO1xcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgICAgIGNvbG9yOiAjYmJiYmJiOyB9XFxuICAucGxheUNvbnRyb2xsZXIgLmRpc2NXcmFwcGVyIHtcXG4gICAgZmxleDogMTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyOyB9XFxuICAgIC5wbGF5Q29udHJvbGxlciAuZGlzY1dyYXBwZXIgLmRpc2Mge1xcbiAgICAgIHdpZHRoOiAyNTBweDtcXG4gICAgICBoZWlnaHQ6IDI1MHB4O1xcbiAgICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi4vaW1nL2Rpc3QucG5nXCIpKSArIFwiKTtcXG4gICAgICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbiAgICAgIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICAgICAgei1pbmRleDogLTE7XFxuICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4gICAgICBAbWVkaWEgKG1pbi13aWR0aDogNDE0cHgpIHtcXG4gICAgICAgIC5wbGF5Q29udHJvbGxlciAuZGlzY1dyYXBwZXIgLmRpc2Mge1xcbiAgICAgICAgICB3aWR0aDogMzUwcHg7XFxuICAgICAgICAgIGhlaWdodDogMzUwcHg7IH0gfVxcbiAgICAgIEBtZWRpYSAobWluLXdpZHRoOiAzNjBweCkge1xcbiAgICAgICAgLnBsYXlDb250cm9sbGVyIC5kaXNjV3JhcHBlciAuZGlzYyB7XFxuICAgICAgICAgIHdpZHRoOiAzMDBweDtcXG4gICAgICAgICAgaGVpZ2h0OiAzMDBweDsgfSB9XFxuICAgICAgLnBsYXlDb250cm9sbGVyIC5kaXNjV3JhcHBlciAuZGlzYyAuY292ZXJXcmFwcGVyIHtcXG4gICAgICAgIHdpZHRoOiAyNTBweDtcXG4gICAgICAgIGhlaWdodDogMjUwcHg7XFxuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjY1KTsgfVxcbiAgICAgICAgQG1lZGlhIChtaW4td2lkdGg6IDQxNHB4KSB7XFxuICAgICAgICAgIC5wbGF5Q29udHJvbGxlciAuZGlzY1dyYXBwZXIgLmRpc2MgLmNvdmVyV3JhcHBlciB7XFxuICAgICAgICAgICAgd2lkdGg6IDM1MHB4O1xcbiAgICAgICAgICAgIGhlaWdodDogMzUwcHg7IH0gfVxcbiAgICAgICAgQG1lZGlhIChtaW4td2lkdGg6IDM2MHB4KSB7XFxuICAgICAgICAgIC5wbGF5Q29udHJvbGxlciAuZGlzY1dyYXBwZXIgLmRpc2MgLmNvdmVyV3JhcHBlciB7XFxuICAgICAgICAgICAgd2lkdGg6IDMwMHB4O1xcbiAgICAgICAgICAgIGhlaWdodDogMzAwcHg7IH0gfVxcbiAgICAgICAgLnBsYXlDb250cm9sbGVyIC5kaXNjV3JhcHBlciAuZGlzYyAuY292ZXJXcmFwcGVyIC5jb3ZlciB7XFxuICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgICAgYmFja2dyb3VuZC1zaXplOiBjb250YWluO1xcbiAgICAgICAgICBoZWlnaHQ6IDEwMCU7XFxuICAgICAgICAgIHdpZHRoOiAxMDAlOyB9XFxuICAgICAgLnBsYXlDb250cm9sbGVyIC5kaXNjV3JhcHBlciAuZGlzYyAuZGlzYy1saWdodCB7XFxuICAgICAgICB3aWR0aDogMjUwcHg7XFxuICAgICAgICBoZWlnaHQ6IDI1MHB4O1xcbiAgICAgICAgdG9wOiAwO1xcbiAgICAgICAgbGVmdDogMDtcXG4gICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IHVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi4vaW1nL2Rpc3QtbGlnaHQucG5nXCIpKSArIFwiKTtcXG4gICAgICAgIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxuICAgICAgICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgei1pbmRleDogLTE7IH1cXG4gICAgICAgIEBtZWRpYSAobWluLXdpZHRoOiA0MTRweCkge1xcbiAgICAgICAgICAucGxheUNvbnRyb2xsZXIgLmRpc2NXcmFwcGVyIC5kaXNjIC5kaXNjLWxpZ2h0IHtcXG4gICAgICAgICAgICB3aWR0aDogMzUwcHg7XFxuICAgICAgICAgICAgaGVpZ2h0OiAzNTBweDsgfSB9XFxuICAgICAgICBAbWVkaWEgKG1pbi13aWR0aDogMzYwcHgpIHtcXG4gICAgICAgICAgLnBsYXlDb250cm9sbGVyIC5kaXNjV3JhcHBlciAuZGlzYyAuZGlzYy1saWdodCB7XFxuICAgICAgICAgICAgd2lkdGg6IDMwMHB4O1xcbiAgICAgICAgICAgIGhlaWdodDogMzAwcHg7IH0gfVxcbiAgICAucGxheUNvbnRyb2xsZXIgLmRpc2NXcmFwcGVyIC5kaXNjLnBsYXlpbmcge1xcbiAgICAgIGFuaW1hdGlvbjogY2lyY2xpbmcgMjBzIGluZmluaXRlIGxpbmVhcjtcXG4gICAgICAtd2Via2l0LWFuaW1hdGlvbjogY2lyY2xpbmcgMjBzIGluZmluaXRlIGxpbmVhcjsgfVxcbiAgLnBsYXlDb250cm9sbGVyIC5jb250cm9sUGFuZWwge1xcbiAgICBoZWlnaHQ6IDEwMHB4O1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBwYWRkaW5nOiAwIDEwcHg7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kOyB9XFxuICAgIC5wbGF5Q29udHJvbGxlciAuY29udHJvbFBhbmVsIC5wcm9ncmVzc0JhciB7XFxuICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgaGVpZ2h0OiAzcHg7XFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICAgICAgLnBsYXlDb250cm9sbGVyIC5jb250cm9sUGFuZWwgLnByb2dyZXNzQmFyIC50b3RhbEJhciB7XFxuICAgICAgICBoZWlnaHQ6IDNweDtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICB3aWR0aDogMTAwJTsgfVxcbiAgICAgIC5wbGF5Q29udHJvbGxlciAuY29udHJvbFBhbmVsIC5wcm9ncmVzc0JhciAuY3VycmVudEJhciB7XFxuICAgICAgICBoZWlnaHQ6IDNweDtcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICM5YzI3YjA7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICB3aWR0aDogNDAlOyB9XFxuICAgICAgLnBsYXlDb250cm9sbGVyIC5jb250cm9sUGFuZWwgLnByb2dyZXNzQmFyIC5jdXJyZW50QmFyOjpiZWZvcmUsXFxuICAgICAgLnBsYXlDb250cm9sbGVyIC5jb250cm9sUGFuZWwgLnByb2dyZXNzQmFyIC5jdXJyZW50QmFyOjphZnRlciB7XFxuICAgICAgICBjb250ZW50OiAnJztcXG4gICAgICAgIGhlaWdodDogMTVweDtcXG4gICAgICAgIHdpZHRoOiAxNXB4O1xcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwJTtcXG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgICByaWdodDogLTZweDtcXG4gICAgICAgIHRvcDogLTZweDsgfVxcbiAgICAgIC5wbGF5Q29udHJvbGxlciAuY29udHJvbFBhbmVsIC5wcm9ncmVzc0JhciAuY3VycmVudEJhcjo6YWZ0ZXIge1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzljMjdiMDtcXG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC40KTsgfVxcbiAgICAucGxheUNvbnRyb2xsZXIgLmNvbnRyb2xQYW5lbCAuY29udHJvbEJ1dHRvbiB7XFxuICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgICAgZm9udC1zaXplOiAyNXB4O1xcbiAgICAgIGNvbG9yOiAjZmZmO1xcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7IH1cXG4gICAgICAucGxheUNvbnRyb2xsZXIgLmNvbnRyb2xQYW5lbCAuY29udHJvbEJ1dHRvbiAuYWRkVG9Db2xsZWN0aW9uLFxcbiAgICAgIC5wbGF5Q29udHJvbGxlciAuY29udHJvbFBhbmVsIC5jb250cm9sQnV0dG9uIC5saXN0TWVudSB7XFxuICAgICAgICBmb250LXNpemU6IDI1cHg7IH1cXG4gICAgICAucGxheUNvbnRyb2xsZXIgLmNvbnRyb2xQYW5lbCAuY29udHJvbEJ1dHRvbiAubmV4dFNvbmcsXFxuICAgICAgLnBsYXlDb250cm9sbGVyIC5jb250cm9sUGFuZWwgLmNvbnRyb2xCdXR0b24gLnByZXZTb25nIHtcXG4gICAgICAgIGZvbnQtc2l6ZTogMzVweDsgfVxcbiAgICAgIC5wbGF5Q29udHJvbGxlciAuY29udHJvbFBhbmVsIC5jb250cm9sQnV0dG9uIC50b2dnbGUge1xcbiAgICAgICAgZm9udC1zaXplOiA0NXB4OyB9XFxuICAgICAgLnBsYXlDb250cm9sbGVyIC5jb250cm9sUGFuZWwgLmNvbnRyb2xCdXR0b24gLnRvZ2dsZSA+IHN2ZyB7XFxuICAgICAgICBkaXNwbGF5OiBub25lOyB9XFxuICAgICAgLnBsYXlDb250cm9sbGVyIC5jb250cm9sUGFuZWwgLmNvbnRyb2xCdXR0b24gLnRvZ2dsZSA+IHN2Zy5zaG93IHtcXG4gICAgICAgIGRpc3BsYXk6IGlubGluZTsgfVxcblxcbi5wbGF5Q29udHJvbGxlci5zaG93IHtcXG4gIGRpc3BsYXk6IGZsZXg7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js!./node_modules/sass-loader/lib/loader.js!./src/css/app.scss\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjOztBQUVsRTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/css-base.js\n");

/***/ }),

/***/ "./node_modules/css-loader/lib/url/escape.js":
/*!***************************************************!*\
  !*** ./node_modules/css-loader/lib/url/escape.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function escape(url) {\n    if (typeof url !== 'string') {\n        return url\n    }\n    // If url is already wrapped in quotes, remove them\n    if (/^['\"].*['\"]$/.test(url)) {\n        url = url.slice(1, -1);\n    }\n    // Should url be wrapped?\n    // See https://drafts.csswg.org/css-values-3/#urls\n    if (/[\"'() \\t\\n]/.test(url)) {\n        return '\"' + url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n') + '\"'\n    }\n\n    return url\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qcz9iMDQxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvdXJsL2VzY2FwZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXNjYXBlKHVybCkge1xuICAgIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdXJsXG4gICAgfVxuICAgIC8vIElmIHVybCBpcyBhbHJlYWR5IHdyYXBwZWQgaW4gcXVvdGVzLCByZW1vdmUgdGhlbVxuICAgIGlmICgvXlsnXCJdLipbJ1wiXSQvLnRlc3QodXJsKSkge1xuICAgICAgICB1cmwgPSB1cmwuc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgICAvLyBTaG91bGQgdXJsIGJlIHdyYXBwZWQ/XG4gICAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcbiAgICBpZiAoL1tcIicoKSBcXHRcXG5dLy50ZXN0KHVybCkpIHtcbiAgICAgICAgcmV0dXJuICdcIicgKyB1cmwucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKSArICdcIidcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/lib/url/escape.js\n");

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.3.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2018-01-20T17:24Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\nvar isFunction = function isFunction( obj ) {\n\n      // Support: Chrome <=57, Firefox <=52\n      // In some browsers, typeof returns \"function\" for HTML <object> elements\n      // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n      // We don't want to classify *any* DOM node as a function.\n      return typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\n  };\n\n\nvar isWindow = function isWindow( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t};\n\n\n\n\n\tvar preservedScriptAttributes = {\n\t\ttype: true,\n\t\tsrc: true,\n\t\tnoModule: true\n\t};\n\n\tfunction DOMEval( code, doc, node ) {\n\t\tdoc = doc || document;\n\n\t\tvar i,\n\t\t\tscript = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tif ( node ) {\n\t\t\tfor ( i in preservedScriptAttributes ) {\n\t\t\t\tif ( node[ i ] ) {\n\t\t\t\t\tscript[ i ] = node[ i ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + \"\";\n\t}\n\n\t// Support: Android <=2.3 only (functionish RegExp)\n\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\ttypeof obj;\n}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.3.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && Array.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\n\t\t/* eslint-disable no-unused-vars */\n\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tDOMEval( code );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = toType( obj );\n\n\tif ( isFunction( obj ) || isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n};\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Filtered directly for both simple and complex selectors\n\treturn jQuery.filter( qualifier, elements, not );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n        if ( nodeName( elem, \"iframe\" ) ) {\n            return elem.contentDocument;\n        }\n\n        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n        // Treat the template element as a regular one in browsers that\n        // don't support it.\n        if ( nodeName( elem, \"template\" ) ) {\n            elem = elem.content || elem;\n        }\n\n        return jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// rejected_handlers.disable\n\t\t\t\t\t// fulfilled_handlers.disable\n\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n\n\t\t\t\t\t// progress_handlers.lock\n\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( toType( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\n\n\n// Matches dashed string for camelizing\nvar rmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g;\n\n// Used by camelCase as callback to replace()\nfunction fcamelCase( all, letter ) {\n\treturn letter.toUpperCase();\n}\n\n// Convert dashed to camelCase; used by the css and data modules\n// Support: IE <=9 - 11, Edge 12 - 15\n// Microsoft forgot to hump their vendor prefix (#9572)\nfunction camelCase( string ) {\n\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n}\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( camelCase );\n\t\t\t} else {\n\t\t\t\tkey = camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted, scale,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Support: Firefox <=54\n\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n\t\tinitial = initial / 2;\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\twhile ( maxIterations-- ) {\n\n\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\n\t\t\t\tmaxIterations = 0;\n\t\t\t}\n\t\t\tinitialInUnit = initialInUnit / scale;\n\n\t\t}\n\n\t\tinitialInUnit = initialInUnit * 2;\n\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\nvar rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( toType( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\nvar documentElement = document.documentElement;\n\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 only\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || Date.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13 only\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, \"table\" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true/\" ) {\n\t\telem.type = elem.type.slice( 5 );\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tvalueIsFunction = isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( valueIsFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc, node );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\nvar rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\n\t\t\t\"margin-top:1px;padding:0;border:0\";\n\t\tdiv.style.cssText =\n\t\t\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"width:60%;top:1%\";\n\t\tdocumentElement.appendChild( container ).appendChild( div );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n\n\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.right = \"60%\";\n\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n\n\t\t// Support: IE 9 - 11 only\n\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n\n\t\t// Support: IE 9 only\n\t\t// Detect overflow:scroll screwiness (gh-3699)\n\t\tdiv.style.position = \"absolute\";\n\t\tscrollboxSizeVal = div.offsetWidth === 36 || \"absolute\";\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tfunction roundPixelMeasures( measure ) {\n\t\treturn Math.round( parseFloat( measure ) );\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n\t\treliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tjQuery.extend( support, {\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelBoxStyles: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelBoxStylesVal;\n\t\t},\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t},\n\t\tscrollboxSize: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn scrollboxSizeVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css('filter') (IE 9 only, #12537)\n\t//   .css('--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a property mapped along what jQuery.cssProps suggests or to\n// a vendor prefixed property.\nfunction finalPropName( name ) {\n\tvar ret = jQuery.cssProps[ name ];\n\tif ( !ret ) {\n\t\tret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;\n\t}\n\treturn ret;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n\tvar i = dimension === \"width\" ? 1 : 0,\n\t\textra = 0,\n\t\tdelta = 0;\n\n\t// Adjustment may not be necessary\n\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\treturn 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin\n\t\tif ( box === \"margin\" ) {\n\t\t\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\t// If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\t\tif ( !isBorderBox ) {\n\n\t\t\t// Add padding\n\t\t\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// For \"border\" or \"margin\", add border\n\t\t\tif ( box !== \"padding\" ) {\n\t\t\t\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\n\t\t\t// But still keep track of it otherwise\n\t\t\t} else {\n\t\t\t\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\n\t\t// If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n\t\t// \"padding\" or \"margin\"\n\t\t} else {\n\n\t\t\t// For \"content\", subtract padding\n\t\t\tif ( box === \"content\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// For \"content\" or \"padding\", subtract border\n\t\t\tif ( box !== \"margin\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Account for positive content-box scroll gutter when requested by providing computedVal\n\tif ( !isBorderBox && computedVal >= 0 ) {\n\n\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n\t\t// Assuming integer scroll gutter, subtract the rest and round down\n\t\tdelta += Math.max( 0, Math.ceil(\n\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\tcomputedVal -\n\t\t\tdelta -\n\t\t\textra -\n\t\t\t0.5\n\t\t) );\n\t}\n\n\treturn delta;\n}\n\nfunction getWidthOrHeight( elem, dimension, extra ) {\n\n\t// Start with computed style\n\tvar styles = getStyles( elem ),\n\t\tval = curCSS( elem, dimension, styles ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\tvalueIsBorderBox = isBorderBox;\n\n\t// Support: Firefox <=54\n\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n\tif ( rnumnonpx.test( val ) ) {\n\t\tif ( !extra ) {\n\t\t\treturn val;\n\t\t}\n\t\tval = \"auto\";\n\t}\n\n\t// Check for style in case a browser which returns unreliable values\n\t// for getComputedStyle silently falls back to the reliable elem.style\n\tvalueIsBorderBox = valueIsBorderBox &&\n\t\t( support.boxSizingReliable() || val === elem.style[ dimension ] );\n\n\t// Fall back to offsetWidth/offsetHeight when value is \"auto\"\n\t// This happens for inline elements with no explicit setting (gh-3571)\n\t// Support: Android <=4.1 - 4.3 only\n\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n\tif ( val === \"auto\" ||\n\t\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) {\n\n\t\tval = elem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];\n\n\t\t// offsetWidth/offsetHeight provide border-box values\n\t\tvalueIsBorderBox = true;\n\t}\n\n\t// Normalize \"\" and auto\n\tval = parseFloat( val ) || 0;\n\n\t// Adjust for the element's box model\n\treturn ( val +\n\t\tboxModelAdjustment(\n\t\t\telem,\n\t\t\tdimension,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles,\n\n\t\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n\t\t\tval\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === \"number\" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, dimension ) {\n\tjQuery.cssHooks[ dimension ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = getStyles( elem ),\n\t\t\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\tsubtract = extra && boxModelAdjustment(\n\t\t\t\t\telem,\n\t\t\t\t\tdimension,\n\t\t\t\t\textra,\n\t\t\t\t\tisBorderBox,\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n\t\t\t// faking a content-box to get border and padding (gh-3699)\n\t\t\tif ( isBorderBox && support.scrollboxSize() === styles.position ) {\n\t\t\t\tsubtract -= Math.ceil(\n\t\t\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n\t\t\t\t\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\n\t\t\t\t\t0.5\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ dimension ] = value;\n\t\t\t\tvalue = jQuery.css( elem, dimension );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( prefix !== \"margin\" ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = Date.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 15\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n\t\t// the overflowX value there.\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there's more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tresult.stop.bind( result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tisFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = Date.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\nfunction classesToArray( value ) {\n\tif ( Array.isArray( value ) ) {\n\t\treturn value;\n\t}\n\tif ( typeof value === \"string\" ) {\n\t\treturn value.match( rnothtmlwhite ) || [];\n\t}\n\treturn [];\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisValidValue = type === \"string\" || Array.isArray( value );\n\n\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( isValidValue ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = classesToArray( value );\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, valueIsFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueIsFunction = isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\tstopPropagationCallback = function( e ) {\n\t\te.stopPropagation();\n\t};\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = lastElement = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tlastElement = cur;\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\telem[ type ]();\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = Date.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && toType( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available and should be processed, append data to url\n\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar htmlIsFunction = isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\n\t// offset() relates an element's border box to the document origin\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\t\trect = elem.getBoundingClientRect();\n\t\twin = elem.ownerDocument.defaultView;\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset,\n\t\t\tleft: rect.left + win.pageXOffset\n\t\t};\n\t},\n\n\t// position() relates an element's margin box to its offset parent's padding box\n\t// This corresponds to the behavior of CSS absolute positioning\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset, doc,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\toffset = this.offset();\n\n\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n\t\t\t// when a statically positioned element is identified\n\t\t\tdoc = elem.ownerDocument;\n\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n\t\t\twhile ( offsetParent &&\n\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\n\t\t\t\toffsetParent = offsetParent.parentNode;\n\t\t\t}\n\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n\n\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n\t\t\t\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\n\t\t\t}\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\n// Bind a function to a context, optionally partially applying any\n// arguments.\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n// However, it is not slated for removal any time soon\njQuery.proxy = function( fn, context ) {\n\tvar tmp, args, proxy;\n\n\tif ( typeof context === \"string\" ) {\n\t\ttmp = fn[ context ];\n\t\tcontext = fn;\n\t\tfn = tmp;\n\t}\n\n\t// Quick check to determine if target is callable, in the spec\n\t// this throws a TypeError, but we will just return undefined.\n\tif ( !isFunction( fn ) ) {\n\t\treturn undefined;\n\t}\n\n\t// Simulated bind\n\targs = slice.call( arguments, 2 );\n\tproxy = function() {\n\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t};\n\n\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\treturn proxy;\n};\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\njQuery.isFunction = isFunction;\njQuery.isWindow = isWindow;\njQuery.camelCase = camelCase;\njQuery.type = toType;\n\njQuery.now = Date.now;\n\njQuery.isNumeric = function( obj ) {\n\n\t// As of jQuery 3.0, isNumeric is limited to\n\t// strings and numbers (primitives or objects)\n\t// that can be coerced to finite numbers (gh-2662)\n\tvar type = jQuery.type( obj );\n\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t!isNaN( obj - parseFloat( obj ) );\n};\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\treturn jQuery;\n\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzPzExNTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsWUFBWTs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQSxnQkFBZ0IsSUFBSTs7QUFFcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUSw2QkFBNkI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0Usc0NBQXNDLDJCQUEyQjtBQUNqRTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksdUVBQXVFO0FBQ25GO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLFFBQVEsR0FBRztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLDBCQUEwQix3QkFBd0I7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxzQ0FBc0M7QUFDOUUsb0NBQW9DLHVDQUF1QztBQUMzRSxvQ0FBb0Msc0NBQXNDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGFBQWE7QUFDcEMsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0JBQWdCO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBOztBQUVBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGNBQWM7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUNBQXVDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBdUQ7QUFDOUU7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsK0JBQStCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMscUNBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsU0FBUyw4QkFBOEI7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLGNBQWMsV0FBVztBQUN4RSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBLHNCQUFzQixjQUFjLHNCQUFzQixnQkFBZ0I7QUFDMUUsZ0JBQWdCLFdBQVcsWUFBWTtBQUN2QyxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUErRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTzs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixpREFBaUQsMEJBQTBCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QixXQUFXLGtCQUFrQjtBQUM3QixjQUFjO0FBQ2QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLG1CQUFtQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBSztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUNBQXFDOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDs7QUFFQSxXQUFXO0FBQ1gsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYyxzREFBc0Q7QUFDcEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQSxjQUFjLG1DQUFtQztBQUNqRCxlQUFlLDZEQUE2RDtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUFBO0FBQ0Y7Ozs7O0FBS0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjMuMVxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTgtMDEtMjBUMTc6MjRaXG4gKi9cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSApKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFyciA9IFtdO1xuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuICAgICAgLy8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXG4gICAgICAvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiO1xuICB9O1xuXG5cbnZhciBpc1dpbmRvdyA9IGZ1bmN0aW9uIGlzV2luZG93KCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fTtcblxuXG5cblxuXHR2YXIgcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyA9IHtcblx0XHR0eXBlOiB0cnVlLFxuXHRcdHNyYzogdHJ1ZSxcblx0XHRub01vZHVsZTogdHJ1ZVxuXHR9O1xuXG5cdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIGRvYywgbm9kZSApIHtcblx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHR2YXIgaSxcblx0XHRcdHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Zm9yICggaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzICkge1xuXHRcdFx0XHRpZiAoIG5vZGVbIGkgXSApIHtcblx0XHRcdFx0XHRzY3JpcHRbIGkgXSA9IG5vZGVbIGkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdH1cblxuXG5mdW5jdGlvbiB0b1R5cGUoIG9iaiApIHtcblx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0dHlwZW9mIG9iajtcbn1cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjMuMy4xXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFpc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIEFycmF5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzYxMjVcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHRET01FdmFsKCBjb2RlICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTA4LTA4XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0cmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGRpc2FibGVkQW5jZXN0b3IgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgKFwiZm9ybVwiIGluIGVsZW0gfHwgXCJsYWJlbFwiIGluIGVsZW0pO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cblx0XHRcdFx0Ly8gcVNBIGxvb2tzIG91dHNpZGUgRWxlbWVudCBjb250ZXh0LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50XG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHdvcmthcm91bmQgdGVjaG5pcXVlXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbmV3U2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cblx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG5cdFx0aWYgKCBcImZvcm1cIiBpbiBlbGVtICkge1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG5cdFx0XHQvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcblx0XHRcdC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuXHRcdFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcblx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuXHRcdFx0XHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblx0XHRcdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0ZGlzYWJsZWRBbmNlc3RvciggZWxlbSApID09PSBkaXNhYmxlZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG5cdFx0Ly8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuXHRcdC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuXHRcdC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuXHRcdH0gZWxzZSBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdH1cblxuXHRcdC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3Rcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG5cdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuIChzZWwgKyBcIlwiKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKSApICYgMTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5cbi8vIERlcHJlY2F0ZWRcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XG5cblxuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cblxuXG5mdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcblxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblxufTtcbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbmdsZSBlbGVtZW50XG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBGaWx0ZXJlZCBkaXJlY3RseSBmb3IgYm90aCBzaW1wbGUgYW5kIGNvbXBsZXggc2VsZWN0b3JzXG5cdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG5cdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG5cdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCBcImlmcmFtZVwiICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcbiAgICAgICAgLy8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG4gICAgICAgIC8vIGRvbid0IHN1cHBvcnQgaXQuXG4gICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuICAgICAgICAgICAgZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxuXHRcdFx0Ly8gKiBmYWxzZTogWyB2YWx1ZSBdLnNsaWNlKCAwICkgPT4gcmVzb2x2ZSggdmFsdWUgKVxuXHRcdFx0Ly8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcblx0XHRcdHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0gaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoZW4gKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cblx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblByb2dyZXNzIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblJlamVjdGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdFRocm93ZXJcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XG5cblx0XHRcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDMgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMiBdLmxvY2ssXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5sb2NrXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG5cdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0dmFyXG5cblx0XHRcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRpID0gcmVtYWluaW5nLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkXG5cdFx0XHRtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0bWFzdGVyLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBtYXN0ZXIuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgbWFzdGVyLnJlamVjdCxcblx0XHRcdFx0IXJlbWFpbmluZyApO1xuXG5cdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRpZiAoIG1hc3Rlci5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxuXHRcdFx0XHRpc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbWFzdGVyLnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIG1hc3Rlci5yZWplY3QgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIHN0YWNrICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIHRvVHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cblxuXHQvLyBHZXRzXG5cdGlmICggYnVsayApIHtcblx0XHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcblx0fVxuXG5cdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG5cblxuLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG52YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nO1xuXG4vLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcbmZ1bmN0aW9uIGZjYW1lbENhc2UoIGFsbCwgbGV0dGVyICkge1xuXHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbi8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3MilcbmZ1bmN0aW9uIGNhbWVsQ2FzZSggc3RyaW5nICkge1xuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcbn1cbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBjYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBjYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKykvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xufSApKCk7XG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHR2YXIgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHR9XG5cblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblxuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayAmJiBub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gbm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcblx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbmpRdWVyeS5lYWNoKCB7XG5cdGFsdEtleTogdHJ1ZSxcblx0YnViYmxlczogdHJ1ZSxcblx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdGN0cmxLZXk6IHRydWUsXG5cdGRldGFpbDogdHJ1ZSxcblx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0bWV0YUtleTogdHJ1ZSxcblx0cGFnZVg6IHRydWUsXG5cdHBhZ2VZOiB0cnVlLFxuXHRzaGlmdEtleTogdHJ1ZSxcblx0dmlldzogdHJ1ZSxcblx0XCJjaGFyXCI6IHRydWUsXG5cdGNoYXJDb2RlOiB0cnVlLFxuXHRrZXk6IHRydWUsXG5cdGtleUNvZGU6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0YnV0dG9uczogdHJ1ZSxcblx0Y2xpZW50WDogdHJ1ZSxcblx0Y2xpZW50WTogdHJ1ZSxcblx0b2Zmc2V0WDogdHJ1ZSxcblx0b2Zmc2V0WTogdHJ1ZSxcblx0cG9pbnRlcklkOiB0cnVlLFxuXHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0c2NyZWVuWDogdHJ1ZSxcblx0c2NyZWVuWTogdHJ1ZSxcblx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0dG9FbGVtZW50OiB0cnVlLFxuXHR0b3VjaGVzOiB0cnVlLFxuXG5cdHdoaWNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcblxuXHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIHJtb3VzZUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdGlmICggYnV0dG9uICYgMSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgMiApIHtcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgNCApIHtcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC53aGljaDtcblx0fVxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBkb2MsIG5vZGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggbm9kZS5vd25lckRvY3VtZW50LCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxudmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoIGNzc0V4cGFuZC5qb2luKCBcInxcIiApLCBcImlcIiApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7XCIgK1xuXHRcdFx0XCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ3aWR0aDo2MCU7dG9wOjElXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5yaWdodCA9IFwiNjAlXCI7XG5cdFx0cGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLnJpZ2h0ICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0XHQvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLndpZHRoICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gZGl2Lm9mZnNldFdpZHRoID09PSAzNiB8fCBcImFic29sdXRlXCI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKCBtZWFzdXJlICkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbEJveFN0eWxlczogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsQm94U3R5bGVzVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRzY3JvbGxib3hTaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gc2Nyb2xsYm94U2l6ZVZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuXHRcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcblx0XHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG5cdFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG5cdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgIzEyNTM3KVxuXHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRyY3VzdG9tUHJvcCA9IC9eLS0vLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fSxcblxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGU7XG5cbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFJldHVybiBhIHByb3BlcnR5IG1hcHBlZCBhbG9uZyB3aGF0IGpRdWVyeS5jc3NQcm9wcyBzdWdnZXN0cyBvciB0b1xuLy8gYSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHkuXG5mdW5jdGlvbiBmaW5hbFByb3BOYW1lKCBuYW1lICkge1xuXHR2YXIgcmV0ID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF07XG5cdGlmICggIXJldCApIHtcblx0XHRyZXQgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcblx0fVxuXHRyZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgYm94LCBpc0JvcmRlckJveCwgc3R5bGVzLCBjb21wdXRlZFZhbCApIHtcblx0dmFyIGkgPSBkaW1lbnNpb24gPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXHRcdGV4dHJhID0gMCxcblx0XHRkZWx0YSA9IDA7XG5cblx0Ly8gQWRqdXN0bWVudCBtYXkgbm90IGJlIG5lY2Vzc2FyeVxuXHRpZiAoIGJveCA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApICkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luXG5cdFx0aWYgKCBib3ggPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBib3ggKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGNvbnRlbnQtYm94LCB3ZSdyZSBzZWVraW5nIFwicGFkZGluZ1wiIG9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIlxuXHRcdGlmICggIWlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBBZGQgcGFkZGluZ1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQnV0IHN0aWxsIGtlZXAgdHJhY2sgb2YgaXQgb3RoZXJ3aXNlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleHRyYSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGJvcmRlci1ib3ggKGNvbnRlbnQgKyBwYWRkaW5nICsgYm9yZGVyKSwgd2UncmUgc2Vla2luZyBcImNvbnRlbnRcIiBvclxuXHRcdC8vIFwicGFkZGluZ1wiIG9yIFwibWFyZ2luXCJcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIsIHN1YnRyYWN0IHBhZGRpbmdcblx0XHRcdGlmICggYm94ID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiBvciBcInBhZGRpbmdcIiwgc3VidHJhY3QgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBY2NvdW50IGZvciBwb3NpdGl2ZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyIHdoZW4gcmVxdWVzdGVkIGJ5IHByb3ZpZGluZyBjb21wdXRlZFZhbFxuXHRpZiAoICFpc0JvcmRlckJveCAmJiBjb21wdXRlZFZhbCA+PSAwICkge1xuXG5cdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIGEgcm91bmRlZCBzdW0gb2YgY29udGVudCwgcGFkZGluZywgc2Nyb2xsIGd1dHRlciwgYW5kIGJvcmRlclxuXHRcdC8vIEFzc3VtaW5nIGludGVnZXIgc2Nyb2xsIGd1dHRlciwgc3VidHJhY3QgdGhlIHJlc3QgYW5kIHJvdW5kIGRvd25cblx0XHRkZWx0YSArPSBNYXRoLm1heCggMCwgTWF0aC5jZWlsKFxuXHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdGNvbXB1dGVkVmFsIC1cblx0XHRcdGRlbHRhIC1cblx0XHRcdGV4dHJhIC1cblx0XHRcdDAuNVxuXHRcdCkgKTtcblx0fVxuXG5cdHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveDtcblxuXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0Ly8gUmV0dXJuIGEgY29uZm91bmRpbmcgbm9uLXBpeGVsIHZhbHVlIG9yIGZlaWduIGlnbm9yYW5jZSwgYXMgYXBwcm9wcmlhdGUuXG5cdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdGlmICggIWV4dHJhICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cdFx0dmFsID0gXCJhdXRvXCI7XG5cdH1cblxuXHQvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuXHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdHZhbHVlSXNCb3JkZXJCb3ggPSB2YWx1ZUlzQm9yZGVyQm94ICYmXG5cdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSApO1xuXG5cdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgLSA0LjMgb25seVxuXHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxuXHRpZiAoIHZhbCA9PT0gXCJhdXRvXCIgfHxcblx0XHQhcGFyc2VGbG9hdCggdmFsICkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJpbmxpbmVcIiApIHtcblxuXHRcdHZhbCA9IGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXTtcblxuXHRcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBwcm92aWRlIGJvcmRlci1ib3ggdmFsdWVzXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IHRydWU7XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHt9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gcXVlcnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhICYmIGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdGRpbWVuc2lvbixcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXG5cdFx0XHQvLyBmYWtpbmcgYSBjb250ZW50LWJveCB0byBnZXQgYm9yZGVyIGFuZCBwYWRkaW5nIChnaC0zNjk5KVxuXHRcdFx0aWYgKCBpc0JvcmRlckJveCAmJiBzdXBwb3J0LnNjcm9sbGJveFNpemUoKSA9PT0gc3R5bGVzLnBvc2l0aW9uICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHxcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBEYXRlLm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0gRGF0ZS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgKSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UrKyApICsgdW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0Y2FjaGU6IHRydWUsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbElzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cblx0XHRcdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApLnByb3AoIHtcblx0XHRcdFx0XHRjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXG5cdFx0XHRcdFx0c3JjOiBzLnVybFxuXHRcdFx0XHR9ICkub24oXG5cdFx0XHRcdFx0XCJsb2FkIGVycm9yXCIsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdGNvbnRleHQgPSBmbjtcblx0XHRmbiA9IHRtcDtcblx0fVxuXG5cdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNpbXVsYXRlZCBiaW5kXG5cdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0fTtcblxuXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0cmV0dXJuIHByb3h5O1xufTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xufTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/jquery/dist/jquery.js\n");

/***/ }),

/***/ "./node_modules/leancloud-realtime/dist/realtime.browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/leancloud-realtime/dist/realtime.browser.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {\n\t true ? factory(exports) :\n\tundefined;\n}(this, (function (exports) { 'use strict';\n\nvar define = undefined;\nvar require = require || function(id) {throw new Error('Unexpected required ' + id)};\n\n\n\nvar process = (typeof window !== 'undefined' && window.process) || {};\nprocess.env = process.env || {};\n\nvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction commonjsRequire () {\n\tthrow new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');\n}\n\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar _global = createCommonjsModule(function (module) {\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n});\n\nvar _core = createCommonjsModule(function (module) {\nvar core = module.exports = { version: '2.5.7' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n});\nvar _core_1 = _core.version;\n\nvar _aFunction = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n// optional / simple context binding\n\nvar _ctx = function (fn, that, length) {\n  _aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\nvar _isObject = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\nvar _anObject = function (it) {\n  if (!_isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n\nvar _fails = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n// Thank's IE8 for his funny defineProperty\nvar _descriptors = !_fails(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n\nvar document$1 = _global.document;\n// typeof document.createElement is 'object' in old IE\nvar is = _isObject(document$1) && _isObject(document$1.createElement);\nvar _domCreate = function (it) {\n  return is ? document$1.createElement(it) : {};\n};\n\nvar _ie8DomDefine = !_descriptors && !_fails(function () {\n  return Object.defineProperty(_domCreate('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\n\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nvar _toPrimitive = function (it, S) {\n  if (!_isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\nvar dP = Object.defineProperty;\n\nvar f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  _anObject(O);\n  P = _toPrimitive(P, true);\n  _anObject(Attributes);\n  if (_ie8DomDefine) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar _objectDp = {\n\tf: f\n};\n\nvar _propertyDesc = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar _hide = _descriptors ? function (object, key, value) {\n  return _objectDp.f(object, key, _propertyDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar hasOwnProperty = {}.hasOwnProperty;\nvar _has = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var IS_WRAP = type & $export.W;\n  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});\n  var expProto = exports[PROTOTYPE];\n  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] : (_global[name] || {})[PROTOTYPE];\n  var key, own, out;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if (own && _has(exports, key)) continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? _ctx(out, _global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function (C) {\n      var F = function (a, b, c) {\n        if (this instanceof C) {\n          switch (arguments.length) {\n            case 0: return new C();\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if (IS_PROTO) {\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if (type & $export.R && expProto && !expProto[key]) _hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nvar _export = $export;\n\nvar toString = {}.toString;\n\nvar _cof = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\n// eslint-disable-next-line no-prototype-builtins\nvar _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return _cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n// 7.2.1 RequireObjectCoercible(argument)\nvar _defined = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n// to indexed object, toObject with fallback for non-array-like ES3 strings\n\n\nvar _toIobject = function (it) {\n  return _iobject(_defined(it));\n};\n\n// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nvar _toInteger = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n// 7.1.15 ToLength\n\nvar min = Math.min;\nvar _toLength = function (it) {\n  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\nvar max = Math.max;\nvar min$1 = Math.min;\nvar _toAbsoluteIndex = function (index, length) {\n  index = _toInteger(index);\n  return index < 0 ? max(index + length, 0) : min$1(index, length);\n};\n\n// false -> Array#indexOf\n// true  -> Array#includes\n\n\n\nvar _arrayIncludes = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = _toIobject($this);\n    var length = _toLength(O.length);\n    var index = _toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar _library = true;\n\nvar _shared = createCommonjsModule(function (module) {\nvar SHARED = '__core-js_shared__';\nvar store = _global[SHARED] || (_global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: _core.version,\n  mode: _library ? 'pure' : 'global',\n  copyright: '© 2018 Denis Pushkarev (zloirock.ru)'\n});\n});\n\nvar id = 0;\nvar px = Math.random();\nvar _uid = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\nvar shared = _shared('keys');\n\nvar _sharedKey = function (key) {\n  return shared[key] || (shared[key] = _uid(key));\n};\n\nvar arrayIndexOf = _arrayIncludes(false);\nvar IE_PROTO = _sharedKey('IE_PROTO');\n\nvar _objectKeysInternal = function (object, names) {\n  var O = _toIobject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) _has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (_has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n// IE 8- don't enum bug keys\nvar _enumBugKeys = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n// 19.1.2.14 / 15.2.3.14 Object.keys(O)\n\n\n\nvar _objectKeys = Object.keys || function keys(O) {\n  return _objectKeysInternal(O, _enumBugKeys);\n};\n\nvar f$1 = Object.getOwnPropertySymbols;\n\nvar _objectGops = {\n\tf: f$1\n};\n\nvar f$2 = {}.propertyIsEnumerable;\n\nvar _objectPie = {\n\tf: f$2\n};\n\n// 7.1.13 ToObject(argument)\n\nvar _toObject = function (it) {\n  return Object(_defined(it));\n};\n\n// 19.1.2.1 Object.assign(target, source, ...)\n\n\n\n\n\nvar $assign = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nvar _objectAssign = !$assign || _fails(function () {\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line no-undef\n  var S = Symbol();\n  var K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function (k) { B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n  var T = _toObject(target);\n  var aLen = arguments.length;\n  var index = 1;\n  var getSymbols = _objectGops.f;\n  var isEnum = _objectPie.f;\n  while (aLen > index) {\n    var S = _iobject(arguments[index++]);\n    var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\n  } return T;\n} : $assign;\n\n// 19.1.3.1 Object.assign(target, source)\n\n\n_export(_export.S + _export.F, 'Object', { assign: _objectAssign });\n\nvar assign = _core.Object.assign;\n\nvar assign$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": assign, __esModule: true };\n});\n\nvar _Object$assign = unwrapExports(assign$1);\n\nvar _extends = createCommonjsModule(function (module, exports) {\n\nexports.__esModule = true;\n\n\n\nvar _assign2 = _interopRequireDefault(assign$1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _assign2.default || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n});\n\nvar _extends$1 = unwrapExports(_extends);\n\n// true  -> String#at\n// false -> String#codePointAt\nvar _stringAt = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(_defined(that));\n    var i = _toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\nvar _redefine = _hide;\n\nvar _iterators = {};\n\nvar _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {\n  _anObject(O);\n  var keys = _objectKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) _objectDp.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\nvar document$2 = _global.document;\nvar _html = document$2 && document$2.documentElement;\n\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n\n\n\nvar IE_PROTO$1 = _sharedKey('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE$1 = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = _domCreate('iframe');\n  var i = _enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  _html.appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE$1][_enumBugKeys[i]];\n  return createDict();\n};\n\nvar _objectCreate = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE$1] = _anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE$1] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO$1] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : _objectDps(result, Properties);\n};\n\nvar _wks = createCommonjsModule(function (module) {\nvar store = _shared('wks');\n\nvar Symbol = _global.Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : _uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n});\n\nvar def = _objectDp.f;\n\nvar TAG = _wks('toStringTag');\n\nvar _setToStringTag = function (it, tag, stat) {\n  if (it && !_has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n_hide(IteratorPrototype, _wks('iterator'), function () { return this; });\n\nvar _iterCreate = function (Constructor, NAME, next) {\n  Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });\n  _setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\n\n\nvar IE_PROTO$2 = _sharedKey('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nvar _objectGpo = Object.getPrototypeOf || function (O) {\n  O = _toObject(O);\n  if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\nvar ITERATOR = _wks('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nvar _iterDefine = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  _iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = _objectGpo($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      _setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!_library && typeof IteratorPrototype[ITERATOR] != 'function') _hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!_library || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    _hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  _iterators[NAME] = $default;\n  _iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) _redefine(proto, key, methods[key]);\n    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\nvar $at = _stringAt(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n_iterDefine(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n\nvar _iterStep = function (done, value) {\n  return { value: value, done: !!done };\n};\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nvar es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {\n  this._t = _toIobject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return _iterStep(1);\n  }\n  if (kind == 'keys') return _iterStep(0, index);\n  if (kind == 'values') return _iterStep(0, O[index]);\n  return _iterStep(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n_iterators.Arguments = _iterators.Array;\n\nvar TO_STRING_TAG = _wks('toStringTag');\n\nvar DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +\n  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +\n  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +\n  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +\n  'TextTrackList,TouchList').split(',');\n\nfor (var i = 0; i < DOMIterables.length; i++) {\n  var NAME = DOMIterables[i];\n  var Collection = _global[NAME];\n  var proto = Collection && Collection.prototype;\n  if (proto && !proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);\n  _iterators[NAME] = _iterators.Array;\n}\n\n// getting tag from 19.1.3.6 Object.prototype.toString()\n\nvar TAG$1 = _wks('toStringTag');\n// ES3 wrong here\nvar ARG = _cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nvar _classof = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG$1)) == 'string' ? T\n    // builtinTag case\n    : ARG ? _cof(O)\n    // ES3 arguments fallback\n    : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\nvar _anInstance = function (it, Constructor, name, forbiddenField) {\n  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n\n// call something on iterator step with safe closing on error\n\nvar _iterCall = function (iterator, fn, value, entries) {\n  try {\n    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) _anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n// check on default Array iterator\n\nvar ITERATOR$1 = _wks('iterator');\nvar ArrayProto = Array.prototype;\n\nvar _isArrayIter = function (it) {\n  return it !== undefined && (_iterators.Array === it || ArrayProto[ITERATOR$1] === it);\n};\n\nvar ITERATOR$2 = _wks('iterator');\n\nvar core_getIteratorMethod = _core.getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR$2]\n    || it['@@iterator']\n    || _iterators[_classof(it)];\n};\n\nvar _forOf = createCommonjsModule(function (module) {\nvar BREAK = {};\nvar RETURN = {};\nvar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n  var iterFn = ITERATOR ? function () { return iterable; } : core_getIteratorMethod(iterable);\n  var f = _ctx(fn, that, entries ? 2 : 1);\n  var index = 0;\n  var length, step, iterator, result;\n  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {\n    result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if (result === BREAK || result === RETURN) return result;\n  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n    result = _iterCall(iterator, f, step.value, entries);\n    if (result === BREAK || result === RETURN) return result;\n  }\n};\nexports.BREAK = BREAK;\nexports.RETURN = RETURN;\n});\n\n// 7.3.20 SpeciesConstructor(O, defaultConstructor)\n\n\nvar SPECIES = _wks('species');\nvar _speciesConstructor = function (O, D) {\n  var C = _anObject(O).constructor;\n  var S;\n  return C === undefined || (S = _anObject(C)[SPECIES]) == undefined ? D : _aFunction(S);\n};\n\n// fast apply, http://jsperf.lnkit.com/fast-apply/5\nvar _invoke = function (fn, args, that) {\n  var un = that === undefined;\n  switch (args.length) {\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return fn.apply(that, args);\n};\n\nvar process$1 = _global.process;\nvar setTask = _global.setImmediate;\nvar clearTask = _global.clearImmediate;\nvar MessageChannel = _global.MessageChannel;\nvar Dispatch = _global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer, channel, port;\nvar run = function () {\n  var id = +this;\n  // eslint-disable-next-line no-prototype-builtins\n  if (queue.hasOwnProperty(id)) {\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function (event) {\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!setTask || !clearTask) {\n  setTask = function setImmediate(fn) {\n    var args = [];\n    var i = 1;\n    while (arguments.length > i) args.push(arguments[i++]);\n    queue[++counter] = function () {\n      // eslint-disable-next-line no-new-func\n      _invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id) {\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if (_cof(process$1) == 'process') {\n    defer = function (id) {\n      process$1.nextTick(_ctx(run, id, 1));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(_ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if (MessageChannel) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = _ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (_global.addEventListener && typeof postMessage == 'function' && !_global.importScripts) {\n    defer = function (id) {\n      _global.postMessage(id + '', '*');\n    };\n    _global.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in _domCreate('script')) {\n    defer = function (id) {\n      _html.appendChild(_domCreate('script'))[ONREADYSTATECHANGE] = function () {\n        _html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(_ctx(run, id, 1), 0);\n    };\n  }\n}\nvar _task = {\n  set: setTask,\n  clear: clearTask\n};\n\nvar macrotask = _task.set;\nvar Observer = _global.MutationObserver || _global.WebKitMutationObserver;\nvar process$2 = _global.process;\nvar Promise$1 = _global.Promise;\nvar isNode = _cof(process$2) == 'process';\n\nvar _microtask = function () {\n  var head, last, notify;\n\n  var flush = function () {\n    var parent, fn;\n    if (isNode && (parent = process$2.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (e) {\n        if (head) notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // Node.js\n  if (isNode) {\n    notify = function () {\n      process$2.nextTick(flush);\n    };\n  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339\n  } else if (Observer && !(_global.navigator && _global.navigator.standalone)) {\n    var toggle = true;\n    var node = document.createTextNode('');\n    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new\n    notify = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (Promise$1 && Promise$1.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    var promise = Promise$1.resolve(undefined);\n    notify = function () {\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function () {\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(_global, flush);\n    };\n  }\n\n  return function (fn) {\n    var task = { fn: fn, next: undefined };\n    if (last) last.next = task;\n    if (!head) {\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n\n// 25.4.1.5 NewPromiseCapability(C)\n\n\nfunction PromiseCapability(C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = _aFunction(resolve);\n  this.reject = _aFunction(reject);\n}\n\nvar f$3 = function (C) {\n  return new PromiseCapability(C);\n};\n\nvar _newPromiseCapability = {\n\tf: f$3\n};\n\nvar _perform = function (exec) {\n  try {\n    return { e: false, v: exec() };\n  } catch (e) {\n    return { e: true, v: e };\n  }\n};\n\nvar navigator$1 = _global.navigator;\n\nvar _userAgent = navigator$1 && navigator$1.userAgent || '';\n\nvar _promiseResolve = function (C, x) {\n  _anObject(C);\n  if (_isObject(x) && x.constructor === C) return x;\n  var promiseCapability = _newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n\nvar _redefineAll = function (target, src, safe) {\n  for (var key in src) {\n    if (safe && target[key]) target[key] = src[key];\n    else _hide(target, key, src[key]);\n  } return target;\n};\n\nvar SPECIES$1 = _wks('species');\n\nvar _setSpecies = function (KEY) {\n  var C = typeof _core[KEY] == 'function' ? _core[KEY] : _global[KEY];\n  if (_descriptors && C && !C[SPECIES$1]) _objectDp.f(C, SPECIES$1, {\n    configurable: true,\n    get: function () { return this; }\n  });\n};\n\nvar ITERATOR$3 = _wks('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR$3]();\n  riter['return'] = function () { SAFE_CLOSING = true; };\n} catch (e) { /* empty */ }\n\nvar _iterDetect = function (exec, skipClosing) {\n  if (!skipClosing && !SAFE_CLOSING) return false;\n  var safe = false;\n  try {\n    var arr = [7];\n    var iter = arr[ITERATOR$3]();\n    iter.next = function () { return { done: safe = true }; };\n    arr[ITERATOR$3] = function () { return iter; };\n    exec(arr);\n  } catch (e) { /* empty */ }\n  return safe;\n};\n\nvar task = _task.set;\nvar microtask = _microtask();\n\n\n\n\nvar PROMISE = 'Promise';\nvar TypeError$1 = _global.TypeError;\nvar process$3 = _global.process;\nvar versions = process$3 && process$3.versions;\nvar v8 = versions && versions.v8 || '';\nvar $Promise = _global[PROMISE];\nvar isNode$1 = _classof(process$3) == 'process';\nvar empty = function () { /* empty */ };\nvar Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;\nvar newPromiseCapability = newGenericPromiseCapability = _newPromiseCapability.f;\n\nvar USE_NATIVE = !!function () {\n  try {\n    // correct subclassing with @@species support\n    var promise = $Promise.resolve(1);\n    var FakePromise = (promise.constructor = {})[_wks('species')] = function (exec) {\n      exec(empty, empty);\n    };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode$1 || typeof PromiseRejectionEvent == 'function')\n      && promise.then(empty) instanceof FakePromise\n      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n      // we can't detect it synchronously, so just check versions\n      && v8.indexOf('6.6') !== 0\n      && _userAgent.indexOf('Chrome/66') === -1;\n  } catch (e) { /* empty */ }\n}();\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return _isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar notify = function (promise, isReject) {\n  if (promise._n) return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function () {\n    var value = promise._v;\n    var ok = promise._s == 1;\n    var i = 0;\n    var run = function (reaction) {\n      var handler = ok ? reaction.ok : reaction.fail;\n      var resolve = reaction.resolve;\n      var reject = reaction.reject;\n      var domain = reaction.domain;\n      var result, then, exited;\n      try {\n        if (handler) {\n          if (!ok) {\n            if (promise._h == 2) onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if (handler === true) result = value;\n          else {\n            if (domain) domain.enter();\n            result = handler(value); // may throw\n            if (domain) {\n              domain.exit();\n              exited = true;\n            }\n          }\n          if (result === reaction.promise) {\n            reject(TypeError$1('Promise-chain cycle'));\n          } else if (then = isThenable(result)) {\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch (e) {\n        if (domain && !exited) domain.exit();\n        reject(e);\n      }\n    };\n    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if (isReject && !promise._h) onUnhandled(promise);\n  });\n};\nvar onUnhandled = function (promise) {\n  task.call(_global, function () {\n    var value = promise._v;\n    var unhandled = isUnhandled(promise);\n    var result, handler, console;\n    if (unhandled) {\n      result = _perform(function () {\n        if (isNode$1) {\n          process$3.emit('unhandledRejection', value, promise);\n        } else if (handler = _global.onunhandledrejection) {\n          handler({ promise: promise, reason: value });\n        } else if ((console = _global.console) && console.error) {\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode$1 || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if (unhandled && result.e) throw result.v;\n  });\n};\nvar isUnhandled = function (promise) {\n  return promise._h !== 1 && (promise._a || promise._c).length === 0;\n};\nvar onHandleUnhandled = function (promise) {\n  task.call(_global, function () {\n    var handler;\n    if (isNode$1) {\n      process$3.emit('rejectionHandled', promise);\n    } else if (handler = _global.onrejectionhandled) {\n      handler({ promise: promise, reason: promise._v });\n    }\n  });\n};\nvar $reject = function (value) {\n  var promise = this;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if (!promise._a) promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function (value) {\n  var promise = this;\n  var then;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if (promise === value) throw TypeError$1(\"Promise can't be resolved itself\");\n    if (then = isThenable(value)) {\n      microtask(function () {\n        var wrapper = { _w: promise, _d: false }; // wrap\n        try {\n          then.call(value, _ctx($resolve, wrapper, 1), _ctx($reject, wrapper, 1));\n        } catch (e) {\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch (e) {\n    $reject.call({ _w: promise, _d: false }, e); // wrap\n  }\n};\n\n// constructor polyfill\nif (!USE_NATIVE) {\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor) {\n    _anInstance(this, $Promise, PROMISE, '_h');\n    _aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(_ctx($resolve, this, 1), _ctx($reject, this, 1));\n    } catch (err) {\n      $reject.call(this, err);\n    }\n  };\n  // eslint-disable-next-line no-unused-vars\n  Internal = function Promise(executor) {\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = _redefineAll($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected) {\n      var reaction = newPromiseCapability(_speciesConstructor(this, $Promise));\n      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode$1 ? process$3.domain : undefined;\n      this._c.push(reaction);\n      if (this._a) this._a.push(reaction);\n      if (this._s) notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function (onRejected) {\n      return this.then(undefined, onRejected);\n    }\n  });\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    this.promise = promise;\n    this.resolve = _ctx($resolve, promise, 1);\n    this.reject = _ctx($reject, promise, 1);\n  };\n  _newPromiseCapability.f = newPromiseCapability = function (C) {\n    return C === $Promise || C === Wrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n}\n\n_export(_export.G + _export.W + _export.F * !USE_NATIVE, { Promise: $Promise });\n_setToStringTag($Promise, PROMISE);\n_setSpecies(PROMISE);\nWrapper = _core[PROMISE];\n\n// statics\n_export(_export.S + _export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r) {\n    var capability = newPromiseCapability(this);\n    var $$reject = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n_export(_export.S + _export.F * (_library || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x) {\n    return _promiseResolve(_library && this === Wrapper ? $Promise : this, x);\n  }\n});\n_export(_export.S + _export.F * !(USE_NATIVE && _iterDetect(function (iter) {\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = _perform(function () {\n      var values = [];\n      var index = 0;\n      var remaining = 1;\n      _forOf(iterable, false, function (promise) {\n        var $index = index++;\n        var alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var reject = capability.reject;\n    var result = _perform(function () {\n      _forOf(iterable, false, function (promise) {\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  }\n});\n\n_export(_export.P + _export.R, 'Promise', { 'finally': function (onFinally) {\n  var C = _speciesConstructor(this, _core.Promise || _global.Promise);\n  var isFunction = typeof onFinally == 'function';\n  return this.then(\n    isFunction ? function (x) {\n      return _promiseResolve(C, onFinally()).then(function () { return x; });\n    } : onFinally,\n    isFunction ? function (e) {\n      return _promiseResolve(C, onFinally()).then(function () { throw e; });\n    } : onFinally\n  );\n} });\n\n// https://github.com/tc39/proposal-promise-try\n\n\n\n\n_export(_export.S, 'Promise', { 'try': function (callbackfn) {\n  var promiseCapability = _newPromiseCapability.f(this);\n  var result = _perform(callbackfn);\n  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);\n  return promiseCapability.promise;\n} });\n\nvar promise = _core.Promise;\n\nvar promise$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": promise, __esModule: true };\n});\n\nvar _Promise = unwrapExports(promise$1);\n\nvar long_1 = createCommonjsModule(function (module) {\n/*\r\n Copyright 2013 Daniel Wirtz <dcode@dcode.io>\r\n Copyright 2009 The Closure Library Authors. All Rights Reserved.\r\n\r\n Licensed under the Apache License, Version 2.0 (the \"License\");\r\n you may not use this file except in compliance with the License.\r\n You may obtain a copy of the License at\r\n\r\n http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n Unless required by applicable law or agreed to in writing, software\r\n distributed under the License is distributed on an \"AS-IS\" BASIS,\r\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n See the License for the specific language governing permissions and\r\n limitations under the License.\r\n */\r\n\r\n/**\r\n * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>\r\n * Released under the Apache License, Version 2.0\r\n * see: https://github.com/dcodeIO/long.js for details\r\n */\r\n(function(global, factory) {\r\n\r\n    /* AMD */ if (false)\r\n        {}\r\n    /* CommonJS */ else if (typeof commonjsRequire === 'function' && 'object' === \"object\" && module && module[\"exports\"])\r\n        module[\"exports\"] = factory();\r\n    /* Global */ else\r\n        (global[\"dcodeIO\"] = global[\"dcodeIO\"] || {})[\"Long\"] = factory();\r\n\r\n})(commonjsGlobal, function() {\r\n\r\n    /**\r\n     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n     *  See the from* functions below for more convenient ways of constructing Longs.\r\n     * @exports Long\r\n     * @class A Long class for representing a 64 bit two's-complement integer value.\r\n     * @param {number} low The low (signed) 32 bits of the long\r\n     * @param {number} high The high (signed) 32 bits of the long\r\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @constructor\r\n     */\r\n    function Long(low, high, unsigned) {\r\n\r\n        /**\r\n         * The low 32 bits as a signed value.\r\n         * @type {number}\r\n         */\r\n        this.low = low | 0;\r\n\r\n        /**\r\n         * The high 32 bits as a signed value.\r\n         * @type {number}\r\n         */\r\n        this.high = high | 0;\r\n\r\n        /**\r\n         * Whether unsigned or not.\r\n         * @type {boolean}\r\n         */\r\n        this.unsigned = !!unsigned;\r\n    }\r\n\r\n    Object.defineProperty(Long.prototype, \"__isLong__\", {\r\n        value: true,\r\n        enumerable: false,\r\n        configurable: false\r\n    });\r\n\r\n    /**\r\n     * @function\r\n     * @param {*} obj Object\r\n     * @returns {boolean}\r\n     * @inner\r\n     */\r\n    function isLong(obj) {\r\n        return (obj && obj[\"__isLong__\"]) === true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the specified object is a Long.\r\n     * @function\r\n     * @param {*} obj Object\r\n     * @returns {boolean}\r\n     */\r\n    Long.isLong = isLong;\r\n\r\n    /**\r\n     * A cache of the Long representations of small integer values.\r\n     * @type {!Object}\r\n     * @inner\r\n     */\r\n    var INT_CACHE = {};\r\n\r\n    /**\r\n     * A cache of the Long representations of small unsigned integer values.\r\n     * @type {!Object}\r\n     * @inner\r\n     */\r\n    var UINT_CACHE = {};\r\n\r\n    /**\r\n     * @param {number} value\r\n     * @param {boolean=} unsigned\r\n     * @returns {!Long}\r\n     * @inner\r\n     */\r\n    function fromInt(value, unsigned) {\r\n        var obj, cachedObj, cache;\r\n        if (unsigned) {\r\n            value >>>= 0;\r\n            if (cache = (0 <= value && value < 256)) {\r\n                cachedObj = UINT_CACHE[value];\r\n                if (cachedObj)\r\n                    return cachedObj;\r\n            }\r\n            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n            if (cache)\r\n                UINT_CACHE[value] = obj;\r\n            return obj;\r\n        } else {\r\n            value |= 0;\r\n            if (cache = (-128 <= value && value < 128)) {\r\n                cachedObj = INT_CACHE[value];\r\n                if (cachedObj)\r\n                    return cachedObj;\r\n            }\r\n            obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n            if (cache)\r\n                INT_CACHE[value] = obj;\r\n            return obj;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a Long representing the given 32 bit integer value.\r\n     * @function\r\n     * @param {number} value The 32 bit integer in question\r\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @returns {!Long} The corresponding Long value\r\n     */\r\n    Long.fromInt = fromInt;\r\n\r\n    /**\r\n     * @param {number} value\r\n     * @param {boolean=} unsigned\r\n     * @returns {!Long}\r\n     * @inner\r\n     */\r\n    function fromNumber(value, unsigned) {\r\n        if (isNaN(value) || !isFinite(value))\r\n            return unsigned ? UZERO : ZERO;\r\n        if (unsigned) {\r\n            if (value < 0)\r\n                return UZERO;\r\n            if (value >= TWO_PWR_64_DBL)\r\n                return MAX_UNSIGNED_VALUE;\r\n        } else {\r\n            if (value <= -TWO_PWR_63_DBL)\r\n                return MIN_VALUE;\r\n            if (value + 1 >= TWO_PWR_63_DBL)\r\n                return MAX_VALUE;\r\n        }\r\n        if (value < 0)\r\n            return fromNumber(-value, unsigned).neg();\r\n        return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n    }\r\n\r\n    /**\r\n     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n     * @function\r\n     * @param {number} value The number in question\r\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @returns {!Long} The corresponding Long value\r\n     */\r\n    Long.fromNumber = fromNumber;\r\n\r\n    /**\r\n     * @param {number} lowBits\r\n     * @param {number} highBits\r\n     * @param {boolean=} unsigned\r\n     * @returns {!Long}\r\n     * @inner\r\n     */\r\n    function fromBits(lowBits, highBits, unsigned) {\r\n        return new Long(lowBits, highBits, unsigned);\r\n    }\r\n\r\n    /**\r\n     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n     *  assumed to use 32 bits.\r\n     * @function\r\n     * @param {number} lowBits The low 32 bits\r\n     * @param {number} highBits The high 32 bits\r\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @returns {!Long} The corresponding Long value\r\n     */\r\n    Long.fromBits = fromBits;\r\n\r\n    /**\r\n     * @function\r\n     * @param {number} base\r\n     * @param {number} exponent\r\n     * @returns {number}\r\n     * @inner\r\n     */\r\n    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n    /**\r\n     * @param {string} str\r\n     * @param {(boolean|number)=} unsigned\r\n     * @param {number=} radix\r\n     * @returns {!Long}\r\n     * @inner\r\n     */\r\n    function fromString(str, unsigned, radix) {\r\n        if (str.length === 0)\r\n            throw Error('empty string');\r\n        if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n            return ZERO;\r\n        if (typeof unsigned === 'number') {\r\n            // For goog.math.long compatibility\r\n            radix = unsigned, unsigned = false;\r\n        } else {\r\n            unsigned = !! unsigned;\r\n        }\r\n        radix = radix || 10;\r\n        if (radix < 2 || 36 < radix)\r\n            throw RangeError('radix');\r\n\r\n        var p;\r\n        if ((p = str.indexOf('-')) > 0)\r\n            throw Error('interior hyphen');\r\n        else if (p === 0) {\r\n            return fromString(str.substring(1), unsigned, radix).neg();\r\n        }\r\n\r\n        // Do several (8) digits each time through the loop, so as to\r\n        // minimize the calls to the very expensive emulated div.\r\n        var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n        var result = ZERO;\r\n        for (var i = 0; i < str.length; i += 8) {\r\n            var size = Math.min(8, str.length - i),\r\n                value = parseInt(str.substring(i, i + size), radix);\r\n            if (size < 8) {\r\n                var power = fromNumber(pow_dbl(radix, size));\r\n                result = result.mul(power).add(fromNumber(value));\r\n            } else {\r\n                result = result.mul(radixToPower);\r\n                result = result.add(fromNumber(value));\r\n            }\r\n        }\r\n        result.unsigned = unsigned;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a Long representation of the given string, written using the specified radix.\r\n     * @function\r\n     * @param {string} str The textual representation of the Long\r\n     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed\r\n     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n     * @returns {!Long} The corresponding Long value\r\n     */\r\n    Long.fromString = fromString;\r\n\r\n    /**\r\n     * @function\r\n     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n     * @returns {!Long}\r\n     * @inner\r\n     */\r\n    function fromValue(val) {\r\n        if (val /* is compatible */ instanceof Long)\r\n            return val;\r\n        if (typeof val === 'number')\r\n            return fromNumber(val);\r\n        if (typeof val === 'string')\r\n            return fromString(val);\r\n        // Throws for non-objects, converts non-instanceof Long:\r\n        return fromBits(val.low, val.high, val.unsigned);\r\n    }\r\n\r\n    /**\r\n     * Converts the specified value to a Long.\r\n     * @function\r\n     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n     * @returns {!Long}\r\n     */\r\n    Long.fromValue = fromValue;\r\n\r\n    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n    // no runtime penalty for these.\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_16_DBL = 1 << 16;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_24_DBL = 1 << 24;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n    /**\r\n     * @type {number}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @const\r\n     * @inner\r\n     */\r\n    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var ZERO = fromInt(0);\r\n\r\n    /**\r\n     * Signed zero.\r\n     * @type {!Long}\r\n     */\r\n    Long.ZERO = ZERO;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var UZERO = fromInt(0, true);\r\n\r\n    /**\r\n     * Unsigned zero.\r\n     * @type {!Long}\r\n     */\r\n    Long.UZERO = UZERO;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var ONE = fromInt(1);\r\n\r\n    /**\r\n     * Signed one.\r\n     * @type {!Long}\r\n     */\r\n    Long.ONE = ONE;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var UONE = fromInt(1, true);\r\n\r\n    /**\r\n     * Unsigned one.\r\n     * @type {!Long}\r\n     */\r\n    Long.UONE = UONE;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var NEG_ONE = fromInt(-1);\r\n\r\n    /**\r\n     * Signed negative one.\r\n     * @type {!Long}\r\n     */\r\n    Long.NEG_ONE = NEG_ONE;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n    /**\r\n     * Maximum signed value.\r\n     * @type {!Long}\r\n     */\r\n    Long.MAX_VALUE = MAX_VALUE;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n    /**\r\n     * Maximum unsigned value.\r\n     * @type {!Long}\r\n     */\r\n    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n    /**\r\n     * @type {!Long}\r\n     * @inner\r\n     */\r\n    var MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n    /**\r\n     * Minimum signed value.\r\n     * @type {!Long}\r\n     */\r\n    Long.MIN_VALUE = MIN_VALUE;\r\n\r\n    /**\r\n     * @alias Long.prototype\r\n     * @inner\r\n     */\r\n    var LongPrototype = Long.prototype;\r\n\r\n    /**\r\n     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n     * @returns {number}\r\n     */\r\n    LongPrototype.toInt = function toInt() {\r\n        return this.unsigned ? this.low >>> 0 : this.low;\r\n    };\r\n\r\n    /**\r\n     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n     * @returns {number}\r\n     */\r\n    LongPrototype.toNumber = function toNumber() {\r\n        if (this.unsigned)\r\n            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n    };\r\n\r\n    /**\r\n     * Converts the Long to a string written in the specified radix.\r\n     * @param {number=} radix Radix (2-36), defaults to 10\r\n     * @returns {string}\r\n     * @override\r\n     * @throws {RangeError} If `radix` is out of range\r\n     */\r\n    LongPrototype.toString = function toString(radix) {\r\n        radix = radix || 10;\r\n        if (radix < 2 || 36 < radix)\r\n            throw RangeError('radix');\r\n        if (this.isZero())\r\n            return '0';\r\n        if (this.isNegative()) { // Unsigned Longs are never negative\r\n            if (this.eq(MIN_VALUE)) {\r\n                // We need to change the Long value before it can be negated, so we remove\r\n                // the bottom-most digit in this base and then recurse to do the rest.\r\n                var radixLong = fromNumber(radix),\r\n                    div = this.div(radixLong),\r\n                    rem1 = div.mul(radixLong).sub(this);\r\n                return div.toString(radix) + rem1.toInt().toString(radix);\r\n            } else\r\n                return '-' + this.neg().toString(radix);\r\n        }\r\n\r\n        // Do several (6) digits each time through the loop, so as to\r\n        // minimize the calls to the very expensive emulated div.\r\n        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n            rem = this;\r\n        var result = '';\r\n        while (true) {\r\n            var remDiv = rem.div(radixToPower),\r\n                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n                digits = intval.toString(radix);\r\n            rem = remDiv;\r\n            if (rem.isZero())\r\n                return digits + result;\r\n            else {\r\n                while (digits.length < 6)\r\n                    digits = '0' + digits;\r\n                result = '' + digits + result;\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets the high 32 bits as a signed integer.\r\n     * @returns {number} Signed high bits\r\n     */\r\n    LongPrototype.getHighBits = function getHighBits() {\r\n        return this.high;\r\n    };\r\n\r\n    /**\r\n     * Gets the high 32 bits as an unsigned integer.\r\n     * @returns {number} Unsigned high bits\r\n     */\r\n    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n        return this.high >>> 0;\r\n    };\r\n\r\n    /**\r\n     * Gets the low 32 bits as a signed integer.\r\n     * @returns {number} Signed low bits\r\n     */\r\n    LongPrototype.getLowBits = function getLowBits() {\r\n        return this.low;\r\n    };\r\n\r\n    /**\r\n     * Gets the low 32 bits as an unsigned integer.\r\n     * @returns {number} Unsigned low bits\r\n     */\r\n    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n        return this.low >>> 0;\r\n    };\r\n\r\n    /**\r\n     * Gets the number of bits needed to represent the absolute value of this Long.\r\n     * @returns {number}\r\n     */\r\n    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n        if (this.isNegative()) // Unsigned Longs are never negative\r\n            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n        var val = this.high != 0 ? this.high : this.low;\r\n        for (var bit = 31; bit > 0; bit--)\r\n            if ((val & (1 << bit)) != 0)\r\n                break;\r\n        return this.high != 0 ? bit + 33 : bit + 1;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value equals zero.\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.isZero = function isZero() {\r\n        return this.high === 0 && this.low === 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is negative.\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.isNegative = function isNegative() {\r\n        return !this.unsigned && this.high < 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is positive.\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.isPositive = function isPositive() {\r\n        return this.unsigned || this.high >= 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is odd.\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.isOdd = function isOdd() {\r\n        return (this.low & 1) === 1;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is even.\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.isEven = function isEven() {\r\n        return (this.low & 1) === 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value equals the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.equals = function equals(other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n            return false;\r\n        return this.high === other.high && this.low === other.low;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.eq = LongPrototype.equals;\r\n\r\n    /**\r\n     * Tests if this Long's value differs from the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.notEquals = function notEquals(other) {\r\n        return !this.eq(/* validates */ other);\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.neq = LongPrototype.notEquals;\r\n\r\n    /**\r\n     * Tests if this Long's value is less than the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.lessThan = function lessThan(other) {\r\n        return this.comp(/* validates */ other) < 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.lt = LongPrototype.lessThan;\r\n\r\n    /**\r\n     * Tests if this Long's value is less than or equal the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n        return this.comp(/* validates */ other) <= 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n    /**\r\n     * Tests if this Long's value is greater than the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.greaterThan = function greaterThan(other) {\r\n        return this.comp(/* validates */ other) > 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n    /**\r\n     * Tests if this Long's value is greater than or equal the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n        return this.comp(/* validates */ other) >= 0;\r\n    };\r\n\r\n    /**\r\n     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {boolean}\r\n     */\r\n    LongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n    /**\r\n     * Compares this Long's value with the specified's.\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n     *  if the given one is greater\r\n     */\r\n    LongPrototype.compare = function compare(other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        if (this.eq(other))\r\n            return 0;\r\n        var thisNeg = this.isNegative(),\r\n            otherNeg = other.isNegative();\r\n        if (thisNeg && !otherNeg)\r\n            return -1;\r\n        if (!thisNeg && otherNeg)\r\n            return 1;\r\n        // At this point the sign bits are the same\r\n        if (!this.unsigned)\r\n            return this.sub(other).isNegative() ? -1 : 1;\r\n        // Both are positive if at least one is unsigned\r\n        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n    };\r\n\r\n    /**\r\n     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n     * @function\r\n     * @param {!Long|number|string} other Other value\r\n     * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n     *  if the given one is greater\r\n     */\r\n    LongPrototype.comp = LongPrototype.compare;\r\n\r\n    /**\r\n     * Negates this Long's value.\r\n     * @returns {!Long} Negated Long\r\n     */\r\n    LongPrototype.negate = function negate() {\r\n        if (!this.unsigned && this.eq(MIN_VALUE))\r\n            return MIN_VALUE;\r\n        return this.not().add(ONE);\r\n    };\r\n\r\n    /**\r\n     * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n     * @function\r\n     * @returns {!Long} Negated Long\r\n     */\r\n    LongPrototype.neg = LongPrototype.negate;\r\n\r\n    /**\r\n     * Returns the sum of this and the specified Long.\r\n     * @param {!Long|number|string} addend Addend\r\n     * @returns {!Long} Sum\r\n     */\r\n    LongPrototype.add = function add(addend) {\r\n        if (!isLong(addend))\r\n            addend = fromValue(addend);\r\n\r\n        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n        var a48 = this.high >>> 16;\r\n        var a32 = this.high & 0xFFFF;\r\n        var a16 = this.low >>> 16;\r\n        var a00 = this.low & 0xFFFF;\r\n\r\n        var b48 = addend.high >>> 16;\r\n        var b32 = addend.high & 0xFFFF;\r\n        var b16 = addend.low >>> 16;\r\n        var b00 = addend.low & 0xFFFF;\r\n\r\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n        c00 += a00 + b00;\r\n        c16 += c00 >>> 16;\r\n        c00 &= 0xFFFF;\r\n        c16 += a16 + b16;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c32 += a32 + b32;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c48 += a48 + b48;\r\n        c48 &= 0xFFFF;\r\n        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the difference of this and the specified Long.\r\n     * @param {!Long|number|string} subtrahend Subtrahend\r\n     * @returns {!Long} Difference\r\n     */\r\n    LongPrototype.subtract = function subtract(subtrahend) {\r\n        if (!isLong(subtrahend))\r\n            subtrahend = fromValue(subtrahend);\r\n        return this.add(subtrahend.neg());\r\n    };\r\n\r\n    /**\r\n     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n     * @function\r\n     * @param {!Long|number|string} subtrahend Subtrahend\r\n     * @returns {!Long} Difference\r\n     */\r\n    LongPrototype.sub = LongPrototype.subtract;\r\n\r\n    /**\r\n     * Returns the product of this and the specified Long.\r\n     * @param {!Long|number|string} multiplier Multiplier\r\n     * @returns {!Long} Product\r\n     */\r\n    LongPrototype.multiply = function multiply(multiplier) {\r\n        if (this.isZero())\r\n            return ZERO;\r\n        if (!isLong(multiplier))\r\n            multiplier = fromValue(multiplier);\r\n        if (multiplier.isZero())\r\n            return ZERO;\r\n        if (this.eq(MIN_VALUE))\r\n            return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n        if (multiplier.eq(MIN_VALUE))\r\n            return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n        if (this.isNegative()) {\r\n            if (multiplier.isNegative())\r\n                return this.neg().mul(multiplier.neg());\r\n            else\r\n                return this.neg().mul(multiplier).neg();\r\n        } else if (multiplier.isNegative())\r\n            return this.mul(multiplier.neg()).neg();\r\n\r\n        // If both longs are small, use float multiplication\r\n        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n        // We can skip products that would overflow.\r\n\r\n        var a48 = this.high >>> 16;\r\n        var a32 = this.high & 0xFFFF;\r\n        var a16 = this.low >>> 16;\r\n        var a00 = this.low & 0xFFFF;\r\n\r\n        var b48 = multiplier.high >>> 16;\r\n        var b32 = multiplier.high & 0xFFFF;\r\n        var b16 = multiplier.low >>> 16;\r\n        var b00 = multiplier.low & 0xFFFF;\r\n\r\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n        c00 += a00 * b00;\r\n        c16 += c00 >>> 16;\r\n        c00 &= 0xFFFF;\r\n        c16 += a16 * b00;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c16 += a00 * b16;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c32 += a32 * b00;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c32 += a16 * b16;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c32 += a00 * b32;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n        c48 &= 0xFFFF;\r\n        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n     * @function\r\n     * @param {!Long|number|string} multiplier Multiplier\r\n     * @returns {!Long} Product\r\n     */\r\n    LongPrototype.mul = LongPrototype.multiply;\r\n\r\n    /**\r\n     * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n     *  unsigned if this Long is unsigned.\r\n     * @param {!Long|number|string} divisor Divisor\r\n     * @returns {!Long} Quotient\r\n     */\r\n    LongPrototype.divide = function divide(divisor) {\r\n        if (!isLong(divisor))\r\n            divisor = fromValue(divisor);\r\n        if (divisor.isZero())\r\n            throw Error('division by zero');\r\n        if (this.isZero())\r\n            return this.unsigned ? UZERO : ZERO;\r\n        var approx, rem, res;\r\n        if (!this.unsigned) {\r\n            // This section is only relevant for signed longs and is derived from the\r\n            // closure library as a whole.\r\n            if (this.eq(MIN_VALUE)) {\r\n                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                    return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n                else if (divisor.eq(MIN_VALUE))\r\n                    return ONE;\r\n                else {\r\n                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                    var halfThis = this.shr(1);\r\n                    approx = halfThis.div(divisor).shl(1);\r\n                    if (approx.eq(ZERO)) {\r\n                        return divisor.isNegative() ? ONE : NEG_ONE;\r\n                    } else {\r\n                        rem = this.sub(divisor.mul(approx));\r\n                        res = approx.add(rem.div(divisor));\r\n                        return res;\r\n                    }\r\n                }\r\n            } else if (divisor.eq(MIN_VALUE))\r\n                return this.unsigned ? UZERO : ZERO;\r\n            if (this.isNegative()) {\r\n                if (divisor.isNegative())\r\n                    return this.neg().div(divisor.neg());\r\n                return this.neg().div(divisor).neg();\r\n            } else if (divisor.isNegative())\r\n                return this.div(divisor.neg()).neg();\r\n            res = ZERO;\r\n        } else {\r\n            // The algorithm below has not been made for unsigned longs. It's therefore\r\n            // required to take special care of the MSB prior to running it.\r\n            if (!divisor.unsigned)\r\n                divisor = divisor.toUnsigned();\r\n            if (divisor.gt(this))\r\n                return UZERO;\r\n            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n                return UONE;\r\n            res = UZERO;\r\n        }\r\n\r\n        // Repeat the following until the remainder is less than other:  find a\r\n        // floating-point that approximates remainder / other *from below*, add this\r\n        // into the result, and subtract it from the remainder.  It is critical that\r\n        // the approximate value is less than or equal to the real value so that the\r\n        // remainder never becomes negative.\r\n        rem = this;\r\n        while (rem.gte(divisor)) {\r\n            // Approximate the result of division. This may be a little greater or\r\n            // smaller than the actual value.\r\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n            // We will tweak the approximate result by changing it in the 48-th digit or\r\n            // the smallest non-fractional digit, whichever is larger.\r\n            var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n                delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n            // Decrease the approximation until it is smaller than the remainder.  Note\r\n            // that if it is too large, the product overflows and is negative.\r\n                approxRes = fromNumber(approx),\r\n                approxRem = approxRes.mul(divisor);\r\n            while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n                approx -= delta;\r\n                approxRes = fromNumber(approx, this.unsigned);\r\n                approxRem = approxRes.mul(divisor);\r\n            }\r\n\r\n            // We know the answer can't be zero... and actually, zero would cause\r\n            // infinite recursion since we would make no progress.\r\n            if (approxRes.isZero())\r\n                approxRes = ONE;\r\n\r\n            res = res.add(approxRes);\r\n            rem = rem.sub(approxRem);\r\n        }\r\n        return res;\r\n    };\r\n\r\n    /**\r\n     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n     * @function\r\n     * @param {!Long|number|string} divisor Divisor\r\n     * @returns {!Long} Quotient\r\n     */\r\n    LongPrototype.div = LongPrototype.divide;\r\n\r\n    /**\r\n     * Returns this Long modulo the specified.\r\n     * @param {!Long|number|string} divisor Divisor\r\n     * @returns {!Long} Remainder\r\n     */\r\n    LongPrototype.modulo = function modulo(divisor) {\r\n        if (!isLong(divisor))\r\n            divisor = fromValue(divisor);\r\n        return this.sub(this.div(divisor).mul(divisor));\r\n    };\r\n\r\n    /**\r\n     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n     * @function\r\n     * @param {!Long|number|string} divisor Divisor\r\n     * @returns {!Long} Remainder\r\n     */\r\n    LongPrototype.mod = LongPrototype.modulo;\r\n\r\n    /**\r\n     * Returns the bitwise NOT of this Long.\r\n     * @returns {!Long}\r\n     */\r\n    LongPrototype.not = function not() {\r\n        return fromBits(~this.low, ~this.high, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the bitwise AND of this Long and the specified.\r\n     * @param {!Long|number|string} other Other Long\r\n     * @returns {!Long}\r\n     */\r\n    LongPrototype.and = function and(other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the bitwise OR of this Long and the specified.\r\n     * @param {!Long|number|string} other Other Long\r\n     * @returns {!Long}\r\n     */\r\n    LongPrototype.or = function or(other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns the bitwise XOR of this Long and the given one.\r\n     * @param {!Long|number|string} other Other Long\r\n     * @returns {!Long}\r\n     */\r\n    LongPrototype.xor = function xor(other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns this Long with bits shifted to the left by the given amount.\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        if ((numBits &= 63) === 0)\r\n            return this;\r\n        else if (numBits < 32)\r\n            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n        else\r\n            return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n     * @function\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n    /**\r\n     * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shiftRight = function shiftRight(numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        if ((numBits &= 63) === 0)\r\n            return this;\r\n        else if (numBits < 32)\r\n            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n        else\r\n            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n    };\r\n\r\n    /**\r\n     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n     * @function\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n    /**\r\n     * Returns this Long with bits logically shifted to the right by the given amount.\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        numBits &= 63;\r\n        if (numBits === 0)\r\n            return this;\r\n        else {\r\n            var high = this.high;\r\n            if (numBits < 32) {\r\n                var low = this.low;\r\n                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n            } else if (numBits === 32)\r\n                return fromBits(high, 0, this.unsigned);\r\n            else\r\n                return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n     * @function\r\n     * @param {number|!Long} numBits Number of bits\r\n     * @returns {!Long} Shifted Long\r\n     */\r\n    LongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n    /**\r\n     * Converts this Long to signed.\r\n     * @returns {!Long} Signed long\r\n     */\r\n    LongPrototype.toSigned = function toSigned() {\r\n        if (!this.unsigned)\r\n            return this;\r\n        return fromBits(this.low, this.high, false);\r\n    };\r\n\r\n    /**\r\n     * Converts this Long to unsigned.\r\n     * @returns {!Long} Unsigned long\r\n     */\r\n    LongPrototype.toUnsigned = function toUnsigned() {\r\n        if (this.unsigned)\r\n            return this;\r\n        return fromBits(this.low, this.high, true);\r\n    };\r\n\r\n    /**\r\n     * Converts this Long to its byte representation.\r\n     * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n     * @returns {!Array.<number>} Byte representation\r\n     */\r\n    LongPrototype.toBytes = function(le) {\r\n        return le ? this.toBytesLE() : this.toBytesBE();\r\n    };\r\n\r\n    /**\r\n     * Converts this Long to its little endian byte representation.\r\n     * @returns {!Array.<number>} Little endian byte representation\r\n     */\r\n    LongPrototype.toBytesLE = function() {\r\n        var hi = this.high,\r\n            lo = this.low;\r\n        return [\r\n             lo         & 0xff,\r\n            (lo >>>  8) & 0xff,\r\n            (lo >>> 16) & 0xff,\r\n            (lo >>> 24) & 0xff,\r\n             hi         & 0xff,\r\n            (hi >>>  8) & 0xff,\r\n            (hi >>> 16) & 0xff,\r\n            (hi >>> 24) & 0xff\r\n        ];\r\n    };\r\n\r\n    /**\r\n     * Converts this Long to its big endian byte representation.\r\n     * @returns {!Array.<number>} Big endian byte representation\r\n     */\r\n    LongPrototype.toBytesBE = function() {\r\n        var hi = this.high,\r\n            lo = this.low;\r\n        return [\r\n            (hi >>> 24) & 0xff,\r\n            (hi >>> 16) & 0xff,\r\n            (hi >>>  8) & 0xff,\r\n             hi         & 0xff,\r\n            (lo >>> 24) & 0xff,\r\n            (lo >>> 16) & 0xff,\r\n            (lo >>>  8) & 0xff,\r\n             lo         & 0xff\r\n        ];\r\n    };\r\n\r\n    return Long;\r\n});\n});\n\nvar bytebuffer = createCommonjsModule(function (module) {\n/*\r\n Copyright 2013-2014 Daniel Wirtz <dcode@dcode.io>\r\n\r\n Licensed under the Apache License, Version 2.0 (the \"License\");\r\n you may not use this file except in compliance with the License.\r\n You may obtain a copy of the License at\r\n\r\n http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n Unless required by applicable law or agreed to in writing, software\r\n distributed under the License is distributed on an \"AS IS\" BASIS,\r\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n See the License for the specific language governing permissions and\r\n limitations under the License.\r\n */\r\n\r\n/**\r\n * @license bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>\r\n * Backing buffer: ArrayBuffer, Accessor: Uint8Array\r\n * Released under the Apache License, Version 2.0\r\n * see: https://github.com/dcodeIO/bytebuffer.js for details\r\n */\r\n(function(global, factory) {\r\n\r\n    /* AMD */ if (false)\r\n        {}\r\n    /* CommonJS */ else if (typeof commonjsRequire === 'function' && 'object' === \"object\" && module && module[\"exports\"])\r\n        module['exports'] = (function() {\r\n            var Long; try { Long = long_1; } catch (e) {}\r\n            return factory(Long);\r\n        })();\r\n    /* Global */ else\r\n        (global[\"dcodeIO\"] = global[\"dcodeIO\"] || {})[\"ByteBuffer\"] = factory(global[\"dcodeIO\"][\"Long\"]);\r\n\r\n})(commonjsGlobal, function(Long) {\r\n\r\n    /**\r\n     * Constructs a new ByteBuffer.\r\n     * @class The swiss army knife for binary data in JavaScript.\r\n     * @exports ByteBuffer\r\n     * @constructor\r\n     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_NOASSERT}.\r\n     * @expose\r\n     */\r\n    var ByteBuffer = function(capacity, littleEndian, noAssert) {\r\n        if (typeof capacity === 'undefined')\r\n            capacity = ByteBuffer.DEFAULT_CAPACITY;\r\n        if (typeof littleEndian === 'undefined')\r\n            littleEndian = ByteBuffer.DEFAULT_ENDIAN;\r\n        if (typeof noAssert === 'undefined')\r\n            noAssert = ByteBuffer.DEFAULT_NOASSERT;\r\n        if (!noAssert) {\r\n            capacity = capacity | 0;\r\n            if (capacity < 0)\r\n                throw RangeError(\"Illegal capacity\");\r\n            littleEndian = !!littleEndian;\r\n            noAssert = !!noAssert;\r\n        }\r\n\r\n        /**\r\n         * Backing ArrayBuffer.\r\n         * @type {!ArrayBuffer}\r\n         * @expose\r\n         */\r\n        this.buffer = capacity === 0 ? EMPTY_BUFFER : new ArrayBuffer(capacity);\r\n\r\n        /**\r\n         * Uint8Array utilized to manipulate the backing buffer. Becomes `null` if the backing buffer has a capacity of `0`.\r\n         * @type {?Uint8Array}\r\n         * @expose\r\n         */\r\n        this.view = capacity === 0 ? null : new Uint8Array(this.buffer);\r\n\r\n        /**\r\n         * Absolute read/write offset.\r\n         * @type {number}\r\n         * @expose\r\n         * @see ByteBuffer#flip\r\n         * @see ByteBuffer#clear\r\n         */\r\n        this.offset = 0;\r\n\r\n        /**\r\n         * Marked offset.\r\n         * @type {number}\r\n         * @expose\r\n         * @see ByteBuffer#mark\r\n         * @see ByteBuffer#reset\r\n         */\r\n        this.markedOffset = -1;\r\n\r\n        /**\r\n         * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.\r\n         * @type {number}\r\n         * @expose\r\n         * @see ByteBuffer#flip\r\n         * @see ByteBuffer#clear\r\n         */\r\n        this.limit = capacity;\r\n\r\n        /**\r\n         * Whether to use little endian byte order, defaults to `false` for big endian.\r\n         * @type {boolean}\r\n         * @expose\r\n         */\r\n        this.littleEndian = littleEndian;\r\n\r\n        /**\r\n         * Whether to skip assertions of offsets and values, defaults to `false`.\r\n         * @type {boolean}\r\n         * @expose\r\n         */\r\n        this.noAssert = noAssert;\r\n    };\r\n\r\n    /**\r\n     * ByteBuffer version.\r\n     * @type {string}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ByteBuffer.VERSION = \"5.0.1\";\r\n\r\n    /**\r\n     * Little endian constant that can be used instead of its boolean value. Evaluates to `true`.\r\n     * @type {boolean}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ByteBuffer.LITTLE_ENDIAN = true;\r\n\r\n    /**\r\n     * Big endian constant that can be used instead of its boolean value. Evaluates to `false`.\r\n     * @type {boolean}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ByteBuffer.BIG_ENDIAN = false;\r\n\r\n    /**\r\n     * Default initial capacity of `16`.\r\n     * @type {number}\r\n     * @expose\r\n     */\r\n    ByteBuffer.DEFAULT_CAPACITY = 16;\r\n\r\n    /**\r\n     * Default endianess of `false` for big endian.\r\n     * @type {boolean}\r\n     * @expose\r\n     */\r\n    ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN;\r\n\r\n    /**\r\n     * Default no assertions flag of `false`.\r\n     * @type {boolean}\r\n     * @expose\r\n     */\r\n    ByteBuffer.DEFAULT_NOASSERT = false;\r\n\r\n    /**\r\n     * A `Long` class for representing a 64-bit two's-complement integer value. May be `null` if Long.js has not been loaded\r\n     *  and int64 support is not available.\r\n     * @type {?Long}\r\n     * @const\r\n     * @see https://github.com/dcodeIO/long.js\r\n     * @expose\r\n     */\r\n    ByteBuffer.Long = Long || null;\r\n\r\n    /**\r\n     * @alias ByteBuffer.prototype\r\n     * @inner\r\n     */\r\n    var ByteBufferPrototype = ByteBuffer.prototype;\r\n\r\n    Object.defineProperty(ByteBufferPrototype, \"__isByteBuffer__\", {\r\n        value: true,\r\n        enumerable: false,\r\n        configurable: false\r\n    });\r\n\r\n    // helpers\r\n\r\n    /**\r\n     * @type {!ArrayBuffer}\r\n     * @inner\r\n     */\r\n    var EMPTY_BUFFER = new ArrayBuffer(0);\r\n\r\n    /**\r\n     * String.fromCharCode reference for compile-time renaming.\r\n     * @type {function(...number):string}\r\n     * @inner\r\n     */\r\n    var stringFromCharCode = String.fromCharCode;\r\n\r\n    /**\r\n     * Creates a source function for a string.\r\n     * @param {string} s String to read from\r\n     * @returns {function():number|null} Source function returning the next char code respectively `null` if there are\r\n     *  no more characters left.\r\n     * @throws {TypeError} If the argument is invalid\r\n     * @inner\r\n     */\r\n    function stringSource(s) {\r\n        var i=0; return function() {\r\n            return i < s.length ? s.charCodeAt(i++) : null;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates a destination function for a string.\r\n     * @returns {function(number=):undefined|string} Destination function successively called with the next char code.\r\n     *  Returns the final string when called without arguments.\r\n     * @inner\r\n     */\r\n    function stringDestination() {\r\n        var cs = [], ps = []; return function() {\r\n            if (arguments.length === 0)\r\n                return ps.join('')+stringFromCharCode.apply(String, cs);\r\n            if (cs.length + arguments.length > 1024)\r\n                ps.push(stringFromCharCode.apply(String, cs)), cs.length = 0;\r\n            Array.prototype.push.apply(cs, arguments);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the accessor type.\r\n     * @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes)\r\n     * @expose\r\n     */\r\n    ByteBuffer.accessor = function() {\r\n        return Uint8Array;\r\n    };\r\n    /**\r\n     * Allocates a new ByteBuffer backed by a buffer of the specified capacity.\r\n     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_NOASSERT}.\r\n     * @returns {!ByteBuffer}\r\n     * @expose\r\n     */\r\n    ByteBuffer.allocate = function(capacity, littleEndian, noAssert) {\r\n        return new ByteBuffer(capacity, littleEndian, noAssert);\r\n    };\r\n\r\n    /**\r\n     * Concatenates multiple ByteBuffers into one.\r\n     * @param {!Array.<!ByteBuffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate\r\n     * @param {(string|boolean)=} encoding String encoding if `buffers` contains a string (\"base64\", \"hex\", \"binary\",\r\n     *  defaults to \"utf8\")\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults\r\n     *  to {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_NOASSERT}.\r\n     * @returns {!ByteBuffer} Concatenated ByteBuffer\r\n     * @expose\r\n     */\r\n    ByteBuffer.concat = function(buffers, encoding, littleEndian, noAssert) {\r\n        if (typeof encoding === 'boolean' || typeof encoding !== 'string') {\r\n            noAssert = littleEndian;\r\n            littleEndian = encoding;\r\n            encoding = undefined;\r\n        }\r\n        var capacity = 0;\r\n        for (var i=0, k=buffers.length, length; i<k; ++i) {\r\n            if (!ByteBuffer.isByteBuffer(buffers[i]))\r\n                buffers[i] = ByteBuffer.wrap(buffers[i], encoding);\r\n            length = buffers[i].limit - buffers[i].offset;\r\n            if (length > 0) capacity += length;\r\n        }\r\n        if (capacity === 0)\r\n            return new ByteBuffer(0, littleEndian, noAssert);\r\n        var bb = new ByteBuffer(capacity, littleEndian, noAssert),\r\n            bi;\r\n        i=0; while (i<k) {\r\n            bi = buffers[i++];\r\n            length = bi.limit - bi.offset;\r\n            if (length <= 0) continue;\r\n            bb.view.set(bi.view.subarray(bi.offset, bi.limit), bb.offset);\r\n            bb.offset += length;\r\n        }\r\n        bb.limit = bb.offset;\r\n        bb.offset = 0;\r\n        return bb;\r\n    };\r\n\r\n    /**\r\n     * Tests if the specified type is a ByteBuffer.\r\n     * @param {*} bb ByteBuffer to test\r\n     * @returns {boolean} `true` if it is a ByteBuffer, otherwise `false`\r\n     * @expose\r\n     */\r\n    ByteBuffer.isByteBuffer = function(bb) {\r\n        return (bb && bb[\"__isByteBuffer__\"]) === true;\r\n    };\r\n    /**\r\n     * Gets the backing buffer type.\r\n     * @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes)\r\n     * @expose\r\n     */\r\n    ByteBuffer.type = function() {\r\n        return ArrayBuffer;\r\n    };\r\n    /**\r\n     * Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its\r\n     *  {@link ByteBuffer#limit} to the length of the wrapped data.\r\n     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped\r\n     * @param {(string|boolean)=} encoding String encoding if `buffer` is a string (\"base64\", \"hex\", \"binary\", defaults to\r\n     *  \"utf8\")\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_NOASSERT}.\r\n     * @returns {!ByteBuffer} A ByteBuffer wrapping `buffer`\r\n     * @expose\r\n     */\r\n    ByteBuffer.wrap = function(buffer, encoding, littleEndian, noAssert) {\r\n        if (typeof encoding !== 'string') {\r\n            noAssert = littleEndian;\r\n            littleEndian = encoding;\r\n            encoding = undefined;\r\n        }\r\n        if (typeof buffer === 'string') {\r\n            if (typeof encoding === 'undefined')\r\n                encoding = \"utf8\";\r\n            switch (encoding) {\r\n                case \"base64\":\r\n                    return ByteBuffer.fromBase64(buffer, littleEndian);\r\n                case \"hex\":\r\n                    return ByteBuffer.fromHex(buffer, littleEndian);\r\n                case \"binary\":\r\n                    return ByteBuffer.fromBinary(buffer, littleEndian);\r\n                case \"utf8\":\r\n                    return ByteBuffer.fromUTF8(buffer, littleEndian);\r\n                case \"debug\":\r\n                    return ByteBuffer.fromDebug(buffer, littleEndian);\r\n                default:\r\n                    throw Error(\"Unsupported encoding: \"+encoding);\r\n            }\r\n        }\r\n        if (buffer === null || typeof buffer !== 'object')\r\n            throw TypeError(\"Illegal buffer\");\r\n        var bb;\r\n        if (ByteBuffer.isByteBuffer(buffer)) {\r\n            bb = ByteBufferPrototype.clone.call(buffer);\r\n            bb.markedOffset = -1;\r\n            return bb;\r\n        }\r\n        if (buffer instanceof Uint8Array) { // Extract ArrayBuffer from Uint8Array\r\n            bb = new ByteBuffer(0, littleEndian, noAssert);\r\n            if (buffer.length > 0) { // Avoid references to more than one EMPTY_BUFFER\r\n                bb.buffer = buffer.buffer;\r\n                bb.offset = buffer.byteOffset;\r\n                bb.limit = buffer.byteOffset + buffer.byteLength;\r\n                bb.view = new Uint8Array(buffer.buffer);\r\n            }\r\n        } else if (buffer instanceof ArrayBuffer) { // Reuse ArrayBuffer\r\n            bb = new ByteBuffer(0, littleEndian, noAssert);\r\n            if (buffer.byteLength > 0) {\r\n                bb.buffer = buffer;\r\n                bb.offset = 0;\r\n                bb.limit = buffer.byteLength;\r\n                bb.view = buffer.byteLength > 0 ? new Uint8Array(buffer) : null;\r\n            }\r\n        } else if (Object.prototype.toString.call(buffer) === \"[object Array]\") { // Create from octets\r\n            bb = new ByteBuffer(buffer.length, littleEndian, noAssert);\r\n            bb.limit = buffer.length;\r\n            for (var i=0; i<buffer.length; ++i)\r\n                bb.view[i] = buffer[i];\r\n        } else\r\n            throw TypeError(\"Illegal buffer\"); // Otherwise fail\r\n        return bb;\r\n    };\r\n\r\n    /**\r\n     * Writes the array as a bitset.\r\n     * @param {Array<boolean>} value Array of booleans to write\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.\r\n     * @returns {!ByteBuffer}\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeBitSet = function(value, offset) {\r\n      var relative = typeof offset === 'undefined';\n      if (relative) offset = this.offset;\n      if (!this.noAssert) {\r\n        if (!(value instanceof Array))\r\n          throw TypeError(\"Illegal BitSet: Not an array\");\r\n        if (typeof offset !== 'number' || offset % 1 !== 0)\n            throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n        offset >>>= 0;\n        if (offset < 0 || offset + 0 > this.buffer.byteLength)\n            throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n      }\r\n\r\n      var start = offset,\r\n          bits = value.length,\r\n          bytes = (bits >> 3),\r\n          bit = 0,\r\n          k;\r\n\r\n      offset += this.writeVarint32(bits,offset);\r\n\r\n      while(bytes--) {\r\n        k = (!!value[bit++] & 1) |\r\n            ((!!value[bit++] & 1) << 1) |\r\n            ((!!value[bit++] & 1) << 2) |\r\n            ((!!value[bit++] & 1) << 3) |\r\n            ((!!value[bit++] & 1) << 4) |\r\n            ((!!value[bit++] & 1) << 5) |\r\n            ((!!value[bit++] & 1) << 6) |\r\n            ((!!value[bit++] & 1) << 7);\r\n        this.writeByte(k,offset++);\r\n      }\r\n\r\n      if(bit < bits) {\r\n        var m = 0; k = 0;\r\n        while(bit < bits) k = k | ((!!value[bit++] & 1) << (m++));\r\n        this.writeByte(k,offset++);\r\n      }\r\n\r\n      if (relative) {\r\n        this.offset = offset;\r\n        return this;\r\n      }\r\n      return offset - start;\r\n    };\r\n\r\n    /**\r\n     * Reads a BitSet as an array of booleans.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.\r\n     * @returns {Array<boolean>\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readBitSet = function(offset) {\r\n      var relative = typeof offset === 'undefined';\n      if (relative) offset = this.offset;\n\r\n      var ret = this.readVarint32(offset),\r\n          bits = ret.value,\r\n          bytes = (bits >> 3),\r\n          bit = 0,\r\n          value = [],\r\n          k;\r\n\r\n      offset += ret.length;\r\n\r\n      while(bytes--) {\r\n        k = this.readByte(offset++);\r\n        value[bit++] = !!(k & 0x01);\r\n        value[bit++] = !!(k & 0x02);\r\n        value[bit++] = !!(k & 0x04);\r\n        value[bit++] = !!(k & 0x08);\r\n        value[bit++] = !!(k & 0x10);\r\n        value[bit++] = !!(k & 0x20);\r\n        value[bit++] = !!(k & 0x40);\r\n        value[bit++] = !!(k & 0x80);\r\n      }\r\n\r\n      if(bit < bits) {\r\n        var m = 0;\r\n        k = this.readByte(offset++);\r\n        while(bit < bits) value[bit++] = !!((k >> (m++)) & 1);\r\n      }\r\n\r\n      if (relative) {\r\n        this.offset = offset;\r\n      }\r\n      return value;\r\n    };\r\n    /**\r\n     * Reads the specified number of bytes.\r\n     * @param {number} length Number of bytes to read\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.\r\n     * @returns {!ByteBuffer}\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readBytes = function(length, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + length > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+length+\") <= \"+this.buffer.byteLength);\n        }\r\n        var slice = this.slice(offset, offset + length);\r\n        if (relative) this.offset += length;\n        return slice;\r\n    };\r\n\r\n    /**\r\n     * Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}.\r\n     * @function\r\n     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its offsets\r\n     *  will be modified according to the performed read operation.\r\n     * @param {(string|number)=} encoding Encoding if `data` is a string (\"base64\", \"hex\", \"binary\", defaults to \"utf8\")\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeBytes = ByteBufferPrototype.append;\r\n\r\n    // types/ints/int8\r\n\r\n    /**\r\n     * Writes an 8bit signed integer.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeInt8 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number' || value % 1 !== 0)\n                throw TypeError(\"Illegal value: \"+value+\" (not an integer)\");\n            value |= 0;\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        offset += 1;\n        var capacity0 = this.buffer.byteLength;\n        if (offset > capacity0)\n            this.resize((capacity0 *= 2) > offset ? capacity0 : offset);\n        offset -= 1;\n        this.view[offset] = value;\r\n        if (relative) this.offset += 1;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}.\r\n     * @function\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8;\r\n\r\n    /**\r\n     * Reads an 8bit signed integer.\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.\r\n     * @returns {number} Value read\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readInt8 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 1 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+1+\") <= \"+this.buffer.byteLength);\n        }\r\n        var value = this.view[offset];\r\n        if ((value & 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed\r\n        if (relative) this.offset += 1;\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}.\r\n     * @function\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.\r\n     * @returns {number} Value read\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8;\r\n\r\n    /**\r\n     * Writes an 8bit unsigned integer.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeUint8 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number' || value % 1 !== 0)\n                throw TypeError(\"Illegal value: \"+value+\" (not an integer)\");\n            value >>>= 0;\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        offset += 1;\n        var capacity1 = this.buffer.byteLength;\n        if (offset > capacity1)\n            this.resize((capacity1 *= 2) > offset ? capacity1 : offset);\n        offset -= 1;\n        this.view[offset] = value;\r\n        if (relative) this.offset += 1;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}.\r\n     * @function\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8;\r\n\r\n    /**\r\n     * Reads an 8bit unsigned integer.\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.\r\n     * @returns {number} Value read\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readUint8 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 1 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+1+\") <= \"+this.buffer.byteLength);\n        }\r\n        var value = this.view[offset];\r\n        if (relative) this.offset += 1;\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}.\r\n     * @function\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.\r\n     * @returns {number} Value read\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8;\r\n\r\n    // types/ints/int16\r\n\r\n    /**\r\n     * Writes a 16bit signed integer.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.\r\n     * @throws {TypeError} If `offset` or `value` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeInt16 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number' || value % 1 !== 0)\n                throw TypeError(\"Illegal value: \"+value+\" (not an integer)\");\n            value |= 0;\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        offset += 2;\n        var capacity2 = this.buffer.byteLength;\n        if (offset > capacity2)\n            this.resize((capacity2 *= 2) > offset ? capacity2 : offset);\n        offset -= 2;\n        if (this.littleEndian) {\r\n            this.view[offset+1] = (value & 0xFF00) >>> 8;\r\n            this.view[offset  ] =  value & 0x00FF;\r\n        } else {\r\n            this.view[offset]   = (value & 0xFF00) >>> 8;\r\n            this.view[offset+1] =  value & 0x00FF;\r\n        }\r\n        if (relative) this.offset += 2;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}.\r\n     * @function\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.\r\n     * @throws {TypeError} If `offset` or `value` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16;\r\n\r\n    /**\r\n     * Reads a 16bit signed integer.\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.\r\n     * @returns {number} Value read\r\n     * @throws {TypeError} If `offset` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readInt16 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 2 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+2+\") <= \"+this.buffer.byteLength);\n        }\r\n        var value = 0;\r\n        if (this.littleEndian) {\r\n            value  = this.view[offset  ];\r\n            value |= this.view[offset+1] << 8;\r\n        } else {\r\n            value  = this.view[offset  ] << 8;\r\n            value |= this.view[offset+1];\r\n        }\r\n        if ((value & 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed\r\n        if (relative) this.offset += 2;\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}.\r\n     * @function\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.\r\n     * @returns {number} Value read\r\n     * @throws {TypeError} If `offset` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16;\r\n\r\n    /**\r\n     * Writes a 16bit unsigned integer.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.\r\n     * @throws {TypeError} If `offset` or `value` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeUint16 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number' || value % 1 !== 0)\n                throw TypeError(\"Illegal value: \"+value+\" (not an integer)\");\n            value >>>= 0;\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        offset += 2;\n        var capacity3 = this.buffer.byteLength;\n        if (offset > capacity3)\n            this.resize((capacity3 *= 2) > offset ? capacity3 : offset);\n        offset -= 2;\n        if (this.littleEndian) {\r\n            this.view[offset+1] = (value & 0xFF00) >>> 8;\r\n            this.view[offset  ] =  value & 0x00FF;\r\n        } else {\r\n            this.view[offset]   = (value & 0xFF00) >>> 8;\r\n            this.view[offset+1] =  value & 0x00FF;\r\n        }\r\n        if (relative) this.offset += 2;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}.\r\n     * @function\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.\r\n     * @throws {TypeError} If `offset` or `value` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16;\r\n\r\n    /**\r\n     * Reads a 16bit unsigned integer.\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.\r\n     * @returns {number} Value read\r\n     * @throws {TypeError} If `offset` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readUint16 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 2 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+2+\") <= \"+this.buffer.byteLength);\n        }\r\n        var value = 0;\r\n        if (this.littleEndian) {\r\n            value  = this.view[offset  ];\r\n            value |= this.view[offset+1] << 8;\r\n        } else {\r\n            value  = this.view[offset  ] << 8;\r\n            value |= this.view[offset+1];\r\n        }\r\n        if (relative) this.offset += 2;\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}.\r\n     * @function\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.\r\n     * @returns {number} Value read\r\n     * @throws {TypeError} If `offset` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16;\r\n\r\n    // types/ints/int32\r\n\r\n    /**\r\n     * Writes a 32bit signed integer.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeInt32 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number' || value % 1 !== 0)\n                throw TypeError(\"Illegal value: \"+value+\" (not an integer)\");\n            value |= 0;\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        offset += 4;\n        var capacity4 = this.buffer.byteLength;\n        if (offset > capacity4)\n            this.resize((capacity4 *= 2) > offset ? capacity4 : offset);\n        offset -= 4;\n        if (this.littleEndian) {\n            this.view[offset+3] = (value >>> 24) & 0xFF;\n            this.view[offset+2] = (value >>> 16) & 0xFF;\n            this.view[offset+1] = (value >>>  8) & 0xFF;\n            this.view[offset  ] =  value         & 0xFF;\n        } else {\n            this.view[offset  ] = (value >>> 24) & 0xFF;\n            this.view[offset+1] = (value >>> 16) & 0xFF;\n            this.view[offset+2] = (value >>>  8) & 0xFF;\n            this.view[offset+3] =  value         & 0xFF;\n        }\n        if (relative) this.offset += 4;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32;\r\n\r\n    /**\r\n     * Reads a 32bit signed integer.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @returns {number} Value read\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readInt32 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 4 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+4+\") <= \"+this.buffer.byteLength);\n        }\r\n        var value = 0;\r\n        if (this.littleEndian) {\n            value  = this.view[offset+2] << 16;\n            value |= this.view[offset+1] <<  8;\n            value |= this.view[offset  ];\n            value += this.view[offset+3] << 24 >>> 0;\n        } else {\n            value  = this.view[offset+1] << 16;\n            value |= this.view[offset+2] <<  8;\n            value |= this.view[offset+3];\n            value += this.view[offset  ] << 24 >>> 0;\n        }\n        value |= 0; // Cast to signed\r\n        if (relative) this.offset += 4;\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}.\r\n     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @returns {number} Value read\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32;\r\n\r\n    /**\r\n     * Writes a 32bit unsigned integer.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeUint32 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number' || value % 1 !== 0)\n                throw TypeError(\"Illegal value: \"+value+\" (not an integer)\");\n            value >>>= 0;\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        offset += 4;\n        var capacity5 = this.buffer.byteLength;\n        if (offset > capacity5)\n            this.resize((capacity5 *= 2) > offset ? capacity5 : offset);\n        offset -= 4;\n        if (this.littleEndian) {\n            this.view[offset+3] = (value >>> 24) & 0xFF;\n            this.view[offset+2] = (value >>> 16) & 0xFF;\n            this.view[offset+1] = (value >>>  8) & 0xFF;\n            this.view[offset  ] =  value         & 0xFF;\n        } else {\n            this.view[offset  ] = (value >>> 24) & 0xFF;\n            this.view[offset+1] = (value >>> 16) & 0xFF;\n            this.view[offset+2] = (value >>>  8) & 0xFF;\n            this.view[offset+3] =  value         & 0xFF;\n        }\n        if (relative) this.offset += 4;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}.\r\n     * @function\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32;\r\n\r\n    /**\r\n     * Reads a 32bit unsigned integer.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @returns {number} Value read\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readUint32 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 4 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+4+\") <= \"+this.buffer.byteLength);\n        }\r\n        var value = 0;\r\n        if (this.littleEndian) {\n            value  = this.view[offset+2] << 16;\n            value |= this.view[offset+1] <<  8;\n            value |= this.view[offset  ];\n            value += this.view[offset+3] << 24 >>> 0;\n        } else {\n            value  = this.view[offset+1] << 16;\n            value |= this.view[offset+2] <<  8;\n            value |= this.view[offset+3];\n            value += this.view[offset  ] << 24 >>> 0;\n        }\n        if (relative) this.offset += 4;\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}.\r\n     * @function\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @returns {number} Value read\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32;\r\n\r\n    // types/ints/int64\r\n\r\n    if (Long) {\r\n\r\n        /**\r\n         * Writes a 64bit signed integer.\r\n         * @param {number|!Long} value Value to write\r\n         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n         * @returns {!ByteBuffer} this\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.writeInt64 = function(value, offset) {\r\n            var relative = typeof offset === 'undefined';\n            if (relative) offset = this.offset;\n            if (!this.noAssert) {\r\n                if (typeof value === 'number')\n                    value = Long.fromNumber(value);\n                else if (typeof value === 'string')\n                    value = Long.fromString(value);\n                else if (!(value && value instanceof Long))\n                    throw TypeError(\"Illegal value: \"+value+\" (not an integer or Long)\");\n                if (typeof offset !== 'number' || offset % 1 !== 0)\n                    throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n                offset >>>= 0;\n                if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                    throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n            }\r\n            if (typeof value === 'number')\n                value = Long.fromNumber(value);\n            else if (typeof value === 'string')\n                value = Long.fromString(value);\n            offset += 8;\n            var capacity6 = this.buffer.byteLength;\n            if (offset > capacity6)\n                this.resize((capacity6 *= 2) > offset ? capacity6 : offset);\n            offset -= 8;\n            var lo = value.low,\r\n                hi = value.high;\r\n            if (this.littleEndian) {\r\n                this.view[offset+3] = (lo >>> 24) & 0xFF;\n                this.view[offset+2] = (lo >>> 16) & 0xFF;\n                this.view[offset+1] = (lo >>>  8) & 0xFF;\n                this.view[offset  ] =  lo         & 0xFF;\n                offset += 4;\r\n                this.view[offset+3] = (hi >>> 24) & 0xFF;\n                this.view[offset+2] = (hi >>> 16) & 0xFF;\n                this.view[offset+1] = (hi >>>  8) & 0xFF;\n                this.view[offset  ] =  hi         & 0xFF;\n            } else {\r\n                this.view[offset  ] = (hi >>> 24) & 0xFF;\n                this.view[offset+1] = (hi >>> 16) & 0xFF;\n                this.view[offset+2] = (hi >>>  8) & 0xFF;\n                this.view[offset+3] =  hi         & 0xFF;\n                offset += 4;\r\n                this.view[offset  ] = (lo >>> 24) & 0xFF;\n                this.view[offset+1] = (lo >>> 16) & 0xFF;\n                this.view[offset+2] = (lo >>>  8) & 0xFF;\n                this.view[offset+3] =  lo         & 0xFF;\n            }\r\n            if (relative) this.offset += 8;\n            return this;\r\n        };\r\n\r\n        /**\r\n         * Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}.\r\n         * @param {number|!Long} value Value to write\r\n         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n         * @returns {!ByteBuffer} this\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64;\r\n\r\n        /**\r\n         * Reads a 64bit signed integer.\r\n         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n         * @returns {!Long}\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.readInt64 = function(offset) {\r\n            var relative = typeof offset === 'undefined';\n            if (relative) offset = this.offset;\n            if (!this.noAssert) {\r\n                if (typeof offset !== 'number' || offset % 1 !== 0)\n                    throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n                offset >>>= 0;\n                if (offset < 0 || offset + 8 > this.buffer.byteLength)\n                    throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+8+\") <= \"+this.buffer.byteLength);\n            }\r\n            var lo = 0,\r\n                hi = 0;\r\n            if (this.littleEndian) {\r\n                lo  = this.view[offset+2] << 16;\n                lo |= this.view[offset+1] <<  8;\n                lo |= this.view[offset  ];\n                lo += this.view[offset+3] << 24 >>> 0;\n                offset += 4;\r\n                hi  = this.view[offset+2] << 16;\n                hi |= this.view[offset+1] <<  8;\n                hi |= this.view[offset  ];\n                hi += this.view[offset+3] << 24 >>> 0;\n            } else {\r\n                hi  = this.view[offset+1] << 16;\n                hi |= this.view[offset+2] <<  8;\n                hi |= this.view[offset+3];\n                hi += this.view[offset  ] << 24 >>> 0;\n                offset += 4;\r\n                lo  = this.view[offset+1] << 16;\n                lo |= this.view[offset+2] <<  8;\n                lo |= this.view[offset+3];\n                lo += this.view[offset  ] << 24 >>> 0;\n            }\r\n            var value = new Long(lo, hi, false);\r\n            if (relative) this.offset += 8;\n            return value;\r\n        };\r\n\r\n        /**\r\n         * Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}.\r\n         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n         * @returns {!Long}\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64;\r\n\r\n        /**\r\n         * Writes a 64bit unsigned integer.\r\n         * @param {number|!Long} value Value to write\r\n         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n         * @returns {!ByteBuffer} this\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.writeUint64 = function(value, offset) {\r\n            var relative = typeof offset === 'undefined';\n            if (relative) offset = this.offset;\n            if (!this.noAssert) {\r\n                if (typeof value === 'number')\n                    value = Long.fromNumber(value);\n                else if (typeof value === 'string')\n                    value = Long.fromString(value);\n                else if (!(value && value instanceof Long))\n                    throw TypeError(\"Illegal value: \"+value+\" (not an integer or Long)\");\n                if (typeof offset !== 'number' || offset % 1 !== 0)\n                    throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n                offset >>>= 0;\n                if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                    throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n            }\r\n            if (typeof value === 'number')\n                value = Long.fromNumber(value);\n            else if (typeof value === 'string')\n                value = Long.fromString(value);\n            offset += 8;\n            var capacity7 = this.buffer.byteLength;\n            if (offset > capacity7)\n                this.resize((capacity7 *= 2) > offset ? capacity7 : offset);\n            offset -= 8;\n            var lo = value.low,\r\n                hi = value.high;\r\n            if (this.littleEndian) {\r\n                this.view[offset+3] = (lo >>> 24) & 0xFF;\n                this.view[offset+2] = (lo >>> 16) & 0xFF;\n                this.view[offset+1] = (lo >>>  8) & 0xFF;\n                this.view[offset  ] =  lo         & 0xFF;\n                offset += 4;\r\n                this.view[offset+3] = (hi >>> 24) & 0xFF;\n                this.view[offset+2] = (hi >>> 16) & 0xFF;\n                this.view[offset+1] = (hi >>>  8) & 0xFF;\n                this.view[offset  ] =  hi         & 0xFF;\n            } else {\r\n                this.view[offset  ] = (hi >>> 24) & 0xFF;\n                this.view[offset+1] = (hi >>> 16) & 0xFF;\n                this.view[offset+2] = (hi >>>  8) & 0xFF;\n                this.view[offset+3] =  hi         & 0xFF;\n                offset += 4;\r\n                this.view[offset  ] = (lo >>> 24) & 0xFF;\n                this.view[offset+1] = (lo >>> 16) & 0xFF;\n                this.view[offset+2] = (lo >>>  8) & 0xFF;\n                this.view[offset+3] =  lo         & 0xFF;\n            }\r\n            if (relative) this.offset += 8;\n            return this;\r\n        };\r\n\r\n        /**\r\n         * Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}.\r\n         * @function\r\n         * @param {number|!Long} value Value to write\r\n         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n         * @returns {!ByteBuffer} this\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64;\r\n\r\n        /**\r\n         * Reads a 64bit unsigned integer.\r\n         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n         * @returns {!Long}\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.readUint64 = function(offset) {\r\n            var relative = typeof offset === 'undefined';\n            if (relative) offset = this.offset;\n            if (!this.noAssert) {\r\n                if (typeof offset !== 'number' || offset % 1 !== 0)\n                    throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n                offset >>>= 0;\n                if (offset < 0 || offset + 8 > this.buffer.byteLength)\n                    throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+8+\") <= \"+this.buffer.byteLength);\n            }\r\n            var lo = 0,\r\n                hi = 0;\r\n            if (this.littleEndian) {\r\n                lo  = this.view[offset+2] << 16;\n                lo |= this.view[offset+1] <<  8;\n                lo |= this.view[offset  ];\n                lo += this.view[offset+3] << 24 >>> 0;\n                offset += 4;\r\n                hi  = this.view[offset+2] << 16;\n                hi |= this.view[offset+1] <<  8;\n                hi |= this.view[offset  ];\n                hi += this.view[offset+3] << 24 >>> 0;\n            } else {\r\n                hi  = this.view[offset+1] << 16;\n                hi |= this.view[offset+2] <<  8;\n                hi |= this.view[offset+3];\n                hi += this.view[offset  ] << 24 >>> 0;\n                offset += 4;\r\n                lo  = this.view[offset+1] << 16;\n                lo |= this.view[offset+2] <<  8;\n                lo |= this.view[offset+3];\n                lo += this.view[offset  ] << 24 >>> 0;\n            }\r\n            var value = new Long(lo, hi, true);\r\n            if (relative) this.offset += 8;\n            return value;\r\n        };\r\n\r\n        /**\r\n         * Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}.\r\n         * @function\r\n         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n         * @returns {!Long}\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64;\r\n\r\n    } // Long\r\n\r\n\r\n    // types/floats/float32\r\n\r\n    /*\r\n     ieee754 - https://github.com/feross/ieee754\r\n\r\n     The MIT License (MIT)\r\n\r\n     Copyright (c) Feross Aboukhadijeh\r\n\r\n     Permission is hereby granted, free of charge, to any person obtaining a copy\r\n     of this software and associated documentation files (the \"Software\"), to deal\r\n     in the Software without restriction, including without limitation the rights\r\n     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n     copies of the Software, and to permit persons to whom the Software is\r\n     furnished to do so, subject to the following conditions:\r\n\r\n     The above copyright notice and this permission notice shall be included in\r\n     all copies or substantial portions of the Software.\r\n\r\n     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n     THE SOFTWARE.\r\n    */\r\n\r\n    /**\r\n     * Reads an IEEE754 float from a byte array.\r\n     * @param {!Array} buffer\r\n     * @param {number} offset\r\n     * @param {boolean} isLE\r\n     * @param {number} mLen\r\n     * @param {number} nBytes\r\n     * @returns {number}\r\n     * @inner\r\n     */\r\n    function ieee754_read(buffer, offset, isLE, mLen, nBytes) {\r\n        var e, m,\r\n            eLen = nBytes * 8 - mLen - 1,\r\n            eMax = (1 << eLen) - 1,\r\n            eBias = eMax >> 1,\r\n            nBits = -7,\r\n            i = isLE ? (nBytes - 1) : 0,\r\n            d = isLE ? -1 : 1,\r\n            s = buffer[offset + i];\r\n\r\n        i += d;\r\n\r\n        e = s & ((1 << (-nBits)) - 1);\r\n        s >>= (-nBits);\r\n        nBits += eLen;\r\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n        m = e & ((1 << (-nBits)) - 1);\r\n        e >>= (-nBits);\r\n        nBits += mLen;\r\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n        if (e === 0) {\r\n            e = 1 - eBias;\r\n        } else if (e === eMax) {\r\n            return m ? NaN : ((s ? -1 : 1) * Infinity);\r\n        } else {\r\n            m = m + Math.pow(2, mLen);\r\n            e = e - eBias;\r\n        }\r\n        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\r\n    }\r\n\r\n    /**\r\n     * Writes an IEEE754 float to a byte array.\r\n     * @param {!Array} buffer\r\n     * @param {number} value\r\n     * @param {number} offset\r\n     * @param {boolean} isLE\r\n     * @param {number} mLen\r\n     * @param {number} nBytes\r\n     * @inner\r\n     */\r\n    function ieee754_write(buffer, value, offset, isLE, mLen, nBytes) {\r\n        var e, m, c,\r\n            eLen = nBytes * 8 - mLen - 1,\r\n            eMax = (1 << eLen) - 1,\r\n            eBias = eMax >> 1,\r\n            rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\r\n            i = isLE ? 0 : (nBytes - 1),\r\n            d = isLE ? 1 : -1,\r\n            s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\r\n\r\n        value = Math.abs(value);\r\n\r\n        if (isNaN(value) || value === Infinity) {\r\n            m = isNaN(value) ? 1 : 0;\r\n            e = eMax;\r\n        } else {\r\n            e = Math.floor(Math.log(value) / Math.LN2);\r\n            if (value * (c = Math.pow(2, -e)) < 1) {\r\n                e--;\r\n                c *= 2;\r\n            }\r\n            if (e + eBias >= 1) {\r\n                value += rt / c;\r\n            } else {\r\n                value += rt * Math.pow(2, 1 - eBias);\r\n            }\r\n            if (value * c >= 2) {\r\n                e++;\r\n                c /= 2;\r\n            }\r\n\r\n            if (e + eBias >= eMax) {\r\n                m = 0;\r\n                e = eMax;\r\n            } else if (e + eBias >= 1) {\r\n                m = (value * c - 1) * Math.pow(2, mLen);\r\n                e = e + eBias;\r\n            } else {\r\n                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\r\n                e = 0;\r\n            }\r\n        }\r\n\r\n        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\r\n\r\n        e = (e << mLen) | m;\r\n        eLen += mLen;\r\n        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\r\n\r\n        buffer[offset + i - d] |= s * 128;\r\n    }\r\n\r\n    /**\r\n     * Writes a 32bit float.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeFloat32 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number')\r\n                throw TypeError(\"Illegal value: \"+value+\" (not a number)\");\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        offset += 4;\n        var capacity8 = this.buffer.byteLength;\n        if (offset > capacity8)\n            this.resize((capacity8 *= 2) > offset ? capacity8 : offset);\n        offset -= 4;\n        ieee754_write(this.view, value, offset, this.littleEndian, 23, 4);\r\n        if (relative) this.offset += 4;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}.\r\n     * @function\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32;\r\n\r\n    /**\r\n     * Reads a 32bit float.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @returns {number}\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readFloat32 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 4 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+4+\") <= \"+this.buffer.byteLength);\n        }\r\n        var value = ieee754_read(this.view, offset, this.littleEndian, 23, 4);\r\n        if (relative) this.offset += 4;\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}.\r\n     * @function\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.\r\n     * @returns {number}\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32;\r\n\r\n    // types/floats/float64\r\n\r\n    /**\r\n     * Writes a 64bit float.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeFloat64 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number')\r\n                throw TypeError(\"Illegal value: \"+value+\" (not a number)\");\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        offset += 8;\n        var capacity9 = this.buffer.byteLength;\n        if (offset > capacity9)\n            this.resize((capacity9 *= 2) > offset ? capacity9 : offset);\n        offset -= 8;\n        ieee754_write(this.view, value, offset, this.littleEndian, 52, 8);\r\n        if (relative) this.offset += 8;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}.\r\n     * @function\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64;\r\n\r\n    /**\r\n     * Reads a 64bit float.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n     * @returns {number}\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readFloat64 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 8 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+8+\") <= \"+this.buffer.byteLength);\n        }\r\n        var value = ieee754_read(this.view, offset, this.littleEndian, 52, 8);\r\n        if (relative) this.offset += 8;\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}.\r\n     * @function\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.\r\n     * @returns {number}\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64;\r\n\r\n\r\n    // types/varints/varint32\r\n\r\n    /**\r\n     * Maximum number of bytes required to store a 32bit base 128 variable-length integer.\r\n     * @type {number}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ByteBuffer.MAX_VARINT32_BYTES = 5;\r\n\r\n    /**\r\n     * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.\r\n     * @param {number} value Value to encode\r\n     * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES}\r\n     * @expose\r\n     */\r\n    ByteBuffer.calculateVarint32 = function(value) {\r\n        // ref: src/google/protobuf/io/coded_stream.cc\r\n        value = value >>> 0;\r\n             if (value < 1 << 7 ) return 1;\r\n        else if (value < 1 << 14) return 2;\r\n        else if (value < 1 << 21) return 3;\r\n        else if (value < 1 << 28) return 4;\r\n        else                      return 5;\r\n    };\r\n\r\n    /**\r\n     * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.\r\n     * @param {number} n Signed 32bit integer\r\n     * @returns {number} Unsigned zigzag encoded 32bit integer\r\n     * @expose\r\n     */\r\n    ByteBuffer.zigZagEncode32 = function(n) {\r\n        return (((n |= 0) << 1) ^ (n >> 31)) >>> 0; // ref: src/google/protobuf/wire_format_lite.h\r\n    };\r\n\r\n    /**\r\n     * Decodes a zigzag encoded signed 32bit integer.\r\n     * @param {number} n Unsigned zigzag encoded 32bit integer\r\n     * @returns {number} Signed 32bit integer\r\n     * @expose\r\n     */\r\n    ByteBuffer.zigZagDecode32 = function(n) {\r\n        return ((n >>> 1) ^ -(n & 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h\r\n    };\r\n\r\n    /**\r\n     * Writes a 32bit base 128 variable-length integer.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted.\r\n     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeVarint32 = function(value, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number' || value % 1 !== 0)\n                throw TypeError(\"Illegal value: \"+value+\" (not an integer)\");\n            value |= 0;\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        var size = ByteBuffer.calculateVarint32(value),\r\n            b;\r\n        offset += size;\n        var capacity10 = this.buffer.byteLength;\n        if (offset > capacity10)\n            this.resize((capacity10 *= 2) > offset ? capacity10 : offset);\n        offset -= size;\n        value >>>= 0;\r\n        while (value >= 0x80) {\r\n            b = (value & 0x7f) | 0x80;\r\n            this.view[offset++] = b;\r\n            value >>>= 7;\r\n        }\r\n        this.view[offset++] = value;\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return this;\r\n        }\r\n        return size;\r\n    };\r\n\r\n    /**\r\n     * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.\r\n     * @param {number} value Value to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted.\r\n     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeVarint32ZigZag = function(value, offset) {\r\n        return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);\r\n    };\r\n\r\n    /**\r\n     * Reads a 32bit base 128 variable-length integer.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted.\r\n     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read\r\n     *  and the actual number of bytes read.\r\n     * @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available\r\n     *  to fully decode the varint.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readVarint32 = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 1 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+1+\") <= \"+this.buffer.byteLength);\n        }\r\n        var c = 0,\r\n            value = 0 >>> 0,\r\n            b;\r\n        do {\r\n            if (!this.noAssert && offset > this.limit) {\r\n                var err = Error(\"Truncated\");\r\n                err['truncated'] = true;\r\n                throw err;\r\n            }\r\n            b = this.view[offset++];\r\n            if (c < 5)\r\n                value |= (b & 0x7f) << (7*c);\r\n            ++c;\r\n        } while ((b & 0x80) !== 0);\r\n        value |= 0;\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return value;\r\n        }\r\n        return {\r\n            \"value\": value,\r\n            \"length\": c\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted.\r\n     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read\r\n     *  and the actual number of bytes read.\r\n     * @throws {Error} If it's not a valid varint\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readVarint32ZigZag = function(offset) {\r\n        var val = this.readVarint32(offset);\r\n        if (typeof val === 'object')\r\n            val[\"value\"] = ByteBuffer.zigZagDecode32(val[\"value\"]);\r\n        else\r\n            val = ByteBuffer.zigZagDecode32(val);\r\n        return val;\r\n    };\r\n\r\n    // types/varints/varint64\r\n\r\n    if (Long) {\r\n\r\n        /**\r\n         * Maximum number of bytes required to store a 64bit base 128 variable-length integer.\r\n         * @type {number}\r\n         * @const\r\n         * @expose\r\n         */\r\n        ByteBuffer.MAX_VARINT64_BYTES = 10;\r\n\r\n        /**\r\n         * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.\r\n         * @param {number|!Long} value Value to encode\r\n         * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES}\r\n         * @expose\r\n         */\r\n        ByteBuffer.calculateVarint64 = function(value) {\r\n            if (typeof value === 'number')\n                value = Long.fromNumber(value);\n            else if (typeof value === 'string')\n                value = Long.fromString(value);\n            // ref: src/google/protobuf/io/coded_stream.cc\r\n            var part0 = value.toInt() >>> 0,\r\n                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,\r\n                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;\r\n            if (part2 == 0) {\r\n                if (part1 == 0) {\r\n                    if (part0 < 1 << 14)\r\n                        return part0 < 1 << 7 ? 1 : 2;\r\n                    else\r\n                        return part0 < 1 << 21 ? 3 : 4;\r\n                } else {\r\n                    if (part1 < 1 << 14)\r\n                        return part1 < 1 << 7 ? 5 : 6;\r\n                    else\r\n                        return part1 < 1 << 21 ? 7 : 8;\r\n                }\r\n            } else\r\n                return part2 < 1 << 7 ? 9 : 10;\r\n        };\r\n\r\n        /**\r\n         * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.\r\n         * @param {number|!Long} value Signed long\r\n         * @returns {!Long} Unsigned zigzag encoded long\r\n         * @expose\r\n         */\r\n        ByteBuffer.zigZagEncode64 = function(value) {\r\n            if (typeof value === 'number')\n                value = Long.fromNumber(value, false);\n            else if (typeof value === 'string')\n                value = Long.fromString(value, false);\n            else if (value.unsigned !== false) value = value.toSigned();\n            // ref: src/google/protobuf/wire_format_lite.h\r\n            return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();\r\n        };\r\n\r\n        /**\r\n         * Decodes a zigzag encoded signed 64bit integer.\r\n         * @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number\r\n         * @returns {!Long} Signed long\r\n         * @expose\r\n         */\r\n        ByteBuffer.zigZagDecode64 = function(value) {\r\n            if (typeof value === 'number')\n                value = Long.fromNumber(value, false);\n            else if (typeof value === 'string')\n                value = Long.fromString(value, false);\n            else if (value.unsigned !== false) value = value.toSigned();\n            // ref: src/google/protobuf/wire_format_lite.h\r\n            return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();\r\n        };\r\n\r\n        /**\r\n         * Writes a 64bit base 128 variable-length integer.\r\n         * @param {number|Long} value Value to write\r\n         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n         *  written if omitted.\r\n         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.writeVarint64 = function(value, offset) {\r\n            var relative = typeof offset === 'undefined';\n            if (relative) offset = this.offset;\n            if (!this.noAssert) {\r\n                if (typeof value === 'number')\n                    value = Long.fromNumber(value);\n                else if (typeof value === 'string')\n                    value = Long.fromString(value);\n                else if (!(value && value instanceof Long))\n                    throw TypeError(\"Illegal value: \"+value+\" (not an integer or Long)\");\n                if (typeof offset !== 'number' || offset % 1 !== 0)\n                    throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n                offset >>>= 0;\n                if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                    throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n            }\r\n            if (typeof value === 'number')\n                value = Long.fromNumber(value, false);\n            else if (typeof value === 'string')\n                value = Long.fromString(value, false);\n            else if (value.unsigned !== false) value = value.toSigned();\n            var size = ByteBuffer.calculateVarint64(value),\r\n                part0 = value.toInt() >>> 0,\r\n                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,\r\n                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;\r\n            offset += size;\n            var capacity11 = this.buffer.byteLength;\n            if (offset > capacity11)\n                this.resize((capacity11 *= 2) > offset ? capacity11 : offset);\n            offset -= size;\n            switch (size) {\r\n                case 10: this.view[offset+9] = (part2 >>>  7) & 0x01;\r\n                case 9 : this.view[offset+8] = size !== 9 ? (part2       ) | 0x80 : (part2       ) & 0x7F;\r\n                case 8 : this.view[offset+7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;\r\n                case 7 : this.view[offset+6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;\r\n                case 6 : this.view[offset+5] = size !== 6 ? (part1 >>>  7) | 0x80 : (part1 >>>  7) & 0x7F;\r\n                case 5 : this.view[offset+4] = size !== 5 ? (part1       ) | 0x80 : (part1       ) & 0x7F;\r\n                case 4 : this.view[offset+3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;\r\n                case 3 : this.view[offset+2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;\r\n                case 2 : this.view[offset+1] = size !== 2 ? (part0 >>>  7) | 0x80 : (part0 >>>  7) & 0x7F;\r\n                case 1 : this.view[offset  ] = size !== 1 ? (part0       ) | 0x80 : (part0       ) & 0x7F;\r\n            }\r\n            if (relative) {\r\n                this.offset += size;\r\n                return this;\r\n            } else {\r\n                return size;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Writes a zig-zag encoded 64bit base 128 variable-length integer.\r\n         * @param {number|Long} value Value to write\r\n         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n         *  written if omitted.\r\n         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.writeVarint64ZigZag = function(value, offset) {\r\n            return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);\r\n        };\r\n\r\n        /**\r\n         * Reads a 64bit base 128 variable-length integer. Requires Long.js.\r\n         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n         *  read if omitted.\r\n         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and\r\n         *  the actual number of bytes read.\r\n         * @throws {Error} If it's not a valid varint\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.readVarint64 = function(offset) {\r\n            var relative = typeof offset === 'undefined';\n            if (relative) offset = this.offset;\n            if (!this.noAssert) {\r\n                if (typeof offset !== 'number' || offset % 1 !== 0)\n                    throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n                offset >>>= 0;\n                if (offset < 0 || offset + 1 > this.buffer.byteLength)\n                    throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+1+\") <= \"+this.buffer.byteLength);\n            }\r\n            // ref: src/google/protobuf/io/coded_stream.cc\r\n            var start = offset,\r\n                part0 = 0,\r\n                part1 = 0,\r\n                part2 = 0,\r\n                b  = 0;\r\n            b = this.view[offset++]; part0  = (b & 0x7F)      ; if ( b & 0x80                                                   ) {\r\n            b = this.view[offset++]; part0 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            b = this.view[offset++]; part0 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            b = this.view[offset++]; part0 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            b = this.view[offset++]; part1  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            b = this.view[offset++]; part1 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            b = this.view[offset++]; part1 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            b = this.view[offset++]; part1 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            b = this.view[offset++]; part2  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            b = this.view[offset++]; part2 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {\r\n            throw Error(\"Buffer overrun\"); }}}}}}}}}}\r\n            var value = Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, false);\r\n            if (relative) {\r\n                this.offset = offset;\r\n                return value;\r\n            } else {\r\n                return {\r\n                    'value': value,\r\n                    'length': offset-start\r\n                };\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.\r\n         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n         *  read if omitted.\r\n         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and\r\n         *  the actual number of bytes read.\r\n         * @throws {Error} If it's not a valid varint\r\n         * @expose\r\n         */\r\n        ByteBufferPrototype.readVarint64ZigZag = function(offset) {\r\n            var val = this.readVarint64(offset);\r\n            if (val && val['value'] instanceof Long)\r\n                val[\"value\"] = ByteBuffer.zigZagDecode64(val[\"value\"]);\r\n            else\r\n                val = ByteBuffer.zigZagDecode64(val);\r\n            return val;\r\n        };\r\n\r\n    } // Long\r\n\r\n\r\n    // types/strings/cstring\r\n\r\n    /**\r\n     * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL\r\n     *  characters itself.\r\n     * @param {string} str String to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  contained in `str` + 1 if omitted.\r\n     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeCString = function(str, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        var i,\r\n            k = str.length;\r\n        if (!this.noAssert) {\r\n            if (typeof str !== 'string')\r\n                throw TypeError(\"Illegal str: Not a string\");\r\n            for (i=0; i<k; ++i) {\r\n                if (str.charCodeAt(i) === 0)\r\n                    throw RangeError(\"Illegal str: Contains NULL-characters\");\r\n            }\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        // UTF8 strings do not contain zero bytes in between except for the zero character, so:\r\n        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];\r\n        offset += k+1;\n        var capacity12 = this.buffer.byteLength;\n        if (offset > capacity12)\n            this.resize((capacity12 *= 2) > offset ? capacity12 : offset);\n        offset -= k+1;\n        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {\r\n            this.view[offset++] = b;\r\n        }.bind(this));\r\n        this.view[offset++] = 0;\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return this;\r\n        }\r\n        return k;\r\n    };\r\n\r\n    /**\r\n     * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters\r\n     *  itself.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  read if omitted.\r\n     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string\r\n     *  read and the actual number of bytes read.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readCString = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 1 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+1+\") <= \"+this.buffer.byteLength);\n        }\r\n        var start = offset;\r\r\n        // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:\r\n        var sd, b = -1;\r\n        utfx.decodeUTF8toUTF16(function() {\r\n            if (b === 0) return null;\r\n            if (offset >= this.limit)\r\n                throw RangeError(\"Illegal range: Truncated data, \"+offset+\" < \"+this.limit);\r\n            b = this.view[offset++];\r\n            return b === 0 ? null : b;\r\n        }.bind(this), sd = stringDestination(), true);\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return sd();\r\n        } else {\r\n            return {\r\n                \"string\": sd(),\r\n                \"length\": offset - start\r\n            };\r\n        }\r\n    };\r\n\r\n    // types/strings/istring\r\n\r\n    /**\r\n     * Writes a length as uint32 prefixed UTF8 encoded string.\r\n     * @param {string} str String to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted.\r\n     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written\r\n     * @expose\r\n     * @see ByteBuffer#writeVarint32\r\n     */\r\n    ByteBufferPrototype.writeIString = function(str, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof str !== 'string')\r\n                throw TypeError(\"Illegal str: Not a string\");\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        var start = offset,\r\n            k;\r\n        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];\r\n        offset += 4+k;\n        var capacity13 = this.buffer.byteLength;\n        if (offset > capacity13)\n            this.resize((capacity13 *= 2) > offset ? capacity13 : offset);\n        offset -= 4+k;\n        if (this.littleEndian) {\n            this.view[offset+3] = (k >>> 24) & 0xFF;\n            this.view[offset+2] = (k >>> 16) & 0xFF;\n            this.view[offset+1] = (k >>>  8) & 0xFF;\n            this.view[offset  ] =  k         & 0xFF;\n        } else {\n            this.view[offset  ] = (k >>> 24) & 0xFF;\n            this.view[offset+1] = (k >>> 16) & 0xFF;\n            this.view[offset+2] = (k >>>  8) & 0xFF;\n            this.view[offset+3] =  k         & 0xFF;\n        }\n        offset += 4;\r\n        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {\r\n            this.view[offset++] = b;\r\n        }.bind(this));\r\n        if (offset !== start + 4 + k)\r\n            throw RangeError(\"Illegal range: Truncated data, \"+offset+\" == \"+(offset+4+k));\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return this;\r\n        }\r\n        return offset - start;\r\n    };\r\n\r\n    /**\r\n     * Reads a length as uint32 prefixed UTF8 encoded string.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  read if omitted.\r\n     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string\r\n     *  read and the actual number of bytes read.\r\n     * @expose\r\n     * @see ByteBuffer#readVarint32\r\n     */\r\n    ByteBufferPrototype.readIString = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 4 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+4+\") <= \"+this.buffer.byteLength);\n        }\r\n        var start = offset;\r\n        var len = this.readUint32(offset);\r\n        var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4);\r\n        offset += str['length'];\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return str['string'];\r\n        } else {\r\n            return {\r\n                'string': str['string'],\r\n                'length': offset - start\r\n            };\r\n        }\r\n    };\r\n\r\n    // types/strings/utf8string\r\n\r\n    /**\r\n     * Metrics representing number of UTF8 characters. Evaluates to `c`.\r\n     * @type {string}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ByteBuffer.METRICS_CHARS = 'c';\r\n\r\n    /**\r\n     * Metrics representing number of bytes. Evaluates to `b`.\r\n     * @type {string}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ByteBuffer.METRICS_BYTES = 'b';\r\n\r\n    /**\r\n     * Writes an UTF8 encoded string.\r\n     * @param {string} str String to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.\r\n     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeUTF8String = function(str, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        var k;\r\n        var start = offset;\r\n        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];\r\n        offset += k;\n        var capacity14 = this.buffer.byteLength;\n        if (offset > capacity14)\n            this.resize((capacity14 *= 2) > offset ? capacity14 : offset);\n        offset -= k;\n        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {\r\n            this.view[offset++] = b;\r\n        }.bind(this));\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return this;\r\n        }\r\n        return offset - start;\r\n    };\r\n\r\n    /**\r\n     * Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}.\r\n     * @function\r\n     * @param {string} str String to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.\r\n     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String;\r\n\r\n    /**\r\n     * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's\r\n     *  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.\r\n     * @param {string} str String to calculate\r\n     * @returns {number} Number of UTF8 characters\r\n     * @expose\r\n     */\r\n    ByteBuffer.calculateUTF8Chars = function(str) {\r\n        return utfx.calculateUTF16asUTF8(stringSource(str))[0];\r\n    };\r\n\r\n    /**\r\n     * Calculates the number of UTF8 bytes of a string.\r\n     * @param {string} str String to calculate\r\n     * @returns {number} Number of UTF8 bytes\r\n     * @expose\r\n     */\r\n    ByteBuffer.calculateUTF8Bytes = function(str) {\r\n        return utfx.calculateUTF16asUTF8(stringSource(str))[1];\r\n    };\r\n\r\n    /**\r\n     * Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}.\r\n     * @function\r\n     * @param {string} str String to calculate\r\n     * @returns {number} Number of UTF8 bytes\r\n     * @expose\r\n     */\r\n    ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes;\r\n\r\n    /**\r\n     * Reads an UTF8 encoded string.\r\n     * @param {number} length Number of characters or bytes to read.\r\n     * @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to\r\n     *  {@link ByteBuffer.METRICS_CHARS}.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  read if omitted.\r\n     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string\r\n     *  read and the actual number of bytes read.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readUTF8String = function(length, metrics, offset) {\r\n        if (typeof metrics === 'number') {\r\n            offset = metrics;\r\n            metrics = undefined;\r\n        }\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;\r\n        if (!this.noAssert) {\r\n            if (typeof length !== 'number' || length % 1 !== 0)\n                throw TypeError(\"Illegal length: \"+length+\" (not an integer)\");\n            length |= 0;\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        var i = 0,\r\n            start = offset,\r\n            sd;\r\n        if (metrics === ByteBuffer.METRICS_CHARS) { // The same for node and the browser\r\n            sd = stringDestination();\r\n            utfx.decodeUTF8(function() {\r\n                return i < length && offset < this.limit ? this.view[offset++] : null;\r\n            }.bind(this), function(cp) {\r\n                ++i; utfx.UTF8toUTF16(cp, sd);\r\n            });\r\n            if (i !== length)\r\n                throw RangeError(\"Illegal range: Truncated data, \"+i+\" == \"+length);\r\n            if (relative) {\r\n                this.offset = offset;\r\n                return sd();\r\n            } else {\r\n                return {\r\n                    \"string\": sd(),\r\n                    \"length\": offset - start\r\n                };\r\n            }\r\n        } else if (metrics === ByteBuffer.METRICS_BYTES) {\r\n            if (!this.noAssert) {\r\n                if (typeof offset !== 'number' || offset % 1 !== 0)\n                    throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n                offset >>>= 0;\n                if (offset < 0 || offset + length > this.buffer.byteLength)\n                    throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+length+\") <= \"+this.buffer.byteLength);\n            }\r\n            var k = offset + length;\r\n            utfx.decodeUTF8toUTF16(function() {\r\n                return offset < k ? this.view[offset++] : null;\r\n            }.bind(this), sd = stringDestination(), this.noAssert);\r\n            if (offset !== k)\r\n                throw RangeError(\"Illegal range: Truncated data, \"+offset+\" == \"+k);\r\n            if (relative) {\r\n                this.offset = offset;\r\n                return sd();\r\n            } else {\r\n                return {\r\n                    'string': sd(),\r\n                    'length': offset - start\r\n                };\r\n            }\r\n        } else\r\n            throw TypeError(\"Unsupported metrics: \"+metrics);\r\n    };\r\n\r\n    /**\r\n     * Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}.\r\n     * @function\r\n     * @param {number} length Number of characters or bytes to read\r\n     * @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to\r\n     *  {@link ByteBuffer.METRICS_CHARS}.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  read if omitted.\r\n     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string\r\n     *  read and the actual number of bytes read.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String;\r\n\r\n    // types/strings/vstring\r\n\r\n    /**\r\n     * Writes a length as varint32 prefixed UTF8 encoded string.\r\n     * @param {string} str String to write\r\n     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted.\r\n     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written\r\n     * @expose\r\n     * @see ByteBuffer#writeVarint32\r\n     */\r\n    ByteBufferPrototype.writeVString = function(str, offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof str !== 'string')\r\n                throw TypeError(\"Illegal str: Not a string\");\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        var start = offset,\r\n            k, l;\r\n        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];\r\n        l = ByteBuffer.calculateVarint32(k);\r\n        offset += l+k;\n        var capacity15 = this.buffer.byteLength;\n        if (offset > capacity15)\n            this.resize((capacity15 *= 2) > offset ? capacity15 : offset);\n        offset -= l+k;\n        offset += this.writeVarint32(k, offset);\r\n        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {\r\n            this.view[offset++] = b;\r\n        }.bind(this));\r\n        if (offset !== start+k+l)\r\n            throw RangeError(\"Illegal range: Truncated data, \"+offset+\" == \"+(offset+k+l));\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return this;\r\n        }\r\n        return offset - start;\r\n    };\r\n\r\n    /**\r\n     * Reads a length as varint32 prefixed UTF8 encoded string.\r\n     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  read if omitted.\r\n     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string\r\n     *  read and the actual number of bytes read.\r\n     * @expose\r\n     * @see ByteBuffer#readVarint32\r\n     */\r\n    ByteBufferPrototype.readVString = function(offset) {\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 1 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+1+\") <= \"+this.buffer.byteLength);\n        }\r\n        var start = offset;\r\n        var len = this.readVarint32(offset);\r\n        var str = this.readUTF8String(len['value'], ByteBuffer.METRICS_BYTES, offset += len['length']);\r\n        offset += str['length'];\r\n        if (relative) {\r\n            this.offset = offset;\r\n            return str['string'];\r\n        } else {\r\n            return {\r\n                'string': str['string'],\r\n                'length': offset - start\r\n            };\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended\r\n     *  data's length.\r\n     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its offsets\r\n     *  will be modified according to the performed read operation.\r\n     * @param {(string|number)=} encoding Encoding if `data` is a string (\"base64\", \"hex\", \"binary\", defaults to \"utf8\")\r\n     * @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     * @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|`\r\n     * @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|`\r\n     */\r\n    ByteBufferPrototype.append = function(source, encoding, offset) {\r\n        if (typeof encoding === 'number' || typeof encoding !== 'string') {\r\n            offset = encoding;\r\n            encoding = undefined;\r\n        }\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        if (!(source instanceof ByteBuffer))\r\n            source = ByteBuffer.wrap(source, encoding);\r\n        var length = source.limit - source.offset;\r\n        if (length <= 0) return this; // Nothing to append\r\n        offset += length;\n        var capacity16 = this.buffer.byteLength;\n        if (offset > capacity16)\n            this.resize((capacity16 *= 2) > offset ? capacity16 : offset);\n        offset -= length;\n        this.view.set(source.view.subarray(source.offset, source.limit), offset);\r\n        source.offset += length;\r\n        if (relative) this.offset += length;\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the\r\n        specified offset up to the length of this ByteBuffer's data.\r\n     * @param {!ByteBuffer} target Target ByteBuffer\r\n     * @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  read if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     * @see ByteBuffer#append\r\n     */\r\n    ByteBufferPrototype.appendTo = function(target, offset) {\r\n        target.append(this, offset);\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to\r\n     *  disable them if your code already makes sure that everything is valid.\r\n     * @param {boolean} assert `true` to enable assertions, otherwise `false`\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.assert = function(assert) {\r\n        this.noAssert = !assert;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Gets the capacity of this ByteBuffer's backing buffer.\r\n     * @returns {number} Capacity of the backing buffer\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.capacity = function() {\r\n        return this.buffer.byteLength;\r\n    };\r\n    /**\r\n     * Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the\r\n     *  backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.clear = function() {\r\n        this.offset = 0;\r\n        this.limit = this.buffer.byteLength;\r\n        this.markedOffset = -1;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset},\r\n     *  {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}.\r\n     * @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false`\r\n     * @returns {!ByteBuffer} Cloned instance\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.clone = function(copy) {\r\n        var bb = new ByteBuffer(0, this.littleEndian, this.noAssert);\r\n        if (copy) {\r\n            bb.buffer = new ArrayBuffer(this.buffer.byteLength);\r\n            bb.view = new Uint8Array(bb.buffer);\r\n        } else {\r\n            bb.buffer = this.buffer;\r\n            bb.view = this.view;\r\n        }\r\n        bb.offset = this.offset;\r\n        bb.markedOffset = this.markedOffset;\r\n        bb.limit = this.limit;\r\n        return bb;\r\n    };\r\n\r\n    /**\r\n     * Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes\r\n     *  between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and\r\n     *  adapt {@link ByteBuffer#markedOffset} to the same relative position if set.\r\n     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}\r\n     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.compact = function(begin, end) {\r\n        if (typeof begin === 'undefined') begin = this.offset;\r\n        if (typeof end === 'undefined') end = this.limit;\r\n        if (!this.noAssert) {\r\n            if (typeof begin !== 'number' || begin % 1 !== 0)\n                throw TypeError(\"Illegal begin: Not an integer\");\n            begin >>>= 0;\n            if (typeof end !== 'number' || end % 1 !== 0)\n                throw TypeError(\"Illegal end: Not an integer\");\n            end >>>= 0;\n            if (begin < 0 || begin > end || end > this.buffer.byteLength)\n                throw RangeError(\"Illegal range: 0 <= \"+begin+\" <= \"+end+\" <= \"+this.buffer.byteLength);\n        }\r\n        if (begin === 0 && end === this.buffer.byteLength)\r\n            return this; // Already compacted\r\n        var len = end - begin;\r\n        if (len === 0) {\r\n            this.buffer = EMPTY_BUFFER;\r\n            this.view = null;\r\n            if (this.markedOffset >= 0) this.markedOffset -= begin;\r\n            this.offset = 0;\r\n            this.limit = 0;\r\n            return this;\r\n        }\r\n        var buffer = new ArrayBuffer(len);\r\n        var view = new Uint8Array(buffer);\r\n        view.set(this.view.subarray(begin, end));\r\n        this.buffer = buffer;\r\n        this.view = view;\r\n        if (this.markedOffset >= 0) this.markedOffset -= begin;\r\n        this.offset = 0;\r\n        this.limit = len;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and\r\n     *  {@link ByteBuffer#limit}.\r\n     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.\r\n     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.\r\n     * @returns {!ByteBuffer} Copy\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.copy = function(begin, end) {\r\n        if (typeof begin === 'undefined') begin = this.offset;\r\n        if (typeof end === 'undefined') end = this.limit;\r\n        if (!this.noAssert) {\r\n            if (typeof begin !== 'number' || begin % 1 !== 0)\n                throw TypeError(\"Illegal begin: Not an integer\");\n            begin >>>= 0;\n            if (typeof end !== 'number' || end % 1 !== 0)\n                throw TypeError(\"Illegal end: Not an integer\");\n            end >>>= 0;\n            if (begin < 0 || begin > end || end > this.buffer.byteLength)\n                throw RangeError(\"Illegal range: 0 <= \"+begin+\" <= \"+end+\" <= \"+this.buffer.byteLength);\n        }\r\n        if (begin === end)\r\n            return new ByteBuffer(0, this.littleEndian, this.noAssert);\r\n        var capacity = end - begin,\r\n            bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert);\r\n        bb.offset = 0;\r\n        bb.limit = capacity;\r\n        if (bb.markedOffset >= 0) bb.markedOffset -= begin;\r\n        this.copyTo(bb, 0, begin, end);\r\n        return bb;\r\n    };\r\n\r\n    /**\r\n     * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and\r\n     *  {@link ByteBuffer#limit}.\r\n     * @param {!ByteBuffer} target Target ByteBuffer\r\n     * @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset}\r\n     *  by the number of bytes copied if omitted.\r\n     * @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the\r\n     *  number of bytes copied if omitted.\r\n     * @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit}\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.copyTo = function(target, targetOffset, sourceOffset, sourceLimit) {\r\n        var relative,\r\n            targetRelative;\r\n        if (!this.noAssert) {\r\n            if (!ByteBuffer.isByteBuffer(target))\r\n                throw TypeError(\"Illegal target: Not a ByteBuffer\");\r\n        }\r\n        targetOffset = (targetRelative = typeof targetOffset === 'undefined') ? target.offset : targetOffset | 0;\r\n        sourceOffset = (relative = typeof sourceOffset === 'undefined') ? this.offset : sourceOffset | 0;\r\n        sourceLimit = typeof sourceLimit === 'undefined' ? this.limit : sourceLimit | 0;\r\n\r\n        if (targetOffset < 0 || targetOffset > target.buffer.byteLength)\r\n            throw RangeError(\"Illegal target range: 0 <= \"+targetOffset+\" <= \"+target.buffer.byteLength);\r\n        if (sourceOffset < 0 || sourceLimit > this.buffer.byteLength)\r\n            throw RangeError(\"Illegal source range: 0 <= \"+sourceOffset+\" <= \"+this.buffer.byteLength);\r\n\r\n        var len = sourceLimit - sourceOffset;\r\n        if (len === 0)\r\n            return target; // Nothing to copy\r\n\r\n        target.ensureCapacity(targetOffset + len);\r\n\r\n        target.view.set(this.view.subarray(sourceOffset, sourceLimit), targetOffset);\r\n\r\n        if (relative) this.offset += len;\r\n        if (targetRelative) target.offset += len;\r\n\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the\r\n     *  current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity,\r\n     *  the required capacity will be used instead.\r\n     * @param {number} capacity Required capacity\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.ensureCapacity = function(capacity) {\r\n        var current = this.buffer.byteLength;\r\n        if (current < capacity)\r\n            return this.resize((current *= 2) > capacity ? current : capacity);\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between\r\n     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.\r\n     * @param {number|string} value Byte value to fill with. If given as a string, the first character is used.\r\n     * @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes\r\n     *  written if omitted. defaults to {@link ByteBuffer#offset}.\r\n     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     * @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes\r\n     */\r\n    ByteBufferPrototype.fill = function(value, begin, end) {\r\n        var relative = typeof begin === 'undefined';\n        if (relative) begin = this.offset;\n        if (typeof value === 'string' && value.length > 0)\r\n            value = value.charCodeAt(0);\r\n        if (typeof begin === 'undefined') begin = this.offset;\r\n        if (typeof end === 'undefined') end = this.limit;\r\n        if (!this.noAssert) {\r\n            if (typeof value !== 'number' || value % 1 !== 0)\n                throw TypeError(\"Illegal value: \"+value+\" (not an integer)\");\n            value |= 0;\n            if (typeof begin !== 'number' || begin % 1 !== 0)\n                throw TypeError(\"Illegal begin: Not an integer\");\n            begin >>>= 0;\n            if (typeof end !== 'number' || end % 1 !== 0)\n                throw TypeError(\"Illegal end: Not an integer\");\n            end >>>= 0;\n            if (begin < 0 || begin > end || end > this.buffer.byteLength)\n                throw RangeError(\"Illegal range: 0 <= \"+begin+\" <= \"+end+\" <= \"+this.buffer.byteLength);\n        }\r\n        if (begin >= end)\r\n            return this; // Nothing to fill\r\n        while (begin < end) this.view[begin++] = value;\r\n        if (relative) this.offset = begin;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and\r\n     *  `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.flip = function() {\r\n        this.limit = this.offset;\r\n        this.offset = 0;\r\n        return this;\r\n    };\r\n    /**\r\n     * Marks an offset on this ByteBuffer to be used later.\r\n     * @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}.\r\n     * @returns {!ByteBuffer} this\r\n     * @throws {TypeError} If `offset` is not a valid number\r\n     * @throws {RangeError} If `offset` is out of bounds\r\n     * @see ByteBuffer#reset\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.mark = function(offset) {\r\n        offset = typeof offset === 'undefined' ? this.offset : offset;\r\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        this.markedOffset = offset;\r\n        return this;\r\n    };\r\n    /**\r\n     * Sets the byte order.\r\n     * @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.order = function(littleEndian) {\r\n        if (!this.noAssert) {\r\n            if (typeof littleEndian !== 'boolean')\r\n                throw TypeError(\"Illegal littleEndian: Not a boolean\");\r\n        }\r\n        this.littleEndian = !!littleEndian;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Switches (to) little endian byte order.\r\n     * @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.LE = function(littleEndian) {\r\n        this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : true;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Switches (to) big endian byte order.\r\n     * @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.BE = function(bigEndian) {\r\n        this.littleEndian = typeof bigEndian !== 'undefined' ? !bigEndian : false;\r\n        return this;\r\n    };\r\n    /**\r\n     * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the\r\n     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer\r\n     *  will be resized and its contents moved accordingly.\r\n     * @param {!ByteBuffer|string|!ArrayBuffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be\r\n     *  modified according to the performed read operation.\r\n     * @param {(string|number)=} encoding Encoding if `data` is a string (\"base64\", \"hex\", \"binary\", defaults to \"utf8\")\r\n     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes\r\n     *  prepended if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     * @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|`\r\n     * @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|`\r\n     */\r\n    ByteBufferPrototype.prepend = function(source, encoding, offset) {\r\n        if (typeof encoding === 'number' || typeof encoding !== 'string') {\r\n            offset = encoding;\r\n            encoding = undefined;\r\n        }\r\n        var relative = typeof offset === 'undefined';\n        if (relative) offset = this.offset;\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: \"+offset+\" (not an integer)\");\n            offset >>>= 0;\n            if (offset < 0 || offset + 0 > this.buffer.byteLength)\n                throw RangeError(\"Illegal offset: 0 <= \"+offset+\" (+\"+0+\") <= \"+this.buffer.byteLength);\n        }\r\n        if (!(source instanceof ByteBuffer))\r\n            source = ByteBuffer.wrap(source, encoding);\r\n        var len = source.limit - source.offset;\r\n        if (len <= 0) return this; // Nothing to prepend\r\n        var diff = len - offset;\r\n        if (diff > 0) { // Not enough space before offset, so resize + move\r\n            var buffer = new ArrayBuffer(this.buffer.byteLength + diff);\r\n            var view = new Uint8Array(buffer);\r\n            view.set(this.view.subarray(offset, this.buffer.byteLength), len);\r\n            this.buffer = buffer;\r\n            this.view = view;\r\n            this.offset += diff;\r\n            if (this.markedOffset >= 0) this.markedOffset += diff;\r\n            this.limit += diff;\r\n            offset += diff;\r\n        } else {\r\n            var arrayView = new Uint8Array(this.buffer);\r\n        }\r\n        this.view.set(source.view.subarray(source.offset, source.limit), offset - len);\r\n\r\n        source.offset = source.limit;\r\n        if (relative)\r\n            this.offset -= len;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the\r\n     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer\r\n     *  will be resized and its contents moved accordingly.\r\n     * @param {!ByteBuffer} target Target ByteBuffer\r\n     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes\r\n     *  prepended if omitted.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     * @see ByteBuffer#prepend\r\n     */\r\n    ByteBufferPrototype.prependTo = function(target, offset) {\r\n        target.prepend(this, offset);\r\n        return this;\r\n    };\r\n    /**\r\n     * Prints debug information about this ByteBuffer's contents.\r\n     * @param {function(string)=} out Output function to call, defaults to console.log\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.printDebug = function(out) {\r\n        if (typeof out !== 'function') out = console.log.bind(console);\r\n        out(\r\n            this.toString()+\"\\n\"+\r\n            \"-------------------------------------------------------------------\\n\"+\r\n            this.toDebug(/* columns */ true)\r\n        );\r\n    };\r\n\r\n    /**\r\n     * Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and\r\n     *  {@link ByteBuffer#limit}, so this returns `limit - offset`.\r\n     * @returns {number} Remaining readable bytes. May be negative if `offset > limit`.\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.remaining = function() {\r\n        return this.limit - this.offset;\r\n    };\r\n    /**\r\n     * Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark}\r\n     *  before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been\r\n     *  marked, sets `offset = 0`.\r\n     * @returns {!ByteBuffer} this\r\n     * @see ByteBuffer#mark\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.reset = function() {\r\n        if (this.markedOffset >= 0) {\r\n            this.offset = this.markedOffset;\r\n            this.markedOffset = -1;\r\n        } else {\r\n            this.offset = 0;\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that\r\n     *  large or larger.\r\n     * @param {number} capacity Capacity required\r\n     * @returns {!ByteBuffer} this\r\n     * @throws {TypeError} If `capacity` is not a number\r\n     * @throws {RangeError} If `capacity < 0`\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.resize = function(capacity) {\r\n        if (!this.noAssert) {\r\n            if (typeof capacity !== 'number' || capacity % 1 !== 0)\n                throw TypeError(\"Illegal capacity: \"+capacity+\" (not an integer)\");\n            capacity |= 0;\n            if (capacity < 0)\r\n                throw RangeError(\"Illegal capacity: 0 <= \"+capacity);\r\n        }\r\n        if (this.buffer.byteLength < capacity) {\r\n            var buffer = new ArrayBuffer(capacity);\r\n            var view = new Uint8Array(buffer);\r\n            view.set(this.view);\r\n            this.buffer = buffer;\r\n            this.view = view;\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Reverses this ByteBuffer's contents.\r\n     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}\r\n     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.reverse = function(begin, end) {\r\n        if (typeof begin === 'undefined') begin = this.offset;\r\n        if (typeof end === 'undefined') end = this.limit;\r\n        if (!this.noAssert) {\r\n            if (typeof begin !== 'number' || begin % 1 !== 0)\n                throw TypeError(\"Illegal begin: Not an integer\");\n            begin >>>= 0;\n            if (typeof end !== 'number' || end % 1 !== 0)\n                throw TypeError(\"Illegal end: Not an integer\");\n            end >>>= 0;\n            if (begin < 0 || begin > end || end > this.buffer.byteLength)\n                throw RangeError(\"Illegal range: 0 <= \"+begin+\" <= \"+end+\" <= \"+this.buffer.byteLength);\n        }\r\n        if (begin === end)\r\n            return this; // Nothing to reverse\r\n        Array.prototype.reverse.call(this.view.subarray(begin, end));\r\n        return this;\r\n    };\r\n    /**\r\n     * Skips the next `length` bytes. This will just advance\r\n     * @param {number} length Number of bytes to skip. May also be negative to move the offset back.\r\n     * @returns {!ByteBuffer} this\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.skip = function(length) {\r\n        if (!this.noAssert) {\r\n            if (typeof length !== 'number' || length % 1 !== 0)\n                throw TypeError(\"Illegal length: \"+length+\" (not an integer)\");\n            length |= 0;\n        }\r\n        var offset = this.offset + length;\r\n        if (!this.noAssert) {\r\n            if (offset < 0 || offset > this.buffer.byteLength)\r\n                throw RangeError(\"Illegal length: 0 <= \"+this.offset+\" + \"+length+\" <= \"+this.buffer.byteLength);\r\n        }\r\n        this.offset = offset;\r\n        return this;\r\n    };\r\n\r\n    /**\r\n     * Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`.\r\n     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.\r\n     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.\r\n     * @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer}\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.slice = function(begin, end) {\r\n        if (typeof begin === 'undefined') begin = this.offset;\r\n        if (typeof end === 'undefined') end = this.limit;\r\n        if (!this.noAssert) {\r\n            if (typeof begin !== 'number' || begin % 1 !== 0)\n                throw TypeError(\"Illegal begin: Not an integer\");\n            begin >>>= 0;\n            if (typeof end !== 'number' || end % 1 !== 0)\n                throw TypeError(\"Illegal end: Not an integer\");\n            end >>>= 0;\n            if (begin < 0 || begin > end || end > this.buffer.byteLength)\n                throw RangeError(\"Illegal range: 0 <= \"+begin+\" <= \"+end+\" <= \"+this.buffer.byteLength);\n        }\r\n        var bb = this.clone();\r\n        bb.offset = begin;\r\n        bb.limit = end;\r\n        return bb;\r\n    };\r\n    /**\r\n     * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between\r\n     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.\r\n     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if\r\n     *  possible. Defaults to `false`\r\n     * @returns {!ArrayBuffer} Contents as an ArrayBuffer\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.toBuffer = function(forceCopy) {\r\n        var offset = this.offset,\r\n            limit = this.limit;\r\n        if (!this.noAssert) {\r\n            if (typeof offset !== 'number' || offset % 1 !== 0)\n                throw TypeError(\"Illegal offset: Not an integer\");\n            offset >>>= 0;\n            if (typeof limit !== 'number' || limit % 1 !== 0)\n                throw TypeError(\"Illegal limit: Not an integer\");\n            limit >>>= 0;\n            if (offset < 0 || offset > limit || limit > this.buffer.byteLength)\n                throw RangeError(\"Illegal range: 0 <= \"+offset+\" <= \"+limit+\" <= \"+this.buffer.byteLength);\n        }\r\n        // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is\r\n        // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So:\r\n        if (!forceCopy && offset === 0 && limit === this.buffer.byteLength)\r\n            return this.buffer;\r\n        if (offset === limit)\r\n            return EMPTY_BUFFER;\r\n        var buffer = new ArrayBuffer(limit - offset);\r\n        new Uint8Array(buffer).set(new Uint8Array(this.buffer).subarray(offset, limit), 0);\r\n        return buffer;\r\n    };\r\n\r\n    /**\r\n     * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between\r\n     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. This is an alias of {@link ByteBuffer#toBuffer}.\r\n     * @function\r\n     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory.\r\n     *  Defaults to `false`\r\n     * @returns {!ArrayBuffer} Contents as an ArrayBuffer\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer;\r\n\r\n    /**\r\n     * Converts the ByteBuffer's contents to a string.\r\n     * @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows\r\n     *  direct conversion to \"utf8\", \"hex\", \"base64\" and \"binary\" encoding. \"debug\" returns a hex representation with\r\n     *  highlighted offsets.\r\n     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}\r\n     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}\r\n     * @returns {string} String representation\r\n     * @throws {Error} If `encoding` is invalid\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.toString = function(encoding, begin, end) {\r\n        if (typeof encoding === 'undefined')\r\n            return \"ByteBufferAB(offset=\"+this.offset+\",markedOffset=\"+this.markedOffset+\",limit=\"+this.limit+\",capacity=\"+this.capacity()+\")\";\r\n        if (typeof encoding === 'number')\r\n            encoding = \"utf8\", begin = encoding, end = begin;\r\n        switch (encoding) {\r\n            case \"utf8\":\r\n                return this.toUTF8(begin, end);\r\n            case \"base64\":\r\n                return this.toBase64(begin, end);\r\n            case \"hex\":\r\n                return this.toHex(begin, end);\r\n            case \"binary\":\r\n                return this.toBinary(begin, end);\r\n            case \"debug\":\r\n                return this.toDebug();\r\n            case \"columns\":\r\n                return this.toColumns();\r\n            default:\r\n                throw Error(\"Unsupported encoding: \"+encoding);\r\n        }\r\n    };\r\n\r\n    // lxiv-embeddable\r\n\r\n    /**\r\n     * lxiv-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>\r\n     * Released under the Apache License, Version 2.0\r\n     * see: https://github.com/dcodeIO/lxiv for details\r\n     */\r\n    var lxiv = function() {\r\n\r\n        /**\r\n         * lxiv namespace.\r\n         * @type {!Object.<string,*>}\r\n         * @exports lxiv\r\n         */\r\n        var lxiv = {};\r\n\r\n        /**\r\n         * Character codes for output.\r\n         * @type {!Array.<number>}\r\n         * @inner\r\n         */\r\n        var aout = [\r\n            65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\r\n            81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102,\r\n            103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,\r\n            119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47\r\n        ];\r\n\r\n        /**\r\n         * Character codes for input.\r\n         * @type {!Array.<number>}\r\n         * @inner\r\n         */\r\n        var ain = [];\r\n        for (var i=0, k=aout.length; i<k; ++i)\r\n            ain[aout[i]] = i;\r\n\r\n        /**\r\n         * Encodes bytes to base64 char codes.\r\n         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if\r\n         *  there are no more bytes left.\r\n         * @param {!function(number)} dst Characters destination as a function successively called with each encoded char\r\n         *  code.\r\n         */\r\n        lxiv.encode = function(src, dst) {\r\n            var b, t;\r\n            while ((b = src()) !== null) {\r\n                dst(aout[(b>>2)&0x3f]);\r\n                t = (b&0x3)<<4;\r\n                if ((b = src()) !== null) {\r\n                    t |= (b>>4)&0xf;\r\n                    dst(aout[(t|((b>>4)&0xf))&0x3f]);\r\n                    t = (b&0xf)<<2;\r\n                    if ((b = src()) !== null)\r\n                        dst(aout[(t|((b>>6)&0x3))&0x3f]), dst(aout[b&0x3f]);\r\n                    else\r\n                        dst(aout[t&0x3f]), dst(61);\r\n                } else\r\n                    dst(aout[t&0x3f]), dst(61), dst(61);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Decodes base64 char codes to bytes.\r\n         * @param {!function():number|null} src Characters source as a function returning the next char code respectively\r\n         *  `null` if there are no more characters left.\r\n         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.\r\n         * @throws {Error} If a character code is invalid\r\n         */\r\n        lxiv.decode = function(src, dst) {\r\n            var c, t1, t2;\r\n            function fail(c) {\r\n                throw Error(\"Illegal character code: \"+c);\r\n            }\r\n            while ((c = src()) !== null) {\r\n                t1 = ain[c];\r\n                if (typeof t1 === 'undefined') fail(c);\r\n                if ((c = src()) !== null) {\r\n                    t2 = ain[c];\r\n                    if (typeof t2 === 'undefined') fail(c);\r\n                    dst((t1<<2)>>>0|(t2&0x30)>>4);\r\n                    if ((c = src()) !== null) {\r\n                        t1 = ain[c];\r\n                        if (typeof t1 === 'undefined')\r\n                            if (c === 61) break; else fail(c);\r\n                        dst(((t2&0xf)<<4)>>>0|(t1&0x3c)>>2);\r\n                        if ((c = src()) !== null) {\r\n                            t2 = ain[c];\r\n                            if (typeof t2 === 'undefined')\r\n                                if (c === 61) break; else fail(c);\r\n                            dst(((t1&0x3)<<6)>>>0|t2);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Tests if a string is valid base64.\r\n         * @param {string} str String to test\r\n         * @returns {boolean} `true` if valid, otherwise `false`\r\n         */\r\n        lxiv.test = function(str) {\r\n            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);\r\n        };\r\n\r\n        return lxiv;\r\n    }();\r\n\r\n    // encodings/base64\r\n\r\n    /**\r\n     * Encodes this ByteBuffer's contents to a base64 encoded string.\r\n     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}.\r\n     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}.\r\n     * @returns {string} Base64 encoded string\r\n     * @throws {RangeError} If `begin` or `end` is out of bounds\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.toBase64 = function(begin, end) {\r\n        if (typeof begin === 'undefined')\r\n            begin = this.offset;\r\n        if (typeof end === 'undefined')\r\n            end = this.limit;\r\n        begin = begin | 0; end = end | 0;\r\n        if (begin < 0 || end > this.capacity || begin > end)\r\n            throw RangeError(\"begin, end\");\r\n        var sd; lxiv.encode(function() {\r\n            return begin < end ? this.view[begin++] : null;\r\n        }.bind(this), sd = stringDestination());\r\n        return sd();\r\n    };\r\n\r\n    /**\r\n     * Decodes a base64 encoded string to a ByteBuffer.\r\n     * @param {string} str String to decode\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @returns {!ByteBuffer} ByteBuffer\r\n     * @expose\r\n     */\r\n    ByteBuffer.fromBase64 = function(str, littleEndian) {\r\n        if (typeof str !== 'string')\r\n            throw TypeError(\"str\");\r\n        var bb = new ByteBuffer(str.length/4*3, littleEndian),\r\n            i = 0;\r\n        lxiv.decode(stringSource(str), function(b) {\r\n            bb.view[i++] = b;\r\n        });\r\n        bb.limit = i;\r\n        return bb;\r\n    };\r\n\r\n    /**\r\n     * Encodes a binary string to base64 like `window.btoa` does.\r\n     * @param {string} str Binary string\r\n     * @returns {string} Base64 encoded string\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa\r\n     * @expose\r\n     */\r\n    ByteBuffer.btoa = function(str) {\r\n        return ByteBuffer.fromBinary(str).toBase64();\r\n    };\r\n\r\n    /**\r\n     * Decodes a base64 encoded string to binary like `window.atob` does.\r\n     * @param {string} b64 Base64 encoded string\r\n     * @returns {string} Binary string\r\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob\r\n     * @expose\r\n     */\r\n    ByteBuffer.atob = function(b64) {\r\n        return ByteBuffer.fromBase64(b64).toBinary();\r\n    };\r\n\r\n    // encodings/binary\r\n\r\n    /**\r\n     * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.\r\n     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.\r\n     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.\r\n     * @returns {string} Binary encoded string\r\n     * @throws {RangeError} If `offset > limit`\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.toBinary = function(begin, end) {\r\n        if (typeof begin === 'undefined')\r\n            begin = this.offset;\r\n        if (typeof end === 'undefined')\r\n            end = this.limit;\r\n        begin |= 0; end |= 0;\r\n        if (begin < 0 || end > this.capacity() || begin > end)\r\n            throw RangeError(\"begin, end\");\r\n        if (begin === end)\r\n            return \"\";\r\n        var chars = [],\r\n            parts = [];\r\n        while (begin < end) {\r\n            chars.push(this.view[begin++]);\r\n            if (chars.length >= 1024)\r\n                parts.push(String.fromCharCode.apply(String, chars)), chars = [];\r\n        }\r\n        return parts.join('') + String.fromCharCode.apply(String, chars);\r\n    };\r\n\r\n    /**\r\n     * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.\r\n     * @param {string} str String to decode\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @returns {!ByteBuffer} ByteBuffer\r\n     * @expose\r\n     */\r\n    ByteBuffer.fromBinary = function(str, littleEndian) {\r\n        if (typeof str !== 'string')\r\n            throw TypeError(\"str\");\r\n        var i = 0,\r\n            k = str.length,\r\n            charCode,\r\n            bb = new ByteBuffer(k, littleEndian);\r\n        while (i<k) {\r\n            charCode = str.charCodeAt(i);\r\n            if (charCode > 0xff)\r\n                throw RangeError(\"illegal char code: \"+charCode);\r\n            bb.view[i++] = charCode;\r\n        }\r\n        bb.limit = k;\r\n        return bb;\r\n    };\r\n\r\n    // encodings/debug\r\n\r\n    /**\r\n     * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:\r\n     * * `<` : offset,\r\n     * * `'` : markedOffset,\r\n     * * `>` : limit,\r\n     * * `|` : offset and limit,\r\n     * * `[` : offset and markedOffset,\r\n     * * `]` : markedOffset and limit,\r\n     * * `!` : offset, markedOffset and limit\r\n     * @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false`\r\n     * @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true`\r\n     * @expose\r\n     * @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3`\r\n     * @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4`\r\n     * @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1`\r\n     * @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1`\r\n     */\r\n    ByteBufferPrototype.toDebug = function(columns) {\r\n        var i = -1,\r\n            k = this.buffer.byteLength,\r\n            b,\r\n            hex = \"\",\r\n            asc = \"\",\r\n            out = \"\";\r\n        while (i<k) {\r\n            if (i !== -1) {\r\n                b = this.view[i];\r\n                if (b < 0x10) hex += \"0\"+b.toString(16).toUpperCase();\r\n                else hex += b.toString(16).toUpperCase();\r\n                if (columns)\r\n                    asc += b > 32 && b < 127 ? String.fromCharCode(b) : '.';\r\n            }\r\n            ++i;\r\n            if (columns) {\r\n                if (i > 0 && i % 16 === 0 && i !== k) {\r\n                    while (hex.length < 3*16+3) hex += \" \";\r\n                    out += hex+asc+\"\\n\";\r\n                    hex = asc = \"\";\r\n                }\r\n            }\r\n            if (i === this.offset && i === this.limit)\r\n                hex += i === this.markedOffset ? \"!\" : \"|\";\r\n            else if (i === this.offset)\r\n                hex += i === this.markedOffset ? \"[\" : \"<\";\r\n            else if (i === this.limit)\r\n                hex += i === this.markedOffset ? \"]\" : \">\";\r\n            else\r\n                hex += i === this.markedOffset ? \"'\" : (columns || (i !== 0 && i !== k) ? \" \" : \"\");\r\n        }\r\n        if (columns && hex !== \" \") {\r\n            while (hex.length < 3*16+3)\r\n                hex += \" \";\r\n            out += hex + asc + \"\\n\";\r\n        }\r\n        return columns ? out : hex;\r\n    };\r\n\r\n    /**\r\n     * Decodes a hex encoded string with marked offsets to a ByteBuffer.\r\n     * @param {string} str Debug string to decode (not be generated with `columns = true`)\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_NOASSERT}.\r\n     * @returns {!ByteBuffer} ByteBuffer\r\n     * @expose\r\n     * @see ByteBuffer#toDebug\r\n     */\r\n    ByteBuffer.fromDebug = function(str, littleEndian, noAssert) {\r\n        var k = str.length,\r\n            bb = new ByteBuffer(((k+1)/3)|0, littleEndian, noAssert);\r\n        var i = 0, j = 0, ch, b,\r\n            rs = false, // Require symbol next\r\n            ho = false, hm = false, hl = false, // Already has offset (ho), markedOffset (hm), limit (hl)?\r\n            fail = false;\r\n        while (i<k) {\r\n            switch (ch = str.charAt(i++)) {\r\n                case '!':\r\n                    if (!noAssert) {\r\n                        if (ho || hm || hl) {\r\n                            fail = true;\r\n                            break;\r\n                        }\r\n                        ho = hm = hl = true;\r\n                    }\r\n                    bb.offset = bb.markedOffset = bb.limit = j;\r\n                    rs = false;\r\n                    break;\r\n                case '|':\r\n                    if (!noAssert) {\r\n                        if (ho || hl) {\r\n                            fail = true;\r\n                            break;\r\n                        }\r\n                        ho = hl = true;\r\n                    }\r\n                    bb.offset = bb.limit = j;\r\n                    rs = false;\r\n                    break;\r\n                case '[':\r\n                    if (!noAssert) {\r\n                        if (ho || hm) {\r\n                            fail = true;\r\n                            break;\r\n                        }\r\n                        ho = hm = true;\r\n                    }\r\n                    bb.offset = bb.markedOffset = j;\r\n                    rs = false;\r\n                    break;\r\n                case '<':\r\n                    if (!noAssert) {\r\n                        if (ho) {\r\n                            fail = true;\r\n                            break;\r\n                        }\r\n                        ho = true;\r\n                    }\r\n                    bb.offset = j;\r\n                    rs = false;\r\n                    break;\r\n                case ']':\r\n                    if (!noAssert) {\r\n                        if (hl || hm) {\r\n                            fail = true;\r\n                            break;\r\n                        }\r\n                        hl = hm = true;\r\n                    }\r\n                    bb.limit = bb.markedOffset = j;\r\n                    rs = false;\r\n                    break;\r\n                case '>':\r\n                    if (!noAssert) {\r\n                        if (hl) {\r\n                            fail = true;\r\n                            break;\r\n                        }\r\n                        hl = true;\r\n                    }\r\n                    bb.limit = j;\r\n                    rs = false;\r\n                    break;\r\n                case \"'\":\r\n                    if (!noAssert) {\r\n                        if (hm) {\r\n                            fail = true;\r\n                            break;\r\n                        }\r\n                        hm = true;\r\n                    }\r\n                    bb.markedOffset = j;\r\n                    rs = false;\r\n                    break;\r\n                case ' ':\r\n                    rs = false;\r\n                    break;\r\n                default:\r\n                    if (!noAssert) {\r\n                        if (rs) {\r\n                            fail = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    b = parseInt(ch+str.charAt(i++), 16);\r\n                    if (!noAssert) {\r\n                        if (isNaN(b) || b < 0 || b > 255)\r\n                            throw TypeError(\"Illegal str: Not a debug encoded string\");\r\n                    }\r\n                    bb.view[j++] = b;\r\n                    rs = true;\r\n            }\r\n            if (fail)\r\n                throw TypeError(\"Illegal str: Invalid symbol at \"+i);\r\n        }\r\n        if (!noAssert) {\r\n            if (!ho || !hl)\r\n                throw TypeError(\"Illegal str: Missing offset or limit\");\r\n            if (j<bb.buffer.byteLength)\r\n                throw TypeError(\"Illegal str: Not a debug encoded string (is it hex?) \"+j+\" < \"+k);\r\n        }\r\n        return bb;\r\n    };\r\n\r\n    // encodings/hex\r\n\r\n    /**\r\n     * Encodes this ByteBuffer's contents to a hex encoded string.\r\n     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.\r\n     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.\r\n     * @returns {string} Hex encoded string\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.toHex = function(begin, end) {\r\n        begin = typeof begin === 'undefined' ? this.offset : begin;\r\n        end = typeof end === 'undefined' ? this.limit : end;\r\n        if (!this.noAssert) {\r\n            if (typeof begin !== 'number' || begin % 1 !== 0)\n                throw TypeError(\"Illegal begin: Not an integer\");\n            begin >>>= 0;\n            if (typeof end !== 'number' || end % 1 !== 0)\n                throw TypeError(\"Illegal end: Not an integer\");\n            end >>>= 0;\n            if (begin < 0 || begin > end || end > this.buffer.byteLength)\n                throw RangeError(\"Illegal range: 0 <= \"+begin+\" <= \"+end+\" <= \"+this.buffer.byteLength);\n        }\r\n        var out = new Array(end - begin),\r\n            b;\r\n        while (begin < end) {\r\n            b = this.view[begin++];\r\n            if (b < 0x10)\r\n                out.push(\"0\", b.toString(16));\r\n            else out.push(b.toString(16));\r\n        }\r\n        return out.join('');\r\n    };\r\n\r\n    /**\r\n     * Decodes a hex encoded string to a ByteBuffer.\r\n     * @param {string} str String to decode\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_NOASSERT}.\r\n     * @returns {!ByteBuffer} ByteBuffer\r\n     * @expose\r\n     */\r\n    ByteBuffer.fromHex = function(str, littleEndian, noAssert) {\r\n        if (!noAssert) {\r\n            if (typeof str !== 'string')\r\n                throw TypeError(\"Illegal str: Not a string\");\r\n            if (str.length % 2 !== 0)\r\n                throw TypeError(\"Illegal str: Length not a multiple of 2\");\r\n        }\r\n        var k = str.length,\r\n            bb = new ByteBuffer((k / 2) | 0, littleEndian),\r\n            b;\r\n        for (var i=0, j=0; i<k; i+=2) {\r\n            b = parseInt(str.substring(i, i+2), 16);\r\n            if (!noAssert)\r\n                if (!isFinite(b) || b < 0 || b > 255)\r\n                    throw TypeError(\"Illegal str: Contains non-hex characters\");\r\n            bb.view[j++] = b;\r\n        }\r\n        bb.limit = j;\r\n        return bb;\r\n    };\r\n\r\n    // utfx-embeddable\r\n\r\n    /**\r\n     * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>\r\n     * Released under the Apache License, Version 2.0\r\n     * see: https://github.com/dcodeIO/utfx for details\r\n     */\r\n    var utfx = function() {\r\n\r\n        /**\r\n         * utfx namespace.\r\n         * @inner\r\n         * @type {!Object.<string,*>}\r\n         */\r\n        var utfx = {};\r\n\r\n        /**\r\n         * Maximum valid code point.\r\n         * @type {number}\r\n         * @const\r\n         */\r\n        utfx.MAX_CODEPOINT = 0x10FFFF;\r\n\r\n        /**\r\n         * Encodes UTF8 code points to UTF8 bytes.\r\n         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point\r\n         *  respectively `null` if there are no more code points left or a single numeric code point.\r\n         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte\r\n         */\r\n        utfx.encodeUTF8 = function(src, dst) {\r\n            var cp = null;\r\n            if (typeof src === 'number')\r\n                cp = src, src = function() { return null; };\r\n            while (cp !== null || (cp = src()) !== null) {\r\n                if (cp < 0x80)\r\n                    dst(cp&0x7F);\r\n                else if (cp < 0x800)\r\n                    dst(((cp>>6)&0x1F)|0xC0), dst((cp&0x3F)|0x80);\r\n                else if (cp < 0x10000)\r\n                    dst(((cp>>12)&0x0F)|0xE0), dst(((cp>>6)&0x3F)|0x80), dst((cp&0x3F)|0x80);\r\n                else\r\n                    dst(((cp>>18)&0x07)|0xF0), dst(((cp>>12)&0x3F)|0x80), dst(((cp>>6)&0x3F)|0x80), dst((cp&0x3F)|0x80);\r\n                cp = null;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Decodes UTF8 bytes to UTF8 code points.\r\n         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there\r\n         *  are no more bytes left.\r\n         * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.\r\n         * @throws {RangeError} If a starting byte is invalid in UTF8\r\n         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the\r\n         *  remaining bytes.\r\n         */\r\n        utfx.decodeUTF8 = function(src, dst) {\r\n            var a, b, c, d, fail = function(b) {\r\n                b = b.slice(0, b.indexOf(null));\r\n                var err = Error(b.toString());\r\n                err.name = \"TruncatedError\";\r\n                err['bytes'] = b;\r\n                throw err;\r\n            };\r\n            while ((a = src()) !== null) {\r\n                if ((a&0x80) === 0)\r\n                    dst(a);\r\n                else if ((a&0xE0) === 0xC0)\r\n                    ((b = src()) === null) && fail([a, b]), dst(((a&0x1F)<<6) | (b&0x3F));\r\n                else if ((a&0xF0) === 0xE0)\r\n                    ((b=src()) === null || (c=src()) === null) && fail([a, b, c]), dst(((a&0x0F)<<12) | ((b&0x3F)<<6) | (c&0x3F));\r\n                else if ((a&0xF8) === 0xF0)\r\n                    ((b=src()) === null || (c=src()) === null || (d=src()) === null) && fail([a, b, c ,d]), dst(((a&0x07)<<18) | ((b&0x3F)<<12) | ((c&0x3F)<<6) | (d&0x3F));\r\n                else throw RangeError(\"Illegal starting byte: \"+a);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Converts UTF16 characters to UTF8 code points.\r\n         * @param {!function():number|null} src Characters source as a function returning the next char code respectively\r\n         *  `null` if there are no more characters left.\r\n         * @param {!function(number)} dst Code points destination as a function successively called with each converted code\r\n         *  point.\r\n         */\r\n        utfx.UTF16toUTF8 = function(src, dst) {\r\n            var c1, c2 = null;\r\n            while (true) {\r\n                if ((c1 = c2 !== null ? c2 : src()) === null)\r\n                    break;\r\n                if (c1 >= 0xD800 && c1 <= 0xDFFF) {\r\n                    if ((c2 = src()) !== null) {\r\n                        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {\r\n                            dst((c1-0xD800)*0x400+c2-0xDC00+0x10000);\r\n                            c2 = null; continue;\r\n                        }\r\n                    }\r\n                }\r\n                dst(c1);\r\n            }\r\n            if (c2 !== null) dst(c2);\r\n        };\r\n\r\n        /**\r\n         * Converts UTF8 code points to UTF16 characters.\r\n         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point\r\n         *  respectively `null` if there are no more code points left or a single numeric code point.\r\n         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.\r\n         * @throws {RangeError} If a code point is out of range\r\n         */\r\n        utfx.UTF8toUTF16 = function(src, dst) {\r\n            var cp = null;\r\n            if (typeof src === 'number')\r\n                cp = src, src = function() { return null; };\r\n            while (cp !== null || (cp = src()) !== null) {\r\n                if (cp <= 0xFFFF)\r\n                    dst(cp);\r\n                else\r\n                    cp -= 0x10000, dst((cp>>10)+0xD800), dst((cp%0x400)+0xDC00);\r\n                cp = null;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Converts and encodes UTF16 characters to UTF8 bytes.\r\n         * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`\r\n         *  if there are no more characters left.\r\n         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.\r\n         */\r\n        utfx.encodeUTF16toUTF8 = function(src, dst) {\r\n            utfx.UTF16toUTF8(src, function(cp) {\r\n                utfx.encodeUTF8(cp, dst);\r\n            });\r\n        };\r\n\r\n        /**\r\n         * Decodes and converts UTF8 bytes to UTF16 characters.\r\n         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there\r\n         *  are no more bytes left.\r\n         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.\r\n         * @throws {RangeError} If a starting byte is invalid in UTF8\r\n         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.\r\n         */\r\n        utfx.decodeUTF8toUTF16 = function(src, dst) {\r\n            utfx.decodeUTF8(src, function(cp) {\r\n                utfx.UTF8toUTF16(cp, dst);\r\n            });\r\n        };\r\n\r\n        /**\r\n         * Calculates the byte length of an UTF8 code point.\r\n         * @param {number} cp UTF8 code point\r\n         * @returns {number} Byte length\r\n         */\r\n        utfx.calculateCodePoint = function(cp) {\r\n            return (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;\r\n        };\r\n\r\n        /**\r\n         * Calculates the number of UTF8 bytes required to store UTF8 code points.\r\n         * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively\r\n         *  `null` if there are no more code points left.\r\n         * @returns {number} The number of UTF8 bytes required\r\n         */\r\n        utfx.calculateUTF8 = function(src) {\r\n            var cp, l=0;\r\n            while ((cp = src()) !== null)\r\n                l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;\r\n            return l;\r\n        };\r\n\r\n        /**\r\n         * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.\r\n         * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively\r\n         *  `null` if there are no more characters left.\r\n         * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.\r\n         */\r\n        utfx.calculateUTF16asUTF8 = function(src) {\r\n            var n=0, l=0;\r\n            utfx.UTF16toUTF8(src, function(cp) {\r\n                ++n; l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;\r\n            });\r\n            return [n,l];\r\n        };\r\n\r\n        return utfx;\r\n    }();\r\n\r\n    // encodings/utf8\r\n\r\n    /**\r\n     * Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded\r\n     *  string.\r\n     * @returns {string} Hex encoded string\r\n     * @throws {RangeError} If `offset > limit`\r\n     * @expose\r\n     */\r\n    ByteBufferPrototype.toUTF8 = function(begin, end) {\r\n        if (typeof begin === 'undefined') begin = this.offset;\r\n        if (typeof end === 'undefined') end = this.limit;\r\n        if (!this.noAssert) {\r\n            if (typeof begin !== 'number' || begin % 1 !== 0)\n                throw TypeError(\"Illegal begin: Not an integer\");\n            begin >>>= 0;\n            if (typeof end !== 'number' || end % 1 !== 0)\n                throw TypeError(\"Illegal end: Not an integer\");\n            end >>>= 0;\n            if (begin < 0 || begin > end || end > this.buffer.byteLength)\n                throw RangeError(\"Illegal range: 0 <= \"+begin+\" <= \"+end+\" <= \"+this.buffer.byteLength);\n        }\r\n        var sd; try {\r\n            utfx.decodeUTF8toUTF16(function() {\r\n                return begin < end ? this.view[begin++] : null;\r\n            }.bind(this), sd = stringDestination());\r\n        } catch (e) {\r\n            if (begin !== end)\r\n                throw RangeError(\"Illegal range: Truncated data, \"+begin+\" != \"+end);\r\n        }\r\n        return sd();\r\n    };\r\n\r\n    /**\r\n     * Decodes an UTF8 encoded string to a ByteBuffer.\r\n     * @param {string} str String to decode\r\n     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_ENDIAN}.\r\n     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to\r\n     *  {@link ByteBuffer.DEFAULT_NOASSERT}.\r\n     * @returns {!ByteBuffer} ByteBuffer\r\n     * @expose\r\n     */\r\n    ByteBuffer.fromUTF8 = function(str, littleEndian, noAssert) {\r\n        if (!noAssert)\r\n            if (typeof str !== 'string')\r\n                throw TypeError(\"Illegal str: Not a string\");\r\n        var bb = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(str), true)[1], littleEndian, noAssert),\r\n            i = 0;\r\n        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {\r\n            bb.view[i++] = b;\r\n        });\r\n        bb.limit = i;\r\n        return bb;\r\n    };\r\n\r\n    return ByteBuffer;\r\n});\n});\n\nvar empty$1 = {};\n\n\nvar empty$2 = Object.freeze({\n\tdefault: empty$1\n});\n\nvar require$$2 = ( empty$2 && empty$1 ) || empty$2;\n\nvar protobufLight = createCommonjsModule(function (module) {\n/*\r\n Copyright 2013 Daniel Wirtz <dcode@dcode.io>\r\n\r\n Licensed under the Apache License, Version 2.0 (the \"License\");\r\n you may not use this file except in compliance with the License.\r\n You may obtain a copy of the License at\r\n\r\n http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n Unless required by applicable law or agreed to in writing, software\r\n distributed under the License is distributed on an \"AS IS\" BASIS,\r\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n See the License for the specific language governing permissions and\r\n limitations under the License.\r\n */\r\n\r\n/**\r\n * @license protobuf.js (c) 2013 Daniel Wirtz <dcode@dcode.io>\r\n * Released under the Apache License, Version 2.0\r\n * see: https://github.com/dcodeIO/protobuf.js for details\r\n */\r\n(function(global, factory) {\r\n\r\n    /* AMD */ if (false)\r\n        {}\r\n    /* CommonJS */ else if (typeof commonjsRequire === \"function\" && 'object' === \"object\" && module && module[\"exports\"])\r\n        module[\"exports\"] = factory(bytebuffer, true);\r\n    /* Global */ else\r\n        (global[\"dcodeIO\"] = global[\"dcodeIO\"] || {})[\"ProtoBuf\"] = factory(global[\"dcodeIO\"][\"ByteBuffer\"]);\r\n\r\n})(commonjsGlobal, function(ByteBuffer, isCommonJS) {\r\n\r\n    /**\r\n     * The ProtoBuf namespace.\r\n     * @exports ProtoBuf\r\n     * @namespace\r\n     * @expose\r\n     */\r\n    var ProtoBuf = {};\r\n\r\n    /**\r\n     * @type {!function(new: ByteBuffer, ...[*])}\r\n     * @expose\r\n     */\r\n    ProtoBuf.ByteBuffer = ByteBuffer;\r\n\r\n    /**\r\n     * @type {?function(new: Long, ...[*])}\r\n     * @expose\r\n     */\r\n    ProtoBuf.Long = ByteBuffer.Long || null;\r\n\r\n    /**\r\n     * ProtoBuf.js version.\r\n     * @type {string}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ProtoBuf.VERSION = \"5.0.3\";\r\n\r\n    /**\r\n     * Wire types.\r\n     * @type {Object.<string,number>}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ProtoBuf.WIRE_TYPES = {};\r\n\r\n    /**\r\n     * Varint wire type.\r\n     * @type {number}\r\n     * @expose\r\n     */\r\n    ProtoBuf.WIRE_TYPES.VARINT = 0;\r\n\r\n    /**\r\n     * Fixed 64 bits wire type.\r\n     * @type {number}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ProtoBuf.WIRE_TYPES.BITS64 = 1;\r\n\r\n    /**\r\n     * Length delimited wire type.\r\n     * @type {number}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ProtoBuf.WIRE_TYPES.LDELIM = 2;\r\n\r\n    /**\r\n     * Start group wire type.\r\n     * @type {number}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ProtoBuf.WIRE_TYPES.STARTGROUP = 3;\r\n\r\n    /**\r\n     * End group wire type.\r\n     * @type {number}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ProtoBuf.WIRE_TYPES.ENDGROUP = 4;\r\n\r\n    /**\r\n     * Fixed 32 bits wire type.\r\n     * @type {number}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ProtoBuf.WIRE_TYPES.BITS32 = 5;\r\n\r\n    /**\r\n     * Packable wire types.\r\n     * @type {!Array.<number>}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ProtoBuf.PACKABLE_WIRE_TYPES = [\r\n        ProtoBuf.WIRE_TYPES.VARINT,\r\n        ProtoBuf.WIRE_TYPES.BITS64,\r\n        ProtoBuf.WIRE_TYPES.BITS32\r\n    ];\r\n\r\n    /**\r\n     * Types.\r\n     * @dict\r\n     * @type {!Object.<string,{name: string, wireType: number, defaultValue: *}>}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ProtoBuf.TYPES = {\r\n        // According to the protobuf spec.\r\n        \"int32\": {\r\n            name: \"int32\",\r\n            wireType: ProtoBuf.WIRE_TYPES.VARINT,\r\n            defaultValue: 0\r\n        },\r\n        \"uint32\": {\r\n            name: \"uint32\",\r\n            wireType: ProtoBuf.WIRE_TYPES.VARINT,\r\n            defaultValue: 0\r\n        },\r\n        \"sint32\": {\r\n            name: \"sint32\",\r\n            wireType: ProtoBuf.WIRE_TYPES.VARINT,\r\n            defaultValue: 0\r\n        },\r\n        \"int64\": {\r\n            name: \"int64\",\r\n            wireType: ProtoBuf.WIRE_TYPES.VARINT,\r\n            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined\r\n        },\r\n        \"uint64\": {\r\n            name: \"uint64\",\r\n            wireType: ProtoBuf.WIRE_TYPES.VARINT,\r\n            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined\r\n        },\r\n        \"sint64\": {\r\n            name: \"sint64\",\r\n            wireType: ProtoBuf.WIRE_TYPES.VARINT,\r\n            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined\r\n        },\r\n        \"bool\": {\r\n            name: \"bool\",\r\n            wireType: ProtoBuf.WIRE_TYPES.VARINT,\r\n            defaultValue: false\r\n        },\r\n        \"double\": {\r\n            name: \"double\",\r\n            wireType: ProtoBuf.WIRE_TYPES.BITS64,\r\n            defaultValue: 0\r\n        },\r\n        \"string\": {\r\n            name: \"string\",\r\n            wireType: ProtoBuf.WIRE_TYPES.LDELIM,\r\n            defaultValue: \"\"\r\n        },\r\n        \"bytes\": {\r\n            name: \"bytes\",\r\n            wireType: ProtoBuf.WIRE_TYPES.LDELIM,\r\n            defaultValue: null // overridden in the code, must be a unique instance\r\n        },\r\n        \"fixed32\": {\r\n            name: \"fixed32\",\r\n            wireType: ProtoBuf.WIRE_TYPES.BITS32,\r\n            defaultValue: 0\r\n        },\r\n        \"sfixed32\": {\r\n            name: \"sfixed32\",\r\n            wireType: ProtoBuf.WIRE_TYPES.BITS32,\r\n            defaultValue: 0\r\n        },\r\n        \"fixed64\": {\r\n            name: \"fixed64\",\r\n            wireType: ProtoBuf.WIRE_TYPES.BITS64,\r\n            defaultValue:  ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined\r\n        },\r\n        \"sfixed64\": {\r\n            name: \"sfixed64\",\r\n            wireType: ProtoBuf.WIRE_TYPES.BITS64,\r\n            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined\r\n        },\r\n        \"float\": {\r\n            name: \"float\",\r\n            wireType: ProtoBuf.WIRE_TYPES.BITS32,\r\n            defaultValue: 0\r\n        },\r\n        \"enum\": {\r\n            name: \"enum\",\r\n            wireType: ProtoBuf.WIRE_TYPES.VARINT,\r\n            defaultValue: 0\r\n        },\r\n        \"message\": {\r\n            name: \"message\",\r\n            wireType: ProtoBuf.WIRE_TYPES.LDELIM,\r\n            defaultValue: null\r\n        },\r\n        \"group\": {\r\n            name: \"group\",\r\n            wireType: ProtoBuf.WIRE_TYPES.STARTGROUP,\r\n            defaultValue: null\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Valid map key types.\r\n     * @type {!Array.<!Object.<string,{name: string, wireType: number, defaultValue: *}>>}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ProtoBuf.MAP_KEY_TYPES = [\r\n        ProtoBuf.TYPES[\"int32\"],\r\n        ProtoBuf.TYPES[\"sint32\"],\r\n        ProtoBuf.TYPES[\"sfixed32\"],\r\n        ProtoBuf.TYPES[\"uint32\"],\r\n        ProtoBuf.TYPES[\"fixed32\"],\r\n        ProtoBuf.TYPES[\"int64\"],\r\n        ProtoBuf.TYPES[\"sint64\"],\r\n        ProtoBuf.TYPES[\"sfixed64\"],\r\n        ProtoBuf.TYPES[\"uint64\"],\r\n        ProtoBuf.TYPES[\"fixed64\"],\r\n        ProtoBuf.TYPES[\"bool\"],\r\n        ProtoBuf.TYPES[\"string\"],\r\n        ProtoBuf.TYPES[\"bytes\"]\r\n    ];\r\n\r\n    /**\r\n     * Minimum field id.\r\n     * @type {number}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ProtoBuf.ID_MIN = 1;\r\n\r\n    /**\r\n     * Maximum field id.\r\n     * @type {number}\r\n     * @const\r\n     * @expose\r\n     */\r\n    ProtoBuf.ID_MAX = 0x1FFFFFFF;\r\n\r\n    /**\r\n     * If set to `true`, field names will be converted from underscore notation to camel case. Defaults to `false`.\r\n     *  Must be set prior to parsing.\r\n     * @type {boolean}\r\n     * @expose\r\n     */\r\n    ProtoBuf.convertFieldsToCamelCase = false;\r\n\r\n    /**\r\n     * By default, messages are populated with (setX, set_x) accessors for each field. This can be disabled by\r\n     *  setting this to `false` prior to building messages.\r\n     * @type {boolean}\r\n     * @expose\r\n     */\r\n    ProtoBuf.populateAccessors = true;\r\n\r\n    /**\r\n     * By default, messages are populated with default values if a field is not present on the wire. To disable\r\n     *  this behavior, set this setting to `false`.\r\n     * @type {boolean}\r\n     * @expose\r\n     */\r\n    ProtoBuf.populateDefaults = true;\r\n\r\n    /**\r\n     * @alias ProtoBuf.Util\r\n     * @expose\r\n     */\r\n    ProtoBuf.Util = (function() {\r\n\r\n        /**\r\n         * ProtoBuf utilities.\r\n         * @exports ProtoBuf.Util\r\n         * @namespace\r\n         */\r\n        var Util = {};\r\n\r\n        /**\r\n         * Flag if running in node or not.\r\n         * @type {boolean}\r\n         * @const\r\n         * @expose\r\n         */\r\n        Util.IS_NODE = !!(\r\n            typeof process === 'object' && process+'' === '[object process]' && !process['browser']\r\n        );\r\n\r\n        /**\r\n         * Constructs a XMLHttpRequest object.\r\n         * @return {XMLHttpRequest}\r\n         * @throws {Error} If XMLHttpRequest is not supported\r\n         * @expose\r\n         */\r\n        Util.XHR = function() {\r\n            // No dependencies please, ref: http://www.quirksmode.org/js/xmlhttp.html\r\n            var XMLHttpFactories = [\r\n                function () {return new XMLHttpRequest()},\r\n                function () {return new ActiveXObject(\"Msxml2.XMLHTTP\")},\r\n                function () {return new ActiveXObject(\"Msxml3.XMLHTTP\")},\r\n                function () {return new ActiveXObject(\"Microsoft.XMLHTTP\")}\r\n            ];\r\n            /** @type {?XMLHttpRequest} */\r\n            var xhr = null;\r\n            for (var i=0;i<XMLHttpFactories.length;i++) {\r\n                try { xhr = XMLHttpFactories[i](); }\r\n                catch (e) { continue; }\r\n                break;\r\n            }\r\n            if (!xhr)\r\n                throw Error(\"XMLHttpRequest is not supported\");\r\n            return xhr;\r\n        };\r\n\r\n        /**\r\n         * Fetches a resource.\r\n         * @param {string} path Resource path\r\n         * @param {function(?string)=} callback Callback receiving the resource's contents. If omitted the resource will\r\n         *   be fetched synchronously. If the request failed, contents will be null.\r\n         * @return {?string|undefined} Resource contents if callback is omitted (null if the request failed), else undefined.\r\n         * @expose\r\n         */\r\n        Util.fetch = function(path, callback) {\r\n            if (callback && typeof callback != 'function')\r\n                callback = null;\r\n            if (Util.IS_NODE) {\r\n                var fs = require$$2;\r\n                if (callback) {\r\n                    fs.readFile(path, function(err, data) {\r\n                        if (err)\r\n                            callback(null);\r\n                        else\r\n                            callback(\"\"+data);\r\n                    });\r\n                } else\r\n                    try {\r\n                        return fs.readFileSync(path);\r\n                    } catch (e) {\r\n                        return null;\r\n                    }\r\n            } else {\r\n                var xhr = Util.XHR();\r\n                xhr.open('GET', path, callback ? true : false);\r\n                // xhr.setRequestHeader('User-Agent', 'XMLHTTP/1.0');\r\n                xhr.setRequestHeader('Accept', 'text/plain');\r\n                if (typeof xhr.overrideMimeType === 'function') xhr.overrideMimeType('text/plain');\r\n                if (callback) {\r\n                    xhr.onreadystatechange = function() {\r\n                        if (xhr.readyState != 4) return;\r\n                        if (/* remote */ xhr.status == 200 || /* local */ (xhr.status == 0 && typeof xhr.responseText === 'string'))\r\n                            callback(xhr.responseText);\r\n                        else\r\n                            callback(null);\r\n                    };\r\n                    if (xhr.readyState == 4)\r\n                        return;\r\n                    xhr.send(null);\r\n                } else {\r\n                    xhr.send(null);\r\n                    if (/* remote */ xhr.status == 200 || /* local */ (xhr.status == 0 && typeof xhr.responseText === 'string'))\r\n                        return xhr.responseText;\r\n                    return null;\r\n                }\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Converts a string to camel case.\r\n         * @param {string} str\r\n         * @returns {string}\r\n         * @expose\r\n         */\r\n        Util.toCamelCase = function(str) {\r\n            return str.replace(/_([a-zA-Z])/g, function ($0, $1) {\r\n                return $1.toUpperCase();\r\n            });\r\n        };\r\n\r\n        return Util;\r\n    })();\r\n\r\n    /**\r\n     * Language expressions.\r\n     * @type {!Object.<string,!RegExp>}\r\n     * @expose\r\n     */\r\n    ProtoBuf.Lang = {\r\n\r\n        // Characters always ending a statement\r\n        DELIM: /[\\s\\{\\}=;:\\[\\],'\"\\(\\)<>]/g,\r\n\r\n        // Field rules\r\n        RULE: /^(?:required|optional|repeated|map)$/,\r\n\r\n        // Field types\r\n        TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/,\r\n\r\n        // Names\r\n        NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/,\r\n\r\n        // Type definitions\r\n        TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/,\r\n\r\n        // Type references\r\n        TYPEREF: /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,\r\n\r\n        // Fully qualified type references\r\n        FQTYPEREF: /^(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)+$/,\r\n\r\n        // All numbers\r\n        NUMBER: /^-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+|([0-9]*(\\.[0-9]*)?([Ee][+-]?[0-9]+)?)|inf|nan)$/,\r\n\r\n        // Decimal numbers\r\n        NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/,\r\n\r\n        // Hexadecimal numbers\r\n        NUMBER_HEX: /^0[xX][0-9a-fA-F]+$/,\r\n\r\n        // Octal numbers\r\n        NUMBER_OCT: /^0[0-7]+$/,\r\n\r\n        // Floating point numbers\r\n        NUMBER_FLT: /^([0-9]*(\\.[0-9]*)?([Ee][+-]?[0-9]+)?|inf|nan)$/,\r\n\r\n        // Booleans\r\n        BOOL: /^(?:true|false)$/i,\r\n\r\n        // Id numbers\r\n        ID: /^(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,\r\n\r\n        // Negative id numbers (enum values)\r\n        NEGID: /^\\-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,\r\n\r\n        // Whitespaces\r\n        WHITESPACE: /\\s/,\r\n\r\n        // All strings\r\n        STRING: /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")|(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g,\r\n\r\n        // Double quoted strings\r\n        STRING_DQ: /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g,\r\n\r\n        // Single quoted strings\r\n        STRING_SQ: /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g\r\n    };\r\n\r\n\r\n    /**\r\n     * @alias ProtoBuf.Reflect\r\n     * @expose\r\n     */\r\n    ProtoBuf.Reflect = (function(ProtoBuf) {\r\n\r\n        /**\r\n         * Reflection types.\r\n         * @exports ProtoBuf.Reflect\r\n         * @namespace\r\n         */\r\n        var Reflect = {};\r\n\r\n        /**\r\n         * Constructs a Reflect base class.\r\n         * @exports ProtoBuf.Reflect.T\r\n         * @constructor\r\n         * @abstract\r\n         * @param {!ProtoBuf.Builder} builder Builder reference\r\n         * @param {?ProtoBuf.Reflect.T} parent Parent object\r\n         * @param {string} name Object name\r\n         */\r\n        var T = function(builder, parent, name) {\r\n\r\n            /**\r\n             * Builder reference.\r\n             * @type {!ProtoBuf.Builder}\r\n             * @expose\r\n             */\r\n            this.builder = builder;\r\n\r\n            /**\r\n             * Parent object.\r\n             * @type {?ProtoBuf.Reflect.T}\r\n             * @expose\r\n             */\r\n            this.parent = parent;\r\n\r\n            /**\r\n             * Object name in namespace.\r\n             * @type {string}\r\n             * @expose\r\n             */\r\n            this.name = name;\r\n\r\n            /**\r\n             * Fully qualified class name\r\n             * @type {string}\r\n             * @expose\r\n             */\r\n            this.className;\r\n        };\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.T.prototype\r\n         * @inner\r\n         */\r\n        var TPrototype = T.prototype;\r\n\r\n        /**\r\n         * Returns the fully qualified name of this object.\r\n         * @returns {string} Fully qualified name as of \".PATH.TO.THIS\"\r\n         * @expose\r\n         */\r\n        TPrototype.fqn = function() {\r\n            var name = this.name,\r\n                ptr = this;\r\n            do {\r\n                ptr = ptr.parent;\r\n                if (ptr == null)\r\n                    break;\r\n                name = ptr.name+\".\"+name;\r\n            } while (true);\r\n            return name;\r\n        };\r\n\r\n        /**\r\n         * Returns a string representation of this Reflect object (its fully qualified name).\r\n         * @param {boolean=} includeClass Set to true to include the class name. Defaults to false.\r\n         * @return String representation\r\n         * @expose\r\n         */\r\n        TPrototype.toString = function(includeClass) {\r\n            return (includeClass ? this.className + \" \" : \"\") + this.fqn();\r\n        };\r\n\r\n        /**\r\n         * Builds this type.\r\n         * @throws {Error} If this type cannot be built directly\r\n         * @expose\r\n         */\r\n        TPrototype.build = function() {\r\n            throw Error(this.toString(true)+\" cannot be built directly\");\r\n        };\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.T\r\n         * @expose\r\n         */\r\n        Reflect.T = T;\r\n\r\n        /**\r\n         * Constructs a new Namespace.\r\n         * @exports ProtoBuf.Reflect.Namespace\r\n         * @param {!ProtoBuf.Builder} builder Builder reference\r\n         * @param {?ProtoBuf.Reflect.Namespace} parent Namespace parent\r\n         * @param {string} name Namespace name\r\n         * @param {Object.<string,*>=} options Namespace options\r\n         * @param {string?} syntax The syntax level of this definition (e.g., proto3)\r\n         * @constructor\r\n         * @extends ProtoBuf.Reflect.T\r\n         */\r\n        var Namespace = function(builder, parent, name, options, syntax) {\r\n            T.call(this, builder, parent, name);\r\n\r\n            /**\r\n             * @override\r\n             */\r\n            this.className = \"Namespace\";\r\n\r\n            /**\r\n             * Children inside the namespace.\r\n             * @type {!Array.<ProtoBuf.Reflect.T>}\r\n             */\r\n            this.children = [];\r\n\r\n            /**\r\n             * Options.\r\n             * @type {!Object.<string, *>}\r\n             */\r\n            this.options = options || {};\r\n\r\n            /**\r\n             * Syntax level (e.g., proto2 or proto3).\r\n             * @type {!string}\r\n             */\r\n            this.syntax = syntax || \"proto2\";\r\n        };\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Namespace.prototype\r\n         * @inner\r\n         */\r\n        var NamespacePrototype = Namespace.prototype = Object.create(T.prototype);\r\n\r\n        /**\r\n         * Returns an array of the namespace's children.\r\n         * @param {ProtoBuf.Reflect.T=} type Filter type (returns instances of this type only). Defaults to null (all children).\r\n         * @return {Array.<ProtoBuf.Reflect.T>}\r\n         * @expose\r\n         */\r\n        NamespacePrototype.getChildren = function(type) {\r\n            type = type || null;\r\n            if (type == null)\r\n                return this.children.slice();\r\n            var children = [];\r\n            for (var i=0, k=this.children.length; i<k; ++i)\r\n                if (this.children[i] instanceof type)\r\n                    children.push(this.children[i]);\r\n            return children;\r\n        };\r\n\r\n        /**\r\n         * Adds a child to the namespace.\r\n         * @param {ProtoBuf.Reflect.T} child Child\r\n         * @throws {Error} If the child cannot be added (duplicate)\r\n         * @expose\r\n         */\r\n        NamespacePrototype.addChild = function(child) {\r\n            var other;\r\n            if (other = this.getChild(child.name)) {\r\n                // Try to revert camelcase transformation on collision\r\n                if (other instanceof Message.Field && other.name !== other.originalName && this.getChild(other.originalName) === null)\r\n                    other.name = other.originalName; // Revert previous first (effectively keeps both originals)\r\n                else if (child instanceof Message.Field && child.name !== child.originalName && this.getChild(child.originalName) === null)\r\n                    child.name = child.originalName;\r\n                else\r\n                    throw Error(\"Duplicate name in namespace \"+this.toString(true)+\": \"+child.name);\r\n            }\r\n            this.children.push(child);\r\n        };\r\n\r\n        /**\r\n         * Gets a child by its name or id.\r\n         * @param {string|number} nameOrId Child name or id\r\n         * @return {?ProtoBuf.Reflect.T} The child or null if not found\r\n         * @expose\r\n         */\r\n        NamespacePrototype.getChild = function(nameOrId) {\r\n            var key = typeof nameOrId === 'number' ? 'id' : 'name';\r\n            for (var i=0, k=this.children.length; i<k; ++i)\r\n                if (this.children[i][key] === nameOrId)\r\n                    return this.children[i];\r\n            return null;\r\n        };\r\n\r\n        /**\r\n         * Resolves a reflect object inside of this namespace.\r\n         * @param {string|!Array.<string>} qn Qualified name to resolve\r\n         * @param {boolean=} excludeNonNamespace Excludes non-namespace types, defaults to `false`\r\n         * @return {?ProtoBuf.Reflect.Namespace} The resolved type or null if not found\r\n         * @expose\r\n         */\r\n        NamespacePrototype.resolve = function(qn, excludeNonNamespace) {\r\n            var part = typeof qn === 'string' ? qn.split(\".\") : qn,\r\n                ptr = this,\r\n                i = 0;\r\n            if (part[i] === \"\") { // Fully qualified name, e.g. \".My.Message'\r\n                while (ptr.parent !== null)\r\n                    ptr = ptr.parent;\r\n                i++;\r\n            }\r\n            var child;\r\n            do {\r\n                do {\r\n                    if (!(ptr instanceof Reflect.Namespace)) {\r\n                        ptr = null;\r\n                        break;\r\n                    }\r\n                    child = ptr.getChild(part[i]);\r\n                    if (!child || !(child instanceof Reflect.T) || (excludeNonNamespace && !(child instanceof Reflect.Namespace))) {\r\n                        ptr = null;\r\n                        break;\r\n                    }\r\n                    ptr = child; i++;\r\n                } while (i < part.length);\r\n                if (ptr != null)\r\n                    break; // Found\r\n                // Else search the parent\r\n                if (this.parent !== null)\r\n                    return this.parent.resolve(qn, excludeNonNamespace);\r\n            } while (ptr != null);\r\n            return ptr;\r\n        };\r\n\r\n        /**\r\n         * Determines the shortest qualified name of the specified type, if any, relative to this namespace.\r\n         * @param {!ProtoBuf.Reflect.T} t Reflection type\r\n         * @returns {string} The shortest qualified name or, if there is none, the fqn\r\n         * @expose\r\n         */\r\n        NamespacePrototype.qn = function(t) {\r\n            var part = [], ptr = t;\r\n            do {\r\n                part.unshift(ptr.name);\r\n                ptr = ptr.parent;\r\n            } while (ptr !== null);\r\n            for (var len=1; len <= part.length; len++) {\r\n                var qn = part.slice(part.length-len);\r\n                if (t === this.resolve(qn, t instanceof Reflect.Namespace))\r\n                    return qn.join(\".\");\r\n            }\r\n            return t.fqn();\r\n        };\r\n\r\n        /**\r\n         * Builds the namespace and returns the runtime counterpart.\r\n         * @return {Object.<string,Function|Object>} Runtime namespace\r\n         * @expose\r\n         */\r\n        NamespacePrototype.build = function() {\r\n            /** @dict */\r\n            var ns = {};\r\n            var children = this.children;\r\n            for (var i=0, k=children.length, child; i<k; ++i) {\r\n                child = children[i];\r\n                if (child instanceof Namespace)\r\n                    ns[child.name] = child.build();\r\n            }\r\n            if (Object.defineProperty)\r\n                Object.defineProperty(ns, \"$options\", { \"value\": this.buildOpt() });\r\n            return ns;\r\n        };\r\n\r\n        /**\r\n         * Builds the namespace's '$options' property.\r\n         * @return {Object.<string,*>}\r\n         */\r\n        NamespacePrototype.buildOpt = function() {\r\n            var opt = {},\r\n                keys = Object.keys(this.options);\r\n            for (var i=0, k=keys.length; i<k; ++i) {\r\n                var key = keys[i],\r\n                    val = this.options[keys[i]];\r\n                // TODO: Options are not resolved, yet.\r\n                // if (val instanceof Namespace) {\r\n                //     opt[key] = val.build();\r\n                // } else {\r\n                opt[key] = val;\r\n                // }\r\n            }\r\n            return opt;\r\n        };\r\n\r\n        /**\r\n         * Gets the value assigned to the option with the specified name.\r\n         * @param {string=} name Returns the option value if specified, otherwise all options are returned.\r\n         * @return {*|Object.<string,*>}null} Option value or NULL if there is no such option\r\n         */\r\n        NamespacePrototype.getOption = function(name) {\r\n            if (typeof name === 'undefined')\r\n                return this.options;\r\n            return typeof this.options[name] !== 'undefined' ? this.options[name] : null;\r\n        };\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Namespace\r\n         * @expose\r\n         */\r\n        Reflect.Namespace = Namespace;\r\n\r\n        /**\r\n         * Constructs a new Element implementation that checks and converts values for a\r\n         * particular field type, as appropriate.\r\n         *\r\n         * An Element represents a single value: either the value of a singular field,\r\n         * or a value contained in one entry of a repeated field or map field. This\r\n         * class does not implement these higher-level concepts; it only encapsulates\r\n         * the low-level typechecking and conversion.\r\n         *\r\n         * @exports ProtoBuf.Reflect.Element\r\n         * @param {{name: string, wireType: number}} type Resolved data type\r\n         * @param {ProtoBuf.Reflect.T|null} resolvedType Resolved type, if relevant\r\n         * (e.g. submessage field).\r\n         * @param {boolean} isMapKey Is this element a Map key? The value will be\r\n         * converted to string form if so.\r\n         * @param {string} syntax Syntax level of defining message type, e.g.,\r\n         * proto2 or proto3.\r\n         * @param {string} name Name of the field containing this element (for error\r\n         * messages)\r\n         * @constructor\r\n         */\r\n        var Element = function(type, resolvedType, isMapKey, syntax, name) {\r\n\r\n            /**\r\n             * Element type, as a string (e.g., int32).\r\n             * @type {{name: string, wireType: number}}\r\n             */\r\n            this.type = type;\r\n\r\n            /**\r\n             * Element type reference to submessage or enum definition, if needed.\r\n             * @type {ProtoBuf.Reflect.T|null}\r\n             */\r\n            this.resolvedType = resolvedType;\r\n\r\n            /**\r\n             * Element is a map key.\r\n             * @type {boolean}\r\n             */\r\n            this.isMapKey = isMapKey;\r\n\r\n            /**\r\n             * Syntax level of defining message type, e.g., proto2 or proto3.\r\n             * @type {string}\r\n             */\r\n            this.syntax = syntax;\r\n\r\n            /**\r\n             * Name of the field containing this element (for error messages)\r\n             * @type {string}\r\n             */\r\n            this.name = name;\r\n\r\n            if (isMapKey && ProtoBuf.MAP_KEY_TYPES.indexOf(type) < 0)\r\n                throw Error(\"Invalid map key type: \" + type.name);\r\n        };\r\n\r\n        var ElementPrototype = Element.prototype;\r\n\r\n        /**\r\n         * Obtains a (new) default value for the specified type.\r\n         * @param type {string|{name: string, wireType: number}} Field type\r\n         * @returns {*} Default value\r\n         * @inner\r\n         */\r\n        function mkDefault(type) {\r\n            if (typeof type === 'string')\r\n                type = ProtoBuf.TYPES[type];\r\n            if (typeof type.defaultValue === 'undefined')\r\n                throw Error(\"default value for type \"+type.name+\" is not supported\");\r\n            if (type == ProtoBuf.TYPES[\"bytes\"])\r\n                return new ByteBuffer(0);\r\n            return type.defaultValue;\r\n        }\r\n\r\n        /**\r\n         * Returns the default value for this field in proto3.\r\n         * @function\r\n         * @param type {string|{name: string, wireType: number}} the field type\r\n         * @returns {*} Default value\r\n         */\r\n        Element.defaultFieldValue = mkDefault;\r\n\r\n        /**\r\n         * Makes a Long from a value.\r\n         * @param {{low: number, high: number, unsigned: boolean}|string|number} value Value\r\n         * @param {boolean=} unsigned Whether unsigned or not, defaults to reuse it from Long-like objects or to signed for\r\n         *  strings and numbers\r\n         * @returns {!Long}\r\n         * @throws {Error} If the value cannot be converted to a Long\r\n         * @inner\r\n         */\r\n        function mkLong(value, unsigned) {\r\n            if (value && typeof value.low === 'number' && typeof value.high === 'number' && typeof value.unsigned === 'boolean'\r\n                && value.low === value.low && value.high === value.high)\r\n                return new ProtoBuf.Long(value.low, value.high, typeof unsigned === 'undefined' ? value.unsigned : unsigned);\r\n            if (typeof value === 'string')\r\n                return ProtoBuf.Long.fromString(value, unsigned || false, 10);\r\n            if (typeof value === 'number')\r\n                return ProtoBuf.Long.fromNumber(value, unsigned || false);\r\n            throw Error(\"not convertible to Long\");\r\n        }\r\n\r\n        ElementPrototype.toString = function() {\r\n            return (this.name || '') + (this.isMapKey ? 'map' : 'value') + ' element';\r\n        };\r\n\r\n        /**\r\n         * Checks if the given value can be set for an element of this type (singular\r\n         * field or one element of a repeated field or map).\r\n         * @param {*} value Value to check\r\n         * @return {*} Verified, maybe adjusted, value\r\n         * @throws {Error} If the value cannot be verified for this element slot\r\n         * @expose\r\n         */\r\n        ElementPrototype.verifyValue = function(value) {\r\n            var self = this;\r\n            function fail(val, msg) {\r\n                throw Error(\"Illegal value for \"+self.toString(true)+\" of type \"+self.type.name+\": \"+val+\" (\"+msg+\")\");\r\n            }\r\n            switch (this.type) {\r\n                // Signed 32bit\r\n                case ProtoBuf.TYPES[\"int32\"]:\r\n                case ProtoBuf.TYPES[\"sint32\"]:\r\n                case ProtoBuf.TYPES[\"sfixed32\"]:\r\n                    // Account for !NaN: value === value\r\n                    if (typeof value !== 'number' || (value === value && value % 1 !== 0))\r\n                        fail(typeof value, \"not an integer\");\r\n                    return value > 4294967295 ? value | 0 : value;\r\n\r\n                // Unsigned 32bit\r\n                case ProtoBuf.TYPES[\"uint32\"]:\r\n                case ProtoBuf.TYPES[\"fixed32\"]:\r\n                    if (typeof value !== 'number' || (value === value && value % 1 !== 0))\r\n                        fail(typeof value, \"not an integer\");\r\n                    return value < 0 ? value >>> 0 : value;\r\n\r\n                // Signed 64bit\r\n                case ProtoBuf.TYPES[\"int64\"]:\r\n                case ProtoBuf.TYPES[\"sint64\"]:\r\n                case ProtoBuf.TYPES[\"sfixed64\"]: {\r\n                    if (ProtoBuf.Long)\r\n                        try {\r\n                            return mkLong(value, false);\r\n                        } catch (e) {\r\n                            fail(typeof value, e.message);\r\n                        }\r\n                    else\r\n                        fail(typeof value, \"requires Long.js\");\r\n                }\r\n\r\n                // Unsigned 64bit\r\n                case ProtoBuf.TYPES[\"uint64\"]:\r\n                case ProtoBuf.TYPES[\"fixed64\"]: {\r\n                    if (ProtoBuf.Long)\r\n                        try {\r\n                            return mkLong(value, true);\r\n                        } catch (e) {\r\n                            fail(typeof value, e.message);\r\n                        }\r\n                    else\r\n                        fail(typeof value, \"requires Long.js\");\r\n                }\r\n\r\n                // Bool\r\n                case ProtoBuf.TYPES[\"bool\"]:\r\n                    if (typeof value !== 'boolean')\r\n                        fail(typeof value, \"not a boolean\");\r\n                    return value;\r\n\r\n                // Float\r\n                case ProtoBuf.TYPES[\"float\"]:\r\n                case ProtoBuf.TYPES[\"double\"]:\r\n                    if (typeof value !== 'number')\r\n                        fail(typeof value, \"not a number\");\r\n                    return value;\r\n\r\n                // Length-delimited string\r\n                case ProtoBuf.TYPES[\"string\"]:\r\n                    if (typeof value !== 'string' && !(value && value instanceof String))\r\n                        fail(typeof value, \"not a string\");\r\n                    return \"\"+value; // Convert String object to string\r\n\r\n                // Length-delimited bytes\r\n                case ProtoBuf.TYPES[\"bytes\"]:\r\n                    if (ByteBuffer.isByteBuffer(value))\r\n                        return value;\r\n                    return ByteBuffer.wrap(value, \"base64\");\r\n\r\n                // Constant enum value\r\n                case ProtoBuf.TYPES[\"enum\"]: {\r\n                    var values = this.resolvedType.getChildren(ProtoBuf.Reflect.Enum.Value);\r\n                    for (i=0; i<values.length; i++)\r\n                        if (values[i].name == value)\r\n                            return values[i].id;\r\n                        else if (values[i].id == value)\r\n                            return values[i].id;\r\n\r\n                    if (this.syntax === 'proto3') {\r\n                        // proto3: just make sure it's an integer.\r\n                        if (typeof value !== 'number' || (value === value && value % 1 !== 0))\r\n                            fail(typeof value, \"not an integer\");\r\n                        if (value > 4294967295 || value < 0)\r\n                            fail(typeof value, \"not in range for uint32\");\r\n                        return value;\r\n                    } else {\r\n                        // proto2 requires enum values to be valid.\r\n                        fail(value, \"not a valid enum value\");\r\n                    }\r\n                }\r\n                // Embedded message\r\n                case ProtoBuf.TYPES[\"group\"]:\r\n                case ProtoBuf.TYPES[\"message\"]: {\r\n                    if (!value || typeof value !== 'object')\r\n                        fail(typeof value, \"object expected\");\r\n                    if (value instanceof this.resolvedType.clazz)\r\n                        return value;\r\n                    if (value instanceof ProtoBuf.Builder.Message) {\r\n                        // Mismatched type: Convert to object (see: https://github.com/dcodeIO/ProtoBuf.js/issues/180)\r\n                        var obj = {};\r\n                        for (var i in value)\r\n                            if (value.hasOwnProperty(i))\r\n                                obj[i] = value[i];\r\n                        value = obj;\r\n                    }\r\n                    // Else let's try to construct one from a key-value object\r\n                    return new (this.resolvedType.clazz)(value); // May throw for a hundred of reasons\r\n                }\r\n            }\r\n\r\n            // We should never end here\r\n            throw Error(\"[INTERNAL] Illegal value for \"+this.toString(true)+\": \"+value+\" (undefined type \"+this.type+\")\");\r\n        };\r\n\r\n        /**\r\n         * Calculates the byte length of an element on the wire.\r\n         * @param {number} id Field number\r\n         * @param {*} value Field value\r\n         * @returns {number} Byte length\r\n         * @throws {Error} If the value cannot be calculated\r\n         * @expose\r\n         */\r\n        ElementPrototype.calculateLength = function(id, value) {\r\n            if (value === null) return 0; // Nothing to encode\r\n            // Tag has already been written\r\n            var n;\r\n            switch (this.type) {\r\n                case ProtoBuf.TYPES[\"int32\"]:\r\n                    return value < 0 ? ByteBuffer.calculateVarint64(value) : ByteBuffer.calculateVarint32(value);\r\n                case ProtoBuf.TYPES[\"uint32\"]:\r\n                    return ByteBuffer.calculateVarint32(value);\r\n                case ProtoBuf.TYPES[\"sint32\"]:\r\n                    return ByteBuffer.calculateVarint32(ByteBuffer.zigZagEncode32(value));\r\n                case ProtoBuf.TYPES[\"fixed32\"]:\r\n                case ProtoBuf.TYPES[\"sfixed32\"]:\r\n                case ProtoBuf.TYPES[\"float\"]:\r\n                    return 4;\r\n                case ProtoBuf.TYPES[\"int64\"]:\r\n                case ProtoBuf.TYPES[\"uint64\"]:\r\n                    return ByteBuffer.calculateVarint64(value);\r\n                case ProtoBuf.TYPES[\"sint64\"]:\r\n                    return ByteBuffer.calculateVarint64(ByteBuffer.zigZagEncode64(value));\r\n                case ProtoBuf.TYPES[\"fixed64\"]:\r\n                case ProtoBuf.TYPES[\"sfixed64\"]:\r\n                    return 8;\r\n                case ProtoBuf.TYPES[\"bool\"]:\r\n                    return 1;\r\n                case ProtoBuf.TYPES[\"enum\"]:\r\n                    return ByteBuffer.calculateVarint32(value);\r\n                case ProtoBuf.TYPES[\"double\"]:\r\n                    return 8;\r\n                case ProtoBuf.TYPES[\"string\"]:\r\n                    n = ByteBuffer.calculateUTF8Bytes(value);\r\n                    return ByteBuffer.calculateVarint32(n) + n;\r\n                case ProtoBuf.TYPES[\"bytes\"]:\r\n                    if (value.remaining() < 0)\r\n                        throw Error(\"Illegal value for \"+this.toString(true)+\": \"+value.remaining()+\" bytes remaining\");\r\n                    return ByteBuffer.calculateVarint32(value.remaining()) + value.remaining();\r\n                case ProtoBuf.TYPES[\"message\"]:\r\n                    n = this.resolvedType.calculate(value);\r\n                    return ByteBuffer.calculateVarint32(n) + n;\r\n                case ProtoBuf.TYPES[\"group\"]:\r\n                    n = this.resolvedType.calculate(value);\r\n                    return n + ByteBuffer.calculateVarint32((id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);\r\n            }\r\n            // We should never end here\r\n            throw Error(\"[INTERNAL] Illegal value to encode in \"+this.toString(true)+\": \"+value+\" (unknown type)\");\r\n        };\r\n\r\n        /**\r\n         * Encodes a value to the specified buffer. Does not encode the key.\r\n         * @param {number} id Field number\r\n         * @param {*} value Field value\r\n         * @param {ByteBuffer} buffer ByteBuffer to encode to\r\n         * @return {ByteBuffer} The ByteBuffer for chaining\r\n         * @throws {Error} If the value cannot be encoded\r\n         * @expose\r\n         */\r\n        ElementPrototype.encodeValue = function(id, value, buffer) {\r\n            if (value === null) return buffer; // Nothing to encode\r\n            // Tag has already been written\r\n\r\n            switch (this.type) {\r\n                // 32bit signed varint\r\n                case ProtoBuf.TYPES[\"int32\"]:\r\n                    // \"If you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes\r\n                    // long – it is, effectively, treated like a very large unsigned integer.\" (see #122)\r\n                    if (value < 0)\r\n                        buffer.writeVarint64(value);\r\n                    else\r\n                        buffer.writeVarint32(value);\r\n                    break;\r\n\r\n                // 32bit unsigned varint\r\n                case ProtoBuf.TYPES[\"uint32\"]:\r\n                    buffer.writeVarint32(value);\r\n                    break;\r\n\r\n                // 32bit varint zig-zag\r\n                case ProtoBuf.TYPES[\"sint32\"]:\r\n                    buffer.writeVarint32ZigZag(value);\r\n                    break;\r\n\r\n                // Fixed unsigned 32bit\r\n                case ProtoBuf.TYPES[\"fixed32\"]:\r\n                    buffer.writeUint32(value);\r\n                    break;\r\n\r\n                // Fixed signed 32bit\r\n                case ProtoBuf.TYPES[\"sfixed32\"]:\r\n                    buffer.writeInt32(value);\r\n                    break;\r\n\r\n                // 64bit varint as-is\r\n                case ProtoBuf.TYPES[\"int64\"]:\r\n                case ProtoBuf.TYPES[\"uint64\"]:\r\n                    buffer.writeVarint64(value); // throws\r\n                    break;\r\n\r\n                // 64bit varint zig-zag\r\n                case ProtoBuf.TYPES[\"sint64\"]:\r\n                    buffer.writeVarint64ZigZag(value); // throws\r\n                    break;\r\n\r\n                // Fixed unsigned 64bit\r\n                case ProtoBuf.TYPES[\"fixed64\"]:\r\n                    buffer.writeUint64(value); // throws\r\n                    break;\r\n\r\n                // Fixed signed 64bit\r\n                case ProtoBuf.TYPES[\"sfixed64\"]:\r\n                    buffer.writeInt64(value); // throws\r\n                    break;\r\n\r\n                // Bool\r\n                case ProtoBuf.TYPES[\"bool\"]:\r\n                    if (typeof value === 'string')\r\n                        buffer.writeVarint32(value.toLowerCase() === 'false' ? 0 : !!value);\r\n                    else\r\n                        buffer.writeVarint32(value ? 1 : 0);\r\n                    break;\r\n\r\n                // Constant enum value\r\n                case ProtoBuf.TYPES[\"enum\"]:\r\n                    buffer.writeVarint32(value);\r\n                    break;\r\n\r\n                // 32bit float\r\n                case ProtoBuf.TYPES[\"float\"]:\r\n                    buffer.writeFloat32(value);\r\n                    break;\r\n\r\n                // 64bit float\r\n                case ProtoBuf.TYPES[\"double\"]:\r\n                    buffer.writeFloat64(value);\r\n                    break;\r\n\r\n                // Length-delimited string\r\n                case ProtoBuf.TYPES[\"string\"]:\r\n                    buffer.writeVString(value);\r\n                    break;\r\n\r\n                // Length-delimited bytes\r\n                case ProtoBuf.TYPES[\"bytes\"]:\r\n                    if (value.remaining() < 0)\r\n                        throw Error(\"Illegal value for \"+this.toString(true)+\": \"+value.remaining()+\" bytes remaining\");\r\n                    var prevOffset = value.offset;\r\n                    buffer.writeVarint32(value.remaining());\r\n                    buffer.append(value);\r\n                    value.offset = prevOffset;\r\n                    break;\r\n\r\n                // Embedded message\r\n                case ProtoBuf.TYPES[\"message\"]:\r\n                    var bb = new ByteBuffer().LE();\r\n                    this.resolvedType.encode(value, bb);\r\n                    buffer.writeVarint32(bb.offset);\r\n                    buffer.append(bb.flip());\r\n                    break;\r\n\r\n                // Legacy group\r\n                case ProtoBuf.TYPES[\"group\"]:\r\n                    this.resolvedType.encode(value, buffer);\r\n                    buffer.writeVarint32((id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);\r\n                    break;\r\n\r\n                default:\r\n                    // We should never end here\r\n                    throw Error(\"[INTERNAL] Illegal value to encode in \"+this.toString(true)+\": \"+value+\" (unknown type)\");\r\n            }\r\n            return buffer;\r\n        };\r\n\r\n        /**\r\n         * Decode one element value from the specified buffer.\r\n         * @param {ByteBuffer} buffer ByteBuffer to decode from\r\n         * @param {number} wireType The field wire type\r\n         * @param {number} id The field number\r\n         * @return {*} Decoded value\r\n         * @throws {Error} If the field cannot be decoded\r\n         * @expose\r\n         */\r\n        ElementPrototype.decode = function(buffer, wireType, id) {\r\n            if (wireType != this.type.wireType)\r\n                throw Error(\"Unexpected wire type for element\");\r\n\r\n            var value, nBytes;\r\n            switch (this.type) {\r\n                // 32bit signed varint\r\n                case ProtoBuf.TYPES[\"int32\"]:\r\n                    return buffer.readVarint32() | 0;\r\n\r\n                // 32bit unsigned varint\r\n                case ProtoBuf.TYPES[\"uint32\"]:\r\n                    return buffer.readVarint32() >>> 0;\r\n\r\n                // 32bit signed varint zig-zag\r\n                case ProtoBuf.TYPES[\"sint32\"]:\r\n                    return buffer.readVarint32ZigZag() | 0;\r\n\r\n                // Fixed 32bit unsigned\r\n                case ProtoBuf.TYPES[\"fixed32\"]:\r\n                    return buffer.readUint32() >>> 0;\r\n\r\n                case ProtoBuf.TYPES[\"sfixed32\"]:\r\n                    return buffer.readInt32() | 0;\r\n\r\n                // 64bit signed varint\r\n                case ProtoBuf.TYPES[\"int64\"]:\r\n                    return buffer.readVarint64();\r\n\r\n                // 64bit unsigned varint\r\n                case ProtoBuf.TYPES[\"uint64\"]:\r\n                    return buffer.readVarint64().toUnsigned();\r\n\r\n                // 64bit signed varint zig-zag\r\n                case ProtoBuf.TYPES[\"sint64\"]:\r\n                    return buffer.readVarint64ZigZag();\r\n\r\n                // Fixed 64bit unsigned\r\n                case ProtoBuf.TYPES[\"fixed64\"]:\r\n                    return buffer.readUint64();\r\n\r\n                // Fixed 64bit signed\r\n                case ProtoBuf.TYPES[\"sfixed64\"]:\r\n                    return buffer.readInt64();\r\n\r\n                // Bool varint\r\n                case ProtoBuf.TYPES[\"bool\"]:\r\n                    return !!buffer.readVarint32();\r\n\r\n                // Constant enum value (varint)\r\n                case ProtoBuf.TYPES[\"enum\"]:\r\n                    // The following Builder.Message#set will already throw\r\n                    return buffer.readVarint32();\r\n\r\n                // 32bit float\r\n                case ProtoBuf.TYPES[\"float\"]:\r\n                    return buffer.readFloat();\r\n\r\n                // 64bit float\r\n                case ProtoBuf.TYPES[\"double\"]:\r\n                    return buffer.readDouble();\r\n\r\n                // Length-delimited string\r\n                case ProtoBuf.TYPES[\"string\"]:\r\n                    return buffer.readVString();\r\n\r\n                // Length-delimited bytes\r\n                case ProtoBuf.TYPES[\"bytes\"]: {\r\n                    nBytes = buffer.readVarint32();\r\n                    if (buffer.remaining() < nBytes)\r\n                        throw Error(\"Illegal number of bytes for \"+this.toString(true)+\": \"+nBytes+\" required but got only \"+buffer.remaining());\r\n                    value = buffer.clone(); // Offset already set\r\n                    value.limit = value.offset+nBytes;\r\n                    buffer.offset += nBytes;\r\n                    return value;\r\n                }\r\n\r\n                // Length-delimited embedded message\r\n                case ProtoBuf.TYPES[\"message\"]: {\r\n                    nBytes = buffer.readVarint32();\r\n                    return this.resolvedType.decode(buffer, nBytes);\r\n                }\r\n\r\n                // Legacy group\r\n                case ProtoBuf.TYPES[\"group\"]:\r\n                    return this.resolvedType.decode(buffer, -1, id);\r\n            }\r\n\r\n            // We should never end here\r\n            throw Error(\"[INTERNAL] Illegal decode type\");\r\n        };\r\n\r\n        /**\r\n         * Converts a value from a string to the canonical element type.\r\n         *\r\n         * Legal only when isMapKey is true.\r\n         *\r\n         * @param {string} str The string value\r\n         * @returns {*} The value\r\n         */\r\n        ElementPrototype.valueFromString = function(str) {\r\n            if (!this.isMapKey) {\r\n                throw Error(\"valueFromString() called on non-map-key element\");\r\n            }\r\n\r\n            switch (this.type) {\r\n                case ProtoBuf.TYPES[\"int32\"]:\r\n                case ProtoBuf.TYPES[\"sint32\"]:\r\n                case ProtoBuf.TYPES[\"sfixed32\"]:\r\n                case ProtoBuf.TYPES[\"uint32\"]:\r\n                case ProtoBuf.TYPES[\"fixed32\"]:\r\n                    return this.verifyValue(parseInt(str));\r\n\r\n                case ProtoBuf.TYPES[\"int64\"]:\r\n                case ProtoBuf.TYPES[\"sint64\"]:\r\n                case ProtoBuf.TYPES[\"sfixed64\"]:\r\n                case ProtoBuf.TYPES[\"uint64\"]:\r\n                case ProtoBuf.TYPES[\"fixed64\"]:\r\n                      // Long-based fields support conversions from string already.\r\n                      return this.verifyValue(str);\r\n\r\n                case ProtoBuf.TYPES[\"bool\"]:\r\n                      return str === \"true\";\r\n\r\n                case ProtoBuf.TYPES[\"string\"]:\r\n                      return this.verifyValue(str);\r\n\r\n                case ProtoBuf.TYPES[\"bytes\"]:\r\n                      return ByteBuffer.fromBinary(str);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Converts a value from the canonical element type to a string.\r\n         *\r\n         * It should be the case that `valueFromString(valueToString(val))` returns\r\n         * a value equivalent to `verifyValue(val)` for every legal value of `val`\r\n         * according to this element type.\r\n         *\r\n         * This may be used when the element must be stored or used as a string,\r\n         * e.g., as a map key on an Object.\r\n         *\r\n         * Legal only when isMapKey is true.\r\n         *\r\n         * @param {*} val The value\r\n         * @returns {string} The string form of the value.\r\n         */\r\n        ElementPrototype.valueToString = function(value) {\r\n            if (!this.isMapKey) {\r\n                throw Error(\"valueToString() called on non-map-key element\");\r\n            }\r\n\r\n            if (this.type === ProtoBuf.TYPES[\"bytes\"]) {\r\n                return value.toString(\"binary\");\r\n            } else {\r\n                return value.toString();\r\n            }\r\n        };\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Element\r\n         * @expose\r\n         */\r\n        Reflect.Element = Element;\r\n\r\n        /**\r\n         * Constructs a new Message.\r\n         * @exports ProtoBuf.Reflect.Message\r\n         * @param {!ProtoBuf.Builder} builder Builder reference\r\n         * @param {!ProtoBuf.Reflect.Namespace} parent Parent message or namespace\r\n         * @param {string} name Message name\r\n         * @param {Object.<string,*>=} options Message options\r\n         * @param {boolean=} isGroup `true` if this is a legacy group\r\n         * @param {string?} syntax The syntax level of this definition (e.g., proto3)\r\n         * @constructor\r\n         * @extends ProtoBuf.Reflect.Namespace\r\n         */\r\n        var Message = function(builder, parent, name, options, isGroup, syntax) {\r\n            Namespace.call(this, builder, parent, name, options, syntax);\r\n\r\n            /**\r\n             * @override\r\n             */\r\n            this.className = \"Message\";\r\n\r\n            /**\r\n             * Extensions range.\r\n             * @type {!Array.<number>|undefined}\r\n             * @expose\r\n             */\r\n            this.extensions = undefined;\r\n\r\n            /**\r\n             * Runtime message class.\r\n             * @type {?function(new:ProtoBuf.Builder.Message)}\r\n             * @expose\r\n             */\r\n            this.clazz = null;\r\n\r\n            /**\r\n             * Whether this is a legacy group or not.\r\n             * @type {boolean}\r\n             * @expose\r\n             */\r\n            this.isGroup = !!isGroup;\r\n\r\n            // The following cached collections are used to efficiently iterate over or look up fields when decoding.\r\n\r\n            /**\r\n             * Cached fields.\r\n             * @type {?Array.<!ProtoBuf.Reflect.Message.Field>}\r\n             * @private\r\n             */\r\n            this._fields = null;\r\n\r\n            /**\r\n             * Cached fields by id.\r\n             * @type {?Object.<number,!ProtoBuf.Reflect.Message.Field>}\r\n             * @private\r\n             */\r\n            this._fieldsById = null;\r\n\r\n            /**\r\n             * Cached fields by name.\r\n             * @type {?Object.<string,!ProtoBuf.Reflect.Message.Field>}\r\n             * @private\r\n             */\r\n            this._fieldsByName = null;\r\n        };\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Message.prototype\r\n         * @inner\r\n         */\r\n        var MessagePrototype = Message.prototype = Object.create(Namespace.prototype);\r\n\r\n        /**\r\n         * Builds the message and returns the runtime counterpart, which is a fully functional class.\r\n         * @see ProtoBuf.Builder.Message\r\n         * @param {boolean=} rebuild Whether to rebuild or not, defaults to false\r\n         * @return {ProtoBuf.Reflect.Message} Message class\r\n         * @throws {Error} If the message cannot be built\r\n         * @expose\r\n         */\r\n        MessagePrototype.build = function(rebuild) {\r\n            if (this.clazz && !rebuild)\r\n                return this.clazz;\r\n\r\n            // Create the runtime Message class in its own scope\r\n            var clazz = (function(ProtoBuf, T) {\r\n\r\n                var fields = T.getChildren(ProtoBuf.Reflect.Message.Field),\r\n                    oneofs = T.getChildren(ProtoBuf.Reflect.Message.OneOf);\r\n\r\n                /**\r\n                 * Constructs a new runtime Message.\r\n                 * @name ProtoBuf.Builder.Message\r\n                 * @class Barebone of all runtime messages.\r\n                 * @param {!Object.<string,*>|string} values Preset values\r\n                 * @param {...string} var_args\r\n                 * @constructor\r\n                 * @throws {Error} If the message cannot be created\r\n                 */\r\n                var Message = function(values, var_args) {\r\n                    ProtoBuf.Builder.Message.call(this);\r\n\r\n                    // Create virtual oneof properties\r\n                    for (var i=0, k=oneofs.length; i<k; ++i)\r\n                        this[oneofs[i].name] = null;\r\n                    // Create fields and set default values\r\n                    for (i=0, k=fields.length; i<k; ++i) {\r\n                        var field = fields[i];\r\n                        this[field.name] =\r\n                            field.repeated ? [] :\r\n                            (field.map ? new ProtoBuf.Map(field) : null);\r\n                        if ((field.required || T.syntax === 'proto3') &&\r\n                            field.defaultValue !== null)\r\n                            this[field.name] = field.defaultValue;\r\n                    }\r\n\r\n                    if (arguments.length > 0) {\r\n                        var value;\r\n                        // Set field values from a values object\r\n                        if (arguments.length === 1 && values !== null && typeof values === 'object' &&\r\n                            /* not _another_ Message */ (typeof values.encode !== 'function' || values instanceof Message) &&\r\n                            /* not a repeated field */ !Array.isArray(values) &&\r\n                            /* not a Map */ !(values instanceof ProtoBuf.Map) &&\r\n                            /* not a ByteBuffer */ !ByteBuffer.isByteBuffer(values) &&\r\n                            /* not an ArrayBuffer */ !(values instanceof ArrayBuffer) &&\r\n                            /* not a Long */ !(ProtoBuf.Long && values instanceof ProtoBuf.Long)) {\r\n                            this.$set(values);\r\n                        } else // Set field values from arguments, in declaration order\r\n                            for (i=0, k=arguments.length; i<k; ++i)\r\n                                if (typeof (value = arguments[i]) !== 'undefined')\r\n                                    this.$set(fields[i].name, value); // May throw\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * @alias ProtoBuf.Builder.Message.prototype\r\n                 * @inner\r\n                 */\r\n                var MessagePrototype = Message.prototype = Object.create(ProtoBuf.Builder.Message.prototype);\r\n\r\n                /**\r\n                 * Adds a value to a repeated field.\r\n                 * @name ProtoBuf.Builder.Message#add\r\n                 * @function\r\n                 * @param {string} key Field name\r\n                 * @param {*} value Value to add\r\n                 * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)\r\n                 * @returns {!ProtoBuf.Builder.Message} this\r\n                 * @throws {Error} If the value cannot be added\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.add = function(key, value, noAssert) {\r\n                    var field = T._fieldsByName[key];\r\n                    if (!noAssert) {\r\n                        if (!field)\r\n                            throw Error(this+\"#\"+key+\" is undefined\");\r\n                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))\r\n                            throw Error(this+\"#\"+key+\" is not a field: \"+field.toString(true)); // May throw if it's an enum or embedded message\r\n                        if (!field.repeated)\r\n                            throw Error(this+\"#\"+key+\" is not a repeated field\");\r\n                        value = field.verifyValue(value, true);\r\n                    }\r\n                    if (this[key] === null)\r\n                        this[key] = [];\r\n                    this[key].push(value);\r\n                    return this;\r\n                };\r\n\r\n                /**\r\n                 * Adds a value to a repeated field. This is an alias for {@link ProtoBuf.Builder.Message#add}.\r\n                 * @name ProtoBuf.Builder.Message#$add\r\n                 * @function\r\n                 * @param {string} key Field name\r\n                 * @param {*} value Value to add\r\n                 * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)\r\n                 * @returns {!ProtoBuf.Builder.Message} this\r\n                 * @throws {Error} If the value cannot be added\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.$add = MessagePrototype.add;\r\n\r\n                /**\r\n                 * Sets a field's value.\r\n                 * @name ProtoBuf.Builder.Message#set\r\n                 * @function\r\n                 * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values\r\n                 * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted\r\n                 * @param {boolean=} noAssert Whether to not assert for an actual field / proper value type, defaults to `false`\r\n                 * @returns {!ProtoBuf.Builder.Message} this\r\n                 * @throws {Error} If the value cannot be set\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.set = function(keyOrObj, value, noAssert) {\r\n                    if (keyOrObj && typeof keyOrObj === 'object') {\r\n                        noAssert = value;\r\n                        for (var ikey in keyOrObj) {\r\n                            // Check if virtual oneof field - don't set these\r\n                            if (keyOrObj.hasOwnProperty(ikey) && typeof (value = keyOrObj[ikey]) !== 'undefined' && T._oneofsByName[ikey] === undefined)\r\n                                this.$set(ikey, value, noAssert);\r\n                        }\r\n                        return this;\r\n                    }\r\n                    var field = T._fieldsByName[keyOrObj];\r\n                    if (!noAssert) {\r\n                        if (!field)\r\n                            throw Error(this+\"#\"+keyOrObj+\" is not a field: undefined\");\r\n                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))\r\n                            throw Error(this+\"#\"+keyOrObj+\" is not a field: \"+field.toString(true));\r\n                        this[field.name] = (value = field.verifyValue(value)); // May throw\r\n                    } else\r\n                        this[keyOrObj] = value;\r\n                    if (field && field.oneof) { // Field is part of an OneOf (not a virtual OneOf field)\r\n                        var currentField = this[field.oneof.name]; // Virtual field references currently set field\r\n                        if (value !== null) {\r\n                            if (currentField !== null && currentField !== field.name)\r\n                                this[currentField] = null; // Clear currently set field\r\n                            this[field.oneof.name] = field.name; // Point virtual field at this field\r\n                        } else if (/* value === null && */currentField === keyOrObj)\r\n                            this[field.oneof.name] = null; // Clear virtual field (current field explicitly cleared)\r\n                    }\r\n                    return this;\r\n                };\r\n\r\n                /**\r\n                 * Sets a field's value. This is an alias for [@link ProtoBuf.Builder.Message#set}.\r\n                 * @name ProtoBuf.Builder.Message#$set\r\n                 * @function\r\n                 * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values\r\n                 * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted\r\n                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`\r\n                 * @throws {Error} If the value cannot be set\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.$set = MessagePrototype.set;\r\n\r\n                /**\r\n                 * Gets a field's value.\r\n                 * @name ProtoBuf.Builder.Message#get\r\n                 * @function\r\n                 * @param {string} key Key\r\n                 * @param {boolean=} noAssert Whether to not assert for an actual field, defaults to `false`\r\n                 * @return {*} Value\r\n                 * @throws {Error} If there is no such field\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.get = function(key, noAssert) {\r\n                    if (noAssert)\r\n                        return this[key];\r\n                    var field = T._fieldsByName[key];\r\n                    if (!field || !(field instanceof ProtoBuf.Reflect.Message.Field))\r\n                        throw Error(this+\"#\"+key+\" is not a field: undefined\");\r\n                    if (!(field instanceof ProtoBuf.Reflect.Message.Field))\r\n                        throw Error(this+\"#\"+key+\" is not a field: \"+field.toString(true));\r\n                    return this[field.name];\r\n                };\r\n\r\n                /**\r\n                 * Gets a field's value. This is an alias for {@link ProtoBuf.Builder.Message#$get}.\r\n                 * @name ProtoBuf.Builder.Message#$get\r\n                 * @function\r\n                 * @param {string} key Key\r\n                 * @return {*} Value\r\n                 * @throws {Error} If there is no such field\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.$get = MessagePrototype.get;\r\n\r\n                // Getters and setters\r\n\r\n                for (var i=0; i<fields.length; i++) {\r\n                    var field = fields[i];\r\n                    // no setters for extension fields as these are named by their fqn\r\n                    if (field instanceof ProtoBuf.Reflect.Message.ExtensionField)\r\n                        continue;\r\n\r\n                    if (T.builder.options['populateAccessors'])\r\n                        (function(field) {\r\n                            // set/get[SomeValue]\r\n                            var Name = field.originalName.replace(/(_[a-zA-Z])/g, function(match) {\r\n                                return match.toUpperCase().replace('_','');\r\n                            });\r\n                            Name = Name.substring(0,1).toUpperCase() + Name.substring(1);\r\n\r\n                            // set/get_[some_value] FIXME: Do we really need these?\r\n                            var name = field.originalName.replace(/([A-Z])/g, function(match) {\r\n                                return \"_\"+match;\r\n                            });\r\n\r\n                            /**\r\n                             * The current field's unbound setter function.\r\n                             * @function\r\n                             * @param {*} value\r\n                             * @param {boolean=} noAssert\r\n                             * @returns {!ProtoBuf.Builder.Message}\r\n                             * @inner\r\n                             */\r\n                            var setter = function(value, noAssert) {\r\n                                this[field.name] = noAssert ? value : field.verifyValue(value);\r\n                                return this;\r\n                            };\r\n\r\n                            /**\r\n                             * The current field's unbound getter function.\r\n                             * @function\r\n                             * @returns {*}\r\n                             * @inner\r\n                             */\r\n                            var getter = function() {\r\n                                return this[field.name];\r\n                            };\r\n\r\n                            if (T.getChild(\"set\"+Name) === null)\r\n                                /**\r\n                                 * Sets a value. This method is present for each field, but only if there is no name conflict with\r\n                                 *  another field.\r\n                                 * @name ProtoBuf.Builder.Message#set[SomeField]\r\n                                 * @function\r\n                                 * @param {*} value Value to set\r\n                                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`\r\n                                 * @returns {!ProtoBuf.Builder.Message} this\r\n                                 * @abstract\r\n                                 * @throws {Error} If the value cannot be set\r\n                                 */\r\n                                MessagePrototype[\"set\"+Name] = setter;\r\n\r\n                            if (T.getChild(\"set_\"+name) === null)\r\n                                /**\r\n                                 * Sets a value. This method is present for each field, but only if there is no name conflict with\r\n                                 *  another field.\r\n                                 * @name ProtoBuf.Builder.Message#set_[some_field]\r\n                                 * @function\r\n                                 * @param {*} value Value to set\r\n                                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`\r\n                                 * @returns {!ProtoBuf.Builder.Message} this\r\n                                 * @abstract\r\n                                 * @throws {Error} If the value cannot be set\r\n                                 */\r\n                                MessagePrototype[\"set_\"+name] = setter;\r\n\r\n                            if (T.getChild(\"get\"+Name) === null)\r\n                                /**\r\n                                 * Gets a value. This method is present for each field, but only if there is no name conflict with\r\n                                 *  another field.\r\n                                 * @name ProtoBuf.Builder.Message#get[SomeField]\r\n                                 * @function\r\n                                 * @abstract\r\n                                 * @return {*} The value\r\n                                 */\r\n                                MessagePrototype[\"get\"+Name] = getter;\r\n\r\n                            if (T.getChild(\"get_\"+name) === null)\r\n                                /**\r\n                                 * Gets a value. This method is present for each field, but only if there is no name conflict with\r\n                                 *  another field.\r\n                                 * @name ProtoBuf.Builder.Message#get_[some_field]\r\n                                 * @function\r\n                                 * @return {*} The value\r\n                                 * @abstract\r\n                                 */\r\n                                MessagePrototype[\"get_\"+name] = getter;\r\n\r\n                        })(field);\r\n                }\r\n\r\n                // En-/decoding\r\n\r\n                /**\r\n                 * Encodes the message.\r\n                 * @name ProtoBuf.Builder.Message#$encode\r\n                 * @function\r\n                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.\r\n                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`\r\n                 * @return {!ByteBuffer} Encoded message as a ByteBuffer\r\n                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still\r\n                 *  returns the encoded ByteBuffer in the `encoded` property on the error.\r\n                 * @expose\r\n                 * @see ProtoBuf.Builder.Message#encode64\r\n                 * @see ProtoBuf.Builder.Message#encodeHex\r\n                 * @see ProtoBuf.Builder.Message#encodeAB\r\n                 */\r\n                MessagePrototype.encode = function(buffer, noVerify) {\r\n                    if (typeof buffer === 'boolean')\r\n                        noVerify = buffer, buffer = undefined;\r\n                    var isNew = false;\r\n                    if (!buffer)\r\n                        buffer = new ByteBuffer(), isNew = true;\r\n                    var le = buffer.littleEndian;\r\n                    try {\r\n                        T.encode(this, buffer.LE(), noVerify);\r\n                        return (isNew ? buffer.flip() : buffer).LE(le);\r\n                    } catch (e) {\r\n                        buffer.LE(le);\r\n                        throw(e);\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * Encodes a message using the specified data payload.\r\n                 * @param {!Object.<string,*>} data Data payload\r\n                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.\r\n                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`\r\n                 * @return {!ByteBuffer} Encoded message as a ByteBuffer\r\n                 * @expose\r\n                 */\r\n                Message.encode = function(data, buffer, noVerify) {\r\n                    return new Message(data).encode(buffer, noVerify);\r\n                };\r\n\r\n                /**\r\n                 * Calculates the byte length of the message.\r\n                 * @name ProtoBuf.Builder.Message#calculate\r\n                 * @function\r\n                 * @returns {number} Byte length\r\n                 * @throws {Error} If the message cannot be calculated or if required fields are missing.\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.calculate = function() {\r\n                    return T.calculate(this);\r\n                };\r\n\r\n                /**\r\n                 * Encodes the varint32 length-delimited message.\r\n                 * @name ProtoBuf.Builder.Message#encodeDelimited\r\n                 * @function\r\n                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.\r\n                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`\r\n                 * @return {!ByteBuffer} Encoded message as a ByteBuffer\r\n                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still\r\n                 *  returns the encoded ByteBuffer in the `encoded` property on the error.\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.encodeDelimited = function(buffer, noVerify) {\r\n                    var isNew = false;\r\n                    if (!buffer)\r\n                        buffer = new ByteBuffer(), isNew = true;\r\n                    var enc = new ByteBuffer().LE();\r\n                    T.encode(this, enc, noVerify).flip();\r\n                    buffer.writeVarint32(enc.remaining());\r\n                    buffer.append(enc);\r\n                    return isNew ? buffer.flip() : buffer;\r\n                };\r\n\r\n                /**\r\n                 * Directly encodes the message to an ArrayBuffer.\r\n                 * @name ProtoBuf.Builder.Message#encodeAB\r\n                 * @function\r\n                 * @return {ArrayBuffer} Encoded message as ArrayBuffer\r\n                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still\r\n                 *  returns the encoded ArrayBuffer in the `encoded` property on the error.\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.encodeAB = function() {\r\n                    try {\r\n                        return this.encode().toArrayBuffer();\r\n                    } catch (e) {\r\n                        if (e[\"encoded\"]) e[\"encoded\"] = e[\"encoded\"].toArrayBuffer();\r\n                        throw(e);\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * Returns the message as an ArrayBuffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeAB}.\r\n                 * @name ProtoBuf.Builder.Message#toArrayBuffer\r\n                 * @function\r\n                 * @return {ArrayBuffer} Encoded message as ArrayBuffer\r\n                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still\r\n                 *  returns the encoded ArrayBuffer in the `encoded` property on the error.\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.toArrayBuffer = MessagePrototype.encodeAB;\r\n\r\n                /**\r\n                 * Directly encodes the message to a node Buffer.\r\n                 * @name ProtoBuf.Builder.Message#encodeNB\r\n                 * @function\r\n                 * @return {!Buffer}\r\n                 * @throws {Error} If the message cannot be encoded, not running under node.js or if required fields are\r\n                 *  missing. The later still returns the encoded node Buffer in the `encoded` property on the error.\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.encodeNB = function() {\r\n                    try {\r\n                        return this.encode().toBuffer();\r\n                    } catch (e) {\r\n                        if (e[\"encoded\"]) e[\"encoded\"] = e[\"encoded\"].toBuffer();\r\n                        throw(e);\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * Returns the message as a node Buffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeNB}.\r\n                 * @name ProtoBuf.Builder.Message#toBuffer\r\n                 * @function\r\n                 * @return {!Buffer}\r\n                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still\r\n                 *  returns the encoded node Buffer in the `encoded` property on the error.\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.toBuffer = MessagePrototype.encodeNB;\r\n\r\n                /**\r\n                 * Directly encodes the message to a base64 encoded string.\r\n                 * @name ProtoBuf.Builder.Message#encode64\r\n                 * @function\r\n                 * @return {string} Base64 encoded string\r\n                 * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later\r\n                 *  still returns the encoded base64 string in the `encoded` property on the error.\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.encode64 = function() {\r\n                    try {\r\n                        return this.encode().toBase64();\r\n                    } catch (e) {\r\n                        if (e[\"encoded\"]) e[\"encoded\"] = e[\"encoded\"].toBase64();\r\n                        throw(e);\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * Returns the message as a base64 encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encode64}.\r\n                 * @name ProtoBuf.Builder.Message#toBase64\r\n                 * @function\r\n                 * @return {string} Base64 encoded string\r\n                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still\r\n                 *  returns the encoded base64 string in the `encoded` property on the error.\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.toBase64 = MessagePrototype.encode64;\r\n\r\n                /**\r\n                 * Directly encodes the message to a hex encoded string.\r\n                 * @name ProtoBuf.Builder.Message#encodeHex\r\n                 * @function\r\n                 * @return {string} Hex encoded string\r\n                 * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later\r\n                 *  still returns the encoded hex string in the `encoded` property on the error.\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.encodeHex = function() {\r\n                    try {\r\n                        return this.encode().toHex();\r\n                    } catch (e) {\r\n                        if (e[\"encoded\"]) e[\"encoded\"] = e[\"encoded\"].toHex();\r\n                        throw(e);\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * Returns the message as a hex encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encodeHex}.\r\n                 * @name ProtoBuf.Builder.Message#toHex\r\n                 * @function\r\n                 * @return {string} Hex encoded string\r\n                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still\r\n                 *  returns the encoded hex string in the `encoded` property on the error.\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.toHex = MessagePrototype.encodeHex;\r\n\r\n                /**\r\n                 * Clones a message object or field value to a raw object.\r\n                 * @param {*} obj Object to clone\r\n                 * @param {boolean} binaryAsBase64 Whether to include binary data as base64 strings or as a buffer otherwise\r\n                 * @param {boolean} longsAsStrings Whether to encode longs as strings\r\n                 * @param {!ProtoBuf.Reflect.T=} resolvedType The resolved field type if a field\r\n                 * @returns {*} Cloned object\r\n                 * @inner\r\n                 */\r\n                function cloneRaw(obj, binaryAsBase64, longsAsStrings, resolvedType) {\r\n                    if (obj === null || typeof obj !== 'object') {\r\n                        // Convert enum values to their respective names\r\n                        if (resolvedType && resolvedType instanceof ProtoBuf.Reflect.Enum) {\r\n                            var name = ProtoBuf.Reflect.Enum.getName(resolvedType.object, obj);\r\n                            if (name !== null)\r\n                                return name;\r\n                        }\r\n                        // Pass-through string, number, boolean, null...\r\n                        return obj;\r\n                    }\r\n                    // Convert ByteBuffers to raw buffer or strings\r\n                    if (ByteBuffer.isByteBuffer(obj))\r\n                        return binaryAsBase64 ? obj.toBase64() : obj.toBuffer();\r\n                    // Convert Longs to proper objects or strings\r\n                    if (ProtoBuf.Long.isLong(obj))\r\n                        return longsAsStrings ? obj.toString() : ProtoBuf.Long.fromValue(obj);\r\n                    var clone;\r\n                    // Clone arrays\r\n                    if (Array.isArray(obj)) {\r\n                        clone = [];\r\n                        obj.forEach(function(v, k) {\r\n                            clone[k] = cloneRaw(v, binaryAsBase64, longsAsStrings, resolvedType);\r\n                        });\r\n                        return clone;\r\n                    }\r\n                    clone = {};\r\n                    // Convert maps to objects\r\n                    if (obj instanceof ProtoBuf.Map) {\r\n                        var it = obj.entries();\r\n                        for (var e = it.next(); !e.done; e = it.next())\r\n                            clone[obj.keyElem.valueToString(e.value[0])] = cloneRaw(e.value[1], binaryAsBase64, longsAsStrings, obj.valueElem.resolvedType);\r\n                        return clone;\r\n                    }\r\n                    // Everything else is a non-null object\r\n                    var type = obj.$type,\r\n                        field = undefined;\r\n                    for (var i in obj)\r\n                        if (obj.hasOwnProperty(i)) {\r\n                            if (type && (field = type.getChild(i)))\r\n                                clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings, field.resolvedType);\r\n                            else\r\n                                clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings);\r\n                        }\r\n                    return clone;\r\n                }\r\n\r\n                /**\r\n                 * Returns the message's raw payload.\r\n                 * @param {boolean=} binaryAsBase64 Whether to include binary data as base64 strings instead of Buffers, defaults to `false`\r\n                 * @param {boolean} longsAsStrings Whether to encode longs as strings\r\n                 * @returns {Object.<string,*>} Raw payload\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.toRaw = function(binaryAsBase64, longsAsStrings) {\r\n                    return cloneRaw(this, !!binaryAsBase64, !!longsAsStrings, this.$type);\r\n                };\r\n\r\n                /**\r\n                 * Encodes a message to JSON.\r\n                 * @returns {string} JSON string\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.encodeJSON = function() {\r\n                    return JSON.stringify(\r\n                        cloneRaw(this,\r\n                             /* binary-as-base64 */ true,\r\n                             /* longs-as-strings */ true,\r\n                             this.$type\r\n                        )\r\n                    );\r\n                };\r\n\r\n                /**\r\n                 * Decodes a message from the specified buffer or string.\r\n                 * @name ProtoBuf.Builder.Message.decode\r\n                 * @function\r\n                 * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from\r\n                 * @param {(number|string)=} length Message length. Defaults to decode all the remainig data.\r\n                 * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64\r\n                 * @return {!ProtoBuf.Builder.Message} Decoded message\r\n                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still\r\n                 *  returns the decoded message with missing fields in the `decoded` property on the error.\r\n                 * @expose\r\n                 * @see ProtoBuf.Builder.Message.decode64\r\n                 * @see ProtoBuf.Builder.Message.decodeHex\r\n                 */\r\n                Message.decode = function(buffer, length, enc) {\r\n                    if (typeof length === 'string')\r\n                        enc = length, length = -1;\r\n                    if (typeof buffer === 'string')\r\n                        buffer = ByteBuffer.wrap(buffer, enc ? enc : \"base64\");\r\n                    else if (!ByteBuffer.isByteBuffer(buffer))\r\n                        buffer = ByteBuffer.wrap(buffer); // May throw\r\n                    var le = buffer.littleEndian;\r\n                    try {\r\n                        var msg = T.decode(buffer.LE(), length);\r\n                        buffer.LE(le);\r\n                        return msg;\r\n                    } catch (e) {\r\n                        buffer.LE(le);\r\n                        throw(e);\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * Decodes a varint32 length-delimited message from the specified buffer or string.\r\n                 * @name ProtoBuf.Builder.Message.decodeDelimited\r\n                 * @function\r\n                 * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from\r\n                 * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64\r\n                 * @return {ProtoBuf.Builder.Message} Decoded message or `null` if not enough bytes are available yet\r\n                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still\r\n                 *  returns the decoded message with missing fields in the `decoded` property on the error.\r\n                 * @expose\r\n                 */\r\n                Message.decodeDelimited = function(buffer, enc) {\r\n                    if (typeof buffer === 'string')\r\n                        buffer = ByteBuffer.wrap(buffer, enc ? enc : \"base64\");\r\n                    else if (!ByteBuffer.isByteBuffer(buffer))\r\n                        buffer = ByteBuffer.wrap(buffer); // May throw\r\n                    if (buffer.remaining() < 1)\r\n                        return null;\r\n                    var off = buffer.offset,\r\n                        len = buffer.readVarint32();\r\n                    if (buffer.remaining() < len) {\r\n                        buffer.offset = off;\r\n                        return null;\r\n                    }\r\n                    try {\r\n                        var msg = T.decode(buffer.slice(buffer.offset, buffer.offset + len).LE());\r\n                        buffer.offset += len;\r\n                        return msg;\r\n                    } catch (err) {\r\n                        buffer.offset += len;\r\n                        throw err;\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * Decodes the message from the specified base64 encoded string.\r\n                 * @name ProtoBuf.Builder.Message.decode64\r\n                 * @function\r\n                 * @param {string} str String to decode from\r\n                 * @return {!ProtoBuf.Builder.Message} Decoded message\r\n                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still\r\n                 *  returns the decoded message with missing fields in the `decoded` property on the error.\r\n                 * @expose\r\n                 */\r\n                Message.decode64 = function(str) {\r\n                    return Message.decode(str, \"base64\");\r\n                };\r\n\r\n                /**\r\n                 * Decodes the message from the specified hex encoded string.\r\n                 * @name ProtoBuf.Builder.Message.decodeHex\r\n                 * @function\r\n                 * @param {string} str String to decode from\r\n                 * @return {!ProtoBuf.Builder.Message} Decoded message\r\n                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still\r\n                 *  returns the decoded message with missing fields in the `decoded` property on the error.\r\n                 * @expose\r\n                 */\r\n                Message.decodeHex = function(str) {\r\n                    return Message.decode(str, \"hex\");\r\n                };\r\n\r\n                /**\r\n                 * Decodes the message from a JSON string.\r\n                 * @name ProtoBuf.Builder.Message.decodeJSON\r\n                 * @function\r\n                 * @param {string} str String to decode from\r\n                 * @return {!ProtoBuf.Builder.Message} Decoded message\r\n                 * @throws {Error} If the message cannot be decoded or if required fields are\r\n                 * missing.\r\n                 * @expose\r\n                 */\r\n                Message.decodeJSON = function(str) {\r\n                    return new Message(JSON.parse(str));\r\n                };\r\n\r\n                // Utility\r\n\r\n                /**\r\n                 * Returns a string representation of this Message.\r\n                 * @name ProtoBuf.Builder.Message#toString\r\n                 * @function\r\n                 * @return {string} String representation as of \".Fully.Qualified.MessageName\"\r\n                 * @expose\r\n                 */\r\n                MessagePrototype.toString = function() {\r\n                    return T.toString();\r\n                };\r\n\r\n                if (Object.defineProperty)\r\n                    Object.defineProperty(Message, '$options', { \"value\": T.buildOpt() }), Object.defineProperty(MessagePrototype, \"$options\", { \"value\": Message[\"$options\"] }), Object.defineProperty(Message, \"$type\", { \"value\": T }), Object.defineProperty(MessagePrototype, \"$type\", { \"value\": T });\r\n\r\n                return Message;\r\n\r\n            })(ProtoBuf, this);\r\n\r\n            // Static enums and prototyped sub-messages / cached collections\r\n            this._fields = [];\r\n            this._fieldsById = {};\r\n            this._fieldsByName = {};\r\n            this._oneofsByName = {};\r\n            for (var i=0, k=this.children.length, child; i<k; i++) {\r\n                child = this.children[i];\r\n                if (child instanceof Enum || child instanceof Message || child instanceof Service) {\r\n                    if (clazz.hasOwnProperty(child.name))\r\n                        throw Error(\"Illegal reflect child of \"+this.toString(true)+\": \"+child.toString(true)+\" cannot override static property '\"+child.name+\"'\");\r\n                    clazz[child.name] = child.build();\r\n                } else if (child instanceof Message.Field)\r\n                    child.build(), this._fields.push(child), this._fieldsById[child.id] = child, this._fieldsByName[child.name] = child;\r\n                else if (child instanceof Message.OneOf) {\r\n                    this._oneofsByName[child.name] = child;\r\n                }\r\n                else if (!(child instanceof Message.OneOf) && !(child instanceof Extension)) // Not built\r\n                    throw Error(\"Illegal reflect child of \"+this.toString(true)+\": \"+this.children[i].toString(true));\r\n            }\r\n\r\n            return this.clazz = clazz;\r\n        };\r\n\r\n        /**\r\n         * Encodes a runtime message's contents to the specified buffer.\r\n         * @param {!ProtoBuf.Builder.Message} message Runtime message to encode\r\n         * @param {ByteBuffer} buffer ByteBuffer to write to\r\n         * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`\r\n         * @return {ByteBuffer} The ByteBuffer for chaining\r\n         * @throws {Error} If required fields are missing or the message cannot be encoded for another reason\r\n         * @expose\r\n         */\r\n        MessagePrototype.encode = function(message, buffer, noVerify) {\r\n            var fieldMissing = null,\r\n                field;\r\n            for (var i=0, k=this._fields.length, val; i<k; ++i) {\r\n                field = this._fields[i];\r\n                val = message[field.name];\r\n                if (field.required && val === null) {\r\n                    if (fieldMissing === null)\r\n                        fieldMissing = field;\r\n                } else\r\n                    field.encode(noVerify ? val : field.verifyValue(val), buffer, message);\r\n            }\r\n            if (fieldMissing !== null) {\r\n                var err = Error(\"Missing at least one required field for \"+this.toString(true)+\": \"+fieldMissing);\r\n                err[\"encoded\"] = buffer; // Still expose what we got\r\n                throw(err);\r\n            }\r\n            return buffer;\r\n        };\r\n\r\n        /**\r\n         * Calculates a runtime message's byte length.\r\n         * @param {!ProtoBuf.Builder.Message} message Runtime message to encode\r\n         * @returns {number} Byte length\r\n         * @throws {Error} If required fields are missing or the message cannot be calculated for another reason\r\n         * @expose\r\n         */\r\n        MessagePrototype.calculate = function(message) {\r\n            for (var n=0, i=0, k=this._fields.length, field, val; i<k; ++i) {\r\n                field = this._fields[i];\r\n                val = message[field.name];\r\n                if (field.required && val === null)\r\n                   throw Error(\"Missing at least one required field for \"+this.toString(true)+\": \"+field);\r\n                else\r\n                    n += field.calculate(val, message);\r\n            }\r\n            return n;\r\n        };\r\n\r\n        /**\r\n         * Skips all data until the end of the specified group has been reached.\r\n         * @param {number} expectedId Expected GROUPEND id\r\n         * @param {!ByteBuffer} buf ByteBuffer\r\n         * @returns {boolean} `true` if a value as been skipped, `false` if the end has been reached\r\n         * @throws {Error} If it wasn't possible to find the end of the group (buffer overrun or end tag mismatch)\r\n         * @inner\r\n         */\r\n        function skipTillGroupEnd(expectedId, buf) {\r\n            var tag = buf.readVarint32(), // Throws on OOB\r\n                wireType = tag & 0x07,\r\n                id = tag >>> 3;\r\n            switch (wireType) {\r\n                case ProtoBuf.WIRE_TYPES.VARINT:\r\n                    do tag = buf.readUint8();\r\n                    while ((tag & 0x80) === 0x80);\r\n                    break;\r\n                case ProtoBuf.WIRE_TYPES.BITS64:\r\n                    buf.offset += 8;\r\n                    break;\r\n                case ProtoBuf.WIRE_TYPES.LDELIM:\r\n                    tag = buf.readVarint32(); // reads the varint\r\n                    buf.offset += tag;        // skips n bytes\r\n                    break;\r\n                case ProtoBuf.WIRE_TYPES.STARTGROUP:\r\n                    skipTillGroupEnd(id, buf);\r\n                    break;\r\n                case ProtoBuf.WIRE_TYPES.ENDGROUP:\r\n                    if (id === expectedId)\r\n                        return false;\r\n                    else\r\n                        throw Error(\"Illegal GROUPEND after unknown group: \"+id+\" (\"+expectedId+\" expected)\");\r\n                case ProtoBuf.WIRE_TYPES.BITS32:\r\n                    buf.offset += 4;\r\n                    break;\r\n                default:\r\n                    throw Error(\"Illegal wire type in unknown group \"+expectedId+\": \"+wireType);\r\n            }\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * Decodes an encoded message and returns the decoded message.\r\n         * @param {ByteBuffer} buffer ByteBuffer to decode from\r\n         * @param {number=} length Message length. Defaults to decode all remaining data.\r\n         * @param {number=} expectedGroupEndId Expected GROUPEND id if this is a legacy group\r\n         * @return {ProtoBuf.Builder.Message} Decoded message\r\n         * @throws {Error} If the message cannot be decoded\r\n         * @expose\r\n         */\r\n        MessagePrototype.decode = function(buffer, length, expectedGroupEndId) {\r\n            if (typeof length !== 'number')\r\n                length = -1;\r\n            var start = buffer.offset,\r\n                msg = new (this.clazz)(),\r\n                tag, wireType, id, field;\r\n            while (buffer.offset < start+length || (length === -1 && buffer.remaining() > 0)) {\r\n                tag = buffer.readVarint32();\r\n                wireType = tag & 0x07;\r\n                id = tag >>> 3;\r\n                if (wireType === ProtoBuf.WIRE_TYPES.ENDGROUP) {\r\n                    if (id !== expectedGroupEndId)\r\n                        throw Error(\"Illegal group end indicator for \"+this.toString(true)+\": \"+id+\" (\"+(expectedGroupEndId ? expectedGroupEndId+\" expected\" : \"not a group\")+\")\");\r\n                    break;\r\n                }\r\n                if (!(field = this._fieldsById[id])) {\r\n                    // \"messages created by your new code can be parsed by your old code: old binaries simply ignore the new field when parsing.\"\r\n                    switch (wireType) {\r\n                        case ProtoBuf.WIRE_TYPES.VARINT:\r\n                            buffer.readVarint32();\r\n                            break;\r\n                        case ProtoBuf.WIRE_TYPES.BITS32:\r\n                            buffer.offset += 4;\r\n                            break;\r\n                        case ProtoBuf.WIRE_TYPES.BITS64:\r\n                            buffer.offset += 8;\r\n                            break;\r\n                        case ProtoBuf.WIRE_TYPES.LDELIM:\r\n                            var len = buffer.readVarint32();\r\n                            buffer.offset += len;\r\n                            break;\r\n                        case ProtoBuf.WIRE_TYPES.STARTGROUP:\r\n                            while (skipTillGroupEnd(id, buffer)) {}\r\n                            break;\r\n                        default:\r\n                            throw Error(\"Illegal wire type for unknown field \"+id+\" in \"+this.toString(true)+\"#decode: \"+wireType);\r\n                    }\r\n                    continue;\r\n                }\r\n                if (field.repeated && !field.options[\"packed\"]) {\r\n                    msg[field.name].push(field.decode(wireType, buffer));\r\n                } else if (field.map) {\r\n                    var keyval = field.decode(wireType, buffer);\r\n                    msg[field.name].set(keyval[0], keyval[1]);\r\n                } else {\r\n                    msg[field.name] = field.decode(wireType, buffer);\r\n                    if (field.oneof) { // Field is part of an OneOf (not a virtual OneOf field)\r\n                        var currentField = msg[field.oneof.name]; // Virtual field references currently set field\r\n                        if (currentField !== null && currentField !== field.name)\r\n                            msg[currentField] = null; // Clear currently set field\r\n                        msg[field.oneof.name] = field.name; // Point virtual field at this field\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Check if all required fields are present and set default values for optional fields that are not\r\n            for (var i=0, k=this._fields.length; i<k; ++i) {\r\n                field = this._fields[i];\r\n                if (msg[field.name] === null) {\r\n                    if (this.syntax === \"proto3\") { // Proto3 sets default values by specification\r\n                        msg[field.name] = field.defaultValue;\r\n                    } else if (field.required) {\r\n                        var err = Error(\"Missing at least one required field for \" + this.toString(true) + \": \" + field.name);\r\n                        err[\"decoded\"] = msg; // Still expose what we got\r\n                        throw(err);\r\n                    } else if (ProtoBuf.populateDefaults && field.defaultValue !== null)\r\n                        msg[field.name] = field.defaultValue;\r\n                }\r\n            }\r\n            return msg;\r\n        };\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Message\r\n         * @expose\r\n         */\r\n        Reflect.Message = Message;\r\n\r\n        /**\r\n         * Constructs a new Message Field.\r\n         * @exports ProtoBuf.Reflect.Message.Field\r\n         * @param {!ProtoBuf.Builder} builder Builder reference\r\n         * @param {!ProtoBuf.Reflect.Message} message Message reference\r\n         * @param {string} rule Rule, one of requried, optional, repeated\r\n         * @param {string?} keytype Key data type, if any.\r\n         * @param {string} type Data type, e.g. int32\r\n         * @param {string} name Field name\r\n         * @param {number} id Unique field id\r\n         * @param {Object.<string,*>=} options Options\r\n         * @param {!ProtoBuf.Reflect.Message.OneOf=} oneof Enclosing OneOf\r\n         * @param {string?} syntax The syntax level of this definition (e.g., proto3)\r\n         * @constructor\r\n         * @extends ProtoBuf.Reflect.T\r\n         */\r\n        var Field = function(builder, message, rule, keytype, type, name, id, options, oneof, syntax) {\r\n            T.call(this, builder, message, name);\r\n\r\n            /**\r\n             * @override\r\n             */\r\n            this.className = \"Message.Field\";\r\n\r\n            /**\r\n             * Message field required flag.\r\n             * @type {boolean}\r\n             * @expose\r\n             */\r\n            this.required = rule === \"required\";\r\n\r\n            /**\r\n             * Message field repeated flag.\r\n             * @type {boolean}\r\n             * @expose\r\n             */\r\n            this.repeated = rule === \"repeated\";\r\n\r\n            /**\r\n             * Message field map flag.\r\n             * @type {boolean}\r\n             * @expose\r\n             */\r\n            this.map = rule === \"map\";\r\n\r\n            /**\r\n             * Message field key type. Type reference string if unresolved, protobuf\r\n             * type if resolved. Valid only if this.map === true, null otherwise.\r\n             * @type {string|{name: string, wireType: number}|null}\r\n             * @expose\r\n             */\r\n            this.keyType = keytype || null;\r\n\r\n            /**\r\n             * Message field type. Type reference string if unresolved, protobuf type if\r\n             * resolved. In a map field, this is the value type.\r\n             * @type {string|{name: string, wireType: number}}\r\n             * @expose\r\n             */\r\n            this.type = type;\r\n\r\n            /**\r\n             * Resolved type reference inside the global namespace.\r\n             * @type {ProtoBuf.Reflect.T|null}\r\n             * @expose\r\n             */\r\n            this.resolvedType = null;\r\n\r\n            /**\r\n             * Unique message field id.\r\n             * @type {number}\r\n             * @expose\r\n             */\r\n            this.id = id;\r\n\r\n            /**\r\n             * Message field options.\r\n             * @type {!Object.<string,*>}\r\n             * @dict\r\n             * @expose\r\n             */\r\n            this.options = options || {};\r\n\r\n            /**\r\n             * Default value.\r\n             * @type {*}\r\n             * @expose\r\n             */\r\n            this.defaultValue = null;\r\n\r\n            /**\r\n             * Enclosing OneOf.\r\n             * @type {?ProtoBuf.Reflect.Message.OneOf}\r\n             * @expose\r\n             */\r\n            this.oneof = oneof || null;\r\n\r\n            /**\r\n             * Syntax level of this definition (e.g., proto3).\r\n             * @type {string}\r\n             * @expose\r\n             */\r\n            this.syntax = syntax || 'proto2';\r\n\r\n            /**\r\n             * Original field name.\r\n             * @type {string}\r\n             * @expose\r\n             */\r\n            this.originalName = this.name; // Used to revert camelcase transformation on naming collisions\r\n\r\n            /**\r\n             * Element implementation. Created in build() after types are resolved.\r\n             * @type {ProtoBuf.Element}\r\n             * @expose\r\n             */\r\n            this.element = null;\r\n\r\n            /**\r\n             * Key element implementation, for map fields. Created in build() after\r\n             * types are resolved.\r\n             * @type {ProtoBuf.Element}\r\n             * @expose\r\n             */\r\n            this.keyElement = null;\r\n\r\n            // Convert field names to camel case notation if the override is set\r\n            if (this.builder.options['convertFieldsToCamelCase'] && !(this instanceof Message.ExtensionField))\r\n                this.name = ProtoBuf.Util.toCamelCase(this.name);\r\n        };\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Message.Field.prototype\r\n         * @inner\r\n         */\r\n        var FieldPrototype = Field.prototype = Object.create(T.prototype);\r\n\r\n        /**\r\n         * Builds the field.\r\n         * @override\r\n         * @expose\r\n         */\r\n        FieldPrototype.build = function() {\r\n            this.element = new Element(this.type, this.resolvedType, false, this.syntax, this.name);\r\n            if (this.map)\r\n                this.keyElement = new Element(this.keyType, undefined, true, this.syntax, this.name);\r\n\r\n            // In proto3, fields do not have field presence, and every field is set to\r\n            // its type's default value (\"\", 0, 0.0, or false).\r\n            if (this.syntax === 'proto3' && !this.repeated && !this.map)\r\n                this.defaultValue = Element.defaultFieldValue(this.type);\r\n\r\n            // Otherwise, default values are present when explicitly specified\r\n            else if (typeof this.options['default'] !== 'undefined')\r\n                this.defaultValue = this.verifyValue(this.options['default']);\r\n        };\r\n\r\n        /**\r\n         * Checks if the given value can be set for this field.\r\n         * @param {*} value Value to check\r\n         * @param {boolean=} skipRepeated Whether to skip the repeated value check or not. Defaults to false.\r\n         * @return {*} Verified, maybe adjusted, value\r\n         * @throws {Error} If the value cannot be set for this field\r\n         * @expose\r\n         */\r\n        FieldPrototype.verifyValue = function(value, skipRepeated) {\r\n            skipRepeated = skipRepeated || false;\r\n            var self = this;\r\n            function fail(val, msg) {\r\n                throw Error(\"Illegal value for \"+self.toString(true)+\" of type \"+self.type.name+\": \"+val+\" (\"+msg+\")\");\r\n            }\r\n            if (value === null) { // NULL values for optional fields\r\n                if (this.required)\r\n                    fail(typeof value, \"required\");\r\n                if (this.syntax === 'proto3' && this.type !== ProtoBuf.TYPES[\"message\"])\r\n                    fail(typeof value, \"proto3 field without field presence cannot be null\");\r\n                return null;\r\n            }\r\n            var i;\r\n            if (this.repeated && !skipRepeated) { // Repeated values as arrays\r\n                if (!Array.isArray(value))\r\n                    value = [value];\r\n                var res = [];\r\n                for (i=0; i<value.length; i++)\r\n                    res.push(this.element.verifyValue(value[i]));\r\n                return res;\r\n            }\r\n            if (this.map && !skipRepeated) { // Map values as objects\r\n                if (!(value instanceof ProtoBuf.Map)) {\r\n                    // If not already a Map, attempt to convert.\r\n                    if (!(value instanceof Object)) {\r\n                        fail(typeof value,\r\n                             \"expected ProtoBuf.Map or raw object for map field\");\r\n                    }\r\n                    return new ProtoBuf.Map(this, value);\r\n                } else {\r\n                    return value;\r\n                }\r\n            }\r\n            // All non-repeated fields expect no array\r\n            if (!this.repeated && Array.isArray(value))\r\n                fail(typeof value, \"no array expected\");\r\n\r\n            return this.element.verifyValue(value);\r\n        };\r\n\r\n        /**\r\n         * Determines whether the field will have a presence on the wire given its\r\n         * value.\r\n         * @param {*} value Verified field value\r\n         * @param {!ProtoBuf.Builder.Message} message Runtime message\r\n         * @return {boolean} Whether the field will be present on the wire\r\n         */\r\n        FieldPrototype.hasWirePresence = function(value, message) {\r\n            if (this.syntax !== 'proto3')\r\n                return (value !== null);\r\n            if (this.oneof && message[this.oneof.name] === this.name)\r\n                return true;\r\n            switch (this.type) {\r\n                case ProtoBuf.TYPES[\"int32\"]:\r\n                case ProtoBuf.TYPES[\"sint32\"]:\r\n                case ProtoBuf.TYPES[\"sfixed32\"]:\r\n                case ProtoBuf.TYPES[\"uint32\"]:\r\n                case ProtoBuf.TYPES[\"fixed32\"]:\r\n                    return value !== 0;\r\n\r\n                case ProtoBuf.TYPES[\"int64\"]:\r\n                case ProtoBuf.TYPES[\"sint64\"]:\r\n                case ProtoBuf.TYPES[\"sfixed64\"]:\r\n                case ProtoBuf.TYPES[\"uint64\"]:\r\n                case ProtoBuf.TYPES[\"fixed64\"]:\r\n                    return value.low !== 0 || value.high !== 0;\r\n\r\n                case ProtoBuf.TYPES[\"bool\"]:\r\n                    return value;\r\n\r\n                case ProtoBuf.TYPES[\"float\"]:\r\n                case ProtoBuf.TYPES[\"double\"]:\r\n                    return value !== 0.0;\r\n\r\n                case ProtoBuf.TYPES[\"string\"]:\r\n                    return value.length > 0;\r\n\r\n                case ProtoBuf.TYPES[\"bytes\"]:\r\n                    return value.remaining() > 0;\r\n\r\n                case ProtoBuf.TYPES[\"enum\"]:\r\n                    return value !== 0;\r\n\r\n                case ProtoBuf.TYPES[\"message\"]:\r\n                    return value !== null;\r\n                default:\r\n                    return true;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Encodes the specified field value to the specified buffer.\r\n         * @param {*} value Verified field value\r\n         * @param {ByteBuffer} buffer ByteBuffer to encode to\r\n         * @param {!ProtoBuf.Builder.Message} message Runtime message\r\n         * @return {ByteBuffer} The ByteBuffer for chaining\r\n         * @throws {Error} If the field cannot be encoded\r\n         * @expose\r\n         */\r\n        FieldPrototype.encode = function(value, buffer, message) {\r\n            if (this.type === null || typeof this.type !== 'object')\r\n                throw Error(\"[INTERNAL] Unresolved type in \"+this.toString(true)+\": \"+this.type);\r\n            if (value === null || (this.repeated && value.length == 0))\r\n                return buffer; // Optional omitted\r\n            try {\r\n                if (this.repeated) {\r\n                    var i;\r\n                    // \"Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire\r\n                    // types) can be declared 'packed'.\"\r\n                    if (this.options[\"packed\"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {\r\n                        // \"All of the elements of the field are packed into a single key-value pair with wire type 2\r\n                        // (length-delimited). Each element is encoded the same way it would be normally, except without a\r\n                        // tag preceding it.\"\r\n                        buffer.writeVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);\r\n                        buffer.ensureCapacity(buffer.offset += 1); // We do not know the length yet, so let's assume a varint of length 1\r\n                        var start = buffer.offset; // Remember where the contents begin\r\n                        for (i=0; i<value.length; i++)\r\n                            this.element.encodeValue(this.id, value[i], buffer);\r\n                        var len = buffer.offset-start,\r\n                            varintLen = ByteBuffer.calculateVarint32(len);\r\n                        if (varintLen > 1) { // We need to move the contents\r\n                            var contents = buffer.slice(start, buffer.offset);\r\n                            start += varintLen-1;\r\n                            buffer.offset = start;\r\n                            buffer.append(contents);\r\n                        }\r\n                        buffer.writeVarint32(len, start-varintLen);\r\n                    } else {\r\n                        // \"If your message definition has repeated elements (without the [packed=true] option), the encoded\r\n                        // message has zero or more key-value pairs with the same tag number\"\r\n                        for (i=0; i<value.length; i++)\r\n                            buffer.writeVarint32((this.id << 3) | this.type.wireType), this.element.encodeValue(this.id, value[i], buffer);\r\n                    }\r\n                } else if (this.map) {\r\n                    // Write out each map entry as a submessage.\r\n                    value.forEach(function(val, key, m) {\r\n                        // Compute the length of the submessage (key, val) pair.\r\n                        var length =\r\n                            ByteBuffer.calculateVarint32((1 << 3) | this.keyType.wireType) +\r\n                            this.keyElement.calculateLength(1, key) +\r\n                            ByteBuffer.calculateVarint32((2 << 3) | this.type.wireType) +\r\n                            this.element.calculateLength(2, val);\r\n\r\n                        // Submessage with wire type of length-delimited.\r\n                        buffer.writeVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);\r\n                        buffer.writeVarint32(length);\r\n\r\n                        // Write out the key and val.\r\n                        buffer.writeVarint32((1 << 3) | this.keyType.wireType);\r\n                        this.keyElement.encodeValue(1, key, buffer);\r\n                        buffer.writeVarint32((2 << 3) | this.type.wireType);\r\n                        this.element.encodeValue(2, val, buffer);\r\n                    }, this);\r\n                } else {\r\n                    if (this.hasWirePresence(value, message)) {\r\n                        buffer.writeVarint32((this.id << 3) | this.type.wireType);\r\n                        this.element.encodeValue(this.id, value, buffer);\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                throw Error(\"Illegal value for \"+this.toString(true)+\": \"+value+\" (\"+e+\")\");\r\n            }\r\n            return buffer;\r\n        };\r\n\r\n        /**\r\n         * Calculates the length of this field's value on the network level.\r\n         * @param {*} value Field value\r\n         * @param {!ProtoBuf.Builder.Message} message Runtime message\r\n         * @returns {number} Byte length\r\n         * @expose\r\n         */\r\n        FieldPrototype.calculate = function(value, message) {\r\n            value = this.verifyValue(value); // May throw\r\n            if (this.type === null || typeof this.type !== 'object')\r\n                throw Error(\"[INTERNAL] Unresolved type in \"+this.toString(true)+\": \"+this.type);\r\n            if (value === null || (this.repeated && value.length == 0))\r\n                return 0; // Optional omitted\r\n            var n = 0;\r\n            try {\r\n                if (this.repeated) {\r\n                    var i, ni;\r\n                    if (this.options[\"packed\"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {\r\n                        n += ByteBuffer.calculateVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);\r\n                        ni = 0;\r\n                        for (i=0; i<value.length; i++)\r\n                            ni += this.element.calculateLength(this.id, value[i]);\r\n                        n += ByteBuffer.calculateVarint32(ni);\r\n                        n += ni;\r\n                    } else {\r\n                        for (i=0; i<value.length; i++)\r\n                            n += ByteBuffer.calculateVarint32((this.id << 3) | this.type.wireType), n += this.element.calculateLength(this.id, value[i]);\r\n                    }\r\n                } else if (this.map) {\r\n                    // Each map entry becomes a submessage.\r\n                    value.forEach(function(val, key, m) {\r\n                        // Compute the length of the submessage (key, val) pair.\r\n                        var length =\r\n                            ByteBuffer.calculateVarint32((1 << 3) | this.keyType.wireType) +\r\n                            this.keyElement.calculateLength(1, key) +\r\n                            ByteBuffer.calculateVarint32((2 << 3) | this.type.wireType) +\r\n                            this.element.calculateLength(2, val);\r\n\r\n                        n += ByteBuffer.calculateVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);\r\n                        n += ByteBuffer.calculateVarint32(length);\r\n                        n += length;\r\n                    }, this);\r\n                } else {\r\n                    if (this.hasWirePresence(value, message)) {\r\n                        n += ByteBuffer.calculateVarint32((this.id << 3) | this.type.wireType);\r\n                        n += this.element.calculateLength(this.id, value);\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                throw Error(\"Illegal value for \"+this.toString(true)+\": \"+value+\" (\"+e+\")\");\r\n            }\r\n            return n;\r\n        };\r\n\r\n        /**\r\n         * Decode the field value from the specified buffer.\r\n         * @param {number} wireType Leading wire type\r\n         * @param {ByteBuffer} buffer ByteBuffer to decode from\r\n         * @param {boolean=} skipRepeated Whether to skip the repeated check or not. Defaults to false.\r\n         * @return {*} Decoded value: array for packed repeated fields, [key, value] for\r\n         *             map fields, or an individual value otherwise.\r\n         * @throws {Error} If the field cannot be decoded\r\n         * @expose\r\n         */\r\n        FieldPrototype.decode = function(wireType, buffer, skipRepeated) {\r\n            var value, nBytes;\r\n\r\n            // We expect wireType to match the underlying type's wireType unless we see\r\n            // a packed repeated field, or unless this is a map field.\r\n            var wireTypeOK =\r\n                (!this.map && wireType == this.type.wireType) ||\r\n                (!skipRepeated && this.repeated && this.options[\"packed\"] &&\r\n                 wireType == ProtoBuf.WIRE_TYPES.LDELIM) ||\r\n                (this.map && wireType == ProtoBuf.WIRE_TYPES.LDELIM);\r\n            if (!wireTypeOK)\r\n                throw Error(\"Illegal wire type for field \"+this.toString(true)+\": \"+wireType+\" (\"+this.type.wireType+\" expected)\");\r\n\r\n            // Handle packed repeated fields.\r\n            if (wireType == ProtoBuf.WIRE_TYPES.LDELIM && this.repeated && this.options[\"packed\"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {\r\n                if (!skipRepeated) {\r\n                    nBytes = buffer.readVarint32();\r\n                    nBytes = buffer.offset + nBytes; // Limit\r\n                    var values = [];\r\n                    while (buffer.offset < nBytes)\r\n                        values.push(this.decode(this.type.wireType, buffer, true));\r\n                    return values;\r\n                }\r\n                // Read the next value otherwise...\r\n            }\r\n\r\n            // Handle maps.\r\n            if (this.map) {\r\n                // Read one (key, value) submessage, and return [key, value]\r\n                var key = Element.defaultFieldValue(this.keyType);\r\n                value = Element.defaultFieldValue(this.type);\r\n\r\n                // Read the length\r\n                nBytes = buffer.readVarint32();\r\n                if (buffer.remaining() < nBytes)\r\n                    throw Error(\"Illegal number of bytes for \"+this.toString(true)+\": \"+nBytes+\" required but got only \"+buffer.remaining());\r\n\r\n                // Get a sub-buffer of this key/value submessage\r\n                var msgbuf = buffer.clone();\r\n                msgbuf.limit = msgbuf.offset + nBytes;\r\n                buffer.offset += nBytes;\r\n\r\n                while (msgbuf.remaining() > 0) {\r\n                    var tag = msgbuf.readVarint32();\r\n                    wireType = tag & 0x07;\r\n                    var id = tag >>> 3;\r\n                    if (id === 1) {\r\n                        key = this.keyElement.decode(msgbuf, wireType, id);\r\n                    } else if (id === 2) {\r\n                        value = this.element.decode(msgbuf, wireType, id);\r\n                    } else {\r\n                        throw Error(\"Unexpected tag in map field key/value submessage\");\r\n                    }\r\n                }\r\n\r\n                return [key, value];\r\n            }\r\n\r\n            // Handle singular and non-packed repeated field values.\r\n            return this.element.decode(buffer, wireType, this.id);\r\n        };\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Message.Field\r\n         * @expose\r\n         */\r\n        Reflect.Message.Field = Field;\r\n\r\n        /**\r\n         * Constructs a new Message ExtensionField.\r\n         * @exports ProtoBuf.Reflect.Message.ExtensionField\r\n         * @param {!ProtoBuf.Builder} builder Builder reference\r\n         * @param {!ProtoBuf.Reflect.Message} message Message reference\r\n         * @param {string} rule Rule, one of requried, optional, repeated\r\n         * @param {string} type Data type, e.g. int32\r\n         * @param {string} name Field name\r\n         * @param {number} id Unique field id\r\n         * @param {!Object.<string,*>=} options Options\r\n         * @constructor\r\n         * @extends ProtoBuf.Reflect.Message.Field\r\n         */\r\n        var ExtensionField = function(builder, message, rule, type, name, id, options) {\r\n            Field.call(this, builder, message, rule, /* keytype = */ null, type, name, id, options);\r\n\r\n            /**\r\n             * Extension reference.\r\n             * @type {!ProtoBuf.Reflect.Extension}\r\n             * @expose\r\n             */\r\n            this.extension;\r\n        };\r\n\r\n        // Extends Field\r\n        ExtensionField.prototype = Object.create(Field.prototype);\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Message.ExtensionField\r\n         * @expose\r\n         */\r\n        Reflect.Message.ExtensionField = ExtensionField;\r\n\r\n        /**\r\n         * Constructs a new Message OneOf.\r\n         * @exports ProtoBuf.Reflect.Message.OneOf\r\n         * @param {!ProtoBuf.Builder} builder Builder reference\r\n         * @param {!ProtoBuf.Reflect.Message} message Message reference\r\n         * @param {string} name OneOf name\r\n         * @constructor\r\n         * @extends ProtoBuf.Reflect.T\r\n         */\r\n        var OneOf = function(builder, message, name) {\r\n            T.call(this, builder, message, name);\r\n\r\n            /**\r\n             * Enclosed fields.\r\n             * @type {!Array.<!ProtoBuf.Reflect.Message.Field>}\r\n             * @expose\r\n             */\r\n            this.fields = [];\r\n        };\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Message.OneOf\r\n         * @expose\r\n         */\r\n        Reflect.Message.OneOf = OneOf;\r\n\r\n        /**\r\n         * Constructs a new Enum.\r\n         * @exports ProtoBuf.Reflect.Enum\r\n         * @param {!ProtoBuf.Builder} builder Builder reference\r\n         * @param {!ProtoBuf.Reflect.T} parent Parent Reflect object\r\n         * @param {string} name Enum name\r\n         * @param {Object.<string,*>=} options Enum options\r\n         * @param {string?} syntax The syntax level (e.g., proto3)\r\n         * @constructor\r\n         * @extends ProtoBuf.Reflect.Namespace\r\n         */\r\n        var Enum = function(builder, parent, name, options, syntax) {\r\n            Namespace.call(this, builder, parent, name, options, syntax);\r\n\r\n            /**\r\n             * @override\r\n             */\r\n            this.className = \"Enum\";\r\n\r\n            /**\r\n             * Runtime enum object.\r\n             * @type {Object.<string,number>|null}\r\n             * @expose\r\n             */\r\n            this.object = null;\r\n        };\r\n\r\n        /**\r\n         * Gets the string name of an enum value.\r\n         * @param {!ProtoBuf.Builder.Enum} enm Runtime enum\r\n         * @param {number} value Enum value\r\n         * @returns {?string} Name or `null` if not present\r\n         * @expose\r\n         */\r\n        Enum.getName = function(enm, value) {\r\n            var keys = Object.keys(enm);\r\n            for (var i=0, key; i<keys.length; ++i)\r\n                if (enm[key = keys[i]] === value)\r\n                    return key;\r\n            return null;\r\n        };\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Enum.prototype\r\n         * @inner\r\n         */\r\n        var EnumPrototype = Enum.prototype = Object.create(Namespace.prototype);\r\n\r\n        /**\r\n         * Builds this enum and returns the runtime counterpart.\r\n         * @param {boolean} rebuild Whether to rebuild or not, defaults to false\r\n         * @returns {!Object.<string,number>}\r\n         * @expose\r\n         */\r\n        EnumPrototype.build = function(rebuild) {\r\n            if (this.object && !rebuild)\r\n                return this.object;\r\n            var enm = new ProtoBuf.Builder.Enum(),\r\n                values = this.getChildren(Enum.Value);\r\n            for (var i=0, k=values.length; i<k; ++i)\r\n                enm[values[i]['name']] = values[i]['id'];\r\n            if (Object.defineProperty)\r\n                Object.defineProperty(enm, '$options', {\r\n                    \"value\": this.buildOpt(),\r\n                    \"enumerable\": false\r\n                });\r\n            return this.object = enm;\r\n        };\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Enum\r\n         * @expose\r\n         */\r\n        Reflect.Enum = Enum;\r\n\r\n        /**\r\n         * Constructs a new Enum Value.\r\n         * @exports ProtoBuf.Reflect.Enum.Value\r\n         * @param {!ProtoBuf.Builder} builder Builder reference\r\n         * @param {!ProtoBuf.Reflect.Enum} enm Enum reference\r\n         * @param {string} name Field name\r\n         * @param {number} id Unique field id\r\n         * @constructor\r\n         * @extends ProtoBuf.Reflect.T\r\n         */\r\n        var Value = function(builder, enm, name, id) {\r\n            T.call(this, builder, enm, name);\r\n\r\n            /**\r\n             * @override\r\n             */\r\n            this.className = \"Enum.Value\";\r\n\r\n            /**\r\n             * Unique enum value id.\r\n             * @type {number}\r\n             * @expose\r\n             */\r\n            this.id = id;\r\n        };\r\n\r\n        // Extends T\r\n        Value.prototype = Object.create(T.prototype);\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Enum.Value\r\n         * @expose\r\n         */\r\n        Reflect.Enum.Value = Value;\r\n\r\n        /**\r\n         * An extension (field).\r\n         * @exports ProtoBuf.Reflect.Extension\r\n         * @constructor\r\n         * @param {!ProtoBuf.Builder} builder Builder reference\r\n         * @param {!ProtoBuf.Reflect.T} parent Parent object\r\n         * @param {string} name Object name\r\n         * @param {!ProtoBuf.Reflect.Message.Field} field Extension field\r\n         */\r\n        var Extension = function(builder, parent, name, field) {\r\n            T.call(this, builder, parent, name);\r\n\r\n            /**\r\n             * Extended message field.\r\n             * @type {!ProtoBuf.Reflect.Message.Field}\r\n             * @expose\r\n             */\r\n            this.field = field;\r\n        };\r\n\r\n        // Extends T\r\n        Extension.prototype = Object.create(T.prototype);\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Extension\r\n         * @expose\r\n         */\r\n        Reflect.Extension = Extension;\r\n\r\n        /**\r\n         * Constructs a new Service.\r\n         * @exports ProtoBuf.Reflect.Service\r\n         * @param {!ProtoBuf.Builder} builder Builder reference\r\n         * @param {!ProtoBuf.Reflect.Namespace} root Root\r\n         * @param {string} name Service name\r\n         * @param {Object.<string,*>=} options Options\r\n         * @constructor\r\n         * @extends ProtoBuf.Reflect.Namespace\r\n         */\r\n        var Service = function(builder, root, name, options) {\r\n            Namespace.call(this, builder, root, name, options);\r\n\r\n            /**\r\n             * @override\r\n             */\r\n            this.className = \"Service\";\r\n\r\n            /**\r\n             * Built runtime service class.\r\n             * @type {?function(new:ProtoBuf.Builder.Service)}\r\n             */\r\n            this.clazz = null;\r\n        };\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Service.prototype\r\n         * @inner\r\n         */\r\n        var ServicePrototype = Service.prototype = Object.create(Namespace.prototype);\r\n\r\n        /**\r\n         * Builds the service and returns the runtime counterpart, which is a fully functional class.\r\n         * @see ProtoBuf.Builder.Service\r\n         * @param {boolean=} rebuild Whether to rebuild or not\r\n         * @return {Function} Service class\r\n         * @throws {Error} If the message cannot be built\r\n         * @expose\r\n         */\r\n        ServicePrototype.build = function(rebuild) {\r\n            if (this.clazz && !rebuild)\r\n                return this.clazz;\r\n\r\n            // Create the runtime Service class in its own scope\r\n            return this.clazz = (function(ProtoBuf, T) {\r\n\r\n                /**\r\n                 * Constructs a new runtime Service.\r\n                 * @name ProtoBuf.Builder.Service\r\n                 * @param {function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))=} rpcImpl RPC implementation receiving the method name and the message\r\n                 * @class Barebone of all runtime services.\r\n                 * @constructor\r\n                 * @throws {Error} If the service cannot be created\r\n                 */\r\n                var Service = function(rpcImpl) {\r\n                    ProtoBuf.Builder.Service.call(this);\r\n\r\n                    /**\r\n                     * Service implementation.\r\n                     * @name ProtoBuf.Builder.Service#rpcImpl\r\n                     * @type {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))}\r\n                     * @expose\r\n                     */\r\n                    this.rpcImpl = rpcImpl || function(name, msg, callback) {\r\n                        // This is what a user has to implement: A function receiving the method name, the actual message to\r\n                        // send (type checked) and the callback that's either provided with the error as its first\r\n                        // argument or null and the actual response message.\r\n                        setTimeout(callback.bind(this, Error(\"Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services\")), 0); // Must be async!\r\n                    };\r\n                };\r\n\r\n                /**\r\n                 * @alias ProtoBuf.Builder.Service.prototype\r\n                 * @inner\r\n                 */\r\n                var ServicePrototype = Service.prototype = Object.create(ProtoBuf.Builder.Service.prototype);\r\n\r\n                /**\r\n                 * Asynchronously performs an RPC call using the given RPC implementation.\r\n                 * @name ProtoBuf.Builder.Service.[Method]\r\n                 * @function\r\n                 * @param {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))} rpcImpl RPC implementation\r\n                 * @param {ProtoBuf.Builder.Message} req Request\r\n                 * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving\r\n                 *  the error if any and the response either as a pre-parsed message or as its raw bytes\r\n                 * @abstract\r\n                 */\r\n\r\n                /**\r\n                 * Asynchronously performs an RPC call using the instance's RPC implementation.\r\n                 * @name ProtoBuf.Builder.Service#[Method]\r\n                 * @function\r\n                 * @param {ProtoBuf.Builder.Message} req Request\r\n                 * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving\r\n                 *  the error if any and the response either as a pre-parsed message or as its raw bytes\r\n                 * @abstract\r\n                 */\r\n\r\n                var rpc = T.getChildren(ProtoBuf.Reflect.Service.RPCMethod);\r\n                for (var i=0; i<rpc.length; i++) {\r\n                    (function(method) {\r\n\r\n                        // service#Method(message, callback)\r\n                        ServicePrototype[method.name] = function(req, callback) {\r\n                            try {\r\n                                try {\r\n                                    // If given as a buffer, decode the request. Will throw a TypeError if not a valid buffer.\r\n                                    req = method.resolvedRequestType.clazz.decode(ByteBuffer.wrap(req));\r\n                                } catch (err) {\r\n                                    if (!(err instanceof TypeError))\r\n                                        throw err;\r\n                                }\r\n                                if (req === null || typeof req !== 'object')\r\n                                    throw Error(\"Illegal arguments\");\r\n                                if (!(req instanceof method.resolvedRequestType.clazz))\r\n                                    req = new method.resolvedRequestType.clazz(req);\r\n                                this.rpcImpl(method.fqn(), req, function(err, res) { // Assumes that this is properly async\r\n                                    if (err) {\r\n                                        callback(err);\r\n                                        return;\r\n                                    }\r\n                                    // Coalesce to empty string when service response has empty content\r\n                                    if (res === null)\r\n                                        res = '';\r\n                                    try { res = method.resolvedResponseType.clazz.decode(res); } catch (notABuffer) {}\r\n                                    if (!res || !(res instanceof method.resolvedResponseType.clazz)) {\r\n                                        callback(Error(\"Illegal response type received in service method \"+ T.name+\"#\"+method.name));\r\n                                        return;\r\n                                    }\r\n                                    callback(null, res);\r\n                                });\r\n                            } catch (err) {\r\n                                setTimeout(callback.bind(this, err), 0);\r\n                            }\r\n                        };\r\n\r\n                        // Service.Method(rpcImpl, message, callback)\r\n                        Service[method.name] = function(rpcImpl, req, callback) {\r\n                            new Service(rpcImpl)[method.name](req, callback);\r\n                        };\r\n\r\n                        if (Object.defineProperty)\r\n                            Object.defineProperty(Service[method.name], \"$options\", { \"value\": method.buildOpt() }), Object.defineProperty(ServicePrototype[method.name], \"$options\", { \"value\": Service[method.name][\"$options\"] });\r\n                    })(rpc[i]);\r\n                }\r\n\r\n                if (Object.defineProperty)\r\n                    Object.defineProperty(Service, \"$options\", { \"value\": T.buildOpt() }), Object.defineProperty(ServicePrototype, \"$options\", { \"value\": Service[\"$options\"] }), Object.defineProperty(Service, \"$type\", { \"value\": T }), Object.defineProperty(ServicePrototype, \"$type\", { \"value\": T });\r\n\r\n                return Service;\r\n\r\n            })(ProtoBuf, this);\r\n        };\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Service\r\n         * @expose\r\n         */\r\n        Reflect.Service = Service;\r\n\r\n        /**\r\n         * Abstract service method.\r\n         * @exports ProtoBuf.Reflect.Service.Method\r\n         * @param {!ProtoBuf.Builder} builder Builder reference\r\n         * @param {!ProtoBuf.Reflect.Service} svc Service\r\n         * @param {string} name Method name\r\n         * @param {Object.<string,*>=} options Options\r\n         * @constructor\r\n         * @extends ProtoBuf.Reflect.T\r\n         */\r\n        var Method = function(builder, svc, name, options) {\r\n            T.call(this, builder, svc, name);\r\n\r\n            /**\r\n             * @override\r\n             */\r\n            this.className = \"Service.Method\";\r\n\r\n            /**\r\n             * Options.\r\n             * @type {Object.<string, *>}\r\n             * @expose\r\n             */\r\n            this.options = options || {};\r\n        };\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Service.Method.prototype\r\n         * @inner\r\n         */\r\n        var MethodPrototype = Method.prototype = Object.create(T.prototype);\r\n\r\n        /**\r\n         * Builds the method's '$options' property.\r\n         * @name ProtoBuf.Reflect.Service.Method#buildOpt\r\n         * @function\r\n         * @return {Object.<string,*>}\r\n         */\r\n        MethodPrototype.buildOpt = NamespacePrototype.buildOpt;\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Service.Method\r\n         * @expose\r\n         */\r\n        Reflect.Service.Method = Method;\r\n\r\n        /**\r\n         * RPC service method.\r\n         * @exports ProtoBuf.Reflect.Service.RPCMethod\r\n         * @param {!ProtoBuf.Builder} builder Builder reference\r\n         * @param {!ProtoBuf.Reflect.Service} svc Service\r\n         * @param {string} name Method name\r\n         * @param {string} request Request message name\r\n         * @param {string} response Response message name\r\n         * @param {boolean} request_stream Whether requests are streamed\r\n         * @param {boolean} response_stream Whether responses are streamed\r\n         * @param {Object.<string,*>=} options Options\r\n         * @constructor\r\n         * @extends ProtoBuf.Reflect.Service.Method\r\n         */\r\n        var RPCMethod = function(builder, svc, name, request, response, request_stream, response_stream, options) {\r\n            Method.call(this, builder, svc, name, options);\r\n\r\n            /**\r\n             * @override\r\n             */\r\n            this.className = \"Service.RPCMethod\";\r\n\r\n            /**\r\n             * Request message name.\r\n             * @type {string}\r\n             * @expose\r\n             */\r\n            this.requestName = request;\r\n\r\n            /**\r\n             * Response message name.\r\n             * @type {string}\r\n             * @expose\r\n             */\r\n            this.responseName = response;\r\n\r\n            /**\r\n             * Whether requests are streamed\r\n             * @type {bool}\r\n             * @expose\r\n             */\r\n            this.requestStream = request_stream;\r\n\r\n            /**\r\n             * Whether responses are streamed\r\n             * @type {bool}\r\n             * @expose\r\n             */\r\n            this.responseStream = response_stream;\r\n\r\n            /**\r\n             * Resolved request message type.\r\n             * @type {ProtoBuf.Reflect.Message}\r\n             * @expose\r\n             */\r\n            this.resolvedRequestType = null;\r\n\r\n            /**\r\n             * Resolved response message type.\r\n             * @type {ProtoBuf.Reflect.Message}\r\n             * @expose\r\n             */\r\n            this.resolvedResponseType = null;\r\n        };\r\n\r\n        // Extends Method\r\n        RPCMethod.prototype = Object.create(Method.prototype);\r\n\r\n        /**\r\n         * @alias ProtoBuf.Reflect.Service.RPCMethod\r\n         * @expose\r\n         */\r\n        Reflect.Service.RPCMethod = RPCMethod;\r\n\r\n        return Reflect;\r\n\r\n    })(ProtoBuf);\r\n\r\n    /**\r\n     * @alias ProtoBuf.Builder\r\n     * @expose\r\n     */\r\n    ProtoBuf.Builder = (function(ProtoBuf, Lang, Reflect) {\r\n\r\n        /**\r\n         * Constructs a new Builder.\r\n         * @exports ProtoBuf.Builder\r\n         * @class Provides the functionality to build protocol messages.\r\n         * @param {Object.<string,*>=} options Options\r\n         * @constructor\r\n         */\r\n        var Builder = function(options) {\r\n\r\n            /**\r\n             * Namespace.\r\n             * @type {ProtoBuf.Reflect.Namespace}\r\n             * @expose\r\n             */\r\n            this.ns = new Reflect.Namespace(this, null, \"\"); // Global namespace\r\n\r\n            /**\r\n             * Namespace pointer.\r\n             * @type {ProtoBuf.Reflect.T}\r\n             * @expose\r\n             */\r\n            this.ptr = this.ns;\r\n\r\n            /**\r\n             * Resolved flag.\r\n             * @type {boolean}\r\n             * @expose\r\n             */\r\n            this.resolved = false;\r\n\r\n            /**\r\n             * The current building result.\r\n             * @type {Object.<string,ProtoBuf.Builder.Message|Object>|null}\r\n             * @expose\r\n             */\r\n            this.result = null;\r\n\r\n            /**\r\n             * Imported files.\r\n             * @type {Array.<string>}\r\n             * @expose\r\n             */\r\n            this.files = {};\r\n\r\n            /**\r\n             * Import root override.\r\n             * @type {?string}\r\n             * @expose\r\n             */\r\n            this.importRoot = null;\r\n\r\n            /**\r\n             * Options.\r\n             * @type {!Object.<string, *>}\r\n             * @expose\r\n             */\r\n            this.options = options || {};\r\n        };\r\n\r\n        /**\r\n         * @alias ProtoBuf.Builder.prototype\r\n         * @inner\r\n         */\r\n        var BuilderPrototype = Builder.prototype;\r\n\r\n        // ----- Definition tests -----\r\n\r\n        /**\r\n         * Tests if a definition most likely describes a message.\r\n         * @param {!Object} def\r\n         * @returns {boolean}\r\n         * @expose\r\n         */\r\n        Builder.isMessage = function(def) {\r\n            // Messages require a string name\r\n            if (typeof def[\"name\"] !== 'string')\r\n                return false;\r\n            // Messages do not contain values (enum) or rpc methods (service)\r\n            if (typeof def[\"values\"] !== 'undefined' || typeof def[\"rpc\"] !== 'undefined')\r\n                return false;\r\n            return true;\r\n        };\r\n\r\n        /**\r\n         * Tests if a definition most likely describes a message field.\r\n         * @param {!Object} def\r\n         * @returns {boolean}\r\n         * @expose\r\n         */\r\n        Builder.isMessageField = function(def) {\r\n            // Message fields require a string rule, name and type and an id\r\n            if (typeof def[\"rule\"] !== 'string' || typeof def[\"name\"] !== 'string' || typeof def[\"type\"] !== 'string' || typeof def[\"id\"] === 'undefined')\r\n                return false;\r\n            return true;\r\n        };\r\n\r\n        /**\r\n         * Tests if a definition most likely describes an enum.\r\n         * @param {!Object} def\r\n         * @returns {boolean}\r\n         * @expose\r\n         */\r\n        Builder.isEnum = function(def) {\r\n            // Enums require a string name\r\n            if (typeof def[\"name\"] !== 'string')\r\n                return false;\r\n            // Enums require at least one value\r\n            if (typeof def[\"values\"] === 'undefined' || !Array.isArray(def[\"values\"]) || def[\"values\"].length === 0)\r\n                return false;\r\n            return true;\r\n        };\r\n\r\n        /**\r\n         * Tests if a definition most likely describes a service.\r\n         * @param {!Object} def\r\n         * @returns {boolean}\r\n         * @expose\r\n         */\r\n        Builder.isService = function(def) {\r\n            // Services require a string name and an rpc object\r\n            if (typeof def[\"name\"] !== 'string' || typeof def[\"rpc\"] !== 'object' || !def[\"rpc\"])\r\n                return false;\r\n            return true;\r\n        };\r\n\r\n        /**\r\n         * Tests if a definition most likely describes an extended message\r\n         * @param {!Object} def\r\n         * @returns {boolean}\r\n         * @expose\r\n         */\r\n        Builder.isExtend = function(def) {\r\n            // Extends rquire a string ref\r\n            if (typeof def[\"ref\"] !== 'string')\r\n                return false;\r\n            return true;\r\n        };\r\n\r\n        // ----- Building -----\r\n\r\n        /**\r\n         * Resets the pointer to the root namespace.\r\n         * @returns {!ProtoBuf.Builder} this\r\n         * @expose\r\n         */\r\n        BuilderPrototype.reset = function() {\r\n            this.ptr = this.ns;\r\n            return this;\r\n        };\r\n\r\n        /**\r\n         * Defines a namespace on top of the current pointer position and places the pointer on it.\r\n         * @param {string} namespace\r\n         * @return {!ProtoBuf.Builder} this\r\n         * @expose\r\n         */\r\n        BuilderPrototype.define = function(namespace) {\r\n            if (typeof namespace !== 'string' || !Lang.TYPEREF.test(namespace))\r\n                throw Error(\"illegal namespace: \"+namespace);\r\n            namespace.split(\".\").forEach(function(part) {\r\n                var ns = this.ptr.getChild(part);\r\n                if (ns === null) // Keep existing\r\n                    this.ptr.addChild(ns = new Reflect.Namespace(this, this.ptr, part));\r\n                this.ptr = ns;\r\n            }, this);\r\n            return this;\r\n        };\r\n\r\n        /**\r\n         * Creates the specified definitions at the current pointer position.\r\n         * @param {!Array.<!Object>} defs Messages, enums or services to create\r\n         * @returns {!ProtoBuf.Builder} this\r\n         * @throws {Error} If a message definition is invalid\r\n         * @expose\r\n         */\r\n        BuilderPrototype.create = function(defs) {\r\n            if (!defs)\r\n                return this; // Nothing to create\r\n            if (!Array.isArray(defs))\r\n                defs = [defs];\r\n            else {\r\n                if (defs.length === 0)\r\n                    return this;\r\n                defs = defs.slice();\r\n            }\r\n\r\n            // It's quite hard to keep track of scopes and memory here, so let's do this iteratively.\r\n            var stack = [defs];\r\n            while (stack.length > 0) {\r\n                defs = stack.pop();\r\n\r\n                if (!Array.isArray(defs)) // Stack always contains entire namespaces\r\n                    throw Error(\"not a valid namespace: \"+JSON.stringify(defs));\r\n\r\n                while (defs.length > 0) {\r\n                    var def = defs.shift(); // Namespaces always contain an array of messages, enums and services\r\n\r\n                    if (Builder.isMessage(def)) {\r\n                        var obj = new Reflect.Message(this, this.ptr, def[\"name\"], def[\"options\"], def[\"isGroup\"], def[\"syntax\"]);\r\n\r\n                        // Create OneOfs\r\n                        var oneofs = {};\r\n                        if (def[\"oneofs\"])\r\n                            Object.keys(def[\"oneofs\"]).forEach(function(name) {\r\n                                obj.addChild(oneofs[name] = new Reflect.Message.OneOf(this, obj, name));\r\n                            }, this);\r\n\r\n                        // Create fields\r\n                        if (def[\"fields\"])\r\n                            def[\"fields\"].forEach(function(fld) {\r\n                                if (obj.getChild(fld[\"id\"]|0) !== null)\r\n                                    throw Error(\"duplicate or invalid field id in \"+obj.name+\": \"+fld['id']);\r\n                                if (fld[\"options\"] && typeof fld[\"options\"] !== 'object')\r\n                                    throw Error(\"illegal field options in \"+obj.name+\"#\"+fld[\"name\"]);\r\n                                var oneof = null;\r\n                                if (typeof fld[\"oneof\"] === 'string' && !(oneof = oneofs[fld[\"oneof\"]]))\r\n                                    throw Error(\"illegal oneof in \"+obj.name+\"#\"+fld[\"name\"]+\": \"+fld[\"oneof\"]);\r\n                                fld = new Reflect.Message.Field(this, obj, fld[\"rule\"], fld[\"keytype\"], fld[\"type\"], fld[\"name\"], fld[\"id\"], fld[\"options\"], oneof, def[\"syntax\"]);\r\n                                if (oneof)\r\n                                    oneof.fields.push(fld);\r\n                                obj.addChild(fld);\r\n                            }, this);\r\n\r\n                        // Push children to stack\r\n                        var subObj = [];\r\n                        if (def[\"enums\"])\r\n                            def[\"enums\"].forEach(function(enm) {\r\n                                subObj.push(enm);\r\n                            });\r\n                        if (def[\"messages\"])\r\n                            def[\"messages\"].forEach(function(msg) {\r\n                                subObj.push(msg);\r\n                            });\r\n                        if (def[\"services\"])\r\n                            def[\"services\"].forEach(function(svc) {\r\n                                subObj.push(svc);\r\n                            });\r\n\r\n                        // Set extension ranges\r\n                        if (def[\"extensions\"]) {\r\n                            if (typeof def[\"extensions\"][0] === 'number') // pre 5.0.1\r\n                                obj.extensions = [ def[\"extensions\"] ];\r\n                            else\r\n                                obj.extensions = def[\"extensions\"];\r\n                        }\r\n\r\n                        // Create on top of current namespace\r\n                        this.ptr.addChild(obj);\r\n                        if (subObj.length > 0) {\r\n                            stack.push(defs); // Push the current level back\r\n                            defs = subObj; // Continue processing sub level\r\n                            subObj = null;\r\n                            this.ptr = obj; // And move the pointer to this namespace\r\n                            obj = null;\r\n                            continue;\r\n                        }\r\n                        subObj = null;\r\n\r\n                    } else if (Builder.isEnum(def)) {\r\n\r\n                        obj = new Reflect.Enum(this, this.ptr, def[\"name\"], def[\"options\"], def[\"syntax\"]);\r\n                        def[\"values\"].forEach(function(val) {\r\n                            obj.addChild(new Reflect.Enum.Value(this, obj, val[\"name\"], val[\"id\"]));\r\n                        }, this);\r\n                        this.ptr.addChild(obj);\r\n\r\n                    } else if (Builder.isService(def)) {\r\n\r\n                        obj = new Reflect.Service(this, this.ptr, def[\"name\"], def[\"options\"]);\r\n                        Object.keys(def[\"rpc\"]).forEach(function(name) {\r\n                            var mtd = def[\"rpc\"][name];\r\n                            obj.addChild(new Reflect.Service.RPCMethod(this, obj, name, mtd[\"request\"], mtd[\"response\"], !!mtd[\"request_stream\"], !!mtd[\"response_stream\"], mtd[\"options\"]));\r\n                        }, this);\r\n                        this.ptr.addChild(obj);\r\n\r\n                    } else if (Builder.isExtend(def)) {\r\n\r\n                        obj = this.ptr.resolve(def[\"ref\"], true);\r\n                        if (obj) {\r\n                            def[\"fields\"].forEach(function(fld) {\r\n                                if (obj.getChild(fld['id']|0) !== null)\r\n                                    throw Error(\"duplicate extended field id in \"+obj.name+\": \"+fld['id']);\r\n                                // Check if field id is allowed to be extended\r\n                                if (obj.extensions) {\r\n                                    var valid = false;\r\n                                    obj.extensions.forEach(function(range) {\r\n                                        if (fld[\"id\"] >= range[0] && fld[\"id\"] <= range[1])\r\n                                            valid = true;\r\n                                    });\r\n                                    if (!valid)\r\n                                        throw Error(\"illegal extended field id in \"+obj.name+\": \"+fld['id']+\" (not within valid ranges)\");\r\n                                }\r\n                                // Convert extension field names to camel case notation if the override is set\r\n                                var name = fld[\"name\"];\r\n                                if (this.options['convertFieldsToCamelCase'])\r\n                                    name = ProtoBuf.Util.toCamelCase(name);\r\n                                // see #161: Extensions use their fully qualified name as their runtime key and...\r\n                                var field = new Reflect.Message.ExtensionField(this, obj, fld[\"rule\"], fld[\"type\"], this.ptr.fqn()+'.'+name, fld[\"id\"], fld[\"options\"]);\r\n                                // ...are added on top of the current namespace as an extension which is used for\r\n                                // resolving their type later on (the extension always keeps the original name to\r\n                                // prevent naming collisions)\r\n                                var ext = new Reflect.Extension(this, this.ptr, fld[\"name\"], field);\r\n                                field.extension = ext;\r\n                                this.ptr.addChild(ext);\r\n                                obj.addChild(field);\r\n                            }, this);\r\n\r\n                        } else if (!/\\.?google\\.protobuf\\./.test(def[\"ref\"])) // Silently skip internal extensions\r\n                            throw Error(\"extended message \"+def[\"ref\"]+\" is not defined\");\r\n\r\n                    } else\r\n                        throw Error(\"not a valid definition: \"+JSON.stringify(def));\r\n\r\n                    def = null;\r\n                    obj = null;\r\n                }\r\n                // Break goes here\r\n                defs = null;\r\n                this.ptr = this.ptr.parent; // Namespace done, continue at parent\r\n            }\r\n            this.resolved = false; // Require re-resolve\r\n            this.result = null; // Require re-build\r\n            return this;\r\n        };\r\n\r\n        /**\r\n         * Propagates syntax to all children.\r\n         * @param {!Object} parent\r\n         * @inner\r\n         */\r\n        function propagateSyntax(parent) {\r\n            if (parent['messages']) {\r\n                parent['messages'].forEach(function(child) {\r\n                    child[\"syntax\"] = parent[\"syntax\"];\r\n                    propagateSyntax(child);\r\n                });\r\n            }\r\n            if (parent['enums']) {\r\n                parent['enums'].forEach(function(child) {\r\n                    child[\"syntax\"] = parent[\"syntax\"];\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Imports another definition into this builder.\r\n         * @param {Object.<string,*>} json Parsed import\r\n         * @param {(string|{root: string, file: string})=} filename Imported file name\r\n         * @returns {!ProtoBuf.Builder} this\r\n         * @throws {Error} If the definition or file cannot be imported\r\n         * @expose\r\n         */\r\n        BuilderPrototype[\"import\"] = function(json, filename) {\r\n            var delim = '/';\r\n\r\n            // Make sure to skip duplicate imports\r\n\r\n            if (typeof filename === 'string') {\r\n\r\n                if (ProtoBuf.Util.IS_NODE)\r\n                    filename = require$$2['resolve'](filename);\r\n                if (this.files[filename] === true)\r\n                    return this.reset();\r\n                this.files[filename] = true;\r\n\r\n            } else if (typeof filename === 'object') { // Object with root, file.\r\n\r\n                var root = filename.root;\r\n                if (ProtoBuf.Util.IS_NODE)\r\n                    root = require$$2['resolve'](root);\r\n                if (root.indexOf(\"\\\\\") >= 0 || filename.file.indexOf(\"\\\\\") >= 0)\r\n                    delim = '\\\\';\r\n                var fname;\r\n                if (ProtoBuf.Util.IS_NODE)\r\n                    fname = require$$2['join'](root, filename.file);\r\n                else\r\n                    fname = root + delim + filename.file;\r\n                if (this.files[fname] === true)\r\n                    return this.reset();\r\n                this.files[fname] = true;\r\n            }\r\n\r\n            // Import imports\r\n\r\n            if (json['imports'] && json['imports'].length > 0) {\r\n                var importRoot,\r\n                    resetRoot = false;\r\n\r\n                if (typeof filename === 'object') { // If an import root is specified, override\r\n\r\n                    this.importRoot = filename[\"root\"]; resetRoot = true; // ... and reset afterwards\r\n                    importRoot = this.importRoot;\r\n                    filename = filename[\"file\"];\r\n                    if (importRoot.indexOf(\"\\\\\") >= 0 || filename.indexOf(\"\\\\\") >= 0)\r\n                        delim = '\\\\';\r\n\r\n                } else if (typeof filename === 'string') {\r\n\r\n                    if (this.importRoot) // If import root is overridden, use it\r\n                        importRoot = this.importRoot;\r\n                    else { // Otherwise compute from filename\r\n                        if (filename.indexOf(\"/\") >= 0) { // Unix\r\n                            importRoot = filename.replace(/\\/[^\\/]*$/, \"\");\r\n                            if (/* /file.proto */ importRoot === \"\")\r\n                                importRoot = \"/\";\r\n                        } else if (filename.indexOf(\"\\\\\") >= 0) { // Windows\r\n                            importRoot = filename.replace(/\\\\[^\\\\]*$/, \"\");\r\n                            delim = '\\\\';\r\n                        } else\r\n                            importRoot = \".\";\r\n                    }\r\n\r\n                } else\r\n                    importRoot = null;\r\n\r\n                for (var i=0; i<json['imports'].length; i++) {\r\n                    if (typeof json['imports'][i] === 'string') { // Import file\r\n                        if (!importRoot)\r\n                            throw Error(\"cannot determine import root\");\r\n                        var importFilename = json['imports'][i];\r\n                        if (importFilename === \"google/protobuf/descriptor.proto\")\r\n                            continue; // Not needed and therefore not used\r\n                        if (ProtoBuf.Util.IS_NODE)\r\n                            importFilename = require$$2['join'](importRoot, importFilename);\r\n                        else\r\n                            importFilename = importRoot + delim + importFilename;\r\n                        if (this.files[importFilename] === true)\r\n                            continue; // Already imported\r\n                        if (/\\.proto$/i.test(importFilename) && !ProtoBuf.DotProto)       // If this is a light build\r\n                            importFilename = importFilename.replace(/\\.proto$/, \".json\"); // always load the JSON file\r\n                        var contents = ProtoBuf.Util.fetch(importFilename);\r\n                        if (contents === null)\r\n                            throw Error(\"failed to import '\"+importFilename+\"' in '\"+filename+\"': file not found\");\r\n                        if (/\\.json$/i.test(importFilename)) // Always possible\r\n                            this[\"import\"](JSON.parse(contents+\"\"), importFilename); // May throw\r\n                        else\r\n                            this[\"import\"](ProtoBuf.DotProto.Parser.parse(contents), importFilename); // May throw\r\n                    } else // Import structure\r\n                        if (!filename)\r\n                            this[\"import\"](json['imports'][i]);\r\n                        else if (/\\.(\\w+)$/.test(filename)) // With extension: Append _importN to the name portion to make it unique\r\n                            this[\"import\"](json['imports'][i], filename.replace(/^(.+)\\.(\\w+)$/, function($0, $1, $2) { return $1+\"_import\"+i+\".\"+$2; }));\r\n                        else // Without extension: Append _importN to make it unique\r\n                            this[\"import\"](json['imports'][i], filename+\"_import\"+i);\r\n                }\r\n                if (resetRoot) // Reset import root override when all imports are done\r\n                    this.importRoot = null;\r\n            }\r\n\r\n            // Import structures\r\n\r\n            if (json['package'])\r\n                this.define(json['package']);\r\n            if (json['syntax'])\r\n                propagateSyntax(json);\r\n            var base = this.ptr;\r\n            if (json['options'])\r\n                Object.keys(json['options']).forEach(function(key) {\r\n                    base.options[key] = json['options'][key];\r\n                });\r\n            if (json['messages'])\r\n                this.create(json['messages']), this.ptr = base;\r\n            if (json['enums'])\r\n                this.create(json['enums']), this.ptr = base;\r\n            if (json['services'])\r\n                this.create(json['services']), this.ptr = base;\r\n            if (json['extends'])\r\n                this.create(json['extends']);\r\n\r\n            return this.reset();\r\n        };\r\n\r\n        /**\r\n         * Resolves all namespace objects.\r\n         * @throws {Error} If a type cannot be resolved\r\n         * @returns {!ProtoBuf.Builder} this\r\n         * @expose\r\n         */\r\n        BuilderPrototype.resolveAll = function() {\r\n            // Resolve all reflected objects\r\n            var res;\r\n            if (this.ptr == null || typeof this.ptr.type === 'object')\r\n                return this; // Done (already resolved)\r\n\r\n            if (this.ptr instanceof Reflect.Namespace) { // Resolve children\r\n\r\n                this.ptr.children.forEach(function(child) {\r\n                    this.ptr = child;\r\n                    this.resolveAll();\r\n                }, this);\r\n\r\n            } else if (this.ptr instanceof Reflect.Message.Field) { // Resolve type\r\n\r\n                if (!Lang.TYPE.test(this.ptr.type)) {\r\n                    if (!Lang.TYPEREF.test(this.ptr.type))\r\n                        throw Error(\"illegal type reference in \"+this.ptr.toString(true)+\": \"+this.ptr.type);\r\n                    res = (this.ptr instanceof Reflect.Message.ExtensionField ? this.ptr.extension.parent : this.ptr.parent).resolve(this.ptr.type, true);\r\n                    if (!res)\r\n                        throw Error(\"unresolvable type reference in \"+this.ptr.toString(true)+\": \"+this.ptr.type);\r\n                    this.ptr.resolvedType = res;\r\n                    if (res instanceof Reflect.Enum) {\r\n                        this.ptr.type = ProtoBuf.TYPES[\"enum\"];\r\n                        if (this.ptr.syntax === 'proto3' && res.syntax !== 'proto3')\r\n                            throw Error(\"proto3 message cannot reference proto2 enum\");\r\n                    }\r\n                    else if (res instanceof Reflect.Message)\r\n                        this.ptr.type = res.isGroup ? ProtoBuf.TYPES[\"group\"] : ProtoBuf.TYPES[\"message\"];\r\n                    else\r\n                        throw Error(\"illegal type reference in \"+this.ptr.toString(true)+\": \"+this.ptr.type);\r\n                } else\r\n                    this.ptr.type = ProtoBuf.TYPES[this.ptr.type];\r\n\r\n                // If it's a map field, also resolve the key type. The key type can be only a numeric, string, or bool type\r\n                // (i.e., no enums or messages), so we don't need to resolve against the current namespace.\r\n                if (this.ptr.map) {\r\n                    if (!Lang.TYPE.test(this.ptr.keyType))\r\n                        throw Error(\"illegal key type for map field in \"+this.ptr.toString(true)+\": \"+this.ptr.keyType);\r\n                    this.ptr.keyType = ProtoBuf.TYPES[this.ptr.keyType];\r\n                }\r\n\r\n                // If it's a repeated and packable field then proto3 mandates it should be packed by\r\n                // default\r\n                if (\r\n                  this.ptr.syntax === 'proto3' &&\r\n                  this.ptr.repeated && this.ptr.options.packed === undefined &&\r\n                  ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.ptr.type.wireType) !== -1\r\n                ) {\r\n                  this.ptr.options.packed = true;\r\n                }\r\n\r\n            } else if (this.ptr instanceof ProtoBuf.Reflect.Service.Method) {\r\n\r\n                if (this.ptr instanceof ProtoBuf.Reflect.Service.RPCMethod) {\r\n                    res = this.ptr.parent.resolve(this.ptr.requestName, true);\r\n                    if (!res || !(res instanceof ProtoBuf.Reflect.Message))\r\n                        throw Error(\"Illegal type reference in \"+this.ptr.toString(true)+\": \"+this.ptr.requestName);\r\n                    this.ptr.resolvedRequestType = res;\r\n                    res = this.ptr.parent.resolve(this.ptr.responseName, true);\r\n                    if (!res || !(res instanceof ProtoBuf.Reflect.Message))\r\n                        throw Error(\"Illegal type reference in \"+this.ptr.toString(true)+\": \"+this.ptr.responseName);\r\n                    this.ptr.resolvedResponseType = res;\r\n                } else // Should not happen as nothing else is implemented\r\n                    throw Error(\"illegal service type in \"+this.ptr.toString(true));\r\n\r\n            } else if (\r\n                !(this.ptr instanceof ProtoBuf.Reflect.Message.OneOf) && // Not built\r\n                !(this.ptr instanceof ProtoBuf.Reflect.Extension) && // Not built\r\n                !(this.ptr instanceof ProtoBuf.Reflect.Enum.Value) // Built in enum\r\n            )\r\n                throw Error(\"illegal object in namespace: \"+typeof(this.ptr)+\": \"+this.ptr);\r\n\r\n            return this.reset();\r\n        };\r\n\r\n        /**\r\n         * Builds the protocol. This will first try to resolve all definitions and, if this has been successful,\r\n         * return the built package.\r\n         * @param {(string|Array.<string>)=} path Specifies what to return. If omitted, the entire namespace will be returned.\r\n         * @returns {!ProtoBuf.Builder.Message|!Object.<string,*>}\r\n         * @throws {Error} If a type could not be resolved\r\n         * @expose\r\n         */\r\n        BuilderPrototype.build = function(path) {\r\n            this.reset();\r\n            if (!this.resolved)\r\n                this.resolveAll(), this.resolved = true, this.result = null; // Require re-build\r\n            if (this.result === null) // (Re-)Build\r\n                this.result = this.ns.build();\r\n            if (!path)\r\n                return this.result;\r\n            var part = typeof path === 'string' ? path.split(\".\") : path,\r\n                ptr = this.result; // Build namespace pointer (no hasChild etc.)\r\n            for (var i=0; i<part.length; i++)\r\n                if (ptr[part[i]])\r\n                    ptr = ptr[part[i]];\r\n                else {\r\n                    ptr = null;\r\n                    break;\r\n                }\r\n            return ptr;\r\n        };\r\n\r\n        /**\r\n         * Similar to {@link ProtoBuf.Builder#build}, but looks up the internal reflection descriptor.\r\n         * @param {string=} path Specifies what to return. If omitted, the entire namespace wiil be returned.\r\n         * @param {boolean=} excludeNonNamespace Excludes non-namespace types like fields, defaults to `false`\r\n         * @returns {?ProtoBuf.Reflect.T} Reflection descriptor or `null` if not found\r\n         */\r\n        BuilderPrototype.lookup = function(path, excludeNonNamespace) {\r\n            return path ? this.ns.resolve(path, excludeNonNamespace) : this.ns;\r\n        };\r\n\r\n        /**\r\n         * Returns a string representation of this object.\r\n         * @return {string} String representation as of \"Builder\"\r\n         * @expose\r\n         */\r\n        BuilderPrototype.toString = function() {\r\n            return \"Builder\";\r\n        };\r\n\r\n        // ----- Base classes -----\r\n        // Exist for the sole purpose of being able to \"... instanceof ProtoBuf.Builder.Message\" etc.\r\n\r\n        /**\r\n         * @alias ProtoBuf.Builder.Message\r\n         */\r\n        Builder.Message = function() {};\r\n\r\n        /**\r\n         * @alias ProtoBuf.Builder.Enum\r\n         */\r\n        Builder.Enum = function() {};\r\n\r\n        /**\r\n         * @alias ProtoBuf.Builder.Message\r\n         */\r\n        Builder.Service = function() {};\r\n\r\n        return Builder;\r\n\r\n    })(ProtoBuf, ProtoBuf.Lang, ProtoBuf.Reflect);\r\n\r\n    /**\r\n     * @alias ProtoBuf.Map\r\n     * @expose\r\n     */\r\n    ProtoBuf.Map = (function(ProtoBuf, Reflect) {\r\n\r\n        /**\r\n         * Constructs a new Map. A Map is a container that is used to implement map\r\n         * fields on message objects. It closely follows the ES6 Map API; however,\r\n         * it is distinct because we do not want to depend on external polyfills or\r\n         * on ES6 itself.\r\n         *\r\n         * @exports ProtoBuf.Map\r\n         * @param {!ProtoBuf.Reflect.Field} field Map field\r\n         * @param {Object.<string,*>=} contents Initial contents\r\n         * @constructor\r\n         */\r\n        var Map = function(field, contents) {\r\n            if (!field.map)\r\n                throw Error(\"field is not a map\");\r\n\r\n            /**\r\n             * The field corresponding to this map.\r\n             * @type {!ProtoBuf.Reflect.Field}\r\n             */\r\n            this.field = field;\r\n\r\n            /**\r\n             * Element instance corresponding to key type.\r\n             * @type {!ProtoBuf.Reflect.Element}\r\n             */\r\n            this.keyElem = new Reflect.Element(field.keyType, null, true, field.syntax);\r\n\r\n            /**\r\n             * Element instance corresponding to value type.\r\n             * @type {!ProtoBuf.Reflect.Element}\r\n             */\r\n            this.valueElem = new Reflect.Element(field.type, field.resolvedType, false, field.syntax);\r\n\r\n            /**\r\n             * Internal map: stores mapping of (string form of key) -> (key, value)\r\n             * pair.\r\n             *\r\n             * We provide map semantics for arbitrary key types, but we build on top\r\n             * of an Object, which has only string keys. In order to avoid the need\r\n             * to convert a string key back to its native type in many situations,\r\n             * we store the native key value alongside the value. Thus, we only need\r\n             * a one-way mapping from a key type to its string form that guarantees\r\n             * uniqueness and equality (i.e., str(K1) === str(K2) if and only if K1\r\n             * === K2).\r\n             *\r\n             * @type {!Object<string, {key: *, value: *}>}\r\n             */\r\n            this.map = {};\r\n\r\n            /**\r\n             * Returns the number of elements in the map.\r\n             */\r\n            Object.defineProperty(this, \"size\", {\r\n                get: function() { return Object.keys(this.map).length; }\r\n            });\r\n\r\n            // Fill initial contents from a raw object.\r\n            if (contents) {\r\n                var keys = Object.keys(contents);\r\n                for (var i = 0; i < keys.length; i++) {\r\n                    var key = this.keyElem.valueFromString(keys[i]);\r\n                    var val = this.valueElem.verifyValue(contents[keys[i]]);\r\n                    this.map[this.keyElem.valueToString(key)] =\r\n                        { key: key, value: val };\r\n                }\r\n            }\r\n        };\r\n\r\n        var MapPrototype = Map.prototype;\r\n\r\n        /**\r\n         * Helper: return an iterator over an array.\r\n         * @param {!Array<*>} arr the array\r\n         * @returns {!Object} an iterator\r\n         * @inner\r\n         */\r\n        function arrayIterator(arr) {\r\n            var idx = 0;\r\n            return {\r\n                next: function() {\r\n                    if (idx < arr.length)\r\n                        return { done: false, value: arr[idx++] };\r\n                    return { done: true };\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Clears the map.\r\n         */\r\n        MapPrototype.clear = function() {\r\n            this.map = {};\r\n        };\r\n\r\n        /**\r\n         * Deletes a particular key from the map.\r\n         * @returns {boolean} Whether any entry with this key was deleted.\r\n         */\r\n        MapPrototype[\"delete\"] = function(key) {\r\n            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));\r\n            var hadKey = keyValue in this.map;\r\n            delete this.map[keyValue];\r\n            return hadKey;\r\n        };\r\n\r\n        /**\r\n         * Returns an iterator over [key, value] pairs in the map.\r\n         * @returns {Object} The iterator\r\n         */\r\n        MapPrototype.entries = function() {\r\n            var entries = [];\r\n            var strKeys = Object.keys(this.map);\r\n            for (var i = 0, entry; i < strKeys.length; i++)\r\n                entries.push([(entry=this.map[strKeys[i]]).key, entry.value]);\r\n            return arrayIterator(entries);\r\n        };\r\n\r\n        /**\r\n         * Returns an iterator over keys in the map.\r\n         * @returns {Object} The iterator\r\n         */\r\n        MapPrototype.keys = function() {\r\n            var keys = [];\r\n            var strKeys = Object.keys(this.map);\r\n            for (var i = 0; i < strKeys.length; i++)\r\n                keys.push(this.map[strKeys[i]].key);\r\n            return arrayIterator(keys);\r\n        };\r\n\r\n        /**\r\n         * Returns an iterator over values in the map.\r\n         * @returns {!Object} The iterator\r\n         */\r\n        MapPrototype.values = function() {\r\n            var values = [];\r\n            var strKeys = Object.keys(this.map);\r\n            for (var i = 0; i < strKeys.length; i++)\r\n                values.push(this.map[strKeys[i]].value);\r\n            return arrayIterator(values);\r\n        };\r\n\r\n        /**\r\n         * Iterates over entries in the map, calling a function on each.\r\n         * @param {function(this:*, *, *, *)} cb The callback to invoke with value, key, and map arguments.\r\n         * @param {Object=} thisArg The `this` value for the callback\r\n         */\r\n        MapPrototype.forEach = function(cb, thisArg) {\r\n            var strKeys = Object.keys(this.map);\r\n            for (var i = 0, entry; i < strKeys.length; i++)\r\n                cb.call(thisArg, (entry=this.map[strKeys[i]]).value, entry.key, this);\r\n        };\r\n\r\n        /**\r\n         * Sets a key in the map to the given value.\r\n         * @param {*} key The key\r\n         * @param {*} value The value\r\n         * @returns {!ProtoBuf.Map} The map instance\r\n         */\r\n        MapPrototype.set = function(key, value) {\r\n            var keyValue = this.keyElem.verifyValue(key);\r\n            var valValue = this.valueElem.verifyValue(value);\r\n            this.map[this.keyElem.valueToString(keyValue)] =\r\n                { key: keyValue, value: valValue };\r\n            return this;\r\n        };\r\n\r\n        /**\r\n         * Gets the value corresponding to a key in the map.\r\n         * @param {*} key The key\r\n         * @returns {*|undefined} The value, or `undefined` if key not present\r\n         */\r\n        MapPrototype.get = function(key) {\r\n            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));\r\n            if (!(keyValue in this.map))\r\n                return undefined;\r\n            return this.map[keyValue].value;\r\n        };\r\n\r\n        /**\r\n         * Determines whether the given key is present in the map.\r\n         * @param {*} key The key\r\n         * @returns {boolean} `true` if the key is present\r\n         */\r\n        MapPrototype.has = function(key) {\r\n            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));\r\n            return (keyValue in this.map);\r\n        };\r\n\r\n        return Map;\r\n    })(ProtoBuf, ProtoBuf.Reflect);\r\n\r\n\r\n    /**\r\n     * Constructs a new empty Builder.\r\n     * @param {Object.<string,*>=} options Builder options, defaults to global options set on ProtoBuf\r\n     * @return {!ProtoBuf.Builder} Builder\r\n     * @expose\r\n     */\r\n    ProtoBuf.newBuilder = function(options) {\r\n        options = options || {};\r\n        if (typeof options['convertFieldsToCamelCase'] === 'undefined')\r\n            options['convertFieldsToCamelCase'] = ProtoBuf.convertFieldsToCamelCase;\r\n        if (typeof options['populateAccessors'] === 'undefined')\r\n            options['populateAccessors'] = ProtoBuf.populateAccessors;\r\n        return new ProtoBuf.Builder(options);\r\n    };\r\n\r\n    /**\r\n     * Loads a .json definition and returns the Builder.\r\n     * @param {!*|string} json JSON definition\r\n     * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.\r\n     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.\r\n     * @return {ProtoBuf.Builder} Builder to create new messages\r\n     * @throws {Error} If the definition cannot be parsed or built\r\n     * @expose\r\n     */\r\n    ProtoBuf.loadJson = function(json, builder, filename) {\r\n        if (typeof builder === 'string' || (builder && typeof builder[\"file\"] === 'string' && typeof builder[\"root\"] === 'string'))\r\n            filename = builder, builder = null;\r\n        if (!builder || typeof builder !== 'object')\r\n            builder = ProtoBuf.newBuilder();\r\n        if (typeof json === 'string')\r\n            json = JSON.parse(json);\r\n        builder[\"import\"](json, filename);\r\n        builder.resolveAll();\r\n        return builder;\r\n    };\r\n\r\n    /**\r\n     * Loads a .json file and returns the Builder.\r\n     * @param {string|!{root: string, file: string}} filename Path to json file or an object specifying 'file' with\r\n     *  an overridden 'root' path for all imported files.\r\n     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and\r\n     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the\r\n     *  file will be read synchronously and this function will return the Builder.\r\n     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.\r\n     * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the\r\n     *   request has failed), else undefined\r\n     * @expose\r\n     */\r\n    ProtoBuf.loadJsonFile = function(filename, callback, builder) {\r\n        if (callback && typeof callback === 'object')\r\n            builder = callback, callback = null;\r\n        else if (!callback || typeof callback !== 'function')\r\n            callback = null;\r\n        if (callback)\r\n            return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename[\"root\"]+\"/\"+filename[\"file\"], function(contents) {\r\n                if (contents === null) {\r\n                    callback(Error(\"Failed to fetch file\"));\r\n                    return;\r\n                }\r\n                try {\r\n                    callback(null, ProtoBuf.loadJson(JSON.parse(contents), builder, filename));\r\n                } catch (e) {\r\n                    callback(e);\r\n                }\r\n            });\r\n        var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename[\"root\"]+\"/\"+filename[\"file\"] : filename);\r\n        return contents === null ? null : ProtoBuf.loadJson(JSON.parse(contents), builder, filename);\r\n    };\r\n\r\n    return ProtoBuf;\r\n});\n});\n\nvar messageCompiled = protobufLight.newBuilder({})['import']({\n    \"package\": \"push_server.messages2\",\n    \"syntax\": \"proto2\",\n    \"options\": {\n        \"objc_class_prefix\": \"AVIM\"\n    },\n    \"messages\": [{\n        \"name\": \"JsonObjectMessage\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"required\",\n            \"type\": \"string\",\n            \"name\": \"data\",\n            \"id\": 1\n        }]\n    }, {\n        \"name\": \"UnreadTuple\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"required\",\n            \"type\": \"string\",\n            \"name\": \"cid\",\n            \"id\": 1\n        }, {\n            \"rule\": \"required\",\n            \"type\": \"int32\",\n            \"name\": \"unread\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"mid\",\n            \"id\": 3\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"timestamp\",\n            \"id\": 4\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"from\",\n            \"id\": 5\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"data\",\n            \"id\": 6\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"patchTimestamp\",\n            \"id\": 7\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"mentioned\",\n            \"id\": 8\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bytes\",\n            \"name\": \"binaryMsg\",\n            \"id\": 9\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"convType\",\n            \"id\": 10\n        }]\n    }, {\n        \"name\": \"LogItem\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"from\",\n            \"id\": 1\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"data\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"timestamp\",\n            \"id\": 3\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"msgId\",\n            \"id\": 4\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"ackAt\",\n            \"id\": 5\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"readAt\",\n            \"id\": 6\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"patchTimestamp\",\n            \"id\": 7\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"mentionAll\",\n            \"id\": 8\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"mentionPids\",\n            \"id\": 9\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"bin\",\n            \"id\": 10\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"convType\",\n            \"id\": 11\n        }]\n    }, {\n        \"name\": \"ConvMemberInfo\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"pid\",\n            \"id\": 1\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"role\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"infoId\",\n            \"id\": 3\n        }]\n    }, {\n        \"name\": \"DataCommand\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"ids\",\n            \"id\": 1\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"JsonObjectMessage\",\n            \"name\": \"msg\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"offline\",\n            \"id\": 3\n        }]\n    }, {\n        \"name\": \"SessionCommand\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"t\",\n            \"id\": 1\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"n\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"s\",\n            \"id\": 3\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"ua\",\n            \"id\": 4\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"r\",\n            \"id\": 5\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"tag\",\n            \"id\": 6\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"deviceId\",\n            \"id\": 7\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"sessionPeerIds\",\n            \"id\": 8\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"onlineSessionPeerIds\",\n            \"id\": 9\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"st\",\n            \"id\": 10\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"stTtl\",\n            \"id\": 11\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"code\",\n            \"id\": 12\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"reason\",\n            \"id\": 13\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"deviceToken\",\n            \"id\": 14\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"sp\",\n            \"id\": 15\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"detail\",\n            \"id\": 16\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"lastUnreadNotifTime\",\n            \"id\": 17\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"lastPatchTime\",\n            \"id\": 18\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"configBitmap\",\n            \"id\": 19\n        }]\n    }, {\n        \"name\": \"ErrorCommand\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"required\",\n            \"type\": \"int32\",\n            \"name\": \"code\",\n            \"id\": 1\n        }, {\n            \"rule\": \"required\",\n            \"type\": \"string\",\n            \"name\": \"reason\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"appCode\",\n            \"id\": 3\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"detail\",\n            \"id\": 4\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"pids\",\n            \"id\": 5\n        }]\n    }, {\n        \"name\": \"DirectCommand\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"msg\",\n            \"id\": 1\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"uid\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"fromPeerId\",\n            \"id\": 3\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"timestamp\",\n            \"id\": 4\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"offline\",\n            \"id\": 5\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"hasMore\",\n            \"id\": 6\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"toPeerIds\",\n            \"id\": 7\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"r\",\n            \"id\": 10\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"cid\",\n            \"id\": 11\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"id\",\n            \"id\": 12\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"transient\",\n            \"id\": 13\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"dt\",\n            \"id\": 14\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"roomId\",\n            \"id\": 15\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"pushData\",\n            \"id\": 16\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"will\",\n            \"id\": 17\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"patchTimestamp\",\n            \"id\": 18\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bytes\",\n            \"name\": \"binaryMsg\",\n            \"id\": 19\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"mentionPids\",\n            \"id\": 20\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"mentionAll\",\n            \"id\": 21\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"convType\",\n            \"id\": 22\n        }]\n    }, {\n        \"name\": \"AckCommand\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"code\",\n            \"id\": 1\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"reason\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"mid\",\n            \"id\": 3\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"cid\",\n            \"id\": 4\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"t\",\n            \"id\": 5\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"uid\",\n            \"id\": 6\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"fromts\",\n            \"id\": 7\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"tots\",\n            \"id\": 8\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"type\",\n            \"id\": 9\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"ids\",\n            \"id\": 10\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"appCode\",\n            \"id\": 11\n        }]\n    }, {\n        \"name\": \"UnreadCommand\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"repeated\",\n            \"type\": \"UnreadTuple\",\n            \"name\": \"convs\",\n            \"id\": 1\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"notifTime\",\n            \"id\": 2\n        }]\n    }, {\n        \"name\": \"ConvCommand\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"m\",\n            \"id\": 1\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"transient\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"unique\",\n            \"id\": 3\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"cid\",\n            \"id\": 4\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"cdate\",\n            \"id\": 5\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"initBy\",\n            \"id\": 6\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"sort\",\n            \"id\": 7\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"limit\",\n            \"id\": 8\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"skip\",\n            \"id\": 9\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"flag\",\n            \"id\": 10\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"count\",\n            \"id\": 11\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"udate\",\n            \"id\": 12\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"t\",\n            \"id\": 13\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"n\",\n            \"id\": 14\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"s\",\n            \"id\": 15\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"statusSub\",\n            \"id\": 16\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"statusPub\",\n            \"id\": 17\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"statusTTL\",\n            \"id\": 18\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"uniqueId\",\n            \"id\": 19\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"targetClientId\",\n            \"id\": 20\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"maxReadTimestamp\",\n            \"id\": 21\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"maxAckTimestamp\",\n            \"id\": 22\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"queryAllMembers\",\n            \"id\": 23\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"MaxReadTuple\",\n            \"name\": \"maxReadTuples\",\n            \"id\": 24\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"cids\",\n            \"id\": 25\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"ConvMemberInfo\",\n            \"name\": \"info\",\n            \"id\": 26\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"tempConv\",\n            \"id\": 27\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"tempConvTTL\",\n            \"id\": 28\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"tempConvIds\",\n            \"id\": 29\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"allowedPids\",\n            \"id\": 30\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"ErrorCommand\",\n            \"name\": \"failedPids\",\n            \"id\": 31\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"next\",\n            \"id\": 40\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"JsonObjectMessage\",\n            \"name\": \"results\",\n            \"id\": 100\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"JsonObjectMessage\",\n            \"name\": \"where\",\n            \"id\": 101\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"JsonObjectMessage\",\n            \"name\": \"attr\",\n            \"id\": 103\n        }]\n    }, {\n        \"name\": \"RoomCommand\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"roomId\",\n            \"id\": 1\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"s\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"t\",\n            \"id\": 3\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"n\",\n            \"id\": 4\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"transient\",\n            \"id\": 5\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"roomPeerIds\",\n            \"id\": 6\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"byPeerId\",\n            \"id\": 7\n        }]\n    }, {\n        \"name\": \"LogsCommand\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"cid\",\n            \"id\": 1\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"l\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"limit\",\n            \"id\": 3\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"t\",\n            \"id\": 4\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"tt\",\n            \"id\": 5\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"tmid\",\n            \"id\": 6\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"mid\",\n            \"id\": 7\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"checksum\",\n            \"id\": 8\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"stored\",\n            \"id\": 9\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"QueryDirection\",\n            \"name\": \"direction\",\n            \"id\": 10,\n            \"options\": {\n                \"default\": \"OLD\"\n            }\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"tIncluded\",\n            \"id\": 11\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"ttIncluded\",\n            \"id\": 12\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"lctype\",\n            \"id\": 13\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"LogItem\",\n            \"name\": \"logs\",\n            \"id\": 105\n        }],\n        \"enums\": [{\n            \"name\": \"QueryDirection\",\n            \"syntax\": \"proto2\",\n            \"values\": [{\n                \"name\": \"OLD\",\n                \"id\": 1\n            }, {\n                \"name\": \"NEW\",\n                \"id\": 2\n            }]\n        }]\n    }, {\n        \"name\": \"RcpCommand\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"id\",\n            \"id\": 1\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"cid\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"t\",\n            \"id\": 3\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"read\",\n            \"id\": 4\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"from\",\n            \"id\": 5\n        }]\n    }, {\n        \"name\": \"ReadTuple\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"required\",\n            \"type\": \"string\",\n            \"name\": \"cid\",\n            \"id\": 1\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"timestamp\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"mid\",\n            \"id\": 3\n        }]\n    }, {\n        \"name\": \"MaxReadTuple\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"pid\",\n            \"id\": 1\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"maxAckTimestamp\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"maxReadTimestamp\",\n            \"id\": 3\n        }]\n    }, {\n        \"name\": \"ReadCommand\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"cid\",\n            \"id\": 1\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"cids\",\n            \"id\": 2\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"ReadTuple\",\n            \"name\": \"convs\",\n            \"id\": 3\n        }]\n    }, {\n        \"name\": \"PresenceCommand\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"optional\",\n            \"type\": \"StatusType\",\n            \"name\": \"status\",\n            \"id\": 1\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"sessionPeerIds\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"cid\",\n            \"id\": 3\n        }]\n    }, {\n        \"name\": \"ReportCommand\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"initiative\",\n            \"id\": 1\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"type\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"data\",\n            \"id\": 3\n        }]\n    }, {\n        \"name\": \"PatchItem\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"cid\",\n            \"id\": 1\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"mid\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"timestamp\",\n            \"id\": 3\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"recall\",\n            \"id\": 4\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"data\",\n            \"id\": 5\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"patchTimestamp\",\n            \"id\": 6\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"from\",\n            \"id\": 7\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bytes\",\n            \"name\": \"binaryMsg\",\n            \"id\": 8\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"bool\",\n            \"name\": \"mentionAll\",\n            \"id\": 9\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"mentionPids\",\n            \"id\": 10\n        }]\n    }, {\n        \"name\": \"PatchCommand\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"repeated\",\n            \"type\": \"PatchItem\",\n            \"name\": \"patches\",\n            \"id\": 1\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"lastPatchTime\",\n            \"id\": 2\n        }]\n    }, {\n        \"name\": \"PubsubCommand\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"cid\",\n            \"id\": 1\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"cids\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"topic\",\n            \"id\": 3\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"subtopic\",\n            \"id\": 4\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"topics\",\n            \"id\": 5\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"subtopics\",\n            \"id\": 6\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"JsonObjectMessage\",\n            \"name\": \"results\",\n            \"id\": 7\n        }]\n    }, {\n        \"name\": \"BlacklistCommand\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"srcCid\",\n            \"id\": 1\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"toPids\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"srcPid\",\n            \"id\": 3\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"toCids\",\n            \"id\": 4\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"limit\",\n            \"id\": 5\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"next\",\n            \"id\": 6\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"blockedPids\",\n            \"id\": 8\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"blockedCids\",\n            \"id\": 9\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"string\",\n            \"name\": \"allowedPids\",\n            \"id\": 10\n        }, {\n            \"rule\": \"repeated\",\n            \"type\": \"ErrorCommand\",\n            \"name\": \"failedPids\",\n            \"id\": 11\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"t\",\n            \"id\": 12\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"n\",\n            \"id\": 13\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"s\",\n            \"id\": 14\n        }]\n    }, {\n        \"name\": \"GenericCommand\",\n        \"syntax\": \"proto2\",\n        \"fields\": [{\n            \"rule\": \"optional\",\n            \"type\": \"CommandType\",\n            \"name\": \"cmd\",\n            \"id\": 1\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"OpType\",\n            \"name\": \"op\",\n            \"id\": 2\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"appId\",\n            \"id\": 3\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"peerId\",\n            \"id\": 4\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"i\",\n            \"id\": 5\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"string\",\n            \"name\": \"installationId\",\n            \"id\": 6\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"priority\",\n            \"id\": 7\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int32\",\n            \"name\": \"service\",\n            \"id\": 8\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"int64\",\n            \"name\": \"serverTs\",\n            \"id\": 9\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"DataCommand\",\n            \"name\": \"dataMessage\",\n            \"id\": 101\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"SessionCommand\",\n            \"name\": \"sessionMessage\",\n            \"id\": 102\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"ErrorCommand\",\n            \"name\": \"errorMessage\",\n            \"id\": 103\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"DirectCommand\",\n            \"name\": \"directMessage\",\n            \"id\": 104\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"AckCommand\",\n            \"name\": \"ackMessage\",\n            \"id\": 105\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"UnreadCommand\",\n            \"name\": \"unreadMessage\",\n            \"id\": 106\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"ReadCommand\",\n            \"name\": \"readMessage\",\n            \"id\": 107\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"RcpCommand\",\n            \"name\": \"rcpMessage\",\n            \"id\": 108\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"LogsCommand\",\n            \"name\": \"logsMessage\",\n            \"id\": 109\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"ConvCommand\",\n            \"name\": \"convMessage\",\n            \"id\": 110\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"RoomCommand\",\n            \"name\": \"roomMessage\",\n            \"id\": 111\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"PresenceCommand\",\n            \"name\": \"presenceMessage\",\n            \"id\": 112\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"ReportCommand\",\n            \"name\": \"reportMessage\",\n            \"id\": 113\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"PatchCommand\",\n            \"name\": \"patchMessage\",\n            \"id\": 114\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"PubsubCommand\",\n            \"name\": \"pubsubMessage\",\n            \"id\": 115\n        }, {\n            \"rule\": \"optional\",\n            \"type\": \"BlacklistCommand\",\n            \"name\": \"blacklistMessage\",\n            \"id\": 116\n        }]\n    }],\n    \"enums\": [{\n        \"name\": \"CommandType\",\n        \"syntax\": \"proto2\",\n        \"values\": [{\n            \"name\": \"session\",\n            \"id\": 0\n        }, {\n            \"name\": \"conv\",\n            \"id\": 1\n        }, {\n            \"name\": \"direct\",\n            \"id\": 2\n        }, {\n            \"name\": \"ack\",\n            \"id\": 3\n        }, {\n            \"name\": \"rcp\",\n            \"id\": 4\n        }, {\n            \"name\": \"unread\",\n            \"id\": 5\n        }, {\n            \"name\": \"logs\",\n            \"id\": 6\n        }, {\n            \"name\": \"error\",\n            \"id\": 7\n        }, {\n            \"name\": \"login\",\n            \"id\": 8\n        }, {\n            \"name\": \"data\",\n            \"id\": 9\n        }, {\n            \"name\": \"room\",\n            \"id\": 10\n        }, {\n            \"name\": \"read\",\n            \"id\": 11\n        }, {\n            \"name\": \"presence\",\n            \"id\": 12\n        }, {\n            \"name\": \"report\",\n            \"id\": 13\n        }, {\n            \"name\": \"echo\",\n            \"id\": 14\n        }, {\n            \"name\": \"loggedin\",\n            \"id\": 15\n        }, {\n            \"name\": \"logout\",\n            \"id\": 16\n        }, {\n            \"name\": \"loggedout\",\n            \"id\": 17\n        }, {\n            \"name\": \"patch\",\n            \"id\": 18\n        }, {\n            \"name\": \"pubsub\",\n            \"id\": 19\n        }, {\n            \"name\": \"blacklist\",\n            \"id\": 20\n        }]\n    }, {\n        \"name\": \"OpType\",\n        \"syntax\": \"proto2\",\n        \"values\": [{\n            \"name\": \"open\",\n            \"id\": 1\n        }, {\n            \"name\": \"add\",\n            \"id\": 2\n        }, {\n            \"name\": \"remove\",\n            \"id\": 3\n        }, {\n            \"name\": \"close\",\n            \"id\": 4\n        }, {\n            \"name\": \"opened\",\n            \"id\": 5\n        }, {\n            \"name\": \"closed\",\n            \"id\": 6\n        }, {\n            \"name\": \"query\",\n            \"id\": 7\n        }, {\n            \"name\": \"query_result\",\n            \"id\": 8\n        }, {\n            \"name\": \"conflict\",\n            \"id\": 9\n        }, {\n            \"name\": \"added\",\n            \"id\": 10\n        }, {\n            \"name\": \"removed\",\n            \"id\": 11\n        }, {\n            \"name\": \"refresh\",\n            \"id\": 12\n        }, {\n            \"name\": \"refreshed\",\n            \"id\": 13\n        }, {\n            \"name\": \"start\",\n            \"id\": 30\n        }, {\n            \"name\": \"started\",\n            \"id\": 31\n        }, {\n            \"name\": \"joined\",\n            \"id\": 32\n        }, {\n            \"name\": \"members_joined\",\n            \"id\": 33\n        }, {\n            \"name\": \"left\",\n            \"id\": 39\n        }, {\n            \"name\": \"members_left\",\n            \"id\": 40\n        }, {\n            \"name\": \"results\",\n            \"id\": 42\n        }, {\n            \"name\": \"count\",\n            \"id\": 43\n        }, {\n            \"name\": \"result\",\n            \"id\": 44\n        }, {\n            \"name\": \"update\",\n            \"id\": 45\n        }, {\n            \"name\": \"updated\",\n            \"id\": 46\n        }, {\n            \"name\": \"mute\",\n            \"id\": 47\n        }, {\n            \"name\": \"unmute\",\n            \"id\": 48\n        }, {\n            \"name\": \"status\",\n            \"id\": 49\n        }, {\n            \"name\": \"members\",\n            \"id\": 50\n        }, {\n            \"name\": \"max_read\",\n            \"id\": 51\n        }, {\n            \"name\": \"is_member\",\n            \"id\": 52\n        }, {\n            \"name\": \"member_info_update\",\n            \"id\": 53\n        }, {\n            \"name\": \"member_info_updated\",\n            \"id\": 54\n        }, {\n            \"name\": \"member_info_changed\",\n            \"id\": 55\n        }, {\n            \"name\": \"join\",\n            \"id\": 80\n        }, {\n            \"name\": \"invite\",\n            \"id\": 81\n        }, {\n            \"name\": \"leave\",\n            \"id\": 82\n        }, {\n            \"name\": \"kick\",\n            \"id\": 83\n        }, {\n            \"name\": \"reject\",\n            \"id\": 84\n        }, {\n            \"name\": \"invited\",\n            \"id\": 85\n        }, {\n            \"name\": \"kicked\",\n            \"id\": 86\n        }, {\n            \"name\": \"upload\",\n            \"id\": 100\n        }, {\n            \"name\": \"uploaded\",\n            \"id\": 101\n        }, {\n            \"name\": \"subscribe\",\n            \"id\": 120\n        }, {\n            \"name\": \"subscribed\",\n            \"id\": 121\n        }, {\n            \"name\": \"unsubscribe\",\n            \"id\": 122\n        }, {\n            \"name\": \"unsubscribed\",\n            \"id\": 123\n        }, {\n            \"name\": \"is_subscribed\",\n            \"id\": 124\n        }, {\n            \"name\": \"modify\",\n            \"id\": 150\n        }, {\n            \"name\": \"modified\",\n            \"id\": 151\n        }, {\n            \"name\": \"block\",\n            \"id\": 170\n        }, {\n            \"name\": \"unblock\",\n            \"id\": 171\n        }, {\n            \"name\": \"blocked\",\n            \"id\": 172\n        }, {\n            \"name\": \"unblocked\",\n            \"id\": 173\n        }, {\n            \"name\": \"members_blocked\",\n            \"id\": 174\n        }, {\n            \"name\": \"members_unblocked\",\n            \"id\": 175\n        }, {\n            \"name\": \"add_shutup\",\n            \"id\": 180\n        }, {\n            \"name\": \"remove_shutup\",\n            \"id\": 181\n        }, {\n            \"name\": \"query_shutup\",\n            \"id\": 182\n        }, {\n            \"name\": \"shutup_added\",\n            \"id\": 183\n        }, {\n            \"name\": \"shutup_removed\",\n            \"id\": 184\n        }, {\n            \"name\": \"shutup_result\",\n            \"id\": 185\n        }, {\n            \"name\": \"shutuped\",\n            \"id\": 186\n        }, {\n            \"name\": \"unshutuped\",\n            \"id\": 187\n        }, {\n            \"name\": \"members_shutuped\",\n            \"id\": 188\n        }, {\n            \"name\": \"members_unshutuped\",\n            \"id\": 189\n        }]\n    }, {\n        \"name\": \"StatusType\",\n        \"syntax\": \"proto2\",\n        \"values\": [{\n            \"name\": \"on\",\n            \"id\": 1\n        }, {\n            \"name\": \"off\",\n            \"id\": 2\n        }]\n    }],\n    \"isNamespace\": true\n}).build();\n\nvar _messages$push_server = messageCompiled.push_server.messages2,\n    JsonObjectMessage = _messages$push_server.JsonObjectMessage,\n    UnreadTuple = _messages$push_server.UnreadTuple,\n    LogItem = _messages$push_server.LogItem,\n    DataCommand = _messages$push_server.DataCommand,\n    SessionCommand = _messages$push_server.SessionCommand,\n    ErrorCommand = _messages$push_server.ErrorCommand,\n    DirectCommand = _messages$push_server.DirectCommand,\n    AckCommand = _messages$push_server.AckCommand,\n    UnreadCommand = _messages$push_server.UnreadCommand,\n    ConvCommand = _messages$push_server.ConvCommand,\n    RoomCommand = _messages$push_server.RoomCommand,\n    LogsCommand = _messages$push_server.LogsCommand,\n    RcpCommand = _messages$push_server.RcpCommand,\n    ReadTuple = _messages$push_server.ReadTuple,\n    MaxReadTuple = _messages$push_server.MaxReadTuple,\n    ReadCommand = _messages$push_server.ReadCommand,\n    PresenceCommand = _messages$push_server.PresenceCommand,\n    ReportCommand = _messages$push_server.ReportCommand,\n    GenericCommand = _messages$push_server.GenericCommand,\n    BlacklistCommand = _messages$push_server.BlacklistCommand,\n    PatchCommand = _messages$push_server.PatchCommand,\n    PatchItem = _messages$push_server.PatchItem,\n    ConvMemberInfo = _messages$push_server.ConvMemberInfo,\n    CommandType = _messages$push_server.CommandType,\n    OpType = _messages$push_server.OpType,\n    StatusType = _messages$push_server.StatusType;\n\n\nvar message = Object.freeze({\n\tJsonObjectMessage: JsonObjectMessage,\n\tUnreadTuple: UnreadTuple,\n\tLogItem: LogItem,\n\tDataCommand: DataCommand,\n\tSessionCommand: SessionCommand,\n\tErrorCommand: ErrorCommand,\n\tDirectCommand: DirectCommand,\n\tAckCommand: AckCommand,\n\tUnreadCommand: UnreadCommand,\n\tConvCommand: ConvCommand,\n\tRoomCommand: RoomCommand,\n\tLogsCommand: LogsCommand,\n\tRcpCommand: RcpCommand,\n\tReadTuple: ReadTuple,\n\tMaxReadTuple: MaxReadTuple,\n\tReadCommand: ReadCommand,\n\tPresenceCommand: PresenceCommand,\n\tReportCommand: ReportCommand,\n\tGenericCommand: GenericCommand,\n\tBlacklistCommand: BlacklistCommand,\n\tPatchCommand: PatchCommand,\n\tPatchItem: PatchItem,\n\tConvMemberInfo: ConvMemberInfo,\n\tCommandType: CommandType,\n\tOpType: OpType,\n\tStatusType: StatusType\n});\n\nvar eventemitter3 = createCommonjsModule(function (module) {\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\n{\n  module.exports = EventEmitter;\n}\n});\n\nvar runtime = createCommonjsModule(function (module) {\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = 'object' === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n});\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nvar runtimeModule = runtime;\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\nvar regenerator = runtimeModule;\n\nvar asyncToGenerator = createCommonjsModule(function (module, exports) {\n\nexports.__esModule = true;\n\n\n\nvar _promise2 = _interopRequireDefault(promise$1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);\n    return new _promise2.default(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          return _promise2.default.resolve(value).then(function (value) {\n            step(\"next\", value);\n          }, function (err) {\n            step(\"throw\", err);\n          });\n        }\n      }\n\n      return step(\"next\");\n    });\n  };\n};\n});\n\nvar _asyncToGenerator = unwrapExports(asyncToGenerator);\n\nvar _createProperty = function (object, index, value) {\n  if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));\n  else object[index] = value;\n};\n\n_export(_export.S + _export.F * !_iterDetect(function (iter) { }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n    var O = _toObject(arrayLike);\n    var C = typeof this == 'function' ? this : Array;\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var index = 0;\n    var iterFn = core_getIteratorMethod(O);\n    var length, result, step, iterator;\n    if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {\n      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n        _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = _toLength(O.length);\n      for (result = new C(length); length > index; index++) {\n        _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n\nvar from = _core.Array.from;\n\nvar from$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": from, __esModule: true };\n});\n\nvar _Array$from = unwrapExports(from$1);\n\nvar toConsumableArray = createCommonjsModule(function (module, exports) {\n\nexports.__esModule = true;\n\n\n\nvar _from2 = _interopRequireDefault(from$1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return (0, _from2.default)(arr);\n  }\n};\n});\n\nvar _toConsumableArray = unwrapExports(toConsumableArray);\n\nvar _meta = createCommonjsModule(function (module) {\nvar META = _uid('meta');\n\n\nvar setDesc = _objectDp.f;\nvar id = 0;\nvar isExtensible = Object.isExtensible || function () {\n  return true;\n};\nvar FREEZE = !_fails(function () {\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function (it) {\n  setDesc(it, META, { value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  } });\n};\nvar fastKey = function (it, create) {\n  // return primitive with prefix\n  if (!_isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!_has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function (it, create) {\n  if (!_has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY: META,\n  NEED: false,\n  fastKey: fastKey,\n  getWeak: getWeak,\n  onFreeze: onFreeze\n};\n});\nvar _meta_1 = _meta.KEY;\nvar _meta_2 = _meta.NEED;\nvar _meta_3 = _meta.fastKey;\nvar _meta_4 = _meta.getWeak;\nvar _meta_5 = _meta.onFreeze;\n\nvar _validateCollection = function (it, TYPE) {\n  if (!_isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');\n  return it;\n};\n\nvar dP$1 = _objectDp.f;\n\n\n\n\n\n\n\n\n\nvar fastKey = _meta.fastKey;\n\nvar SIZE = _descriptors ? '_s' : 'size';\n\nvar getEntry = function (that, key) {\n  // fast case\n  var index = fastKey(key);\n  var entry;\n  if (index !== 'F') return that._i[index];\n  // frozen object case\n  for (entry = that._f; entry; entry = entry.n) {\n    if (entry.k == key) return entry;\n  }\n};\n\nvar _collectionStrong = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      _anInstance(that, C, NAME, '_i');\n      that._t = NAME;         // collection type\n      that._i = _objectCreate(null); // index\n      that._f = undefined;    // first entry\n      that._l = undefined;    // last entry\n      that[SIZE] = 0;         // size\n      if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    _redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear() {\n        for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {\n          entry.r = true;\n          if (entry.p) entry.p = entry.p.n = undefined;\n          delete data[entry.i];\n        }\n        that._f = that._l = undefined;\n        that[SIZE] = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function (key) {\n        var that = _validateCollection(this, NAME);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next = entry.n;\n          var prev = entry.p;\n          delete that._i[entry.i];\n          entry.r = true;\n          if (prev) prev.n = next;\n          if (next) next.p = prev;\n          if (that._f == entry) that._f = next;\n          if (that._l == entry) that._l = prev;\n          that[SIZE]--;\n        } return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn /* , that = undefined */) {\n        _validateCollection(this, NAME);\n        var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n        var entry;\n        while (entry = entry ? entry.n : this._f) {\n          f(entry.v, entry.k, this);\n          // revert to the last existing entry\n          while (entry && entry.r) entry = entry.p;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key) {\n        return !!getEntry(_validateCollection(this, NAME), key);\n      }\n    });\n    if (_descriptors) dP$1(C.prototype, 'size', {\n      get: function () {\n        return _validateCollection(this, NAME)[SIZE];\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var entry = getEntry(that, key);\n    var prev, index;\n    // change existing entry\n    if (entry) {\n      entry.v = value;\n    // create new entry\n    } else {\n      that._l = entry = {\n        i: index = fastKey(key, true), // <- index\n        k: key,                        // <- key\n        v: value,                      // <- value\n        p: prev = that._l,             // <- previous entry\n        n: undefined,                  // <- next entry\n        r: false                       // <- removed\n      };\n      if (!that._f) that._f = entry;\n      if (prev) prev.n = entry;\n      that[SIZE]++;\n      // add to index\n      if (index !== 'F') that._i[index] = entry;\n    } return that;\n  },\n  getEntry: getEntry,\n  setStrong: function (C, NAME, IS_MAP) {\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    _iterDefine(C, NAME, function (iterated, kind) {\n      this._t = _validateCollection(iterated, NAME); // target\n      this._k = kind;                     // kind\n      this._l = undefined;                // previous\n    }, function () {\n      var that = this;\n      var kind = that._k;\n      var entry = that._l;\n      // revert to the last existing entry\n      while (entry && entry.r) entry = entry.p;\n      // get next entry\n      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {\n        // or finish the iteration\n        that._t = undefined;\n        return _iterStep(1);\n      }\n      // return step by kind\n      if (kind == 'keys') return _iterStep(0, entry.k);\n      if (kind == 'values') return _iterStep(0, entry.v);\n      return _iterStep(0, [entry.k, entry.v]);\n    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);\n\n    // add [@@species], 23.1.2.2, 23.2.2.2\n    _setSpecies(NAME);\n  }\n};\n\n// 7.2.2 IsArray(argument)\n\nvar _isArray = Array.isArray || function isArray(arg) {\n  return _cof(arg) == 'Array';\n};\n\nvar SPECIES$2 = _wks('species');\n\nvar _arraySpeciesConstructor = function (original) {\n  var C;\n  if (_isArray(original)) {\n    C = original.constructor;\n    // cross-realm fallback\n    if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;\n    if (_isObject(C)) {\n      C = C[SPECIES$2];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? Array : C;\n};\n\n// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\n\n\nvar _arraySpeciesCreate = function (original, length) {\n  return new (_arraySpeciesConstructor(original))(length);\n};\n\n// 0 -> Array#forEach\n// 1 -> Array#map\n// 2 -> Array#filter\n// 3 -> Array#some\n// 4 -> Array#every\n// 5 -> Array#find\n// 6 -> Array#findIndex\n\n\n\n\n\nvar _arrayMethods = function (TYPE, $create) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  var create = $create || _arraySpeciesCreate;\n  return function ($this, callbackfn, that) {\n    var O = _toObject($this);\n    var self = _iobject(O);\n    var f = _ctx(callbackfn, that, 3);\n    var length = _toLength(self.length);\n    var index = 0;\n    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n    var val, res;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      val = self[index];\n      res = f(val, index, O);\n      if (TYPE) {\n        if (IS_MAP) result[index] = res;   // map\n        else if (res) switch (TYPE) {\n          case 3: return true;             // some\n          case 5: return val;              // find\n          case 6: return index;            // findIndex\n          case 2: result.push(val);        // filter\n        } else if (IS_EVERY) return false; // every\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\n  };\n};\n\nvar dP$2 = _objectDp.f;\nvar each = _arrayMethods(0);\n\n\nvar _collection = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {\n  var Base = _global[NAME];\n  var C = Base;\n  var ADDER = IS_MAP ? 'set' : 'add';\n  var proto = C && C.prototype;\n  var O = {};\n  if (!_descriptors || typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {\n    new C().entries().next();\n  }))) {\n    // create collection constructor\n    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\n    _redefineAll(C.prototype, methods);\n    _meta.NEED = true;\n  } else {\n    C = wrapper(function (target, iterable) {\n      _anInstance(target, C, NAME, '_c');\n      target._c = new Base();\n      if (iterable != undefined) _forOf(iterable, IS_MAP, target[ADDER], target);\n    });\n    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {\n      var IS_ADDER = KEY == 'add' || KEY == 'set';\n      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) _hide(C.prototype, KEY, function (a, b) {\n        _anInstance(this, C, KEY);\n        if (!IS_ADDER && IS_WEAK && !_isObject(a)) return KEY == 'get' ? undefined : false;\n        var result = this._c[KEY](a === 0 ? 0 : a, b);\n        return IS_ADDER ? this : result;\n      });\n    });\n    IS_WEAK || dP$2(C.prototype, 'size', {\n      get: function () {\n        return this._c.size;\n      }\n    });\n  }\n\n  _setToStringTag(C, NAME);\n\n  O[NAME] = C;\n  _export(_export.G + _export.W + _export.F, O);\n\n  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);\n\n  return C;\n};\n\nvar SET = 'Set';\n\n// 23.2 Set Objects\nvar es6_set = _collection(SET, function (get) {\n  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.2.3.1 Set.prototype.add(value)\n  add: function add(value) {\n    return _collectionStrong.def(_validateCollection(this, SET), value = value === 0 ? 0 : value, value);\n  }\n}, _collectionStrong);\n\nvar _arrayFromIterable = function (iter, ITERATOR) {\n  var result = [];\n  _forOf(iter, false, result.push, result, ITERATOR);\n  return result;\n};\n\n// https://github.com/DavidBruant/Map-Set.prototype.toJSON\n\n\nvar _collectionToJson = function (NAME) {\n  return function toJSON() {\n    if (_classof(this) != NAME) throw TypeError(NAME + \"#toJSON isn't generic\");\n    return _arrayFromIterable(this);\n  };\n};\n\n// https://github.com/DavidBruant/Map-Set.prototype.toJSON\n\n\n_export(_export.P + _export.R, 'Set', { toJSON: _collectionToJson('Set') });\n\n// https://tc39.github.io/proposal-setmap-offrom/\n\n\nvar _setCollectionOf = function (COLLECTION) {\n  _export(_export.S, COLLECTION, { of: function of() {\n    var length = arguments.length;\n    var A = new Array(length);\n    while (length--) A[length] = arguments[length];\n    return new this(A);\n  } });\n};\n\n// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of\n_setCollectionOf('Set');\n\n// https://tc39.github.io/proposal-setmap-offrom/\n\n\n\n\n\nvar _setCollectionFrom = function (COLLECTION) {\n  _export(_export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {\n    var mapFn = arguments[1];\n    var mapping, A, n, cb;\n    _aFunction(this);\n    mapping = mapFn !== undefined;\n    if (mapping) _aFunction(mapFn);\n    if (source == undefined) return new this();\n    A = [];\n    if (mapping) {\n      n = 0;\n      cb = _ctx(mapFn, arguments[2], 2);\n      _forOf(source, false, function (nextItem) {\n        A.push(cb(nextItem, n++));\n      });\n    } else {\n      _forOf(source, false, A.push, A);\n    }\n    return new this(A);\n  } });\n};\n\n// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from\n_setCollectionFrom('Set');\n\nvar set = _core.Set;\n\nvar set$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": set, __esModule: true };\n});\n\nvar _Set = unwrapExports(set$1);\n\nvar objectWithoutProperties = createCommonjsModule(function (module, exports) {\n\nexports.__esModule = true;\n\nexports.default = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n});\n\nvar _objectWithoutProperties = unwrapExports(objectWithoutProperties);\n\nvar classCallCheck = createCommonjsModule(function (module, exports) {\n\nexports.__esModule = true;\n\nexports.default = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n});\n\nvar _classCallCheck = unwrapExports(classCallCheck);\n\nvar f$4 = _wks;\n\nvar _wksExt = {\n\tf: f$4\n};\n\nvar iterator = _wksExt.f('iterator');\n\nvar iterator$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": iterator, __esModule: true };\n});\n\nunwrapExports(iterator$1);\n\nvar defineProperty = _objectDp.f;\nvar _wksDefine = function (name) {\n  var $Symbol = _core.Symbol || (_core.Symbol = _library ? {} : _global.Symbol || {});\n  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: _wksExt.f(name) });\n};\n\n// all enumerable object keys, includes symbols\n\n\n\nvar _enumKeys = function (it) {\n  var result = _objectKeys(it);\n  var getSymbols = _objectGops.f;\n  if (getSymbols) {\n    var symbols = getSymbols(it);\n    var isEnum = _objectPie.f;\n    var i = 0;\n    var key;\n    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);\n  } return result;\n};\n\n// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\n\nvar hiddenKeys = _enumBugKeys.concat('length', 'prototype');\n\nvar f$5 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return _objectKeysInternal(O, hiddenKeys);\n};\n\nvar _objectGopn = {\n\tf: f$5\n};\n\n// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n\nvar gOPN = _objectGopn.f;\nvar toString$1 = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return gOPN(it);\n  } catch (e) {\n    return windowNames.slice();\n  }\n};\n\nvar f$6 = function getOwnPropertyNames(it) {\n  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(_toIobject(it));\n};\n\nvar _objectGopnExt = {\n\tf: f$6\n};\n\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar f$7 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = _toIobject(O);\n  P = _toPrimitive(P, true);\n  if (_ie8DomDefine) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);\n};\n\nvar _objectGopd = {\n\tf: f$7\n};\n\n// ECMAScript 6 symbols shim\n\n\n\n\n\nvar META = _meta.KEY;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar gOPD$1 = _objectGopd.f;\nvar dP$3 = _objectDp.f;\nvar gOPN$1 = _objectGopnExt.f;\nvar $Symbol = _global.Symbol;\nvar $JSON = _global.JSON;\nvar _stringify = $JSON && $JSON.stringify;\nvar PROTOTYPE$2 = 'prototype';\nvar HIDDEN = _wks('_hidden');\nvar TO_PRIMITIVE = _wks('toPrimitive');\nvar isEnum = {}.propertyIsEnumerable;\nvar SymbolRegistry = _shared('symbol-registry');\nvar AllSymbols = _shared('symbols');\nvar OPSymbols = _shared('op-symbols');\nvar ObjectProto$1 = Object[PROTOTYPE$2];\nvar USE_NATIVE$1 = typeof $Symbol == 'function';\nvar QObject = _global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE$2] || !QObject[PROTOTYPE$2].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = _descriptors && _fails(function () {\n  return _objectCreate(dP$3({}, 'a', {\n    get: function () { return dP$3(this, 'a', { value: 7 }).a; }\n  })).a != 7;\n}) ? function (it, key, D) {\n  var protoDesc = gOPD$1(ObjectProto$1, key);\n  if (protoDesc) delete ObjectProto$1[key];\n  dP$3(it, key, D);\n  if (protoDesc && it !== ObjectProto$1) dP$3(ObjectProto$1, key, protoDesc);\n} : dP$3;\n\nvar wrap = function (tag) {\n  var sym = AllSymbols[tag] = _objectCreate($Symbol[PROTOTYPE$2]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE$1 && typeof $Symbol.iterator == 'symbol' ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D) {\n  if (it === ObjectProto$1) $defineProperty(OPSymbols, key, D);\n  _anObject(it);\n  key = _toPrimitive(key, true);\n  _anObject(D);\n  if (_has(AllSymbols, key)) {\n    if (!D.enumerable) {\n      if (!_has(it, HIDDEN)) dP$3(it, HIDDEN, _propertyDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if (_has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\n      D = _objectCreate(D, { enumerable: _propertyDesc(0, false) });\n    } return setSymbolDesc(it, key, D);\n  } return dP$3(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P) {\n  _anObject(it);\n  var keys = _enumKeys(P = _toIobject(P));\n  var i = 0;\n  var l = keys.length;\n  var key;\n  while (l > i) $defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P) {\n  return P === undefined ? _objectCreate(it) : $defineProperties(_objectCreate(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key) {\n  var E = isEnum.call(this, key = _toPrimitive(key, true));\n  if (this === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key)) return false;\n  return E || !_has(this, key) || !_has(AllSymbols, key) || _has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n  it = _toIobject(it);\n  key = _toPrimitive(key, true);\n  if (it === ObjectProto$1 && _has(AllSymbols, key) && !_has(OPSymbols, key)) return;\n  var D = gOPD$1(it, key);\n  if (D && _has(AllSymbols, key) && !(_has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it) {\n  var names = gOPN$1(_toIobject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (!_has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\n  var IS_OP = it === ObjectProto$1;\n  var names = gOPN$1(IS_OP ? OPSymbols : _toIobject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (_has(AllSymbols, key = names[i++]) && (IS_OP ? _has(ObjectProto$1, key) : true)) result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif (!USE_NATIVE$1) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');\n    var tag = _uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function (value) {\n      if (this === ObjectProto$1) $set.call(OPSymbols, value);\n      if (_has(this, HIDDEN) && _has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, _propertyDesc(1, value));\n    };\n    if (_descriptors && setter) setSymbolDesc(ObjectProto$1, tag, { configurable: true, set: $set });\n    return wrap(tag);\n  };\n  _redefine($Symbol[PROTOTYPE$2], 'toString', function toString() {\n    return this._k;\n  });\n\n  _objectGopd.f = $getOwnPropertyDescriptor;\n  _objectDp.f = $defineProperty;\n  _objectGopn.f = _objectGopnExt.f = $getOwnPropertyNames;\n  _objectPie.f = $propertyIsEnumerable;\n  _objectGops.f = $getOwnPropertySymbols;\n\n  if (_descriptors && !_library) {\n    _redefine(ObjectProto$1, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  _wksExt.f = function (name) {\n    return wrap(_wks(name));\n  };\n}\n\n_export(_export.G + _export.W + _export.F * !USE_NATIVE$1, { Symbol: $Symbol });\n\nfor (var es6Symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), j = 0; es6Symbols.length > j;)_wks(es6Symbols[j++]);\n\nfor (var wellKnownSymbols = _objectKeys(_wks.store), k = 0; wellKnownSymbols.length > k;) _wksDefine(wellKnownSymbols[k++]);\n\n_export(_export.S + _export.F * !USE_NATIVE$1, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function (key) {\n    return _has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');\n    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;\n  },\n  useSetter: function () { setter = true; },\n  useSimple: function () { setter = false; }\n});\n\n_export(_export.S + _export.F * !USE_NATIVE$1, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && _export(_export.S + _export.F * (!USE_NATIVE$1 || _fails(function () {\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it) {\n    var args = [it];\n    var i = 1;\n    var replacer, $replacer;\n    while (arguments.length > i) args.push(arguments[i++]);\n    $replacer = replacer = args[1];\n    if (!_isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n    if (!_isArray(replacer)) replacer = function (key, value) {\n      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n      if (!isSymbol(value)) return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE$2][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE$2], TO_PRIMITIVE, $Symbol[PROTOTYPE$2].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\n_setToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\n_setToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\n_setToStringTag(_global.JSON, 'JSON', true);\n\n_wksDefine('asyncIterator');\n\n_wksDefine('observable');\n\nvar symbol = _core.Symbol;\n\nvar symbol$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": symbol, __esModule: true };\n});\n\nvar _Symbol = unwrapExports(symbol$1);\n\nvar _typeof_1 = createCommonjsModule(function (module, exports) {\n\nexports.__esModule = true;\n\n\n\nvar _iterator2 = _interopRequireDefault(iterator$1);\n\n\n\nvar _symbol2 = _interopRequireDefault(symbol$1);\n\nvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n} : function (obj) {\n  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n};\n});\n\nvar _typeof = unwrapExports(_typeof_1);\n\nvar possibleConstructorReturn = createCommonjsModule(function (module, exports) {\n\nexports.__esModule = true;\n\n\n\nvar _typeof3 = _interopRequireDefault(_typeof_1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && ((typeof call === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(call)) === \"object\" || typeof call === \"function\") ? call : self;\n};\n});\n\nvar _possibleConstructorReturn = unwrapExports(possibleConstructorReturn);\n\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\n\n\nvar check = function (O, proto) {\n  _anObject(O);\n  if (!_isObject(proto) && proto !== null) throw TypeError(proto + \": can't set as prototype!\");\n};\nvar _setProto = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function (test, buggy, set) {\n      try {\n        set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch (e) { buggy = true; }\n      return function setPrototypeOf(O, proto) {\n        check(O, proto);\n        if (buggy) O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n\n// 19.1.3.19 Object.setPrototypeOf(O, proto)\n\n_export(_export.S, 'Object', { setPrototypeOf: _setProto.set });\n\nvar setPrototypeOf = _core.Object.setPrototypeOf;\n\nvar setPrototypeOf$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": setPrototypeOf, __esModule: true };\n});\n\nunwrapExports(setPrototypeOf$1);\n\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n_export(_export.S, 'Object', { create: _objectCreate });\n\nvar $Object = _core.Object;\nvar create = function create(P, D) {\n  return $Object.create(P, D);\n};\n\nvar create$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": create, __esModule: true };\n});\n\nunwrapExports(create$1);\n\nvar inherits = createCommonjsModule(function (module, exports) {\n\nexports.__esModule = true;\n\n\n\nvar _setPrototypeOf2 = _interopRequireDefault(setPrototypeOf$1);\n\n\n\nvar _create2 = _interopRequireDefault(create$1);\n\n\n\nvar _typeof3 = _interopRequireDefault(_typeof_1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(superClass)));\n  }\n\n  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;\n};\n});\n\nvar _inherits = unwrapExports(inherits);\n\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nvar ms = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\nvar debug = createCommonjsModule(function (module, exports) {\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = ms;\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms$$1 = curr - (prevTime || curr);\n    self.diff = ms$$1;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n});\nvar debug_1 = debug.coerce;\nvar debug_2 = debug.disable;\nvar debug_3 = debug.enable;\nvar debug_4 = debug.enabled;\nvar debug_5 = debug.humanize;\nvar debug_6 = debug.instances;\nvar debug_7 = debug.names;\nvar debug_8 = debug.skips;\nvar debug_9 = debug.formatters;\n\nvar browser = createCommonjsModule(function (module, exports) {\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit');\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n});\nvar browser_1 = browser.log;\nvar browser_2 = browser.formatArgs;\nvar browser_3 = browser.save;\nvar browser_4 = browser.load;\nvar browser_5 = browser.useColors;\nvar browser_6 = browser.storage;\nvar browser_7 = browser.colors;\n\nvar bind = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n\n/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nvar isBuffer_1 = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n};\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString$2 = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString$2.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString$2.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return typeof FormData !== 'undefined' && val instanceof FormData;\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = val && val.buffer && val.buffer instanceof ArrayBuffer;\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString$2.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString$2.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString$2.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString$2.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return false;\n  }\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge() /* obj1, obj2, obj3, ... */{\n  var result = {};\n  function assignValue(val, key) {\n    if (_typeof(result[key]) === 'object' && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nvar utils = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer_1,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim\n};\n\nvar $JSON$1 = _core.JSON || (_core.JSON = { stringify: JSON.stringify });\nvar stringify = function stringify(it) { // eslint-disable-line no-unused-vars\n  return $JSON$1.stringify.apply($JSON$1, arguments);\n};\n\nvar stringify$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": stringify, __esModule: true };\n});\n\nvar _JSON$stringify = unwrapExports(stringify$1);\n\nvar normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\n\nvar enhanceError = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n  error.request = request;\n  error.response = response;\n  return error;\n};\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nvar createError = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nvar settle = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  // Note: status is not exposed by XDomainRequest\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));\n  }\n};\n\nfunction encode(val) {\n  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nvar buildURL = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = _JSON$stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nvar parseHeaders = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) {\n    return parsed;\n  }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n\nvar isURLSameOrigin = utils.isStandardBrowserEnv() ?\n\n// Standard browser envs have full support of the APIs needed to test\n// whether the request URL is of the same origin as current location.\nfunction standardBrowserEnv() {\n  var msie = /(msie|trident)/i.test(navigator.userAgent);\n  var urlParsingNode = document.createElement('a');\n  var originURL;\n\n  /**\n  * Parse a URL to discover it's components\n  *\n  * @param {String} url The URL to be parsed\n  * @returns {Object}\n  */\n  function resolveURL(url) {\n    var href = url;\n\n    if (msie) {\n      // IE needs attribute set twice to normalize properties\n      urlParsingNode.setAttribute('href', href);\n      href = urlParsingNode.href;\n    }\n\n    urlParsingNode.setAttribute('href', href);\n\n    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n    return {\n      href: urlParsingNode.href,\n      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n      host: urlParsingNode.host,\n      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n      hostname: urlParsingNode.hostname,\n      port: urlParsingNode.port,\n      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname\n    };\n  }\n\n  originURL = resolveURL(window.location.href);\n\n  /**\n  * Determine if a URL shares the same origin as the current location\n  *\n  * @param {String} requestURL The URL to test\n  * @returns {boolean} True if URL shares the same origin, otherwise false\n  */\n  return function isURLSameOrigin(requestURL) {\n    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;\n    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;\n  };\n}() :\n\n// Non standard browser envs (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n  return function isURLSameOrigin() {\n    return true;\n  };\n}();\n\n// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js\n\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction E() {\n  this.message = 'String contains an invalid character';\n}\nE.prototype = new Error();\nE.prototype.code = 5;\nE.prototype.name = 'InvalidCharacterError';\n\nfunction btoa(input) {\n  var str = String(input);\n  var output = '';\n  for (\n  // initialize result and counter\n  var block, charCode, idx = 0, map = chars;\n  // if the next str index does not exist:\n  //   change the mapping table to \"=\"\n  //   check if d has no fractional digits\n  str.charAt(idx | 0) || (map = '=', idx % 1);\n  // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {\n    charCode = str.charCodeAt(idx += 3 / 4);\n    if (charCode > 0xFF) {\n      throw new E();\n    }\n    block = block << 8 | charCode;\n  }\n  return output;\n}\n\nvar btoa_1 = btoa;\n\nvar cookies = utils.isStandardBrowserEnv() ?\n\n// Standard browser envs support document.cookie\nfunction standardBrowserEnv() {\n  return {\n    write: function write(name, value, expires, path, domain, secure) {\n      var cookie = [];\n      cookie.push(name + '=' + encodeURIComponent(value));\n\n      if (utils.isNumber(expires)) {\n        cookie.push('expires=' + new Date(expires).toGMTString());\n      }\n\n      if (utils.isString(path)) {\n        cookie.push('path=' + path);\n      }\n\n      if (utils.isString(domain)) {\n        cookie.push('domain=' + domain);\n      }\n\n      if (secure === true) {\n        cookie.push('secure');\n      }\n\n      document.cookie = cookie.join('; ');\n    },\n\n    read: function read(name) {\n      var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n      return match ? decodeURIComponent(match[3]) : null;\n    },\n\n    remove: function remove(name) {\n      this.write(name, '', Date.now() - 86400000);\n    }\n  };\n}() :\n\n// Non standard browser env (web workers, react-native) lack needed support.\nfunction nonStandardBrowserEnv() {\n  return {\n    write: function write() {},\n    read: function read() {\n      return null;\n    },\n    remove: function remove() {}\n  };\n}();\n\nvar btoa$1 = typeof window !== 'undefined' && window.btoa && window.btoa.bind(window) || btoa_1;\n\nvar xhr = function xhrAdapter(config) {\n  return new _Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n    var loadEvent = 'onreadystatechange';\n    var xDomain = false;\n\n    // For IE 8/9 CORS support\n    // Only supports POST and GET calls and doesn't returns the response headers.\n    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.\n    if (process.env.NODE_ENV !== 'test' && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {\n      request = new window.XDomainRequest();\n      loadEvent = 'onload';\n      xDomain = true;\n      request.onprogress = function handleProgress() {};\n      request.ontimeout = function handleTimeout() {};\n    }\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa$1(username + ':' + password);\n    }\n\n    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request[loadEvent] = function handleLoad() {\n      if (!request || request.readyState !== 4 && !xDomain) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)\n        status: request.status === 1223 ? 204 : request.status,\n        statusText: request.status === 1223 ? 'No Content' : request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies$$1 = cookies;\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies$$1.read(config.xsrfCookieName) : undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (config.withCredentials) {\n      request.withCredentials = true;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = xhr;\n  } else if (typeof process !== 'undefined') {\n    // For node use HTTP adapter\n    adapter = xhr;\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return _JSON$stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) {/* Ignore */}\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nvar defaults_1 = defaults;\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nvar InterceptorManager_1 = InterceptorManager;\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nvar transformData = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n\nvar isCancel = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\n\nvar isAbsoluteURL = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return (/^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url)\n  );\n};\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\n\nvar combineURLs = function combineURLs(baseURL, relativeURL) {\n  return relativeURL ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '') : baseURL;\n};\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nvar dispatchRequest = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Support baseURL config\n  if (config.baseURL && !isAbsoluteURL(config.url)) {\n    config.url = combineURLs(config.baseURL, config.url);\n  }\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(config.data, config.headers, config.transformRequest);\n\n  // Flatten headers\n  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});\n\n  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {\n    delete config.headers[method];\n  });\n\n  var adapter = config.adapter || defaults_1.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(response.data, response.headers, config.transformResponse);\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);\n      }\n    }\n\n    return _Promise.reject(reason);\n  });\n};\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager_1(),\n    response: new InterceptorManager_1()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = utils.merge({\n      url: arguments[0]\n    }, arguments[1]);\n  }\n\n  config = utils.merge(defaults_1, { method: 'get' }, this.defaults, config);\n  config.method = config.method.toLowerCase();\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = _Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function (url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function (url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nvar Axios_1 = Axios;\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\n\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nvar Cancel_1 = Cancel;\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new _Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel_1(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nvar CancelToken_1 = CancelToken;\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\n\nvar spread = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios_1(defaultConfig);\n  var instance = bind(Axios_1.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios_1.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults_1);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios_1;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(utils.merge(defaults_1, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = Cancel_1;\naxios.CancelToken = CancelToken_1;\naxios.isCancel = isCancel;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return _Promise.all(promises);\n};\naxios.spread = spread;\n\nvar axios_1 = axios;\n\n// Allow use of default import syntax in TypeScript\nvar default_1 = axios;\naxios_1.default = default_1;\n\nvar axios$1 = axios_1;\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nvar _copyArray = copyArray;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeFloor = Math.floor,\n    nativeRandom = Math.random;\n\n/**\n * The base implementation of `_.random` without support for returning\n * floating-point numbers.\n *\n * @private\n * @param {number} lower The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the random number.\n */\nfunction baseRandom(lower, upper) {\n  return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n}\n\nvar _baseRandom = baseRandom;\n\n/**\n * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n *\n * @private\n * @param {Array} array The array to shuffle.\n * @param {number} [size=array.length] The size of `array`.\n * @returns {Array} Returns `array`.\n */\nfunction shuffleSelf(array, size) {\n  var index = -1,\n      length = array.length,\n      lastIndex = length - 1;\n\n  size = size === undefined ? length : size;\n  while (++index < size) {\n    var rand = _baseRandom(index, lastIndex),\n        value = array[rand];\n\n    array[rand] = array[index];\n    array[index] = value;\n  }\n  array.length = size;\n  return array;\n}\n\nvar _shuffleSelf = shuffleSelf;\n\n/**\n * A specialized version of `_.shuffle` for arrays.\n *\n * @private\n * @param {Array} array The array to shuffle.\n * @returns {Array} Returns the new shuffled array.\n */\nfunction arrayShuffle(array) {\n  return _shuffleSelf(_copyArray(array));\n}\n\nvar _arrayShuffle = arrayShuffle;\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nvar _arrayMap = arrayMap;\n\n/**\n * The base implementation of `_.values` and `_.valuesIn` which creates an\n * array of `object` property values corresponding to the property names\n * of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the array of property values.\n */\nfunction baseValues(object, props) {\n  return _arrayMap(props, function(key) {\n    return object[key];\n  });\n}\n\nvar _baseValues = baseValues;\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nvar _baseTimes = baseTimes;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\nvar _freeGlobal = freeGlobal;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = _freeGlobal || freeSelf || Function('return this')();\n\nvar _root = root;\n\n/** Built-in value references. */\nvar Symbol$1 = _root.Symbol;\n\nvar _Symbol$1 = Symbol$1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$1 = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = _Symbol$1 ? _Symbol$1.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty$1.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nvar _getRawTag = getRawTag;\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$1.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString$1.call(value);\n}\n\nvar _objectToString = objectToString;\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag$1 = _Symbol$1 ? _Symbol$1.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag$1 && symToStringTag$1 in Object(value))\n    ? _getRawTag(value)\n    : _objectToString(value);\n}\n\nvar _baseGetTag = baseGetTag;\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nvar isObjectLike_1 = isObjectLike;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike_1(value) && _baseGetTag(value) == argsTag;\n}\n\nvar _baseIsArguments = baseIsArguments;\n\n/** Used for built-in method references. */\nvar objectProto$2 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$2 = objectProto$2.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto$2.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {\n  return isObjectLike_1(value) && hasOwnProperty$2.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nvar isArguments_1 = isArguments;\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray$1 = Array.isArray;\n\nvar isArray_1 = isArray$1;\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nvar stubFalse_1 = stubFalse;\n\nvar isBuffer_1$1 = createCommonjsModule(function (module, exports) {\n/** Detect free variable `exports`. */\nvar freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? _root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse_1;\n\nmodule.exports = isBuffer;\n});\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nvar _isIndex = isIndex;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER$1 = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;\n}\n\nvar isLength_1 = isLength;\n\n/** `Object#toString` result references. */\nvar argsTag$1 = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike_1(value) &&\n    isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];\n}\n\nvar _baseIsTypedArray = baseIsTypedArray;\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nvar _baseUnary = baseUnary;\n\nvar _nodeUtil = createCommonjsModule(function (module, exports) {\n/** Detect free variable `exports`. */\nvar freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && _freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n});\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;\n\nvar isTypedArray_1 = isTypedArray;\n\n/** Used for built-in method references. */\nvar objectProto$3 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$3 = objectProto$3.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray_1(value),\n      isArg = !isArr && isArguments_1(value),\n      isBuff = !isArr && !isArg && isBuffer_1$1(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? _baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty$3.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           _isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nvar _arrayLikeKeys = arrayLikeKeys;\n\n/** Used for built-in method references. */\nvar objectProto$4 = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$4;\n\n  return value === proto;\n}\n\nvar _isPrototype = isPrototype;\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nvar _overArg = overArg;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = _overArg(Object.keys, Object);\n\nvar _nativeKeys = nativeKeys;\n\n/** Used for built-in method references. */\nvar objectProto$5 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$4 = objectProto$5.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!_isPrototype(object)) {\n    return _nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty$4.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nvar _baseKeys = baseKeys;\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject$1(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nvar isObject_1 = isObject$1;\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag$1 = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction$1(value) {\n  if (!isObject_1(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = _baseGetTag(value);\n  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nvar isFunction_1 = isFunction$1;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength_1(value.length) && !isFunction_1(value);\n}\n\nvar isArrayLike_1 = isArrayLike;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);\n}\n\nvar keys_1 = keys;\n\n/**\n * Creates an array of the own enumerable string keyed property values of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property values.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.values(new Foo);\n * // => [1, 2] (iteration order is not guaranteed)\n *\n * _.values('hi');\n * // => ['h', 'i']\n */\nfunction values(object) {\n  return object == null ? [] : _baseValues(object, keys_1(object));\n}\n\nvar values_1 = values;\n\n/**\n * The base implementation of `_.shuffle`.\n *\n * @private\n * @param {Array|Object} collection The collection to shuffle.\n * @returns {Array} Returns the new shuffled array.\n */\nfunction baseShuffle(collection) {\n  return _shuffleSelf(values_1(collection));\n}\n\nvar _baseShuffle = baseShuffle;\n\n/**\n * Creates an array of shuffled values, using a version of the\n * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to shuffle.\n * @returns {Array} Returns the new shuffled array.\n * @example\n *\n * _.shuffle([1, 2, 3, 4]);\n * // => [4, 1, 3, 2]\n */\nfunction shuffle(collection) {\n  var func = isArray_1(collection) ? _arrayShuffle : _baseShuffle;\n  return func(collection);\n}\n\nvar shuffle_1 = shuffle;\n\n// most Object methods by ES6 should accept primitives\n\n\n\nvar _objectSap = function (KEY, exec) {\n  var fn = (_core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  _export(_export.S + _export.F * _fails(function () { fn(1); }), 'Object', exp);\n};\n\n// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n\nvar $getOwnPropertyDescriptor$1 = _objectGopd.f;\n\n_objectSap('getOwnPropertyDescriptor', function () {\n  return function getOwnPropertyDescriptor(it, key) {\n    return $getOwnPropertyDescriptor$1(_toIobject(it), key);\n  };\n});\n\nvar $Object$1 = _core.Object;\nvar getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n  return $Object$1.getOwnPropertyDescriptor(it, key);\n};\n\nvar getOwnPropertyDescriptor$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": getOwnPropertyDescriptor, __esModule: true };\n});\n\nvar _Object$getOwnPropertyDescriptor = unwrapExports(getOwnPropertyDescriptor$1);\n\nvar toArray = createCommonjsModule(function (module, exports) {\n\nexports.__esModule = true;\n\n\n\nvar _from2 = _interopRequireDefault(from$1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (arr) {\n  return Array.isArray(arr) ? arr : (0, _from2.default)(arr);\n};\n});\n\nvar _toArray = unwrapExports(toArray);\n\nvar stateMachine = createCommonjsModule(function (module, exports) {\n/*\n\n  Javascript State Machine Library - https://github.com/jakesgordon/javascript-state-machine\n\n  Copyright (c) 2012, 2013, 2014, 2015, Jake Gordon and contributors\n  Released under the MIT license - https://github.com/jakesgordon/javascript-state-machine/blob/master/LICENSE\n\n*/\n\n(function () {\n\n  var StateMachine = {\n\n    //---------------------------------------------------------------------------\n\n    VERSION: \"2.4.0\",\n\n    //---------------------------------------------------------------------------\n\n    Result: {\n      SUCCEEDED:    1, // the event transitioned successfully from one state to another\n      NOTRANSITION: 2, // the event was successfull but no state transition was necessary\n      CANCELLED:    3, // the event was cancelled by the caller in a beforeEvent callback\n      PENDING:      4  // the event is asynchronous and the caller is in control of when the transition occurs\n    },\n\n    Error: {\n      INVALID_TRANSITION: 100, // caller tried to fire an event that was innapropriate in the current state\n      PENDING_TRANSITION: 200, // caller tried to fire an event while an async transition was still pending\n      INVALID_CALLBACK:   300 // caller provided callback function threw an exception\n    },\n\n    WILDCARD: '*',\n    ASYNC: 'async',\n\n    //---------------------------------------------------------------------------\n\n    create: function(cfg, target) {\n\n      var initial      = (typeof cfg.initial == 'string') ? { state: cfg.initial } : cfg.initial; // allow for a simple string, or an object with { state: 'foo', event: 'setup', defer: true|false }\n      var terminal     = cfg.terminal || cfg['final'];\n      var fsm          = target || cfg.target  || {};\n      var events       = cfg.events || [];\n      var callbacks    = cfg.callbacks || {};\n      var map          = {}; // track state transitions allowed for an event { event: { from: [ to ] } }\n      var transitions  = {}; // track events allowed from a state            { state: [ event ] }\n\n      var add = function(e) {\n        var from = Array.isArray(e.from) ? e.from : (e.from ? [e.from] : [StateMachine.WILDCARD]); // allow 'wildcard' transition if 'from' is not specified\n        map[e.name] = map[e.name] || {};\n        for (var n = 0 ; n < from.length ; n++) {\n          transitions[from[n]] = transitions[from[n]] || [];\n          transitions[from[n]].push(e.name);\n\n          map[e.name][from[n]] = e.to || from[n]; // allow no-op transition if 'to' is not specified\n        }\n        if (e.to)\n          transitions[e.to] = transitions[e.to] || [];\n      };\n\n      if (initial) {\n        initial.event = initial.event || 'startup';\n        add({ name: initial.event, from: 'none', to: initial.state });\n      }\n\n      for(var n = 0 ; n < events.length ; n++)\n        add(events[n]);\n\n      for(var name in map) {\n        if (map.hasOwnProperty(name))\n          fsm[name] = StateMachine.buildEvent(name, map[name]);\n      }\n\n      for(var name in callbacks) {\n        if (callbacks.hasOwnProperty(name))\n          fsm[name] = callbacks[name];\n      }\n\n      fsm.current     = 'none';\n      fsm.is          = function(state) { return Array.isArray(state) ? (state.indexOf(this.current) >= 0) : (this.current === state); };\n      fsm.can         = function(event) { return !this.transition && (map[event] !== undefined) && (map[event].hasOwnProperty(this.current) || map[event].hasOwnProperty(StateMachine.WILDCARD)); };\n      fsm.cannot      = function(event) { return !this.can(event); };\n      fsm.transitions = function()      { return (transitions[this.current] || []).concat(transitions[StateMachine.WILDCARD] || []); };\n      fsm.isFinished  = function()      { return this.is(terminal); };\n      fsm.error       = cfg.error || function(name, from, to, args, error, msg, e) { throw e || msg; }; // default behavior when something unexpected happens is to throw an exception, but caller can override this behavior if desired (see github issue #3 and #17)\n      fsm.states      = function() { return Object.keys(transitions).sort() };\n\n      if (initial && !initial.defer)\n        fsm[initial.event]();\n\n      return fsm;\n\n    },\n\n    //===========================================================================\n\n    doCallback: function(fsm, func, name, from, to, args) {\n      if (func) {\n        try {\n          return func.apply(fsm, [name, from, to].concat(args));\n        }\n        catch(e) {\n          return fsm.error(name, from, to, args, StateMachine.Error.INVALID_CALLBACK, \"an exception occurred in a caller-provided callback function\", e);\n        }\n      }\n    },\n\n    beforeAnyEvent:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onbeforeevent'],                       name, from, to, args); },\n    afterAnyEvent:   function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onafterevent'] || fsm['onevent'],      name, from, to, args); },\n    leaveAnyState:   function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onleavestate'],                        name, from, to, args); },\n    enterAnyState:   function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onenterstate'] || fsm['onstate'],      name, from, to, args); },\n    changeState:     function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onchangestate'],                       name, from, to, args); },\n\n    beforeThisEvent: function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onbefore' + name],                     name, from, to, args); },\n    afterThisEvent:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onafter'  + name] || fsm['on' + name], name, from, to, args); },\n    leaveThisState:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onleave'  + from],                     name, from, to, args); },\n    enterThisState:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onenter'  + to]   || fsm['on' + to],   name, from, to, args); },\n\n    beforeEvent: function(fsm, name, from, to, args) {\n      if ((false === StateMachine.beforeThisEvent(fsm, name, from, to, args)) ||\n          (false === StateMachine.beforeAnyEvent( fsm, name, from, to, args)))\n        return false;\n    },\n\n    afterEvent: function(fsm, name, from, to, args) {\n      StateMachine.afterThisEvent(fsm, name, from, to, args);\n      StateMachine.afterAnyEvent( fsm, name, from, to, args);\n    },\n\n    leaveState: function(fsm, name, from, to, args) {\n      var specific = StateMachine.leaveThisState(fsm, name, from, to, args),\n          general  = StateMachine.leaveAnyState( fsm, name, from, to, args);\n      if ((false === specific) || (false === general))\n        return false;\n      else if ((StateMachine.ASYNC === specific) || (StateMachine.ASYNC === general))\n        return StateMachine.ASYNC;\n    },\n\n    enterState: function(fsm, name, from, to, args) {\n      StateMachine.enterThisState(fsm, name, from, to, args);\n      StateMachine.enterAnyState( fsm, name, from, to, args);\n    },\n\n    //===========================================================================\n\n    buildEvent: function(name, map) {\n      return function() {\n\n        var from  = this.current;\n        var to    = map[from] || (map[StateMachine.WILDCARD] != StateMachine.WILDCARD ? map[StateMachine.WILDCARD] : from) || from;\n        var args  = Array.prototype.slice.call(arguments); // turn arguments into pure array\n\n        if (this.transition)\n          return this.error(name, from, to, args, StateMachine.Error.PENDING_TRANSITION, \"event \" + name + \" inappropriate because previous transition did not complete\");\n\n        if (this.cannot(name))\n          return this.error(name, from, to, args, StateMachine.Error.INVALID_TRANSITION, \"event \" + name + \" inappropriate in current state \" + this.current);\n\n        if (false === StateMachine.beforeEvent(this, name, from, to, args))\n          return StateMachine.Result.CANCELLED;\n\n        if (from === to) {\n          StateMachine.afterEvent(this, name, from, to, args);\n          return StateMachine.Result.NOTRANSITION;\n        }\n\n        // prepare a transition method for use EITHER lower down, or by caller if they want an async transition (indicated by an ASYNC return value from leaveState)\n        var fsm = this;\n        this.transition = function() {\n          fsm.transition = null; // this method should only ever be called once\n          fsm.current = to;\n          StateMachine.enterState( fsm, name, from, to, args);\n          StateMachine.changeState(fsm, name, from, to, args);\n          StateMachine.afterEvent( fsm, name, from, to, args);\n          return StateMachine.Result.SUCCEEDED;\n        };\n        this.transition.cancel = function() { // provide a way for caller to cancel async transition if desired (issue #22)\n          fsm.transition = null;\n          StateMachine.afterEvent(fsm, name, from, to, args);\n        };\n\n        var leave = StateMachine.leaveState(this, name, from, to, args);\n        if (false === leave) {\n          this.transition = null;\n          return StateMachine.Result.CANCELLED;\n        }\n        else if (StateMachine.ASYNC === leave) {\n          return StateMachine.Result.PENDING;\n        }\n        else {\n          if (this.transition) // need to check in case user manually called transition() but forgot to return StateMachine.ASYNC\n            return this.transition();\n        }\n\n      };\n    }\n\n  }; // StateMachine\n\n  //===========================================================================\n\n  //======\n  // NODE\n  //======\n  {\n    if ('object' !== 'undefined' && module.exports) {\n      exports = module.exports = StateMachine;\n    }\n    exports.StateMachine = StateMachine;\n  }\n\n}());\n});\nvar stateMachine_1 = stateMachine.StateMachine;\n\nvar getWeak = _meta.getWeak;\n\n\n\n\n\n\n\nvar arrayFind = _arrayMethods(5);\nvar arrayFindIndex = _arrayMethods(6);\nvar id$1 = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function (that) {\n  return that._l || (that._l = new UncaughtFrozenStore());\n};\nvar UncaughtFrozenStore = function () {\n  this.a = [];\n};\nvar findUncaughtFrozen = function (store, key) {\n  return arrayFind(store.a, function (it) {\n    return it[0] === key;\n  });\n};\nUncaughtFrozenStore.prototype = {\n  get: function (key) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) return entry[1];\n  },\n  has: function (key) {\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function (key, value) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) entry[1] = value;\n    else this.a.push([key, value]);\n  },\n  'delete': function (key) {\n    var index = arrayFindIndex(this.a, function (it) {\n      return it[0] === key;\n    });\n    if (~index) this.a.splice(index, 1);\n    return !!~index;\n  }\n};\n\nvar _collectionWeak = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      _anInstance(that, C, NAME, '_i');\n      that._t = NAME;      // collection type\n      that._i = id$1++;      // collection id\n      that._l = undefined; // leak store for uncaught frozen objects\n      if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    _redefineAll(C.prototype, {\n      // 23.3.3.2 WeakMap.prototype.delete(key)\n      // 23.4.3.3 WeakSet.prototype.delete(value)\n      'delete': function (key) {\n        if (!_isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(_validateCollection(this, NAME))['delete'](key);\n        return data && _has(data, this._i) && delete data[this._i];\n      },\n      // 23.3.3.4 WeakMap.prototype.has(key)\n      // 23.4.3.4 WeakSet.prototype.has(value)\n      has: function has(key) {\n        if (!_isObject(key)) return false;\n        var data = getWeak(key);\n        if (data === true) return uncaughtFrozenStore(_validateCollection(this, NAME)).has(key);\n        return data && _has(data, this._i);\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var data = getWeak(_anObject(key), true);\n    if (data === true) uncaughtFrozenStore(that).set(key, value);\n    else data[that._i] = value;\n    return that;\n  },\n  ufstore: uncaughtFrozenStore\n};\n\nvar es6_weakMap = createCommonjsModule(function (module) {\nvar each = _arrayMethods(0);\n\n\n\n\n\n\n\nvar WEAK_MAP = 'WeakMap';\nvar getWeak = _meta.getWeak;\nvar isExtensible = Object.isExtensible;\nvar uncaughtFrozenStore = _collectionWeak.ufstore;\nvar tmp = {};\nvar InternalMap;\n\nvar wrapper = function (get) {\n  return function WeakMap() {\n    return get(this, arguments.length > 0 ? arguments[0] : undefined);\n  };\n};\n\nvar methods = {\n  // 23.3.3.3 WeakMap.prototype.get(key)\n  get: function get(key) {\n    if (_isObject(key)) {\n      var data = getWeak(key);\n      if (data === true) return uncaughtFrozenStore(_validateCollection(this, WEAK_MAP)).get(key);\n      return data ? data[this._i] : undefined;\n    }\n  },\n  // 23.3.3.5 WeakMap.prototype.set(key, value)\n  set: function set(key, value) {\n    return _collectionWeak.def(_validateCollection(this, WEAK_MAP), key, value);\n  }\n};\n\n// 23.3 WeakMap Objects\nvar $WeakMap = module.exports = _collection(WEAK_MAP, wrapper, methods, _collectionWeak, true, true);\n\n// IE11 WeakMap frozen keys fix\nif (_fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {\n  InternalMap = _collectionWeak.getConstructor(wrapper, WEAK_MAP);\n  _objectAssign(InternalMap.prototype, methods);\n  _meta.NEED = true;\n  each(['delete', 'has', 'get', 'set'], function (key) {\n    var proto = $WeakMap.prototype;\n    var method = proto[key];\n    _redefine(proto, key, function (a, b) {\n      // store frozen objects on internal weakmap shim\n      if (_isObject(a) && !isExtensible(a)) {\n        if (!this._f) this._f = new InternalMap();\n        var result = this._f[key](a, b);\n        return key == 'set' ? this : result;\n      // store all the rest on native weakmap\n      } return method.call(this, a, b);\n    });\n  });\n}\n});\n\n// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of\n_setCollectionOf('WeakMap');\n\n// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from\n_setCollectionFrom('WeakMap');\n\nvar weakMap = _core.WeakMap;\n\nvar weakMap$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": weakMap, __esModule: true };\n});\n\nvar _WeakMap = unwrapExports(weakMap$1);\n\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n_export(_export.S + _export.F * !_descriptors, 'Object', { defineProperty: _objectDp.f });\n\nvar $Object$2 = _core.Object;\nvar defineProperty$1 = function defineProperty(it, key, desc) {\n  return $Object$2.defineProperty(it, key, desc);\n};\n\nvar defineProperty$2 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": defineProperty$1, __esModule: true };\n});\n\nvar _Object$defineProperty = unwrapExports(defineProperty$2);\n\nvar defineProperty$3 = createCommonjsModule(function (module, exports) {\n\nexports.__esModule = true;\n\n\n\nvar _defineProperty2 = _interopRequireDefault(defineProperty$2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (obj, key, value) {\n  if (key in obj) {\n    (0, _defineProperty2.default)(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n});\n\nvar _defineProperty = unwrapExports(defineProperty$3);\n\n// 19.1.2.14 Object.keys(O)\n\n\n\n_objectSap('keys', function () {\n  return function keys(it) {\n    return _objectKeys(_toObject(it));\n  };\n});\n\nvar keys$1 = _core.Object.keys;\n\nvar keys$2 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": keys$1, __esModule: true };\n});\n\nvar _Object$keys = unwrapExports(keys$2);\n\n/** Built-in value references. */\nvar getPrototype = _overArg(Object.getPrototypeOf, Object);\n\nvar _getPrototype = getPrototype;\n\n/** `Object#toString` result references. */\nvar objectTag$1 = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto$6 = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$5 = objectProto$6.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag$1) {\n    return false;\n  }\n  var proto = _getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty$5.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nvar isPlainObject_1 = isPlainObject;\n\n/* eslint-disable */\nvar global$1 = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : {};\n\nvar createClass = createCommonjsModule(function (module, exports) {\n\nexports.__esModule = true;\n\n\n\nvar _defineProperty2 = _interopRequireDefault(defineProperty$2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      (0, _defineProperty2.default)(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n});\n\nvar _createClass = unwrapExports(createClass);\n\nvar EXPIRED = _Symbol('expired');\nvar debug$1 = browser('LC:Expirable');\n\nvar Expirable = function () {\n  function Expirable(value, ttl) {\n    _classCallCheck(this, Expirable);\n\n    this.originalValue = value;\n    if (typeof ttl === 'number') {\n      this.expiredAt = Date.now() + ttl;\n    }\n  }\n\n  _createClass(Expirable, [{\n    key: 'value',\n    get: function get() {\n      var expired = this.expiredAt && this.expiredAt <= Date.now();\n      if (expired) debug$1('expired: ' + this.originalValue);\n      return expired ? EXPIRED : this.originalValue;\n    }\n  }]);\n\n  return Expirable;\n}();\n\nExpirable.EXPIRED = EXPIRED;\n\nvar debug$2 = browser('LC:Cache');\n\nvar Cache = function () {\n  function Cache() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'anonymous';\n\n    _classCallCheck(this, Cache);\n\n    this.name = name;\n    this._map = {};\n  }\n\n  Cache.prototype.get = function get(key) {\n    var cache = this._map[key];\n    if (cache) {\n      var value = cache.value;\n\n      if (value !== Expirable.EXPIRED) {\n        debug$2('[%s] hit: %s', this.name, key);\n        return value;\n      }\n      delete this._map[key];\n    }\n    debug$2('[' + this.name + '] missed: ' + key);\n    return null;\n  };\n\n  Cache.prototype.set = function set(key, value, ttl) {\n    debug$2('[%s] set: %s %o %d', this.name, key, value, ttl);\n    this._map[key] = new Expirable(value, ttl);\n  };\n\n  return Cache;\n}();\n\nvar tryAll = function tryAll(promiseConstructors) {\n  var promise = new _Promise(promiseConstructors[0]);\n  if (promiseConstructors.length === 1) {\n    return promise;\n  }\n  return promise.catch(function () {\n    return tryAll(promiseConstructors.slice(1));\n  });\n};\n\n// eslint-disable-next-line no-sequences\nvar tap = function tap(interceptor) {\n  return function (value) {\n    return interceptor(value), value;\n  };\n};\n\nvar finalize = function finalize(callback) {\n  return [\n  // eslint-disable-next-line no-sequences\n  function (value) {\n    return callback(), value;\n  }, function (error) {\n    callback();\n    throw error;\n  }];\n};\n\n/**\n * 将对象转换为 Date，支持 string、number、ProtoBuf Long 以及 LeanCloud 的 Date 类型，\n * 其他情况下（包括对象为 falsy）返回原值。\n * @private\n */\nvar decodeDate = function decodeDate(date) {\n  if (!date) return date;\n  if (typeof date === 'string' || typeof date === 'number') {\n    return new Date(date);\n  }\n  if (date.__type === 'Date' && date.iso) {\n    return new Date(date.iso);\n  }\n  // Long\n  if (typeof date.toNumber === 'function') {\n    return new Date(date.toNumber());\n  }\n  return date;\n};\n/**\n * 获取 Date 的毫秒数，如果不是一个 Date 返回 undefined。\n * @private\n */\nvar getTime = function getTime(date) {\n  return date && date.getTime ? date.getTime() : undefined;\n};\n\n/**\n * 解码对象中的 LeanCloud 数据结构。\n * 目前仅会处理 Date 类型。\n * @private\n */\nvar decode = function decode(value) {\n  if (!value) return value;\n  if (value.__type === 'Date' && value.iso) {\n    return new Date(value.iso);\n  }\n  if (isPlainObject_1(value)) {\n    return _Object$keys(value).reduce(function (result, key) {\n      return _extends$1({}, result, _defineProperty({}, key, decode(value[key])));\n    }, {});\n  }\n  return value;\n};\n/**\n * 将对象中的特殊类型编码为 LeanCloud 数据结构。\n * 目前仅会处理 Date 类型。\n * @private\n */\nvar encode$1 = function encode(value) {\n  if (value instanceof Date) return { __type: 'Date', iso: value.toJSON() };\n  if (isPlainObject_1(value)) {\n    return _Object$keys(value).reduce(function (result, key) {\n      return _extends$1({}, result, _defineProperty({}, key, encode(value[key])));\n    }, {});\n  }\n  return value;\n};\n\nvar keyRemap = function keyRemap(keymap, obj) {\n  return _Object$keys(obj).reduce(function (newObj, key) {\n    var newKey = keymap[key] || key;\n    return _Object$assign(newObj, _defineProperty({}, newKey, obj[key]));\n  }, {});\n};\n\nvar isIE10 = global$1.navigator && global$1.navigator.userAgent && global$1.navigator.userAgent.indexOf('MSIE 10.') !== -1;\n\n/* eslint-disable no-proto */\nvar getStaticProperty = function getStaticProperty(klass, property) {\n  return klass[property] || (klass.__proto__ ? getStaticProperty(klass.__proto__, property) : undefined);\n};\n/* eslint-enable no-proto */\n\nvar union = function union(a, b) {\n  return _Array$from(new _Set([].concat(_toConsumableArray(a), _toConsumableArray(b))));\n};\nvar difference = function difference(a, b) {\n  return _Array$from(function (bSet) {\n    return new _Set(a.filter(function (x) {\n      return !bSet.has(x);\n    }));\n  }(new _Set(b)));\n};\n\nvar map = new _WeakMap();\n\n// protected property helper\nvar internal = function internal(object) {\n  if (!map.has(object)) {\n    map.set(object, {});\n  }\n  return map.get(object);\n};\n\nvar compact = function compact(obj, filter) {\n  if (!isPlainObject_1(obj)) return obj;\n  var object = _Object$assign({}, obj);\n  // eslint-disable-next-line no-restricted-syntax\n  for (var prop in object) {\n    if ({}.hasOwnProperty.call(object, prop)) {\n      var value = object[prop];\n      if (value === filter) {\n        delete object[prop];\n      } else {\n        object[prop] = compact(value, filter);\n      }\n    }\n  }\n  return object;\n};\n\n// debug utility\nvar removeNull = function removeNull(obj) {\n  return compact(obj, null);\n};\nvar trim$1 = function trim(message) {\n  return removeNull(JSON.parse(_JSON$stringify(message)));\n};\n\nvar ensureArray = function ensureArray(target) {\n  if (Array.isArray(target)) {\n    return target;\n  }\n  if (target === undefined || target === null) {\n    return [];\n  }\n  return [target];\n};\n\nvar setValue = function setValue(target, key, value) {\n  // '.' is not allowed in Class keys, escaping is not in concern now.\n  var segs = key.split('.');\n  var lastSeg = segs.pop();\n  var currentTarget = target;\n  segs.forEach(function (seg) {\n    if (currentTarget[seg] === undefined) currentTarget[seg] = {};\n    currentTarget = currentTarget[seg];\n  });\n  currentTarget[lastSeg] = value;\n  return target;\n};\n\nvar isWeapp =\n// eslint-disable-next-line no-undef\n(typeof wx === 'undefined' ? 'undefined' : _typeof(wx)) === 'object' && typeof wx.connectSocket === 'function';\n\n// throttle decorator\nvar throttle = function throttle(wait) {\n  return function (target, property, descriptor) {\n    var callback = descriptor.value;\n    // very naive, internal use only\n    if (callback.length) {\n      throw new Error('throttled function should not accept any arguments');\n    }\n    return _extends$1({}, descriptor, {\n      value: function value() {\n        var _this = this;\n\n        var _internal = internal(this),\n            throttleMeta = _internal.throttleMeta;\n\n        if (!throttleMeta) {\n          throttleMeta = {};\n          internal(this).throttleMeta = throttleMeta;\n        }\n        var _throttleMeta = throttleMeta,\n            propertyMeta = _throttleMeta[property];\n\n        if (!propertyMeta) {\n          propertyMeta = {};\n          throttleMeta[property] = propertyMeta;\n        }\n        var _propertyMeta = propertyMeta,\n            _propertyMeta$previou = _propertyMeta.previouseTimestamp,\n            previouseTimestamp = _propertyMeta$previou === undefined ? 0 : _propertyMeta$previou,\n            timeout = _propertyMeta.timeout;\n\n        var now = Date.now();\n        var remainingTime = wait - (now - previouseTimestamp);\n        if (remainingTime <= 0) {\n          throttleMeta[property].previouseTimestamp = now;\n          callback.apply(this);\n        } else if (!timeout) {\n          propertyMeta.timeout = setTimeout(function () {\n            propertyMeta.previouseTimestamp = Date.now();\n            delete propertyMeta.timeout;\n            callback.apply(_this);\n          }, remainingTime);\n        }\n      }\n    });\n  };\n};\n\nvar WebSocket = global$1.WebSocket || global$1.MozWebSocket;\n\nvar _class;\n\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n\nvar debug$3 = browser('LC:WebSocketPlus');\n\nvar OPEN = 'open';\nvar DISCONNECT = 'disconnect';\nvar RECONNECT = 'reconnect';\nvar RETRY = 'retry';\nvar SCHEDULE = 'schedule';\nvar OFFLINE = 'offline';\nvar ONLINE = 'online';\nvar ERROR = 'error';\nvar MESSAGE = 'message';\n\nvar HEARTBEAT_TIME = 180000;\nvar TIMEOUT_TIME = 380000;\n\nvar DEFAULT_RETRY_STRATEGY = function DEFAULT_RETRY_STRATEGY(attempt) {\n  return Math.min(1000 * Math.pow(2, attempt), 300000);\n};\n\nvar requireConnected = function requireConnected(target, name, descriptor) {\n  return _Object$assign({}, descriptor, {\n    value: function requireConnectedWrapper() {\n      var _descriptor$value;\n\n      this.checkConnectionAvailability(name);\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return (_descriptor$value = descriptor.value).call.apply(_descriptor$value, [this].concat(args));\n    }\n  });\n};\n\nvar WebSocketPlus = (_class = function (_EventEmitter) {\n  _inherits(WebSocketPlus, _EventEmitter);\n\n  function WebSocketPlus(getUrls, protocol) {\n    _classCallCheck(this, WebSocketPlus);\n\n    if (typeof WebSocket === 'undefined') {\n      throw new Error('WebSocket is undefined. Polyfill is required in this runtime.');\n    }\n\n    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));\n\n    _this.init();\n    _this._protocol = protocol;\n    _Promise.resolve(typeof getUrls === 'function' ? getUrls() : getUrls).then(ensureArray).then(function (urls) {\n      _this._urls = urls;\n      return _this._open();\n    }).then(function () {\n      _this.__postponeTimeoutTimer = _this._postponeTimeoutTimer.bind(_this);\n      if (global$1.addEventListener) {\n        _this.__pause = function () {\n          return _this.pause();\n        };\n        _this.__resume = function () {\n          return _this.resume();\n        };\n        global$1.addEventListener('offline', _this.__pause);\n        global$1.addEventListener('online', _this.__resume);\n      }\n      _this.open();\n    }).catch(_this.throw.bind(_this));\n    return _this;\n  }\n\n  WebSocketPlus.prototype._open = function _open() {\n    var _this2 = this;\n\n    return this._createWs(this._urls, this._protocol).then(function (ws) {\n      var _urls = _toArray(_this2._urls),\n          first = _urls[0],\n          reset = _urls.slice(1);\n\n      _this2._urls = [].concat(_toConsumableArray(reset), [first]);\n      return ws;\n    });\n  };\n\n  WebSocketPlus.prototype._createWs = function _createWs(urls, protocol) {\n    var _this3 = this;\n\n    return tryAll(urls.map(function (url) {\n      return function (resolve, reject) {\n        debug$3('connect [' + url + '] ' + protocol);\n        var ws = protocol ? new WebSocket(url, protocol) : new WebSocket(url);\n        ws.binaryType = _this3.binaryType || 'arraybuffer';\n        ws.onopen = function () {\n          return resolve(ws);\n        };\n        ws.onclose = function (error) {\n          if (error instanceof Error) {\n            return reject(error);\n          }\n          // in browser, error event is useless\n          return reject(new Error('Failed to connect [' + url + ']'));\n        };\n        ws.onerror = ws.onclose;\n      };\n    })).then(function (ws) {\n      _this3._ws = ws;\n      _this3._ws.onclose = _this3._handleClose.bind(_this3);\n      _this3._ws.onmessage = _this3._handleMessage.bind(_this3);\n      return ws;\n    });\n  };\n\n  WebSocketPlus.prototype._destroyWs = function _destroyWs() {\n    var ws = this._ws;\n    if (!ws) return;\n    ws.onopen = null;\n    ws.onclose = null;\n    ws.onerror = null;\n    ws.onmessage = null;\n    this._ws = null;\n    ws.close();\n  };\n\n  // eslint-disable-next-line class-methods-use-this\n\n\n  WebSocketPlus.prototype.onbeforeevent = function onbeforeevent(event, from, to) {\n    for (var _len2 = arguments.length, payload = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n      payload[_key2 - 3] = arguments[_key2];\n    }\n\n    debug$3.apply(undefined, [event + ': ' + from + ' -> ' + to].concat(payload));\n  };\n\n  WebSocketPlus.prototype.onopen = function onopen() {\n    this.emit(OPEN);\n  };\n\n  WebSocketPlus.prototype.onconnected = function onconnected() {\n    this._startConnectionKeeper();\n  };\n\n  WebSocketPlus.prototype.onleaveconnected = function onleaveconnected(event, from, to) {\n    this._stopConnectionKeeper();\n    this._destroyWs();\n    if (to === 'offline' || to === 'disconnected') {\n      this.emit(DISCONNECT);\n    }\n  };\n\n  WebSocketPlus.prototype.onpause = function onpause() {\n    this.emit(OFFLINE);\n  };\n\n  WebSocketPlus.prototype.onbeforeresume = function onbeforeresume() {\n    this.emit(ONLINE);\n  };\n\n  WebSocketPlus.prototype.onreconnect = function onreconnect() {\n    this.emit(RECONNECT);\n  };\n\n  WebSocketPlus.prototype.ondisconnected = function ondisconnected(event, from, to) {\n    var _this4 = this;\n\n    var attempt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    var delay = DEFAULT_RETRY_STRATEGY.call(null, attempt);\n    debug$3('schedule attempt=' + attempt + ' delay=' + delay);\n    this.emit(SCHEDULE, attempt, delay);\n    if (this.__scheduledRetry) {\n      clearTimeout(this.__scheduledRetry);\n    }\n    this.__scheduledRetry = setTimeout(function () {\n      if (_this4.is('disconnected')) {\n        _this4.retry(attempt);\n      }\n    }, delay);\n  };\n\n  WebSocketPlus.prototype.onretry = function onretry(event, from, to) {\n    var _this5 = this;\n\n    var attempt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    this.emit(RETRY, attempt);\n    this._open().then(function () {\n      return _this5.can('reconnect') ? _this5.reconnect() : _this5._destroyWs();\n    }, function () {\n      return _this5.can('fail') && _this5.fail(attempt + 1);\n    });\n  };\n\n  WebSocketPlus.prototype.onerror = function onerror(event, from, to, error) {\n    this.emit(ERROR, error);\n  };\n\n  WebSocketPlus.prototype.onclose = function onclose() {\n    if (global$1.removeEventListener) {\n      if (this.__pause) global$1.removeEventListener('offline', this.__pause);\n      if (this.__resume) global$1.removeEventListener('online', this.__resume);\n    }\n  };\n\n  WebSocketPlus.prototype.checkConnectionAvailability = function checkConnectionAvailability() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'API';\n\n    if (!this.is('connected')) {\n      var currentState = this.current;\n      console.warn(name + ' should not be called when the connection is ' + currentState);\n      if (this.is('disconnected') || this.is('reconnecting')) {\n        console.warn('disconnect and reconnect event should be handled to avoid such calls.');\n      }\n      throw new Error('Connection unavailable');\n    }\n  };\n\n  // jsdoc-ignore-start\n\n\n  // jsdoc-ignore-end\n  WebSocketPlus.prototype._ping = function _ping() {\n    debug$3('ping');\n    try {\n      this.ping();\n    } catch (error) {\n      console.warn('websocket ping error: ' + error.message);\n    }\n  };\n\n  WebSocketPlus.prototype.ping = function ping() {\n    if (this._ws.ping) {\n      this._ws.ping();\n    } else {\n      console.warn('The WebSocket implement does not support sending ping frame.\\n        Override ping method to use application defined ping/pong mechanism.');\n    }\n  };\n\n  WebSocketPlus.prototype._postponeTimeoutTimer = function _postponeTimeoutTimer() {\n    var _this6 = this;\n\n    debug$3('_postponeTimeoutTimer');\n    this._clearTimeoutTimers();\n    this._timeoutTimer = setTimeout(function () {\n      debug$3('timeout');\n      _this6.disconnect();\n    }, TIMEOUT_TIME);\n  };\n\n  WebSocketPlus.prototype._clearTimeoutTimers = function _clearTimeoutTimers() {\n    if (this._timeoutTimer) {\n      clearTimeout(this._timeoutTimer);\n    }\n  };\n\n  WebSocketPlus.prototype._startConnectionKeeper = function _startConnectionKeeper() {\n    debug$3('start connection keeper');\n    this._heartbeatTimer = setInterval(this._ping.bind(this), HEARTBEAT_TIME);\n    var addListener = this._ws.addListener || this._ws.addEventListener;\n    addListener.call(this._ws, 'message', this.__postponeTimeoutTimer);\n    addListener.call(this._ws, 'pong', this.__postponeTimeoutTimer);\n    this._postponeTimeoutTimer();\n  };\n\n  WebSocketPlus.prototype._stopConnectionKeeper = function _stopConnectionKeeper() {\n    debug$3('stop connection keeper');\n    // websockets/ws#489\n    var removeListener = this._ws.removeListener || this._ws.removeEventListener;\n    removeListener.call(this._ws, 'message', this.__postponeTimeoutTimer);\n    removeListener.call(this._ws, 'pong', this.__postponeTimeoutTimer);\n    this._clearTimeoutTimers();\n    if (this._heartbeatTimer) {\n      clearInterval(this._heartbeatTimer);\n    }\n  };\n\n  WebSocketPlus.prototype._handleClose = function _handleClose(event) {\n    debug$3('ws closed [' + event.code + '] ' + event.reason);\n    // socket closed manually, ignore close event.\n    if (this.isFinished()) return;\n    this.handleClose(event);\n  };\n\n  WebSocketPlus.prototype.handleClose = function handleClose() {\n    // reconnect\n    this.disconnect();\n  };\n\n  // jsdoc-ignore-start\n\n\n  // jsdoc-ignore-end\n  WebSocketPlus.prototype.send = function send(data) {\n    debug$3('send', data);\n    this._ws.send(data);\n  };\n\n  WebSocketPlus.prototype._handleMessage = function _handleMessage(event) {\n    debug$3('message', event.data);\n    this.handleMessage(event.data);\n  };\n\n  WebSocketPlus.prototype.handleMessage = function handleMessage(message) {\n    this.emit(MESSAGE, message);\n  };\n\n  return WebSocketPlus;\n}(eventemitter3), _applyDecoratedDescriptor(_class.prototype, '_ping', [requireConnected], _Object$getOwnPropertyDescriptor(_class.prototype, '_ping'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'send', [requireConnected], _Object$getOwnPropertyDescriptor(_class.prototype, 'send'), _class.prototype), _class);\n\n\nstateMachine.create({\n  target: WebSocketPlus.prototype,\n  initial: {\n    state: 'initialized',\n    event: 'init',\n    defer: true\n  },\n  terminal: 'closed',\n  events: [{\n    name: 'open',\n    from: 'initialized',\n    to: 'connected'\n  }, {\n    name: 'disconnect',\n    from: 'connected',\n    to: 'disconnected'\n  }, {\n    name: 'retry',\n    from: 'disconnected',\n    to: 'reconnecting'\n  }, {\n    name: 'fail',\n    from: 'reconnecting',\n    to: 'disconnected'\n  }, {\n    name: 'reconnect',\n    from: 'reconnecting',\n    to: 'connected'\n  }, {\n    name: 'pause',\n    from: ['connected', 'disconnected', 'reconnecting'],\n    to: 'offline'\n  }, {}, {\n    name: 'resume',\n    from: 'offline',\n    to: 'disconnected'\n  }, {\n    name: 'close',\n    from: ['connected', 'disconnected', 'reconnecting', 'offline'],\n    to: 'closed'\n  }, {\n    name: 'throw',\n    from: '*',\n    to: 'error'\n  }]\n});\n\n// 19.1.2.5 Object.freeze(O)\n\nvar meta = _meta.onFreeze;\n\n_objectSap('freeze', function ($freeze) {\n  return function freeze(it) {\n    return $freeze && _isObject(it) ? $freeze(meta(it)) : it;\n  };\n});\n\nvar freeze = _core.Object.freeze;\n\nvar freeze$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": freeze, __esModule: true };\n});\n\nvar _Object$freeze = unwrapExports(freeze$1);\n\nvar error = _Object$freeze({\n  1000: {\n    name: 'CLOSE_NORMAL'\n  },\n  1006: {\n    name: 'CLOSE_ABNORMAL'\n  },\n  4100: {\n    name: 'APP_NOT_AVAILABLE',\n    message: 'App not exists or realtime message service is disabled.'\n  },\n  4102: {\n    name: 'SIGNATURE_FAILED',\n    message: 'Login signature mismatch.'\n  },\n  4103: {\n    name: 'INVALID_LOGIN',\n    message: 'Malformed clientId.'\n  },\n  4105: {\n    name: 'SESSION_REQUIRED',\n    message: 'Message sent before session opened.'\n  },\n  4107: {\n    name: 'READ_TIMEOUT'\n  },\n  4108: {\n    name: 'LOGIN_TIMEOUT'\n  },\n  4109: {\n    name: 'FRAME_TOO_LONG'\n  },\n  4110: {\n    name: 'INVALID_ORIGIN',\n    message: 'Access denied by domain whitelist.'\n  },\n  4111: {\n    name: 'SESSION_CONFLICT'\n  },\n  4112: {\n    name: 'SESSION_TOKEN_EXPIRED'\n  },\n  4113: {\n    name: 'APP_QUOTA_EXCEEDED',\n    message: 'The daily active users limit exceeded.'\n  },\n  4116: {\n    name: 'MESSAGE_SENT_QUOTA_EXCEEDED',\n    message: 'Command sent too fast.'\n  },\n  4200: {\n    name: 'INTERNAL_ERROR',\n    message: 'Internal error, please contact LeanCloud for support.'\n  },\n  4301: {\n    name: 'CONVERSATION_API_FAILED',\n    message: 'Upstream Conversatoin API failed, see error.detail for details.'\n  },\n  4302: {\n    name: 'CONVERSATION_SIGNATURE_FAILED',\n    message: 'Conversation action signature mismatch.'\n  },\n  4303: {\n    name: 'CONVERSATION_NOT_FOUND'\n  },\n  4304: {\n    name: 'CONVERSATION_FULL'\n  },\n  4305: {\n    name: 'CONVERSATION_REJECTED_BY_APP',\n    message: 'Conversation action rejected by hook.'\n  },\n  4306: {\n    name: 'CONVERSATION_UPDATE_FAILED'\n  },\n  4307: {\n    name: 'CONVERSATION_READ_ONLY'\n  },\n  4308: {\n    name: 'CONVERSATION_NOT_ALLOWED'\n  },\n  4309: {\n    name: 'CONVERSATION_UPDATE_REJECTED',\n    message: 'Conversation update rejected because the client is not a member.'\n  },\n  4310: {\n    name: 'CONVERSATION_QUERY_FAILED',\n    message: 'Conversation query failed because it is too expansive.'\n  },\n  4311: {\n    name: 'CONVERSATION_LOG_FAILED'\n  },\n  4312: {\n    name: 'CONVERSATION_LOG_REJECTED',\n    message: 'Message query rejected because the client is not a member of the conversation.'\n  },\n  4313: {\n    name: 'SYSTEM_CONVERSATION_REQUIRED'\n  },\n  4314: {\n    name: 'NORMAL_CONVERSATION_REQUIRED'\n  },\n  4315: {\n    name: 'CONVERSATION_BLACKLISTED',\n    message: 'Blacklisted in the conversation.'\n  },\n  4316: {\n    name: 'TRANSIENT_CONVERSATION_REQUIRED'\n  },\n  4317: {\n    name: 'CONVERSATION_MEMBERSHIP_REQUIRED'\n  },\n  4318: {\n    name: 'CONVERSATION_API_QUOTA_EXCEEDED',\n    message: 'LeanCloud API quota exceeded. You may upgrade your plan.'\n  },\n  4323: {\n    name: 'TEMPORARY_CONVERSATION_EXPIRED',\n    message: 'Temporary conversation expired or does not exist.'\n  },\n  4401: {\n    name: 'INVALID_MESSAGING_TARGET',\n    message: 'Conversation does not exist or client is not a member.'\n  },\n  4402: {\n    name: 'MESSAGE_REJECTED_BY_APP',\n    message: 'Message rejected by hook.'\n  },\n  4403: {\n    name: 'MESSAGE_OWNERSHIP_REQUIRED'\n  },\n  4404: {\n    name: 'MESSAGE_NOT_FOUND'\n  },\n  4405: {\n    name: 'MESSAGE_UPDATE_REJECTED_BY_APP',\n    message: 'Message update rejected by hook.'\n  },\n  4406: {\n    name: 'MESSAGE_EDIT_DISABLED'\n  },\n  4407: {\n    name: 'MESSAGE_RECALL_DISABLED'\n  }\n});\n\nvar ErrorCode = _Object$freeze(_Object$keys(error).reduce(function (result, code) {\n  return _Object$assign(result, _defineProperty({}, error[code].name, Number(code)));\n}, {}));\n\nvar createError$1 = function createError(_ref) {\n  var code = _ref.code,\n      reason = _ref.reason,\n      appCode = _ref.appCode,\n      detail = _ref.detail,\n      errorMessage = _ref.error;\n\n  var message = reason || detail || errorMessage;\n  var name = reason;\n  if (!message && error[code]) {\n    name = error[code].name;\n\n    message = error[code].message || name;\n  }\n  if (!message) {\n    message = 'Unknow Error: ' + code;\n  }\n  var err = new Error(message);\n  return _Object$assign(err, {\n    code: code,\n    appCode: appCode,\n    detail: detail,\n    name: name\n  });\n};\n\nvar debug$4 = browser('LC:Connection');\n\nvar COMMAND_TIMEOUT = 20000;\n\nvar Connection = function (_WebSocketPlus) {\n  _inherits(Connection, _WebSocketPlus);\n\n  function Connection(getUrl, _ref) {\n    var format = _ref.format,\n        version = _ref.version;\n\n    _classCallCheck(this, Connection);\n\n    debug$4('initializing Connection');\n    var protocolString = 'lc.' + format + '.' + version;\n    if (!isWeapp) {\n      var _this = _possibleConstructorReturn(this, _WebSocketPlus.call(this, getUrl, protocolString));\n    } else {\n      var _this = _possibleConstructorReturn(this, _WebSocketPlus.call(this, getUrl().then(function (urls) {\n        return urls.map(function (url) {\n          return '' + url + (url.indexOf('?') === -1 ? '?' : '&') + 'subprotocol=' + encodeURIComponent(protocolString);\n        });\n      })));\n    }\n    _this._protocalFormat = format;\n    _this._commands = {};\n    _this._serialId = 0;\n    return _possibleConstructorReturn(_this);\n  }\n\n  Connection.prototype.send = function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(command) {\n      var _this2 = this;\n\n      var waitingForRespond = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var serialId, message;\n      return regenerator.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              serialId = void 0;\n\n              if (waitingForRespond) {\n                this._serialId += 1;\n                serialId = this._serialId;\n                command.i = serialId; // eslint-disable-line no-param-reassign\n              }\n              if (debug$4.enabled) debug$4('↑ %O sent', trim$1(command));\n\n              message = void 0;\n\n              if (this._protocalFormat === 'proto2base64') {\n                message = command.toBase64();\n              } else if (command.toArrayBuffer) {\n                message = command.toArrayBuffer();\n              }\n\n              if (message) {\n                _context.next = 7;\n                break;\n              }\n\n              throw new TypeError(command + ' is not a GenericCommand');\n\n            case 7:\n\n              _WebSocketPlus.prototype.send.call(this, message);\n\n              if (waitingForRespond) {\n                _context.next = 10;\n                break;\n              }\n\n              return _context.abrupt('return', undefined);\n\n            case 10:\n              return _context.abrupt('return', new _Promise(function (resolve, reject) {\n                _this2._commands[serialId] = {\n                  resolve: resolve,\n                  reject: reject,\n                  timeout: setTimeout(function () {\n                    if (_this2._commands[serialId]) {\n                      if (debug$4.enabled) debug$4('✗ %O timeout', trim$1(command));\n                      reject(createError$1({\n                        error: 'Command Timeout [cmd:' + command.cmd + ' op:' + command.op + ']',\n                        name: 'COMMAND_TIMEOUT'\n                      }));\n                      delete _this2._commands[serialId];\n                    }\n                  }, COMMAND_TIMEOUT)\n                };\n              }));\n\n            case 11:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function send(_x2) {\n      return _ref2.apply(this, arguments);\n    }\n\n    return send;\n  }();\n\n  Connection.prototype.handleMessage = function handleMessage(msg) {\n    var message = void 0;\n    try {\n      message = GenericCommand.decode(msg);\n      if (debug$4.enabled) debug$4('↓ %O received', trim$1(message));\n    } catch (e) {\n      console.warn('Decode message failed', msg);\n    }\n    var serialId = message.i;\n    if (serialId) {\n      if (this._commands[serialId]) {\n        clearTimeout(this._commands[serialId].timeout);\n        if (message.cmd === CommandType.error) {\n          this._commands[serialId].reject(createError$1(message.errorMessage));\n        } else {\n          this._commands[serialId].resolve(message);\n        }\n        delete this._commands[serialId];\n      } else {\n        console.warn('Unexpected command received with serialId [' + serialId + '],\\n         which have timed out or never been requested.');\n      }\n    } else if (message.cmd === CommandType.error) {\n      this.emit(ERROR, createError$1(message.errorMessage));\n    } else {\n      this.emit(MESSAGE, message);\n    }\n  };\n\n  Connection.prototype.ping = function ping() {\n    return this.send(new GenericCommand({\n      cmd: CommandType.echo\n    })).catch(function (error$$1) {\n      return debug$4('ping failed:', error$$1);\n    });\n  };\n\n  return Connection;\n}(WebSocketPlus);\n\nvar checkType = function checkType(middleware) {\n  return function (param) {\n    var constructor = param.constructor;\n\n    return _Promise.resolve(param).then(middleware).then(tap(function (result) {\n      if (result === undefined || result === null) {\n        // eslint-disable-next-line max-len\n        return console.warn('Middleware[' + (middleware._pluginName || 'anonymous plugin') + ':' + (middleware.name || 'anonymous middleware') + '] param/return types not match. It returns ' + result + ' while a ' + param.constructor.name + ' expected.');\n      }\n      if (!(result instanceof constructor)) {\n        // eslint-disable-next-line max-len\n        return console.warn('Middleware[' + (middleware._pluginName || 'anonymous plugin') + ':' + (middleware.name || 'anonymous middleware') + '] param/return types not match. It returns a ' + result.constructor.name + ' while a ' + param.constructor.name + ' expected.');\n      }\n      return 0;\n    }));\n  };\n};\n\nvar applyDecorators = function applyDecorators(decorators, target) {\n  if (decorators) {\n    decorators.forEach(function (decorator) {\n      try {\n        decorator(target);\n      } catch (error) {\n        if (decorator._pluginName) {\n          error.message += '[' + decorator._pluginName + ']';\n        }\n        throw error;\n      }\n    });\n  }\n};\n\nvar applyMiddlewares = function applyMiddlewares(middlewares) {\n  return function (target) {\n    return ensureArray(middlewares).reduce(function (previousPromise, middleware) {\n      return previousPromise.then(checkType(middleware)).catch(function (error) {\n        if (middleware._pluginName) {\n          // eslint-disable-next-line no-param-reassign\n          error.message += '[' + middleware._pluginName + ']';\n        }\n        throw error;\n      });\n    }, _Promise.resolve(target));\n  };\n};\n\nvar applyDispatcher = function applyDispatcher(dispatchers, payload) {\n  return ensureArray(dispatchers).reduce(function (resultPromise, dispatcher) {\n    return resultPromise.then(function (shouldDispatch) {\n      return shouldDispatch === false ? false : dispatcher.apply(undefined, _toConsumableArray(payload));\n    }).catch(function (error) {\n      if (dispatcher._pluginName) {\n        // eslint-disable-next-line no-param-reassign\n        error.message += '[' + dispatcher._pluginName + ']';\n      }\n      throw error;\n    });\n  }, _Promise.resolve(true));\n};\n\nvar version = \"4.0.1\";\n\nvar debug$5 = browser('LC:Realtime');\nvar debugRequest = browser('LC:request');\n\nvar routerCache = new Cache('push-router');\n\nvar Realtime = function (_EventEmitter) {\n  _inherits(Realtime, _EventEmitter);\n\n  /**\n   * @extends EventEmitter\n   * @param  {Object} options\n   * @param  {String} options.appId\n   * @param  {String} options.appKey （since 4.0.0）\n   * @param  {String} [options.region='cn'] 节点 id\n   * @param  {Boolean} [options.pushOfflineMessages=false] 启用推送离线消息模式（默认为发送未读消息通知模式）\n   * @param  {Boolean} [options.noBinary=false] 设置 WebSocket 使用字符串格式收发消息（默认为二进制格式）。\n   *                                            适用于 WebSocket 实现不支持二进制数据格式的情况\n   * @param  {Boolean} [options.ssl=true] 使用 wss 进行连接\n   * @param  {String|Object} [options.server] 指定私有部署的服务器域名（since 4.0.0）\n   * @param  {String|String[]} [options.RTMServers] 指定私有部署的 RTM 服务器地址（since 4.0.0）\n   * @param  {Plugin[]} [options.plugins] 加载插件（since 3.1.0）\n   */\n  function Realtime(_ref) {\n    var plugins = _ref.plugins,\n        options = _objectWithoutProperties(_ref, ['plugins']);\n\n    _classCallCheck(this, Realtime);\n\n    debug$5('initializing Realtime %s %O', version, options);\n\n    var _this2 = _possibleConstructorReturn(this, _EventEmitter.call(this));\n\n    if (typeof options.appId !== 'string') {\n      throw new TypeError('appId [' + options.appId + '] is not a string');\n    }\n    if (typeof options.appKey !== 'string') {\n      throw new TypeError('appKey [' + options.appKey + '] is not a string');\n    }\n    _this2._options = _Object$assign({\n      appId: undefined,\n      appKey: undefined,\n      region: 'cn',\n      pushOfflineMessages: false,\n      noBinary: false,\n      ssl: true,\n      RTMServerName: process.env.RTM_SERVER_NAME // undocumented on purpose, internal use only\n    }, options);\n    _this2._cache = new Cache('endpoints');\n    var _this = internal(_this2);\n    _this.clients = new _Set();\n    _this.pendingClients = new _Set();\n    var mergedPlugins = [].concat(_toConsumableArray(ensureArray(Realtime.__preRegisteredPlugins)), _toConsumableArray(ensureArray(plugins)));\n    debug$5('Using plugins %o', mergedPlugins.map(function (plugin) {\n      return plugin.name;\n    }));\n    _this2._plugins = mergedPlugins.reduce(function (result, plugin) {\n      // eslint-disable-next-line no-restricted-syntax\n      for (var hook in plugin) {\n        if ({}.hasOwnProperty.call(plugin, hook) && hook !== 'name') {\n          if (plugin.name) {\n            ensureArray(plugin[hook]).forEach(function (value) {\n              // eslint-disable-next-line no-param-reassign\n              value._pluginName = plugin.name;\n            });\n          }\n          // eslint-disable-next-line no-param-reassign\n          result[hook] = ensureArray(result[hook]).concat(plugin[hook]);\n        }\n      }\n      return result;\n    }, {});\n    // onRealtimeCreate hook\n    applyDecorators(_this2._plugins.onRealtimeCreate, _this2);\n    return _this2;\n  }\n\n  Realtime.prototype._request = function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(_ref2) {\n      var method = _ref2.method,\n          _ref2$version = _ref2.version,\n          version$$1 = _ref2$version === undefined ? '1.1' : _ref2$version,\n          path = _ref2.path,\n          query = _ref2.query,\n          headers = _ref2.headers,\n          _ref2$data = _ref2.data,\n          data = _ref2$data === undefined ? {} : _ref2$data;\n\n      var _options, appId, region, server, _ref4, api, url, options;\n\n      return regenerator.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _options = this._options, appId = _options.appId, region = _options.region, server = _options.server;\n              _context.next = 3;\n              return this.constructor._getServerUrls({\n                appId: appId,\n                region: region,\n                server: server\n              });\n\n            case 3:\n              _ref4 = _context.sent;\n              api = _ref4.api;\n              url = 'https://' + api + '/' + version$$1 + path;\n              options = {\n                method: method,\n                params: query,\n                headers: _extends$1({\n                  'X-LC-Id': this._options.appId,\n                  'X-LC-Key': this._options.appKey\n                }, headers),\n                data: data\n              };\n\n              debugRequest('Req: %O %O', url, options);\n              return _context.abrupt('return', axios$1(url, options).then(function (response) {\n                debugRequest('Res: %O %O %O', url, response.status, response.data);\n                return response.data;\n              }, function (error$$1) {\n                debugRequest('Error: %O %O %O', url, error$$1.response.status, error$$1.response.data);\n                if (error$$1.response && error$$1.response.data && error$$1.response.data.code) {\n                  throw createError$1(error$$1.response.data);\n                }\n                throw error$$1;\n              }));\n\n            case 9:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function _request(_x) {\n      return _ref3.apply(this, arguments);\n    }\n\n    return _request;\n  }();\n\n  Realtime.prototype._open = function _open() {\n    var _this3 = this;\n\n    if (this._openPromise) return this._openPromise;\n\n    var format = 'protobuf2';\n    if (this._options.noBinary) {\n      // 不发送 binary data，fallback to base64 string\n      format = 'proto2base64';\n    }\n    var version$$1 = 3;\n    if (this._options.pushOfflineMessages) {\n      // 不推送离线消息，而是发送对话的未读通知\n      version$$1 = 1;\n    }\n    var protocol = {\n      format: format,\n      version: version$$1\n    };\n    this._openPromise = new _Promise(function (resolve, reject) {\n      debug$5('No connection established, create a new one.');\n      var connection = new Connection(function () {\n        return _this3._getRTMServers(_this3._options);\n      }, protocol);\n      connection.on(OPEN, function () {\n        return resolve(connection);\n      });\n      connection.on(ERROR, reject);\n      connection.on(MESSAGE, _this3._dispatchCommand.bind(_this3));\n      /**\n       * 连接断开。\n       * 连接断开可能是因为 SDK 进入了离线状态（see {@link Realtime#event:OFFLINE}），或长时间没有收到服务器心跳。\n       * 连接断开后所有的网络操作都会失败，请在连接断开后禁用相关的 UI 元素。\n       * @event Realtime#DISCONNECT\n       */\n      /**\n       * 计划在一段时间后尝试重新连接\n       * @event Realtime#SCHEDULE\n       * @param {Number} attempt 尝试重连的次数\n       * @param {Number} delay 延迟的毫秒数\n       */\n      /**\n       * 正在尝试重新连接\n       * @event Realtime#RETRY\n       * @param {Number} attempt 尝试重连的次数\n       */\n      /**\n       * 连接恢复正常。\n       * 请重新启用在 {@link Realtime#event:DISCONNECT} 事件中禁用的相关 UI 元素\n       * @event Realtime#RECONNECT\n       */\n\n      /**\n       * 客户端连接断开\n       * @event IMClient#DISCONNECT\n       * @see Realtime#event:DISCONNECT\n       * @since 3.2.0\n       */\n      /**\n       * 计划在一段时间后尝试重新连接\n       * @event IMClient#SCHEDULE\n       * @param {Number} attempt 尝试重连的次数\n       * @param {Number} delay 延迟的毫秒数\n       * @since 3.2.0\n       */\n      /**\n       * 正在尝试重新连接\n       * @event IMClient#RETRY\n       * @param {Number} attempt 尝试重连的次数\n       * @since 3.2.0\n       */\n\n      /**\n       * 客户端进入离线状态。\n       * 这通常意味着网络已断开，或者 {@link Realtime#pause} 被调用\n       * @event Realtime#OFFLINE\n       * @since 3.4.0\n       */\n      /**\n       * 客户端恢复在线状态\n       * 这通常意味着网络已恢复，或者 {@link Realtime#resume} 被调用\n       * @event Realtime#ONLINE\n       * @since 3.4.0\n       */\n      /**\n       * 进入离线状态。\n       * 这通常意味着网络已断开，或者 {@link Realtime#pause} 被调用\n       * @event IMClient#OFFLINE\n       * @since 3.4.0\n       */\n      /**\n       * 恢复在线状态\n       * 这通常意味着网络已恢复，或者 {@link Realtime#resume} 被调用\n       * @event IMClient#ONLINE\n       * @since 3.4.0\n       */\n\n      // event proxy\n      [DISCONNECT, RECONNECT, RETRY, SCHEDULE, OFFLINE, ONLINE].forEach(function (event) {\n        return connection.on(event, function () {\n          for (var _len = arguments.length, payload = Array(_len), _key = 0; _key < _len; _key++) {\n            payload[_key] = arguments[_key];\n          }\n\n          debug$5(event + ' event emitted. %o', payload);\n          _this3.emit.apply(_this3, [event].concat(payload));\n          if (event !== RECONNECT) {\n            internal(_this3).clients.forEach(function (client) {\n              client.emit.apply(client, [event].concat(payload));\n            });\n          }\n        });\n      });\n      // override handleClose\n      connection.handleClose = function handleClose(event) {\n        var isFatal = [ErrorCode.APP_NOT_AVAILABLE, ErrorCode.INVALID_LOGIN, ErrorCode.INVALID_ORIGIN].some(function (errorCode) {\n          return errorCode === event.code;\n        });\n        if (isFatal) {\n          // in these cases, SDK should throw.\n          this.throw(createError$1(event));\n        } else {\n          // reconnect\n          this.disconnect();\n        }\n      };\n      internal(_this3).connection = connection;\n    });\n\n    return this._openPromise;\n  };\n\n  Realtime.prototype._getRTMServers = function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(options) {\n      var info, cachedEndPoints;\n      return regenerator.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!options.RTMServers) {\n                _context2.next = 2;\n                break;\n              }\n\n              return _context2.abrupt('return', shuffle_1(ensureArray(options.RTMServers)));\n\n            case 2:\n              info = void 0;\n              cachedEndPoints = this._cache.get('endpoints');\n\n              if (!cachedEndPoints) {\n                _context2.next = 10;\n                break;\n              }\n\n              _context2.next = 7;\n              return cachedEndPoints;\n\n            case 7:\n              info = _context2.sent;\n              _context2.next = 14;\n              break;\n\n            case 10:\n              _context2.next = 12;\n              return this.constructor._fetchRTMServers(options);\n\n            case 12:\n              info = _context2.sent;\n\n              this._cache.set('endpoints', info, info.ttl * 1000);\n\n            case 14:\n              debug$5('endpoint info: %O', info);\n              return _context2.abrupt('return', [info.server, info.secondary]);\n\n            case 16:\n            case 'end':\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    function _getRTMServers(_x2) {\n      return _ref5.apply(this, arguments);\n    }\n\n    return _getRTMServers;\n  }();\n\n  Realtime._getServerUrls = function () {\n    var _ref7 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(_ref6) {\n      var appId = _ref6.appId,\n          region = _ref6.region,\n          server = _ref6.server;\n      var cachedRouter;\n      return regenerator.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              debug$5('fetch server urls');\n\n              if (!server) {\n                _context3.next = 5;\n                break;\n              }\n\n              if (!(typeof server !== 'string')) {\n                _context3.next = 4;\n                break;\n              }\n\n              return _context3.abrupt('return', server);\n\n            case 4:\n              return _context3.abrupt('return', {\n                RTMRouter: server,\n                api: server\n              });\n\n            case 5:\n              _context3.t0 = region;\n              _context3.next = _context3.t0 === 'cn' ? 8 : _context3.t0 === 'us' ? 12 : 13;\n              break;\n\n            case 8:\n              cachedRouter = routerCache.get(appId);\n\n              if (!cachedRouter) {\n                _context3.next = 11;\n                break;\n              }\n\n              return _context3.abrupt('return', cachedRouter);\n\n            case 11:\n              return _context3.abrupt('return', axios$1.get('https://app-router.leancloud.cn/2/route', {\n                params: {\n                  appId: appId\n                },\n                timeout: 20000\n              }).then(function (res) {\n                return res.data;\n              }).then(tap(debug$5)).then(function (_ref8) {\n                var RTMRouter = _ref8.rtm_router_server,\n                    api = _ref8.api_server,\n                    _ref8$ttl = _ref8.ttl,\n                    ttl = _ref8$ttl === undefined ? 3600 : _ref8$ttl;\n\n                if (!RTMRouter) {\n                  throw new Error('rtm router not exists');\n                }\n                var serverUrls = {\n                  RTMRouter: RTMRouter,\n                  api: api\n                };\n                routerCache.set(appId, serverUrls, ttl * 1000);\n                return serverUrls;\n              }).catch(function () {\n                var id = appId.slice(0, 8).toLowerCase();\n                return {\n                  RTMRouter: id + '.rtm.lncld.net',\n                  api: id + '.api.lncld.net'\n                };\n              }));\n\n            case 12:\n              return _context3.abrupt('return', {\n                RTMRouter: 'router-a0-push.leancloud.cn',\n                api: 'us-api.leancloud.cn'\n              });\n\n            case 13:\n              throw new Error('Region [' + region + '] is not supported.');\n\n            case 14:\n            case 'end':\n              return _context3.stop();\n          }\n        }\n      }, _callee3, this);\n    }));\n\n    function _getServerUrls(_x3) {\n      return _ref7.apply(this, arguments);\n    }\n\n    return _getServerUrls;\n  }();\n\n  Realtime._fetchRTMServers = function _fetchRTMServers(_ref9) {\n    var appId = _ref9.appId,\n        region = _ref9.region,\n        ssl = _ref9.ssl,\n        server = _ref9.server,\n        RTMServerName = _ref9.RTMServerName;\n\n    debug$5('fetch endpoint info');\n    return this._getServerUrls({ appId: appId, region: region, server: server }).then(tap(debug$5)).then(function (_ref10) {\n      var RTMRouter = _ref10.RTMRouter;\n      return axios$1.get('https://' + RTMRouter + '/v1/route', {\n        params: {\n          appId: appId,\n          secure: ssl,\n          features: isWeapp ? 'wechat' : undefined,\n          server: RTMServerName,\n          _t: Date.now()\n        },\n        timeout: 20000\n      }).then(function (res) {\n        return res.data;\n      }).then(tap(debug$5));\n    });\n  };\n\n  Realtime.prototype._close = function _close() {\n    if (this._openPromise) {\n      this._openPromise.then(function (connection) {\n        return connection.close();\n      });\n    }\n    delete this._openPromise;\n  };\n\n  /**\n   * 手动进行重连。\n   * SDK 在网络出现异常时会自动按照一定的时间间隔尝试重连，调用该方法会立即尝试重连并重置重连尝试计数器。\n   * 只能在 `SCHEDULE` 事件之后，`RETRY` 事件之前调用，如果当前网络正常或者正在进行重连，调用该方法会抛异常。\n   */\n\n\n  Realtime.prototype.retry = function retry() {\n    var _internal = internal(this),\n        connection = _internal.connection;\n\n    if (!connection) {\n      throw new Error('no connection established');\n    }\n    if (connection.cannot('retry')) {\n      throw new Error('retrying not allowed when not disconnected. the connection is now ' + connection.current);\n    }\n    return connection.retry();\n  };\n  /**\n   * 暂停，使 SDK 进入离线状态。\n   * 你可以在网络断开、应用进入后台等时刻调用该方法让 SDK 进入离线状态，离线状态下不会尝试重连。\n   * 在浏览器中 SDK 会自动监听网络变化，因此无需手动调用该方法。\n   *\n   * @since 3.4.0\n   * @see Realtime#event:OFFLINE\n   */\n\n\n  Realtime.prototype.pause = function pause() {\n    // 这个方法常常在网络断开、进入后台时被调用，此时 connection 可能没有建立或者已经 close。\n    // 因此不像 retry，这个方法应该尽可能 loose\n    var _internal2 = internal(this),\n        connection = _internal2.connection;\n\n    if (!connection) return;\n    if (connection.can('pause')) connection.pause();\n  };\n  /**\n   * 恢复在线状态。\n   * 你可以在网络恢复、应用回到前台等时刻调用该方法让 SDK 恢复在线状态，恢复在线状态后 SDK 会开始尝试重连。\n   *\n   * @since 3.4.0\n   * @see Realtime#event:ONLINE\n   */\n\n\n  Realtime.prototype.resume = function resume() {\n    // 与 pause 一样，这个方法应该尽可能 loose\n    var _internal3 = internal(this),\n        connection = _internal3.connection;\n\n    if (!connection) return;\n    if (connection.can('resume')) connection.resume();\n  };\n\n  Realtime.prototype._registerPending = function _registerPending(value) {\n    internal(this).pendingClients.add(value);\n  };\n\n  Realtime.prototype._deregisterPending = function _deregisterPending(client) {\n    internal(this).pendingClients.delete(client);\n  };\n\n  Realtime.prototype._register = function _register(client) {\n    internal(this).clients.add(client);\n  };\n\n  Realtime.prototype._deregister = function _deregister(client) {\n    var _this = internal(this);\n    _this.clients.delete(client);\n    if (_this.clients.size + _this.pendingClients.size === 0) {\n      this._close();\n    }\n  };\n\n  Realtime.prototype._dispatchCommand = function _dispatchCommand(command) {\n    return applyDispatcher(this._plugins.beforeCommandDispatch, [command, this]).then(function (shouldDispatch) {\n      // no plugin handled this command\n      if (shouldDispatch) return debug$5('[WARN] Unexpected message received: %O', trim$1(command));\n      return false;\n    });\n  };\n\n  return Realtime;\n}(eventemitter3);\n\nvar rngBrowser = createCommonjsModule(function (module) {\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && msCrypto.getRandomValues.bind(msCrypto));\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n});\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i$1 = 0; i$1 < 256; ++i$1) {\n  byteToHex[i$1] = (i$1 + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nvar bytesToUuid_1 = bytesToUuid;\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rngBrowser)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid_1(rnds);\n}\n\nvar v4_1 = v4;\n\nvar ITERATOR$4 = _wks('iterator');\n\nvar core_isIterable = _core.isIterable = function (it) {\n  var O = Object(it);\n  return O[ITERATOR$4] !== undefined\n    || '@@iterator' in O\n    // eslint-disable-next-line no-prototype-builtins\n    || _iterators.hasOwnProperty(_classof(O));\n};\n\nvar isIterable = core_isIterable;\n\nvar isIterable$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": isIterable, __esModule: true };\n});\n\nunwrapExports(isIterable$1);\n\nvar core_getIterator = _core.getIterator = function (it) {\n  var iterFn = core_getIteratorMethod(it);\n  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');\n  return _anObject(iterFn.call(it));\n};\n\nvar getIterator = core_getIterator;\n\nvar getIterator$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": getIterator, __esModule: true };\n});\n\nvar _getIterator = unwrapExports(getIterator$1);\n\nvar slicedToArray = createCommonjsModule(function (module, exports) {\n\nexports.__esModule = true;\n\n\n\nvar _isIterable3 = _interopRequireDefault(isIterable$1);\n\n\n\nvar _getIterator3 = _interopRequireDefault(getIterator$1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if ((0, _isIterable3.default)(Object(arr))) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n});\n\nvar _slicedToArray = unwrapExports(slicedToArray);\n\nvar isEnum$1 = _objectPie.f;\nvar _objectToArray = function (isEntries) {\n  return function (it) {\n    var O = _toIobject(it);\n    var keys = _objectKeys(O);\n    var length = keys.length;\n    var i = 0;\n    var result = [];\n    var key;\n    while (length > i) if (isEnum$1.call(O, key = keys[i++])) {\n      result.push(isEntries ? [key, O[key]] : O[key]);\n    } return result;\n  };\n};\n\n// https://github.com/tc39/proposal-object-values-entries\n\nvar $values = _objectToArray(false);\n\n_export(_export.S, 'Object', {\n  values: function values(it) {\n    return $values(it);\n  }\n});\n\nvar values$1 = _core.Object.values;\n\nvar values$2 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": values$1, __esModule: true };\n});\n\nvar _Object$values = unwrapExports(values$2);\n\nvar base64Arraybuffer = createCommonjsModule(function (module, exports) {\n/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n(function(){\n\n  var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  // Use a lookup table to find the index.\n  var lookup = new Uint8Array(256);\n  for (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n  }\n\n  exports.encode = function(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer),\n    i, len = bytes.length, base64 = \"\";\n\n    for (i = 0; i < len; i+=3) {\n      base64 += chars[bytes[i] >> 2];\n      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n      base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if ((len % 3) === 2) {\n      base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n      base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n\n    return base64;\n  };\n\n  exports.decode =  function(base64) {\n    var bufferLength = base64.length * 0.75,\n    len = base64.length, i, p = 0,\n    encoded1, encoded2, encoded3, encoded4;\n\n    if (base64[base64.length - 1] === \"=\") {\n      bufferLength--;\n      if (base64[base64.length - 2] === \"=\") {\n        bufferLength--;\n      }\n    }\n\n    var arraybuffer = new ArrayBuffer(bufferLength),\n    bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i+=4) {\n      encoded1 = lookup[base64.charCodeAt(i)];\n      encoded2 = lookup[base64.charCodeAt(i+1)];\n      encoded3 = lookup[base64.charCodeAt(i+2)];\n      encoded4 = lookup[base64.charCodeAt(i+3)];\n\n      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n  };\n})();\n});\nvar base64Arraybuffer_1 = base64Arraybuffer.encode;\nvar base64Arraybuffer_2 = base64Arraybuffer.decode;\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nvar _listCacheClear = listCacheClear;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nvar eq_1 = eq;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq_1(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nvar _assocIndexOf = assocIndexOf;\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nvar _listCacheDelete = listCacheDelete;\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nvar _listCacheGet = listCacheGet;\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return _assocIndexOf(this.__data__, key) > -1;\n}\n\nvar _listCacheHas = listCacheHas;\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = _assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nvar _listCacheSet = listCacheSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = _listCacheClear;\nListCache.prototype['delete'] = _listCacheDelete;\nListCache.prototype.get = _listCacheGet;\nListCache.prototype.has = _listCacheHas;\nListCache.prototype.set = _listCacheSet;\n\nvar _ListCache = ListCache;\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new _ListCache;\n  this.size = 0;\n}\n\nvar _stackClear = stackClear;\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nvar _stackDelete = stackDelete;\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nvar _stackGet = stackGet;\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nvar _stackHas = stackHas;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = _root['__core-js_shared__'];\n\nvar _coreJsData = coreJsData;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nvar _isMasked = isMasked;\n\n/** Used for built-in method references. */\nvar funcProto$1 = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString$1 = funcProto$1.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString$1.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nvar _toSource = toSource;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto$2 = Function.prototype,\n    objectProto$7 = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString$2 = funcProto$2.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$6 = objectProto$7.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString$2.call(hasOwnProperty$6).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject_1(value) || _isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(_toSource(value));\n}\n\nvar _baseIsNative = baseIsNative;\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nvar _getValue = getValue;\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = _getValue(object, key);\n  return _baseIsNative(value) ? value : undefined;\n}\n\nvar _getNative = getNative;\n\n/* Built-in method references that are verified to be native. */\nvar Map = _getNative(_root, 'Map');\n\nvar _Map = Map;\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = _getNative(Object, 'create');\n\nvar _nativeCreate = nativeCreate;\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};\n  this.size = 0;\n}\n\nvar _hashClear = hashClear;\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nvar _hashDelete = hashDelete;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto$8 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$7 = objectProto$8.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (_nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty$7.call(data, key) ? data[key] : undefined;\n}\n\nvar _hashGet = hashGet;\n\n/** Used for built-in method references. */\nvar objectProto$9 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$8 = objectProto$9.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$8.call(data, key);\n}\n\nvar _hashHas = hashHas;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED$1 = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;\n  return this;\n}\n\nvar _hashSet = hashSet;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = _hashClear;\nHash.prototype['delete'] = _hashDelete;\nHash.prototype.get = _hashGet;\nHash.prototype.has = _hashHas;\nHash.prototype.set = _hashSet;\n\nvar _Hash = Hash;\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new _Hash,\n    'map': new (_Map || _ListCache),\n    'string': new _Hash\n  };\n}\n\nvar _mapCacheClear = mapCacheClear;\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nvar _isKeyable = isKeyable;\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return _isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nvar _getMapData = getMapData;\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = _getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nvar _mapCacheDelete = mapCacheDelete;\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return _getMapData(this, key).get(key);\n}\n\nvar _mapCacheGet = mapCacheGet;\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return _getMapData(this, key).has(key);\n}\n\nvar _mapCacheHas = mapCacheHas;\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = _getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nvar _mapCacheSet = mapCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = _mapCacheClear;\nMapCache.prototype['delete'] = _mapCacheDelete;\nMapCache.prototype.get = _mapCacheGet;\nMapCache.prototype.has = _mapCacheHas;\nMapCache.prototype.set = _mapCacheSet;\n\nvar _MapCache = MapCache;\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof _ListCache) {\n    var pairs = data.__data__;\n    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new _MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nvar _stackSet = stackSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new _ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = _stackClear;\nStack.prototype['delete'] = _stackDelete;\nStack.prototype.get = _stackGet;\nStack.prototype.has = _stackHas;\nStack.prototype.set = _stackSet;\n\nvar _Stack = Stack;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED$2 = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED$2);\n  return this;\n}\n\nvar _setCacheAdd = setCacheAdd;\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nvar _setCacheHas = setCacheHas;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new _MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;\nSetCache.prototype.has = _setCacheHas;\n\nvar _SetCache = SetCache;\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvar _arraySome = arraySome;\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nvar _cacheHas = cacheHas;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new _SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!_arraySome(other, function(othValue, othIndex) {\n            if (!_cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nvar _equalArrays = equalArrays;\n\n/** Built-in value references. */\nvar Uint8Array$1 = _root.Uint8Array;\n\nvar _Uint8Array = Uint8Array$1;\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nvar _mapToArray = mapToArray;\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nvar _setToArray = setToArray;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG$1 = 1,\n    COMPARE_UNORDERED_FLAG$1 = 2;\n\n/** `Object#toString` result references. */\nvar boolTag$1 = '[object Boolean]',\n    dateTag$1 = '[object Date]',\n    errorTag$1 = '[object Error]',\n    mapTag$1 = '[object Map]',\n    numberTag$1 = '[object Number]',\n    regexpTag$1 = '[object RegExp]',\n    setTag$1 = '[object Set]',\n    stringTag$1 = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag$1 = '[object ArrayBuffer]',\n    dataViewTag$1 = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = _Symbol$1 ? _Symbol$1.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag$1:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag$1:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag$1:\n    case dateTag$1:\n    case numberTag$1:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq_1(+object, +other);\n\n    case errorTag$1:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag$1:\n    case stringTag$1:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag$1:\n      var convert = _mapToArray;\n\n    case setTag$1:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;\n      convert || (convert = _setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG$1;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nvar _equalByTag = equalByTag;\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nvar _arrayPush = arrayPush;\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));\n}\n\nvar _baseGetAllKeys = baseGetAllKeys;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nvar _arrayFilter = arrayFilter;\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nvar stubArray_1 = stubArray;\n\n/** Used for built-in method references. */\nvar objectProto$10 = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable$1 = objectProto$10.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return _arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable$1.call(object, symbol);\n  });\n};\n\nvar _getSymbols = getSymbols;\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return _baseGetAllKeys(object, keys_1, _getSymbols);\n}\n\nvar _getAllKeys = getAllKeys;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG$2 = 1;\n\n/** Used for built-in method references. */\nvar objectProto$11 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$9 = objectProto$11.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,\n      objProps = _getAllKeys(object),\n      objLength = objProps.length,\n      othProps = _getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty$9.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nvar _equalObjects = equalObjects;\n\n/* Built-in method references that are verified to be native. */\nvar DataView = _getNative(_root, 'DataView');\n\nvar _DataView = DataView;\n\n/* Built-in method references that are verified to be native. */\nvar Promise$2 = _getNative(_root, 'Promise');\n\nvar _Promise$1 = Promise$2;\n\n/* Built-in method references that are verified to be native. */\nvar Set = _getNative(_root, 'Set');\n\nvar _Set$1 = Set;\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = _getNative(_root, 'WeakMap');\n\nvar _WeakMap$1 = WeakMap;\n\n/** `Object#toString` result references. */\nvar mapTag$2 = '[object Map]',\n    objectTag$2 = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag$2 = '[object Set]',\n    weakMapTag$1 = '[object WeakMap]';\n\nvar dataViewTag$2 = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = _toSource(_DataView),\n    mapCtorString = _toSource(_Map),\n    promiseCtorString = _toSource(_Promise$1),\n    setCtorString = _toSource(_Set$1),\n    weakMapCtorString = _toSource(_WeakMap$1);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = _baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2) ||\n    (_Map && getTag(new _Map) != mapTag$2) ||\n    (_Promise$1 && getTag(_Promise$1.resolve()) != promiseTag) ||\n    (_Set$1 && getTag(new _Set$1) != setTag$2) ||\n    (_WeakMap$1 && getTag(new _WeakMap$1) != weakMapTag$1)) {\n  getTag = function(value) {\n    var result = _baseGetTag(value),\n        Ctor = result == objectTag$2 ? value.constructor : undefined,\n        ctorString = Ctor ? _toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag$2;\n        case mapCtorString: return mapTag$2;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag$2;\n        case weakMapCtorString: return weakMapTag$1;\n      }\n    }\n    return result;\n  };\n}\n\nvar _getTag = getTag;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG$3 = 1;\n\n/** `Object#toString` result references. */\nvar argsTag$2 = '[object Arguments]',\n    arrayTag$1 = '[object Array]',\n    objectTag$3 = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto$12 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$10 = objectProto$12.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray_1(object),\n      othIsArr = isArray_1(other),\n      objTag = objIsArr ? arrayTag$1 : _getTag(object),\n      othTag = othIsArr ? arrayTag$1 : _getTag(other);\n\n  objTag = objTag == argsTag$2 ? objectTag$3 : objTag;\n  othTag = othTag == argsTag$2 ? objectTag$3 : othTag;\n\n  var objIsObj = objTag == objectTag$3,\n      othIsObj = othTag == objectTag$3,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer_1$1(object)) {\n    if (!isBuffer_1$1(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new _Stack);\n    return (objIsArr || isTypedArray_1(object))\n      ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {\n    var objIsWrapped = objIsObj && hasOwnProperty$10.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty$10.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new _Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new _Stack);\n  return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nvar _baseIsEqualDeep = baseIsEqualDeep;\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {\n    return value !== value && other !== other;\n  }\n  return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nvar _baseIsEqual = baseIsEqual;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG$4 = 1,\n    COMPARE_UNORDERED_FLAG$2 = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new _Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvar _baseIsMatch = baseIsMatch;\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject_1(value);\n}\n\nvar _isStrictComparable = isStrictComparable;\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys_1(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, _isStrictComparable(value)];\n  }\n  return result;\n}\n\nvar _getMatchData = getMatchData;\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nvar _matchesStrictComparable = matchesStrictComparable;\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = _getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return _matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || _baseIsMatch(object, source, matchData);\n  };\n}\n\nvar _baseMatches = baseMatches;\n\n/** `Object#toString` result references. */\nvar symbolTag$1 = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol$1(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag$1);\n}\n\nvar isSymbol_1 = isSymbol$1;\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray_1(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol_1(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nvar _isKey = isKey;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || _MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = _MapCache;\n\nvar memoize_1 = memoize;\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize_1(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nvar _memoizeCapped = memoizeCapped;\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = _memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nvar _stringToPath = stringToPath;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto$1 = _Symbol$1 ? _Symbol$1.prototype : undefined,\n    symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray_1(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return _arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol_1(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nvar _baseToString = baseToString;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString$3(value) {\n  return value == null ? '' : _baseToString(value);\n}\n\nvar toString_1 = toString$3;\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray_1(value)) {\n    return value;\n  }\n  return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));\n}\n\nvar _castPath = castPath;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY$1 = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol_1(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;\n}\n\nvar _toKey = toKey;\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = _castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[_toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nvar _baseGet = baseGet;\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : _baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nvar get_1 = get;\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nvar _baseHasIn = baseHasIn;\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = _castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = _toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength_1(length) && _isIndex(key, length) &&\n    (isArray_1(object) || isArguments_1(object));\n}\n\nvar _hasPath = hasPath;\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && _hasPath(object, path, _baseHasIn);\n}\n\nvar hasIn_1 = hasIn;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG$5 = 1,\n    COMPARE_UNORDERED_FLAG$3 = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (_isKey(path) && _isStrictComparable(srcValue)) {\n    return _matchesStrictComparable(_toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get_1(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn_1(object, path)\n      : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);\n  };\n}\n\nvar _baseMatchesProperty = baseMatchesProperty;\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nvar identity_1 = identity;\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nvar _baseProperty = baseProperty;\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return _baseGet(object, path);\n  };\n}\n\nvar _basePropertyDeep = basePropertyDeep;\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);\n}\n\nvar property_1 = property;\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity_1;\n  }\n  if (typeof value == 'object') {\n    return isArray_1(value)\n      ? _baseMatchesProperty(value[0], value[1])\n      : _baseMatches(value);\n  }\n  return property_1(value);\n}\n\nvar _baseIteratee = baseIteratee;\n\n/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nvar last_1 = last;\n\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\nvar _baseSlice = baseSlice;\n\n/**\n * Gets the parent value at `path` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} path The path to get the parent value of.\n * @returns {*} Returns the parent value.\n */\nfunction parent(object, path) {\n  return path.length < 2 ? object : _baseGet(object, _baseSlice(path, 0, -1));\n}\n\nvar _parent = parent;\n\n/**\n * The base implementation of `_.unset`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The property path to unset.\n * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n */\nfunction baseUnset(object, path) {\n  path = _castPath(path, object);\n  object = _parent(object, path);\n  return object == null || delete object[_toKey(last_1(path))];\n}\n\nvar _baseUnset = baseUnset;\n\n/** Used for built-in method references. */\nvar arrayProto$1 = Array.prototype;\n\n/** Built-in value references. */\nvar splice$1 = arrayProto$1.splice;\n\n/**\n * The base implementation of `_.pullAt` without support for individual\n * indexes or capturing the removed elements.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {number[]} indexes The indexes of elements to remove.\n * @returns {Array} Returns `array`.\n */\nfunction basePullAt(array, indexes) {\n  var length = array ? indexes.length : 0,\n      lastIndex = length - 1;\n\n  while (length--) {\n    var index = indexes[length];\n    if (length == lastIndex || index !== previous) {\n      var previous = index;\n      if (_isIndex(index)) {\n        splice$1.call(array, index, 1);\n      } else {\n        _baseUnset(array, index);\n      }\n    }\n  }\n  return array;\n}\n\nvar _basePullAt = basePullAt;\n\n/**\n * Removes all elements from `array` that `predicate` returns truthy for\n * and returns an array of the removed elements. The predicate is invoked\n * with three arguments: (value, index, array).\n *\n * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n * to pull elements from an array by value.\n *\n * @static\n * @memberOf _\n * @since 2.0.0\n * @category Array\n * @param {Array} array The array to modify.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new array of removed elements.\n * @example\n *\n * var array = [1, 2, 3, 4];\n * var evens = _.remove(array, function(n) {\n *   return n % 2 == 0;\n * });\n *\n * console.log(array);\n * // => [1, 3]\n *\n * console.log(evens);\n * // => [2, 4]\n */\nfunction remove(array, predicate) {\n  var result = [];\n  if (!(array && array.length)) {\n    return result;\n  }\n  var index = -1,\n      indexes = [],\n      length = array.length;\n\n  predicate = _baseIteratee(predicate, 3);\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result.push(value);\n      indexes.push(index);\n    }\n  }\n  _basePullAt(array, indexes);\n  return result;\n}\n\nvar remove_1 = remove;\n\n// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)\n\nvar $find = _arrayMethods(5);\nvar KEY = 'find';\nvar forced = true;\n// Shouldn't skip holes\nif (KEY in []) Array(1)[KEY](function () { forced = false; });\n_export(_export.P + _export.F * forced, 'Array', {\n  find: function find(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar find = _core.Array.find;\n\nvar find$1 = createCommonjsModule(function (module) {\nmodule.exports = { \"default\": find, __esModule: true };\n});\n\nvar _Array$find = unwrapExports(find$1);\n\n/** `Object#toString` result references. */\nvar mapTag$3 = '[object Map]',\n    setTag$3 = '[object Set]';\n\n/** Used for built-in method references. */\nvar objectProto$13 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$11 = objectProto$13.hasOwnProperty;\n\n/**\n * Checks if `value` is an empty object, collection, map, or set.\n *\n * Objects are considered empty if they have no own enumerable string keyed\n * properties.\n *\n * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n * jQuery-like collections are considered empty if they have a `length` of `0`.\n * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n * @example\n *\n * _.isEmpty(null);\n * // => true\n *\n * _.isEmpty(true);\n * // => true\n *\n * _.isEmpty(1);\n * // => true\n *\n * _.isEmpty([1, 2, 3]);\n * // => false\n *\n * _.isEmpty({ 'a': 1 });\n * // => false\n */\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n  if (isArrayLike_1(value) &&\n      (isArray_1(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n        isBuffer_1$1(value) || isTypedArray_1(value) || isArguments_1(value))) {\n    return !value.length;\n  }\n  var tag = _getTag(value);\n  if (tag == mapTag$3 || tag == setTag$3) {\n    return !value.size;\n  }\n  if (_isPrototype(value)) {\n    return !_baseKeys(value).length;\n  }\n  for (var key in value) {\n    if (hasOwnProperty$11.call(value, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar isEmpty_1 = isEmpty;\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nvar _arrayEach = arrayEach;\n\nvar defineProperty$4 = (function() {\n  try {\n    var func = _getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nvar _defineProperty$1 = defineProperty$4;\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && _defineProperty$1) {\n    _defineProperty$1(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nvar _baseAssignValue = baseAssignValue;\n\n/** Used for built-in method references. */\nvar objectProto$14 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$12 = objectProto$14.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty$12.call(object, key) && eq_1(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    _baseAssignValue(object, key, value);\n  }\n}\n\nvar _assignValue = assignValue;\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      _baseAssignValue(object, key, newValue);\n    } else {\n      _assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nvar _copyObject = copyObject;\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && _copyObject(source, keys_1(source), object);\n}\n\nvar _baseAssign = baseAssign;\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nvar _nativeKeysIn = nativeKeysIn;\n\n/** Used for built-in method references. */\nvar objectProto$15 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$13 = objectProto$15.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject_1(object)) {\n    return _nativeKeysIn(object);\n  }\n  var isProto = _isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty$13.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nvar _baseKeysIn = baseKeysIn;\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn$1(object) {\n  return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);\n}\n\nvar keysIn_1 = keysIn$1;\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && _copyObject(source, keysIn_1(source), object);\n}\n\nvar _baseAssignIn = baseAssignIn;\n\nvar _cloneBuffer = createCommonjsModule(function (module, exports) {\n/** Detect free variable `exports`. */\nvar freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? _root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n});\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return _copyObject(source, _getSymbols(source), object);\n}\n\nvar _copySymbols = copySymbols;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols$1 = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols$1 ? stubArray_1 : function(object) {\n  var result = [];\n  while (object) {\n    _arrayPush(result, _getSymbols(object));\n    object = _getPrototype(object);\n  }\n  return result;\n};\n\nvar _getSymbolsIn = getSymbolsIn;\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return _copyObject(source, _getSymbolsIn(source), object);\n}\n\nvar _copySymbolsIn = copySymbolsIn;\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);\n}\n\nvar _getAllKeysIn = getAllKeysIn;\n\n/** Used for built-in method references. */\nvar objectProto$16 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$14 = objectProto$16.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty$14.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nvar _initCloneArray = initCloneArray;\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));\n  return result;\n}\n\nvar _cloneArrayBuffer = cloneArrayBuffer;\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nvar _cloneDataView = cloneDataView;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nvar _cloneRegExp = cloneRegExp;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto$2 = _Symbol$1 ? _Symbol$1.prototype : undefined,\n    symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};\n}\n\nvar _cloneSymbol = cloneSymbol;\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nvar _cloneTypedArray = cloneTypedArray;\n\n/** `Object#toString` result references. */\nvar boolTag$2 = '[object Boolean]',\n    dateTag$2 = '[object Date]',\n    mapTag$4 = '[object Map]',\n    numberTag$2 = '[object Number]',\n    regexpTag$2 = '[object RegExp]',\n    setTag$4 = '[object Set]',\n    stringTag$2 = '[object String]',\n    symbolTag$2 = '[object Symbol]';\n\nvar arrayBufferTag$2 = '[object ArrayBuffer]',\n    dataViewTag$3 = '[object DataView]',\n    float32Tag$1 = '[object Float32Array]',\n    float64Tag$1 = '[object Float64Array]',\n    int8Tag$1 = '[object Int8Array]',\n    int16Tag$1 = '[object Int16Array]',\n    int32Tag$1 = '[object Int32Array]',\n    uint8Tag$1 = '[object Uint8Array]',\n    uint8ClampedTag$1 = '[object Uint8ClampedArray]',\n    uint16Tag$1 = '[object Uint16Array]',\n    uint32Tag$1 = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag$2:\n      return _cloneArrayBuffer(object);\n\n    case boolTag$2:\n    case dateTag$2:\n      return new Ctor(+object);\n\n    case dataViewTag$3:\n      return _cloneDataView(object, isDeep);\n\n    case float32Tag$1: case float64Tag$1:\n    case int8Tag$1: case int16Tag$1: case int32Tag$1:\n    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:\n      return _cloneTypedArray(object, isDeep);\n\n    case mapTag$4:\n      return new Ctor;\n\n    case numberTag$2:\n    case stringTag$2:\n      return new Ctor(object);\n\n    case regexpTag$2:\n      return _cloneRegExp(object);\n\n    case setTag$4:\n      return new Ctor;\n\n    case symbolTag$2:\n      return _cloneSymbol(object);\n  }\n}\n\nvar _initCloneByTag = initCloneByTag;\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject_1(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nvar _baseCreate = baseCreate;\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !_isPrototype(object))\n    ? _baseCreate(_getPrototype(object))\n    : {};\n}\n\nvar _initCloneObject = initCloneObject;\n\n/** `Object#toString` result references. */\nvar mapTag$5 = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike_1(value) && _getTag(value) == mapTag$5;\n}\n\nvar _baseIsMap = baseIsMap;\n\n/* Node.js helper references. */\nvar nodeIsMap = _nodeUtil && _nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;\n\nvar isMap_1 = isMap;\n\n/** `Object#toString` result references. */\nvar setTag$5 = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike_1(value) && _getTag(value) == setTag$5;\n}\n\nvar _baseIsSet = baseIsSet;\n\n/* Node.js helper references. */\nvar nodeIsSet = _nodeUtil && _nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;\n\nvar isSet_1 = isSet;\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag$3 = '[object Arguments]',\n    arrayTag$2 = '[object Array]',\n    boolTag$3 = '[object Boolean]',\n    dateTag$3 = '[object Date]',\n    errorTag$2 = '[object Error]',\n    funcTag$2 = '[object Function]',\n    genTag$1 = '[object GeneratorFunction]',\n    mapTag$6 = '[object Map]',\n    numberTag$3 = '[object Number]',\n    objectTag$4 = '[object Object]',\n    regexpTag$3 = '[object RegExp]',\n    setTag$6 = '[object Set]',\n    stringTag$3 = '[object String]',\n    symbolTag$3 = '[object Symbol]',\n    weakMapTag$2 = '[object WeakMap]';\n\nvar arrayBufferTag$3 = '[object ArrayBuffer]',\n    dataViewTag$4 = '[object DataView]',\n    float32Tag$2 = '[object Float32Array]',\n    float64Tag$2 = '[object Float64Array]',\n    int8Tag$2 = '[object Int8Array]',\n    int16Tag$2 = '[object Int16Array]',\n    int32Tag$2 = '[object Int32Array]',\n    uint8Tag$2 = '[object Uint8Array]',\n    uint8ClampedTag$2 = '[object Uint8ClampedArray]',\n    uint16Tag$2 = '[object Uint16Array]',\n    uint32Tag$2 = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag$3] = cloneableTags[arrayTag$2] =\ncloneableTags[arrayBufferTag$3] = cloneableTags[dataViewTag$4] =\ncloneableTags[boolTag$3] = cloneableTags[dateTag$3] =\ncloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] =\ncloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] =\ncloneableTags[int32Tag$2] = cloneableTags[mapTag$6] =\ncloneableTags[numberTag$3] = cloneableTags[objectTag$4] =\ncloneableTags[regexpTag$3] = cloneableTags[setTag$6] =\ncloneableTags[stringTag$3] = cloneableTags[symbolTag$3] =\ncloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] =\ncloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;\ncloneableTags[errorTag$2] = cloneableTags[funcTag$2] =\ncloneableTags[weakMapTag$2] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject_1(value)) {\n    return value;\n  }\n  var isArr = isArray_1(value);\n  if (isArr) {\n    result = _initCloneArray(value);\n    if (!isDeep) {\n      return _copyArray(value, result);\n    }\n  } else {\n    var tag = _getTag(value),\n        isFunc = tag == funcTag$2 || tag == genTag$1;\n\n    if (isBuffer_1$1(value)) {\n      return _cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag$4 || tag == argsTag$3 || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : _initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? _copySymbolsIn(value, _baseAssignIn(result, value))\n          : _copySymbols(value, _baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = _initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new _Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet_1(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n\n    return result;\n  }\n\n  if (isMap_1(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n\n    return result;\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? _getAllKeysIn : _getAllKeys)\n    : (isFlat ? keysIn : keys_1);\n\n  var props = isArr ? undefined : keysFunc(value);\n  _arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nvar _baseClone = baseClone;\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG$1 = 1,\n    CLONE_SYMBOLS_FLAG$1 = 4;\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return _baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);\n}\n\nvar cloneDeep_1 = cloneDeep;\n\n// IMClient\nvar INVITED = 'invited';\nvar KICKED = 'kicked';\nvar MEMBERS_JOINED = 'membersjoined';\nvar MEMBERS_LEFT = 'membersleft';\nvar MEMBER_INFO_UPDATED = 'memberinfoupdated';\nvar BLOCKED = 'blocked';\nvar UNBLOCKED = 'unblocked';\nvar MEMBERS_BLOCKED = 'membersblocked';\nvar MEMBERS_UNBLOCKED = 'membersunblocked';\nvar MUTED = 'muted';\nvar UNMUTED = 'unmuted';\nvar MEMBERS_MUTED = 'membersmuted';\nvar MEMBERS_UNMUTED = 'membersunmuted';\nvar MESSAGE$1 = 'message';\nvar UNREAD_MESSAGES_COUNT_UPDATE = 'unreadmessagescountupdate';\nvar CLOSE = 'close';\nvar CONFLICT = 'conflict';\nvar UNHANDLED_MESSAGE = 'unhandledmessage';\nvar CONVERSATION_INFO_UPDATED = 'conversationinfoupdated';\n\n// Conversation\nvar LAST_DELIVERED_AT_UPDATE = 'lastdeliveredatupdate';\nvar LAST_READ_AT_UPDATE = 'lastreadatupdate';\nvar MESSAGE_RECALL = 'messagerecall';\nvar MESSAGE_UPDATE = 'messageupdate';\nvar INFO_UPDATED = 'infoupdated';\n\nvar Event = Object.freeze({\n\tINVITED: INVITED,\n\tKICKED: KICKED,\n\tMEMBERS_JOINED: MEMBERS_JOINED,\n\tMEMBERS_LEFT: MEMBERS_LEFT,\n\tMEMBER_INFO_UPDATED: MEMBER_INFO_UPDATED,\n\tBLOCKED: BLOCKED,\n\tUNBLOCKED: UNBLOCKED,\n\tMEMBERS_BLOCKED: MEMBERS_BLOCKED,\n\tMEMBERS_UNBLOCKED: MEMBERS_UNBLOCKED,\n\tMUTED: MUTED,\n\tUNMUTED: UNMUTED,\n\tMEMBERS_MUTED: MEMBERS_MUTED,\n\tMEMBERS_UNMUTED: MEMBERS_UNMUTED,\n\tMESSAGE: MESSAGE$1,\n\tUNREAD_MESSAGES_COUNT_UPDATE: UNREAD_MESSAGES_COUNT_UPDATE,\n\tCLOSE: CLOSE,\n\tCONFLICT: CONFLICT,\n\tUNHANDLED_MESSAGE: UNHANDLED_MESSAGE,\n\tCONVERSATION_INFO_UPDATED: CONVERSATION_INFO_UPDATED,\n\tLAST_DELIVERED_AT_UPDATE: LAST_DELIVERED_AT_UPDATE,\n\tLAST_READ_AT_UPDATE: LAST_READ_AT_UPDATE,\n\tMESSAGE_RECALL: MESSAGE_RECALL,\n\tMESSAGE_UPDATE: MESSAGE_UPDATE,\n\tINFO_UPDATED: INFO_UPDATED\n});\n\nvar _rMessageStatus;\n\n/**\n * 消息状态枚举\n * @enum {Symbol}\n * @since 3.2.0\n * @memberof module:leancloud-realtime\n */\nvar MessageStatus = {\n  /** 初始状态、未知状态 */\n  NONE: _Symbol('none'),\n  /** 正在发送 */\n  SENDING: _Symbol('sending'),\n  /** 已发送 */\n  SENT: _Symbol('sent'),\n  /** 已送达 */\n  DELIVERED: _Symbol('delivered'),\n  /** 发送失败 */\n  FAILED: _Symbol('failed')\n};\n_Object$freeze(MessageStatus);\n\nvar rMessageStatus = (_rMessageStatus = {}, _defineProperty(_rMessageStatus, MessageStatus.NONE, true), _defineProperty(_rMessageStatus, MessageStatus.SENDING, true), _defineProperty(_rMessageStatus, MessageStatus.SENT, true), _defineProperty(_rMessageStatus, MessageStatus.DELIVERED, true), _defineProperty(_rMessageStatus, MessageStatus.READ, true), _defineProperty(_rMessageStatus, MessageStatus.FAILED, true), _rMessageStatus);\n\nvar Message = function () {\n  /**\n   * @implements AVMessage\n   * @param  {Object|String|ArrayBuffer} content 消息内容\n   */\n  function Message(content) {\n    _classCallCheck(this, Message);\n\n    _Object$assign(this, { content: content }, {\n      /**\n       * @type {String}\n       * @memberof Message#\n       */\n      id: v4_1(),\n      /**\n       * 消息所在的 conversation id\n       * @memberof Message#\n       * @type {String?}\n       */\n      cid: null,\n      /**\n       * 消息发送时间\n       * @memberof Message#\n       * @type {Date}\n       */\n      timestamp: new Date(),\n      /**\n       * 消息发送者\n       * @memberof Message#\n       * @type {String}\n       */\n      from: undefined,\n      /**\n       * 消息提及的用户\n       * @since 4.0.0\n       * @memberof Message#\n       * @type {String[]}\n       */\n      mentionList: [],\n      /**\n       * 消息是否提及了所有人\n       * @since 4.0.0\n       * @memberof Message#\n       * @type {Boolean}\n       */\n      mentionedAll: false,\n      _mentioned: false\n    });\n    this._setStatus(MessageStatus.NONE);\n  }\n\n  /**\n   * 将当前消息的内容序列化为 JSON 对象\n   * @private\n   * @return {Object}\n   */\n\n\n  Message.prototype.getPayload = function getPayload() {\n    return this.content;\n  };\n\n  Message.prototype._toJSON = function _toJSON() {\n    var id = this.id,\n        cid = this.cid,\n        from = this.from,\n        timestamp = this.timestamp,\n        deliveredAt = this.deliveredAt,\n        updatedAt = this.updatedAt,\n        mentionList = this.mentionList,\n        mentionedAll = this.mentionedAll,\n        mentioned = this.mentioned;\n\n    return {\n      id: id,\n      cid: cid,\n      from: from,\n      timestamp: timestamp,\n      deliveredAt: deliveredAt,\n      updatedAt: updatedAt,\n      mentionList: mentionList,\n      mentionedAll: mentionedAll,\n      mentioned: mentioned\n    };\n  };\n\n  /**\n   * 返回 JSON 格式的消息\n   * @return {Object} 返回值是一个 plain Object\n   */\n\n\n  Message.prototype.toJSON = function toJSON() {\n    return _extends$1({}, this._toJSON(), {\n      data: this.content\n    });\n  };\n\n  /**\n   * 返回 JSON 格式的消息，与 toJSON 不同的是，该对象包含了完整的信息，可以通过 {@link IMClient#parseMessage} 反序列化。\n   * @return {Object} 返回值是一个 plain Object\n   * @since 4.0.0\n   */\n\n\n  Message.prototype.toFullJSON = function toFullJSON() {\n    var content = this.content,\n        id = this.id,\n        cid = this.cid,\n        from = this.from,\n        timestamp = this.timestamp,\n        deliveredAt = this.deliveredAt,\n        _updatedAt = this._updatedAt,\n        mentionList = this.mentionList,\n        mentionedAll = this.mentionedAll;\n\n    return {\n      data: content,\n      id: id,\n      cid: cid,\n      from: from,\n      timestamp: getTime(timestamp),\n      deliveredAt: getTime(deliveredAt),\n      updatedAt: getTime(_updatedAt),\n      mentionList: mentionList,\n      mentionedAll: mentionedAll\n    };\n  };\n\n  /**\n   * 消息状态，值为 {@link module:leancloud-realtime.MessageStatus} 之一\n   * @type {Symbol}\n   * @readonly\n   * @since 3.2.0\n   */\n\n\n  Message.prototype._setStatus = function _setStatus(status) {\n    if (!rMessageStatus[status]) {\n      throw new Error('Invalid message status');\n    }\n    this._status = status;\n  };\n\n  Message.prototype._updateMentioned = function _updateMentioned(client) {\n    this._mentioned = this.from !== client && (this.mentionedAll || this.mentionList.indexOf(client) > -1);\n  };\n  /**\n   * 获取提及用户列表\n   * @since 4.0.0\n   * @return {String[]} 提及用户的 id 列表\n   */\n\n\n  Message.prototype.getMentionList = function getMentionList() {\n    return this.mentionList;\n  };\n  /**\n   * 设置提及用户列表\n   * @since 4.0.0\n   * @param {String[]} clients 提及用户的 id 列表\n   * @return {this} self\n   */\n\n\n  Message.prototype.setMentionList = function setMentionList(clients) {\n    this.mentionList = ensureArray(clients);\n    return this;\n  };\n  /**\n   * 设置是否提及所有人\n   * @since 4.0.0\n   * @param {Boolean} [value=true]\n   * @return {this} self\n   */\n\n\n  Message.prototype.mentionAll = function mentionAll() {\n    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    this.mentionedAll = Boolean(value);\n    return this;\n  };\n\n  /**\n   * 判断给定的内容是否是有效的 Message，\n   * 该方法始终返回 true\n   * @private\n   * @returns {Boolean}\n   * @implements AVMessage.validate\n   */\n\n\n  Message.validate = function validate() {\n    return true;\n  };\n\n  /**\n   * 解析处理消息内容\n   * <pre>\n   * 如果子类提供了 message，返回该 message\n   * 如果没有提供，将 json 作为 content 实例化一个 Message\n   * @private\n   * @param  {Object}  json    json 格式的消息内容\n   * @param  {Message} message 子类提供的 message\n   * @return {Message}\n   * @implements AVMessage.parse\n   */\n\n\n  Message.parse = function parse(json, message) {\n    return message || new this(json);\n  };\n\n  _createClass(Message, [{\n    key: 'status',\n    get: function get() {\n      return this._status;\n    }\n  }, {\n    key: 'timestamp',\n    get: function get() {\n      return this._timestamp;\n    },\n    set: function set(value) {\n      this._timestamp = decodeDate(value);\n    }\n\n    /**\n     * 消息送达时间\n     * @type {?Date}\n     */\n\n  }, {\n    key: 'deliveredAt',\n    get: function get() {\n      return this._deliveredAt;\n    },\n    set: function set(value) {\n      this._deliveredAt = decodeDate(value);\n    }\n\n    /**\n     * 消息修改或撤回时间，可以通过比较其与消息的 timestamp 是否相等判断消息是否被修改过或撤回过。\n     * @type {Date}\n     * @since 3.5.0\n     */\n\n  }, {\n    key: 'updatedAt',\n    get: function get() {\n      return this._updatedAt || this.timestamp;\n    },\n    set: function set(value) {\n      this._updatedAt = decodeDate(value);\n    }\n\n    /**\n     * 当前用户是否在该消息中被提及\n     * @type {Boolean}\n     * @readonly\n     * @since 4.0.0\n     */\n\n  }, {\n    key: 'mentioned',\n    get: function get() {\n      return this._mentioned;\n    }\n  }]);\n\n  return Message;\n}();\n\n/* eslint-disable no-param-reassign */\n\n// documented in ../index.js\nvar messageType = function messageType(type) {\n  if (typeof type !== 'number') {\n    throw new TypeError(type + ' is not a Number');\n  }\n  return function (target) {\n    target.TYPE = type;\n    target.validate = function (json) {\n      return json._lctype === type;\n    };\n    target.prototype._getType = function () {\n      return { _lctype: type };\n    };\n  };\n};\n\n// documented in ../index.js\nvar messageField = function messageField(fields) {\n  if (typeof fields !== 'string') {\n    if (!Array.isArray(fields)) {\n      throw new TypeError(fields + ' is not an Array');\n    } else if (fields.some(function (value) {\n      return typeof value !== 'string';\n    })) {\n      throw new TypeError('fields contains non-string typed member');\n    }\n  }\n  return function (target) {\n    // IE10 Hack:\n    // static properties in IE10 will not be inherited from super\n    // search for parse method and assign it manually\n    var originalCustomFields = isIE10 ? getStaticProperty(target, '_customFields') : target._customFields;\n    originalCustomFields = Array.isArray(originalCustomFields) ? originalCustomFields : [];\n    target._customFields = originalCustomFields.concat(fields);\n  };\n};\n\n// IE10 Hack:\n// static properties in IE10 will not be inherited from super\n// search for parse method and assign it manually\n\nvar IE10Compatible = function IE10Compatible(target) {\n  if (isIE10) {\n    target.parse = getStaticProperty(target, 'parse');\n  }\n};\n\nvar _dec, _class$1;\n\n// jsdoc-ignore-start\n\n// jsdoc-ignore-end\n/**\n * 所有内置的富媒体消息均继承自本类\n * @extends Message\n */\nvar TypedMessage = (_dec = messageField(['_lctext', '_lcattrs']), _dec(_class$1 = function (_Message) {\n  _inherits(TypedMessage, _Message);\n\n  function TypedMessage() {\n    _classCallCheck(this, TypedMessage);\n\n    return _possibleConstructorReturn(this, _Message.apply(this, arguments));\n  }\n\n  /**\n   * @param {String} text\n   * @return {this} self\n   */\n  TypedMessage.prototype.setText = function setText(text) {\n    this._lctext = text;\n    return this;\n  };\n  /**\n   * @return {String}\n   */\n\n\n  TypedMessage.prototype.getText = function getText() {\n    return this._lctext;\n  };\n\n  /**\n   * @param {Object} attributes\n   * @return {this} self\n   */\n\n\n  TypedMessage.prototype.setAttributes = function setAttributes(attributes) {\n    this._lcattrs = attributes;\n    return this;\n  };\n  /**\n   * @return {Object}\n   */\n\n\n  TypedMessage.prototype.getAttributes = function getAttributes() {\n    return this._lcattrs;\n  };\n\n  TypedMessage.prototype._getCustomFields = function _getCustomFields() {\n    var _this2 = this;\n\n    var fields = Array.isArray(this.constructor._customFields) ? this.constructor._customFields : [];\n    return fields.reduce(function (result, field) {\n      if (typeof field !== 'string') return result;\n      result[field] = _this2[field]; // eslint-disable-line no-param-reassign\n      return result;\n    }, {});\n  };\n\n  /* eslint-disable class-methods-use-this */\n\n\n  TypedMessage.prototype._getType = function _getType() {\n    throw new Error('not implemented');\n  };\n  /* eslint-enable class-methods-use-this */\n\n  TypedMessage.prototype.getPayload = function getPayload() {\n    return compact(_Object$assign({\n      _lctext: this.getText(),\n      _lcattrs: this.getAttributes()\n    }, this._getCustomFields(), this._getType()));\n  };\n\n  TypedMessage.prototype.toJSON = function toJSON() {\n    var type = this.type,\n        text = this.text,\n        attributes = this.attributes,\n        summary = this.summary;\n\n    return _extends$1({}, _Message.prototype._toJSON.call(this), {\n      type: type,\n      text: text,\n      attributes: attributes,\n      summary: summary\n    });\n  };\n\n  TypedMessage.prototype.toFullJSON = function toFullJSON() {\n    return _extends$1({}, _Message.prototype.toFullJSON.call(this), {\n      data: this.getPayload()\n    });\n  };\n\n  /**\n   * 解析处理消息内容\n   * <pre>\n   * 为给定的 message 设置 text 与 attributes 属性，返回该 message\n   * 如果子类没有提供 message，new this()\n   * @protected\n   * @param  {Object}  json    json 格式的消息内容\n   * @param  {TypedMessage} message 子类提供的 message\n   * @return {TypedMessage}\n   * @implements AVMessage.parse\n   */\n\n\n  TypedMessage.parse = function parse(json) {\n    var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new this();\n\n    message.content = json; // eslint-disable-line no-param-reassign\n    var customFields = isIE10 ? getStaticProperty(message.constructor, '_customFields') : message.constructor._customFields;\n    var fields = Array.isArray(customFields) ? customFields : [];\n    fields = fields.reduce(function (result, field) {\n      if (typeof field !== 'string') return result;\n      result[field] = json[field]; // eslint-disable-line no-param-reassign\n      return result;\n    }, {});\n    _Object$assign(message, fields);\n    return _Message.parse.call(this, json, message);\n  };\n\n  _createClass(TypedMessage, [{\n    key: 'type',\n\n    /**\n     * @type {Number}\n     * @readonly\n     */\n    get: function get() {\n      return this.constructor.TYPE;\n    }\n\n    /** @type {String} */\n\n  }, {\n    key: 'text',\n    set: function set(text) {\n      return this.setText(text);\n    },\n    get: function get() {\n      return this.getText();\n    }\n\n    /** @type {Object} */\n\n  }, {\n    key: 'attributes',\n    set: function set(attributes) {\n      return this.setAttributes(attributes);\n    },\n    get: function get() {\n      return this.getAttributes();\n    }\n\n    /**\n     * 在客户端需要以文本形式展示该消息时显示的文案，\n     * 如 <code>[红包] 新春快乐</code>。\n     * 默认值为消息的 text。\n     * @type {String}\n     * @readonly\n     */\n\n  }, {\n    key: 'summary',\n    get: function get() {\n      return this.text;\n    }\n  }]);\n\n  return TypedMessage;\n}(Message)) || _class$1);\n\nvar _dec$1, _class$2;\n\n// jsdoc-ignore-start\n\n// jsdoc-ignore-end\n/**\n * 已撤回类型消息，当消息被撤回时，SDK 会使用该类型的消息替代原始消息\n * @extends TypedMessage\n */\nvar RecalledMessage = (_dec$1 = messageType(-127), _dec$1(_class$2 = IE10Compatible(_class$2 = function (_TypedMessage) {\n  _inherits(RecalledMessage, _TypedMessage);\n\n  function RecalledMessage() {\n    _classCallCheck(this, RecalledMessage);\n\n    return _possibleConstructorReturn(this, _TypedMessage.apply(this, arguments));\n  }\n\n  _createClass(RecalledMessage, [{\n    key: 'summary',\n\n    /**\n     * 在客户端需要以文本形式展示该消息时显示的文案，值为 <code>[该消息已撤回]</code>\n     * @type {String}\n     * @readonly\n     */\n    // eslint-disable-next-line class-methods-use-this\n    get: function get() {\n      return '[该消息已撤回]';\n    }\n  }]);\n\n  return RecalledMessage;\n}(TypedMessage)) || _class$2) || _class$2);\n\nvar debug$6 = browser('LC:Conversation');\n\nvar serializeMessage = function serializeMessage(message) {\n  var content = message.getPayload();\n  var msg = void 0;\n  var binaryMsg = void 0;\n  if (content instanceof ArrayBuffer) {\n    binaryMsg = content;\n  } else if (typeof content !== 'string') {\n    msg = _JSON$stringify(content);\n  } else {\n    msg = content;\n  }\n  return { msg: msg, binaryMsg: binaryMsg };\n};\n\nvar _LogsCommand$QueryDir = LogsCommand.QueryDirection,\n    NEW = _LogsCommand$QueryDir.NEW,\n    OLD = _LogsCommand$QueryDir.OLD;\n\n/**\n * 历史消息查询方向枚举\n * @enum {Number}\n * @since 4.0.0\n * @memberof module:leancloud-realtime\n */\n\nvar MessageQueryDirection = {\n  /** 从后向前 */\n  NEW_TO_OLD: OLD,\n  /** 从前向后 */\n  OLD_TO_NEW: NEW\n};\n_Object$freeze(MessageQueryDirection);\n\nvar ConversationBase = function (_EventEmitter) {\n  _inherits(ConversationBase, _EventEmitter);\n\n  /**\n   * @extends EventEmitter\n   * @private\n   * @abstract\n   */\n  function ConversationBase(_ref, client) {\n    var id = _ref.id,\n        lastMessageAt = _ref.lastMessageAt,\n        lastMessage = _ref.lastMessage,\n        lastDeliveredAt = _ref.lastDeliveredAt,\n        lastReadAt = _ref.lastReadAt,\n        _ref$unreadMessagesCo = _ref.unreadMessagesCount,\n        unreadMessagesCount = _ref$unreadMessagesCo === undefined ? 0 : _ref$unreadMessagesCo,\n        _ref$members = _ref.members,\n        members = _ref$members === undefined ? [] : _ref$members,\n        _ref$mentioned = _ref.mentioned,\n        mentioned = _ref$mentioned === undefined ? false : _ref$mentioned,\n        properties = _objectWithoutProperties(_ref, ['id', 'lastMessageAt', 'lastMessage', 'lastDeliveredAt', 'lastReadAt', 'unreadMessagesCount', 'members', 'mentioned']);\n\n    _classCallCheck(this, ConversationBase);\n\n    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));\n\n    _Object$assign(_this, _extends$1({\n      /**\n       * 对话 id，对应 _Conversation 表中的 objectId\n       * @memberof ConversationBase#\n       * @type {String}\n       */\n      id: id,\n      /**\n       * 最后一条消息时间\n       * @memberof ConversationBase#\n       * @type {?Date}\n       */\n      lastMessageAt: lastMessageAt,\n      /**\n       * 最后一条消息\n       * @memberof ConversationBase#\n       * @type {?Message}\n       */\n      lastMessage: lastMessage,\n      /**\n       * 参与该对话的用户列表\n       * @memberof ConversationBase#\n       * @type {String[]}\n       */\n      members: members\n    }, properties));\n    _this.members = _Array$from(new _Set(_this.members));\n    _Object$assign(internal(_this), {\n      messagesWaitingForReceipt: {},\n      lastDeliveredAt: lastDeliveredAt,\n      lastReadAt: lastReadAt,\n      unreadMessagesCount: unreadMessagesCount,\n      mentioned: mentioned\n    });\n    if (client instanceof IMClient) {\n      _this._client = client;\n    } else {\n      throw new TypeError('Conversation must be initialized with a client');\n    }\n    if (debug$6.enabled) {\n      _Object$values(Event).forEach(function (event) {\n        return _this.on(event, function () {\n          for (var _len = arguments.length, payload = Array(_len), _key = 0; _key < _len; _key++) {\n            payload[_key] = arguments[_key];\n          }\n\n          return _this._debug(event + ' event emitted. %o', payload);\n        });\n      });\n    }\n    // onConversationCreate hook\n    applyDecorators(_this._client._plugins.onConversationCreate, _this);\n    return _this;\n  }\n\n  /**\n   * 当前用户是否在该对话的未读消息中被提及\n   * @type {Boolean}\n   * @since 4.0.0\n   */\n\n\n  ConversationBase.prototype._setUnreadMessagesMentioned = function _setUnreadMessagesMentioned(value) {\n    internal(this).unreadMessagesMentioned = Boolean(value);\n  };\n\n  ConversationBase.prototype._setLastDeliveredAt = function _setLastDeliveredAt(value) {\n    var date = decodeDate(value);\n    if (!(date < internal(this).lastDeliveredAt)) {\n      internal(this).lastDeliveredAt = date;\n      /**\n       * 最后消息送达时间更新\n       * @event ConversationBase#LAST_DELIVERED_AT_UPDATE\n       * @since 3.4.0\n       */\n      this.emit(LAST_DELIVERED_AT_UPDATE);\n    }\n  };\n  /**\n   * 最后消息被阅读时间，常用来实现发送消息的「已读」标记，可通过 {@link Conversation#fetchReceiptTimestamps} 获取或更新该属性\n   * @type {?Date}\n   * @since 3.4.0\n   */\n\n\n  ConversationBase.prototype._setLastReadAt = function _setLastReadAt(value) {\n    var date = decodeDate(value);\n    if (!(date < internal(this).lastReadAt)) {\n      internal(this).lastReadAt = date;\n      /**\n       * 最后消息被阅读时间更新\n       * @event ConversationBase#LAST_READ_AT_UPDATE\n       * @since 3.4.0\n       */\n      this.emit(LAST_READ_AT_UPDATE);\n    }\n  };\n\n  /**\n   * 返回 JSON 格式的对话，与 toJSON 不同的是，该对象包含了完整的信息，可以通过 {@link IMClient#parseConversation} 反序列化。\n   * @return {Object} 返回值是一个 plain Object\n   * @since 4.0.0\n   */\n\n\n  ConversationBase.prototype.toFullJSON = function toFullJSON() {\n    var id = this.id,\n        members = this.members,\n        lastMessageAt = this.lastMessageAt,\n        lastDeliveredAt = this.lastDeliveredAt,\n        lastReadAt = this.lastReadAt,\n        lastMessage = this.lastMessage,\n        unreadMessagesCount = this.unreadMessagesCount;\n\n    return {\n      id: id,\n      members: members,\n      lastMessageAt: getTime(lastMessageAt),\n      lastDeliveredAt: getTime(lastDeliveredAt),\n      lastReadAt: getTime(lastReadAt),\n      lastMessage: lastMessage ? lastMessage.toFullJSON() : undefined,\n      unreadMessagesCount: unreadMessagesCount\n    };\n  };\n\n  /**\n   * 返回 JSON 格式的对话\n   * @return {Object} 返回值是一个 plain Object\n   * @since 4.0.0\n   */\n\n\n  ConversationBase.prototype.toJSON = function toJSON() {\n    var id = this.id,\n        members = this.members,\n        lastMessageAt = this.lastMessageAt,\n        lastDeliveredAt = this.lastDeliveredAt,\n        lastReadAt = this.lastReadAt,\n        lastMessage = this.lastMessage,\n        unreadMessagesCount = this.unreadMessagesCount,\n        unreadMessagesMentioned = this.unreadMessagesMentioned;\n\n    return {\n      id: id,\n      members: members,\n      lastMessageAt: lastMessageAt,\n      lastDeliveredAt: lastDeliveredAt,\n      lastReadAt: lastReadAt,\n      lastMessage: lastMessage ? lastMessage.toJSON() : undefined,\n      unreadMessagesCount: unreadMessagesCount,\n      unreadMessagesMentioned: unreadMessagesMentioned\n    };\n  };\n\n  ConversationBase.prototype._debug = function _debug() {\n    for (var _len2 = arguments.length, params = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      params[_key2] = arguments[_key2];\n    }\n\n    debug$6.apply(undefined, params.concat(['[' + this.id + ']']));\n  };\n\n  ConversationBase.prototype._send = function _send(command) {\n    var _client;\n\n    /* eslint-disable no-param-reassign */\n    if (command.cmd === null) {\n      command.cmd = 'conv';\n    }\n    if (command.cmd === 'conv' && command.convMessage === null) {\n      command.convMessage = new ConvCommand();\n    }\n    if (command.convMessage && command.convMessage.cid === null) {\n      command.convMessage.cid = this.id;\n    }\n    /* eslint-enable no-param-reassign */\n\n    for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    return (_client = this._client)._send.apply(_client, [command].concat(args));\n  };\n\n  /**\n   * 发送消息\n   * @param  {Message} message 消息，Message 及其子类的实例\n   * @param {Object} [options] since v3.3.0，发送选项\n   * @param {Boolean} [options.transient] since v3.3.1，是否作为暂态消息发送\n   * @param {Boolean} [options.receipt] 是否需要回执，仅在普通对话中有效\n   * @param {Boolean} [options.will] since v3.4.0，是否指定该消息作为「掉线消息」发送，\n   * 「掉线消息」会延迟到当前用户掉线后发送，常用来实现「下线通知」功能\n   * @param {MessagePriority} [options.priority] 消息优先级，仅在暂态对话中有效，\n   * see: {@link module:leancloud-realtime.MessagePriority MessagePriority}\n   * @param {Object} [options.pushData] 消息对应的离线推送内容，如果消息接收方不在线，会推送指定的内容。其结构说明参见: {@link https://url.leanapp.cn/pushData 推送消息内容}\n   * @return {Promise.<Message>} 发送的消息\n   */\n\n\n  ConversationBase.prototype.send = function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(message, options) {\n      var _Object$assign2, transient, receipt, priority, pushData, will, _serializeMessage, msg, binaryMsg, command, resCommand, _resCommand$ackMessag, uid, t, code, reason, appCode;\n\n      return regenerator.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              this._debug(message, 'send');\n\n              if (message instanceof Message) {\n                _context.next = 3;\n                break;\n              }\n\n              throw new TypeError(message + ' is not a Message');\n\n            case 3:\n              _Object$assign2 = _Object$assign({},\n              // support Message static property: sendOptions\n              message.constructor.sendOptions,\n              // support Message static property: getSendOptions\n              typeof message.constructor.getSendOptions === 'function' ? message.constructor.getSendOptions(message) : {}, options), transient = _Object$assign2.transient, receipt = _Object$assign2.receipt, priority = _Object$assign2.priority, pushData = _Object$assign2.pushData, will = _Object$assign2.will;\n\n              if (receipt) {\n                if (this.transient) {\n                  console.warn('receipt option is ignored as the conversation is transient.');\n                } else if (transient) {\n                  console.warn('receipt option is ignored as the message is sent transiently.');\n                } else if (this.members.length > 2) {\n                  console.warn('receipt option is recommended to be used in one-on-one conversation.'); // eslint-disable-line max-len\n                }\n              }\n              if (priority && !this.transient) {\n                console.warn('priority option is ignored as the conversation is not transient.');\n              }\n              _Object$assign(message, {\n                cid: this.id,\n                from: this._client.id\n              });\n              message._setStatus(MessageStatus.SENDING);\n              _serializeMessage = serializeMessage(message), msg = _serializeMessage.msg, binaryMsg = _serializeMessage.binaryMsg;\n              command = new GenericCommand({\n                cmd: 'direct',\n                directMessage: new DirectCommand({\n                  msg: msg,\n                  binaryMsg: binaryMsg,\n                  cid: this.id,\n                  r: receipt,\n                  transient: transient,\n                  dt: message.id,\n                  pushData: _JSON$stringify(pushData),\n                  will: will,\n                  mentionPids: message.mentionList,\n                  mentionAll: message.mentionedAll\n                }),\n                priority: priority\n              });\n              _context.prev = 10;\n              _context.next = 13;\n              return this._send(command);\n\n            case 13:\n              resCommand = _context.sent;\n\n              if (transient) {\n                _context.next = 21;\n                break;\n              }\n\n              _resCommand$ackMessag = resCommand.ackMessage, uid = _resCommand$ackMessag.uid, t = _resCommand$ackMessag.t, code = _resCommand$ackMessag.code, reason = _resCommand$ackMessag.reason, appCode = _resCommand$ackMessag.appCode;\n\n              if (!(code !== null)) {\n                _context.next = 18;\n                break;\n              }\n\n              throw createError$1({\n                code: code,\n                reason: reason,\n                appCode: appCode\n              });\n\n            case 18:\n              _Object$assign(message, {\n                id: uid,\n                timestamp: t\n              });\n              this.lastMessage = message;\n              this.lastMessageAt = message.timestamp;\n\n            case 21:\n              message._setStatus(MessageStatus.SENT);\n              if (receipt) {\n                internal(this).messagesWaitingForReceipt[message.id] = message;\n              }\n              return _context.abrupt('return', message);\n\n            case 26:\n              _context.prev = 26;\n              _context.t0 = _context['catch'](10);\n\n              message._setStatus(MessageStatus.FAILED);\n              throw _context.t0;\n\n            case 30:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, this, [[10, 26]]);\n    }));\n\n    function send(_x, _x2) {\n      return _ref2.apply(this, arguments);\n    }\n\n    return send;\n  }();\n\n  ConversationBase.prototype._update = function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(message, newMessage, recall) {\n      var msg, binaryMsg, content, id, cid, timestamp, from, _status;\n\n      return regenerator.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              this._debug('patch %O %O %O', message, newMessage, recall);\n\n              if (!(message instanceof Message)) {\n                _context2.next = 8;\n                break;\n              }\n\n              if (!(message.from !== this._client.id)) {\n                _context2.next = 4;\n                break;\n              }\n\n              throw new Error('Updating message from others is not allowed');\n\n            case 4:\n              if (!(message.status !== MessageStatus.SENT && message.status !== MessageStatus.DELIVERED)) {\n                _context2.next = 6;\n                break;\n              }\n\n              throw new Error('Message is not sent');\n\n            case 6:\n              _context2.next = 10;\n              break;\n\n            case 8:\n              if (message.id && message.timestamp) {\n                _context2.next = 10;\n                break;\n              }\n\n              throw new TypeError(message + ' is not a Message');\n\n            case 10:\n              msg = void 0;\n              binaryMsg = void 0;\n\n              if (!recall) {\n                content = serializeMessage(newMessage);\n                msg = content.msg;\n                binaryMsg = content.binaryMsg;\n              }\n              _context2.next = 15;\n              return this._send(new GenericCommand({\n                cmd: CommandType.patch,\n                op: OpType.modify,\n                patchMessage: new PatchCommand({\n                  patches: [new PatchItem({\n                    cid: this.id,\n                    mid: message.id,\n                    timestamp: Number(message.timestamp),\n                    recall: recall,\n                    data: msg,\n                    binaryMsg: binaryMsg,\n                    mentionPids: newMessage.mentionList,\n                    mentionAll: newMessage.mentionedAll\n                  })],\n                  lastPatchTime: this._client._lastPatchTime\n                })\n              }));\n\n            case 15:\n              id = message.id, cid = message.cid, timestamp = message.timestamp, from = message.from, _status = message._status;\n\n              _Object$assign(newMessage, {\n                id: id,\n                cid: cid,\n                timestamp: timestamp,\n                from: from,\n                _status: _status\n              });\n              if (this.lastMessage.id === newMessage.id) {\n                this.lastMessage = newMessage;\n              }\n              return _context2.abrupt('return', newMessage);\n\n            case 19:\n            case 'end':\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    function _update(_x3, _x4, _x5) {\n      return _ref3.apply(this, arguments);\n    }\n\n    return _update;\n  }();\n\n  /**\n   * 获取对话人数，或暂态对话的在线人数\n   * @return {Promise.<Number>}\n   */\n\n\n  ConversationBase.prototype.count = function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {\n      var resCommand;\n      return regenerator.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              this._debug('count');\n              _context3.next = 3;\n              return this._send(new GenericCommand({\n                op: 'count'\n              }));\n\n            case 3:\n              resCommand = _context3.sent;\n              return _context3.abrupt('return', resCommand.convMessage.count);\n\n            case 5:\n            case 'end':\n              return _context3.stop();\n          }\n        }\n      }, _callee3, this);\n    }));\n\n    function count() {\n      return _ref4.apply(this, arguments);\n    }\n\n    return count;\n  }();\n\n  /**\n   * 修改已发送的消息\n   * @param {AVMessage} message 要修改的消息，该消息必须是由当前用户发送的。也可以提供一个包含消息 {id, timestamp} 的对象\n   * @param {AVMessage} newMessage 新的消息\n   * @return {Promise.<AVMessage>} 更新后的消息\n   */\n\n\n  ConversationBase.prototype.update = function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(message, newMessage) {\n      return regenerator.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              if (newMessage instanceof Message) {\n                _context4.next = 2;\n                break;\n              }\n\n              throw new TypeError(newMessage + ' is not a Message');\n\n            case 2:\n              return _context4.abrupt('return', this._update(message, newMessage, false));\n\n            case 3:\n            case 'end':\n              return _context4.stop();\n          }\n        }\n      }, _callee4, this);\n    }));\n\n    function update(_x6, _x7) {\n      return _ref5.apply(this, arguments);\n    }\n\n    return update;\n  }();\n\n  /**\n   * 撤回已发送的消息\n   * @param {AVMessage} message 要撤回的消息，该消息必须是由当前用户发送的。也可以提供一个包含消息 {id, timestamp} 的对象\n   * @return {Promise.<RecalledMessage>} 一条已撤回的消息\n   */\n\n\n  ConversationBase.prototype.recall = function () {\n    var _ref6 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(message) {\n      return regenerator.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              return _context5.abrupt('return', this._update(message, new RecalledMessage(), true));\n\n            case 1:\n            case 'end':\n              return _context5.stop();\n          }\n        }\n      }, _callee5, this);\n    }));\n\n    function recall(_x8) {\n      return _ref6.apply(this, arguments);\n    }\n\n    return recall;\n  }();\n\n  /**\n   * 查询消息记录\n   * 如果仅需实现消息向前记录翻页查询需求，建议使用 {@link Conversation#createMessagesIterator}。\n   * 不论何种方向，获得的消息都是按照时间升序排列的。\n   * startClosed 与 endClosed 用于指定查询区间的开闭。\n   *\n   * @param  {Object} [options]\n   * @param  {Number} [options.limit] 限制查询结果的数量，目前服务端默认为 20\n   * @param  {Number}   [options.type] 指定查询的富媒体消息类型，不指定则查询所有消息。\n   * @param  {MessageQueryDirection} [options.direction] 查询的方向。\n   * 在不指定的情况下如果 startTime 大于 endTime，则为从新到旧查询，可以实现加载聊天记录等场景。\n   * 如果 startTime 小于 endTime，则为从旧到新查询，可以实现弹幕等场景。\n   * @param  {Date}   [options.startTime] 从该时间开始查询，不传则从当前时间开始查询\n   * @param  {String} [options.startMessageId] 从该消息之前开始查询，需要与 startTime 同时使用，为防止某时刻有重复消息\n   * @param  {Boolean}[options.startClosed] 指定查询范围是否包括开始的时间点，默认不包括\n   * @param  {Date}   [options.endTime] 查询到该时间为止，不传则查询最早消息为止\n   * @param  {String} [options.endMessageId] 查询到该消息为止，需要与 endTime 同时使用，为防止某时刻有重复消息\n   * @param  {Boolean}[options.endClosed] 指定查询范围是否包括结束的时间点，默认不包括\n   *\n   * @param  {Date}   [options.beforeTime] DEPRECATED: 使用 startTime 代替。限制查询结果为小于该时间之前的消息，不传则为当前时间\n   * @param  {String} [options.beforeMessageId] DEPRECATED: 使用 startMessageId 代替。\n   * 限制查询结果为该消息之前的消息，需要与 beforeTime 同时使用，为防止某时刻有重复消息\n   * @param  {Date}   [options.afterTime] DEPRECATED: 使用 endTime 代替。限制查询结果为大于该时间之前的消息\n   * @param  {String} [options.afterMessageId] DEPRECATED: 使用 endMessageId 代替。\n   * 限制查询结果为该消息之后的消息，需要与 afterTime 同时使用，为防止某时刻有重复消息\n   * @return {Promise.<Message[]>} 消息列表\n   */\n\n\n  ConversationBase.prototype.queryMessages = function () {\n    var _ref7 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var beforeTime, beforeMessageId, afterTime, afterMessageId, limit, direction, type, startTime, startMessageId, startClosed, endTime, endMessageId, endClosed, conditions, resCommand;\n      return regenerator.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              this._debug('query messages %O', options);\n              beforeTime = options.beforeTime, beforeMessageId = options.beforeMessageId, afterTime = options.afterTime, afterMessageId = options.afterMessageId, limit = options.limit, direction = options.direction, type = options.type, startTime = options.startTime, startMessageId = options.startMessageId, startClosed = options.startClosed, endTime = options.endTime, endMessageId = options.endMessageId, endClosed = options.endClosed;\n\n              if (!(beforeMessageId || beforeTime || afterMessageId || afterTime)) {\n                _context7.next = 5;\n                break;\n              }\n\n              console.warn('DEPRECATION: queryMessages options beforeTime, beforeMessageId, afterTime and afterMessageId are deprecated in favor of startTime, startMessageId, endTime and endMessageId.');\n              return _context7.abrupt('return', this.queryMessages({\n                startTime: beforeTime,\n                startMessageId: beforeMessageId,\n                endTime: afterTime,\n                endMessageId: afterMessageId,\n                limit: limit\n              }));\n\n            case 5:\n              if (!(startMessageId && !startTime)) {\n                _context7.next = 7;\n                break;\n              }\n\n              throw new Error('query option startMessageId must be used with option startTime');\n\n            case 7:\n              if (!(endMessageId && !endTime)) {\n                _context7.next = 9;\n                break;\n              }\n\n              throw new Error('query option endMessageId must be used with option endTime');\n\n            case 9:\n              conditions = {\n                t: startTime,\n                mid: startMessageId,\n                tIncluded: startClosed,\n                tt: endTime,\n                tmid: endMessageId,\n                ttIncluded: endClosed,\n                l: limit,\n                lctype: type\n              };\n\n              if (conditions.t instanceof Date) {\n                conditions.t = conditions.t.getTime();\n              }\n              if (conditions.tt instanceof Date) {\n                conditions.tt = conditions.tt.getTime();\n              }\n              if (direction !== undefined) {\n                conditions.direction = direction;\n              } else if (conditions.tt > conditions.t) {\n                conditions.direction = MessageQueryDirection.OLD_TO_NEW;\n              }\n              _context7.next = 15;\n              return this._send(new GenericCommand({\n                cmd: 'logs',\n                logsMessage: new LogsCommand(_Object$assign(conditions, {\n                  cid: this.id\n                }))\n              }));\n\n            case 15:\n              resCommand = _context7.sent;\n              return _context7.abrupt('return', _Promise.all(resCommand.logsMessage.logs.map(function () {\n                var _ref9 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6(_ref8) {\n                  var msgId = _ref8.msgId,\n                      timestamp = _ref8.timestamp,\n                      patchTimestamp = _ref8.patchTimestamp,\n                      from = _ref8.from,\n                      ackAt = _ref8.ackAt,\n                      readAt = _ref8.readAt,\n                      data = _ref8.data,\n                      mentionAll = _ref8.mentionAll,\n                      mentionPids = _ref8.mentionPids,\n                      bin = _ref8.bin;\n                  var messageData, message, status;\n                  return regenerator.wrap(function _callee6$(_context6) {\n                    while (1) {\n                      switch (_context6.prev = _context6.next) {\n                        case 0:\n                          messageData = {\n                            data: data,\n                            bin: bin,\n                            id: msgId,\n                            cid: _this2.id,\n                            timestamp: timestamp,\n                            from: from,\n                            deliveredAt: ackAt,\n                            updatedAt: patchTimestamp,\n                            mentionList: mentionPids,\n                            mentionedAll: mentionAll\n                          };\n                          _context6.next = 3;\n                          return _this2._client.parseMessage(messageData);\n\n                        case 3:\n                          message = _context6.sent;\n                          status = MessageStatus.SENT;\n\n                          if (_this2.members.length === 2) {\n                            if (ackAt) status = MessageStatus.DELIVERED;\n                            if (ackAt) _this2._setLastDeliveredAt(ackAt);\n                            if (readAt) _this2._setLastReadAt(readAt);\n                          }\n                          message._setStatus(status);\n                          return _context6.abrupt('return', message);\n\n                        case 8:\n                        case 'end':\n                          return _context6.stop();\n                      }\n                    }\n                  }, _callee6, _this2);\n                }));\n\n                return function (_x10) {\n                  return _ref9.apply(this, arguments);\n                };\n              }())));\n\n            case 17:\n            case 'end':\n              return _context7.stop();\n          }\n        }\n      }, _callee7, this);\n    }));\n\n    function queryMessages() {\n      return _ref7.apply(this, arguments);\n    }\n\n    return queryMessages;\n  }();\n\n  /**\n   * 获取消息翻页迭代器\n   * @param  {Object} [options]\n   * @param  {Date}   [options.beforeTime] 限制起始查询结果为小于该时间之前的消息，不传则为当前时间\n   * @param  {String} [options.beforeMessageId] 限制起始查询结果为该消息之前的消息，需要与 beforeTime 同时使用，为防止某时刻有重复消息\n   * @param  {Number} [options.limit] 限制每页查询结果的数量，目前服务端默认为 20\n   * @return {AsyncIterater.<Promise.<IteratorResult<Message[]>>>} [AsyncIterator]{@link https://github.com/tc39/proposal-async-iteration}，调用其 next 方法返回获取下一页消息的 Promise\n   * @example\n   * var messageIterator = conversation.createMessagesIterator({ limit: 10 });\n   * messageIterator.next().then(function(result) {\n   *   // result: {\n   *   //   value: [message1, ..., message10],\n   *   //   done: false,\n   *   // }\n   * });\n   * messageIterator.next().then(function(result) {\n   *   // result: {\n   *   //   value: [message11, ..., message20],\n   *   //   done: false,\n   *   // }\n   * });\n   * messageIterator.next().then(function(result) {\n   *   // No more messages\n   *   // result: { value: [], done: true }\n   * });\n   */\n\n\n  ConversationBase.prototype.createMessagesIterator = function createMessagesIterator() {\n    var _this3 = this;\n\n    var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        beforeTime = _ref10.beforeTime,\n        beforeMessageId = _ref10.beforeMessageId,\n        limit = _ref10.limit;\n\n    var promise = void 0;\n    return {\n      next: function next() {\n        if (promise === undefined) {\n          // first call\n          promise = _this3.queryMessages({\n            limit: limit,\n            startTime: beforeTime,\n            startMessageId: beforeMessageId\n          });\n        } else {\n          promise = promise.then(function (prevMessages) {\n            if (prevMessages.length === 0 || prevMessages.length < limit) {\n              // no more messages\n              return [];\n            }\n            return _this3.queryMessages({\n              startTime: prevMessages[0].timestamp,\n              startMessageId: prevMessages[0].id,\n              limit: limit\n            });\n          });\n        }\n        return promise.then(function (value) {\n          return {\n            value: _Array$from(value),\n            done: value.length === 0 || value.length < limit\n          };\n        });\n      }\n    };\n  };\n\n  /**\n   * 将该会话标记为已读\n   * @return {Promise.<this>} self\n   */\n\n\n  ConversationBase.prototype.read = function () {\n    var _ref11 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8() {\n      var client;\n      return regenerator.wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              this.unreadMessagesCount = 0;\n              this._setUnreadMessagesMentioned(false);\n              // 跳过暂态会话\n\n              if (!this.transient) {\n                _context8.next = 4;\n                break;\n              }\n\n              return _context8.abrupt('return', this);\n\n            case 4:\n              client = this._client;\n\n              if (!internal(client).readConversationsBuffer) {\n                internal(client).readConversationsBuffer = new _Set();\n              }\n              internal(client).readConversationsBuffer.add(this);\n              client._doSendRead();\n              return _context8.abrupt('return', this);\n\n            case 9:\n            case 'end':\n              return _context8.stop();\n          }\n        }\n      }, _callee8, this);\n    }));\n\n    function read() {\n      return _ref11.apply(this, arguments);\n    }\n\n    return read;\n  }();\n\n  ConversationBase.prototype._handleReceipt = function _handleReceipt(_ref12) {\n    var messageId = _ref12.messageId,\n        timestamp = _ref12.timestamp,\n        read = _ref12.read;\n\n    if (read) {\n      this._setLastReadAt(timestamp);\n    } else {\n      this._setLastDeliveredAt(timestamp);\n    }\n\n    var _internal = internal(this),\n        messagesWaitingForReceipt = _internal.messagesWaitingForReceipt;\n\n    var message = messagesWaitingForReceipt[messageId];\n    if (!message) return;\n    message._setStatus(MessageStatus.DELIVERED);\n    message.deliveredAt = timestamp;\n    delete messagesWaitingForReceipt[messageId];\n  };\n\n  /**\n   * 更新对话的最新回执时间戳（lastDeliveredAt、lastReadAt）\n   * @since 3.4.0\n   * @return {Promise.<this>} this\n   */\n\n\n  ConversationBase.prototype.fetchReceiptTimestamps = function () {\n    var _ref13 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee9() {\n      var _ref14, _ref14$convMessage, maxReadTimestamp, maxAckTimestamp;\n\n      return regenerator.wrap(function _callee9$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.next = 2;\n              return this._send(new GenericCommand({\n                op: 'max_read'\n              }));\n\n            case 2:\n              _ref14 = _context9.sent;\n              _ref14$convMessage = _ref14.convMessage;\n              maxReadTimestamp = _ref14$convMessage.maxReadTimestamp;\n              maxAckTimestamp = _ref14$convMessage.maxAckTimestamp;\n\n              this._setLastDeliveredAt(maxAckTimestamp);\n              this._setLastReadAt(maxReadTimestamp);\n              return _context9.abrupt('return', this);\n\n            case 9:\n            case 'end':\n              return _context9.stop();\n          }\n        }\n      }, _callee9, this);\n    }));\n\n    function fetchReceiptTimestamps() {\n      return _ref13.apply(this, arguments);\n    }\n\n    return fetchReceiptTimestamps;\n  }();\n\n  ConversationBase.prototype._fetchAllReceiptTimestamps = function _fetchAllReceiptTimestamps() {\n    var convMessage = new ConvCommand({\n      queryAllMembers: true\n    });\n    return this._send(new GenericCommand({\n      op: 'max_read',\n      convMessage: convMessage\n    })).then(function (_ref15) {\n      var maxReadTuples = _ref15.convMessage.maxReadTuples;\n      return maxReadTuples.filter(function (maxReadTuple) {\n        return maxReadTuple.maxAckTimestamp || maxReadTuple.maxReadTimestamp;\n      }).map(function (_ref16) {\n        var pid = _ref16.pid,\n            maxAckTimestamp = _ref16.maxAckTimestamp,\n            maxReadTimestamp = _ref16.maxReadTimestamp;\n        return {\n          pid: pid,\n          lastDeliveredAt: decodeDate(maxAckTimestamp),\n          lastReadAt: decodeDate(maxReadTimestamp)\n        };\n      });\n    });\n  };\n\n  _createClass(ConversationBase, [{\n    key: 'unreadMessagesMentioned',\n    get: function get() {\n      return internal(this).unreadMessagesMentioned;\n    }\n  }, {\n    key: 'unreadMessagesCount',\n    set: function set(value) {\n      if (value !== this.unreadMessagesCount) {\n        internal(this).unreadMessagesCount = value;\n        this._client.emit(UNREAD_MESSAGES_COUNT_UPDATE, [this]);\n      }\n    }\n    /**\n     * 当前用户在该对话的未读消息数\n     * @type {Number}\n     */\n    ,\n    get: function get() {\n      return internal(this).unreadMessagesCount;\n    }\n  }, {\n    key: 'lastMessageAt',\n    set: function set(value) {\n      var time = decodeDate(value);\n      if (time <= this._lastMessageAt) return;\n      this._lastMessageAt = time;\n    },\n    get: function get() {\n      return this._lastMessageAt;\n    }\n    /**\n     * 最后消息送达时间，常用来实现消息的「已送达」标记，可通过 {@link Conversation#fetchReceiptTimestamps} 获取或更新该属性\n     * @type {?Date}\n     * @since 3.4.0\n     */\n\n  }, {\n    key: 'lastDeliveredAt',\n    get: function get() {\n      if (this.members.length !== 2) return null;\n      return internal(this).lastDeliveredAt;\n    }\n  }, {\n    key: 'lastReadAt',\n    get: function get() {\n      if (this.members.length !== 2) return null;\n      return internal(this).lastReadAt;\n    }\n  }]);\n\n  return ConversationBase;\n}(eventemitter3);\n\n/**\n * 对话成员角色枚举\n * @enum {String}\n * @since 4.0.0\n * @memberof module:leancloud-realtime\n */\nvar ConversationMemberRole = {\n  /** 管理员 */\n  MANAGER: 'Manager',\n  /** 成员 */\n  MEMBER: 'Member'\n};\n_Object$freeze(ConversationMemberRole);\n\nvar ConversationMemberInfo = function () {\n  /**\n   * 对话成员属性，保存了成员与某个对话相关的属性，对应 _ConversationMemberInfo 表\n   * @since 4.0.0\n   */\n  function ConversationMemberInfo(_ref) {\n    var conversation = _ref.conversation,\n        memberId = _ref.memberId,\n        role = _ref.role;\n\n    _classCallCheck(this, ConversationMemberInfo);\n\n    if (!conversation) throw new Error('conversation requried');\n    if (!memberId) throw new Error('memberId requried');\n    _Object$assign(internal(this), {\n      conversation: conversation,\n      memberId: memberId,\n      role: role\n    });\n  }\n\n  /**\n   * 对话 Id\n   * @type {String}\n   * @readonly\n   */\n\n\n  ConversationMemberInfo.prototype.toJSON = function toJSON() {\n    var conversationId = this.conversationId,\n        memberId = this.memberId,\n        role = this.role,\n        isOwner = this.isOwner;\n\n    return {\n      conversationId: conversationId,\n      memberId: memberId,\n      role: role,\n      isOwner: isOwner\n    };\n  };\n\n  _createClass(ConversationMemberInfo, [{\n    key: 'conversationId',\n    get: function get() {\n      return internal(this).conversation.id;\n    }\n    /**\n     * 成员 Id\n     * @type {String}\n     * @readonly\n     */\n\n  }, {\n    key: 'memberId',\n    get: function get() {\n      return internal(this).memberId;\n    }\n    /**\n     * 角色\n     * @type {module:leancloud-realtime.ConversationMemberRole | String}\n     * @readonly\n     */\n\n  }, {\n    key: 'role',\n    get: function get() {\n      return internal(this).role;\n    }\n    /**\n     * 是否是管理员\n     * @type {Boolean}\n     * @readonly\n     */\n\n  }, {\n    key: 'isOwner',\n    get: function get() {\n      return this.memberId === internal(this).conversation.creator;\n    }\n  }]);\n\n  return ConversationMemberInfo;\n}();\n\nvar debug$7 = browser('LC:SignatureFactoryRunner');\n\nfunction _validateSignature() {\n  var signatureResult = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var signature = signatureResult.signature,\n      timestamp = signatureResult.timestamp,\n      nonce = signatureResult.nonce;\n\n  if (typeof signature !== 'string' || typeof timestamp !== 'number' || typeof nonce !== 'string') {\n    throw new Error('malformed signature');\n  }\n  return {\n    signature: signature,\n    timestamp: timestamp,\n    nonce: nonce\n  };\n}\n\nvar runSignatureFactory = (function (signatureFactory, params) {\n  return _Promise.resolve().then(function () {\n    debug$7('call signatureFactory with %O', params);\n    return signatureFactory.apply(undefined, _toConsumableArray(params));\n  }).then(tap(function (signatureResult) {\n    return debug$7('sign result %O', signatureResult);\n  }), function (error) {\n    // eslint-disable-next-line no-param-reassign\n    error.message = 'sign error: ' + error.message;\n    debug$7(error);\n    throw error;\n  }).then(_validateSignature);\n});\n\n/**\n * 部分失败异常\n * @typedef OperationFailureError\n * @type {Error}\n * @property {string} message 异常信息\n * @property {string[]} clientIds 因为该原因失败的 client id 列表\n * @property {number} [code] 错误码\n * @property {string} [detail] 详细信息\n */\n\n/**\n * 部分成功的结果\n * @typedef PartiallySuccess\n * @type {Object}\n * @property {string[]} successfulClientIds 成功的 client id 列表\n * @property {OperationFailureError[]} failures 失败的异常列表\n */\n\n/**\n * 分页查询结果\n * @typedef PagedResults\n * @type {Object}\n * @property {T[]} results 查询结果\n * @property {string} [next] 存在表示还有更多结果，在下次查询中带上可实现翻页。\n */\n\nvar createPartiallySuccess = function createPartiallySuccess(_ref) {\n  var allowedPids = _ref.allowedPids,\n      failedPids = _ref.failedPids;\n  return {\n    successfulClientIds: allowedPids,\n    failures: failedPids.map(function (_ref2) {\n      var pids = _ref2.pids,\n          error$$1 = _objectWithoutProperties(_ref2, ['pids']);\n\n      return _Object$assign(createError$1(error$$1), { clientIds: pids });\n    })\n  };\n};\n\n/**\n * @extends ConversationBase\n * @private\n * @abstract\n */\n\nvar PersistentConversation = function (_ConversationBase) {\n  _inherits(PersistentConversation, _ConversationBase);\n\n  function PersistentConversation(data, _ref3, client) {\n    var creator = _ref3.creator,\n        createdAt = _ref3.createdAt,\n        updatedAt = _ref3.updatedAt,\n        _ref3$transient = _ref3.transient,\n        transient = _ref3$transient === undefined ? false : _ref3$transient,\n        _ref3$system = _ref3.system,\n        system = _ref3$system === undefined ? false : _ref3$system,\n        _ref3$muted = _ref3.muted,\n        muted = _ref3$muted === undefined ? false : _ref3$muted,\n        _ref3$mutedMembers = _ref3.mutedMembers,\n        mutedMembers = _ref3$mutedMembers === undefined ? [] : _ref3$mutedMembers,\n        attributes = _objectWithoutProperties(_ref3, ['creator', 'createdAt', 'updatedAt', 'transient', 'system', 'muted', 'mutedMembers']);\n\n    _classCallCheck(this, PersistentConversation);\n\n    var _this = _possibleConstructorReturn(this, _ConversationBase.call(this, _extends$1({}, data, {\n      /**\n       * 对话创建者\n       * @memberof PersistentConversation#\n       * @type {String}\n       */\n      creator: creator,\n      /**\n       * 对话创建时间\n       * @memberof PersistentConversation#\n       * @type {Date}\n       */\n      createdAt: createdAt,\n      /**\n       * 对话更新时间\n       * @memberof PersistentConversation#\n       * @type {Date}\n       */\n      updatedAt: updatedAt,\n      /**\n       * 对该对话设置了静音的用户列表\n       * @memberof PersistentConversation#\n       * @type {?String[]}\n       */\n      mutedMembers: mutedMembers,\n      /**\n       * 暂态对话标记\n       * @memberof PersistentConversation#\n       * @type {Boolean}\n       */\n      transient: transient,\n      /**\n       * 系统对话标记\n       * @memberof PersistentConversation#\n       * @type {Boolean}\n       * @since 3.3.0\n       */\n      system: system,\n      /**\n       * 当前用户静音该对话标记\n       * @memberof PersistentConversation#\n       * @type {Boolean}\n       */\n      muted: muted,\n      _attributes: attributes\n    }), client));\n\n    _this._reset();\n    return _this;\n  }\n\n  /**\n   * 获取对话的自定义属性\n   * @since 3.2.0\n   * @param  {String} key key 属性的键名，'x' 对应 Conversation 表中的 x 列\n   * @return {Any} 属性的值\n   */\n  PersistentConversation.prototype.get = function get(key) {\n    return internal(this).currentAttributes[key];\n  };\n\n  /**\n   * 设置对话的自定义属性\n   * @since 3.2.0\n   * @param {String} key 属性的键名，'x' 对应 Conversation 表中的 x 列，支持使用 'x.y.z' 来修改对象的部分字段。\n   * @param {Any} value 属性的值\n   * @return {this} self\n   * @example\n   *\n   * // 设置对话的 color 属性\n   * conversation.set('color', {\n   *   text: '#000',\n   *   background: '#DDD',\n   * });\n   * // 设置对话的 color.text 属性\n   * conversation.set('color.text', '#333');\n   */\n\n\n  PersistentConversation.prototype.set = function set(key, value) {\n    this._debug('set [' + key + ']: ' + value);\n\n    var _internal = internal(this),\n        pendingAttributes = _internal.pendingAttributes;\n\n    var pendingKeys = _Object$keys(pendingAttributes);\n    // suppose pendingAttributes = { 'a.b': {} }\n    // set 'a' or 'a.b': delete 'a.b'\n    var re = new RegExp('^' + key);\n    var childKeys = pendingKeys.filter(re.test.bind(re));\n    childKeys.forEach(function (k) {\n      delete pendingAttributes[k];\n    });\n    if (childKeys.length) {\n      pendingAttributes[key] = value;\n    } else {\n      // set 'a.c': nothing to do\n      // set 'a.b.c.d': assign c: { d: {} } to 'a.b'\n      // CAUTION: non-standard API, provided by core-js\n      var parentKey = _Array$find(pendingKeys, function (k) {\n        return key.indexOf(k) === 0;\n      }); // 'a.b'\n      if (parentKey) {\n        setValue(pendingAttributes[parentKey], key.slice(parentKey.length + 1), value);\n      } else {\n        pendingAttributes[key] = value;\n      }\n    }\n    this._buildCurrentAttributes();\n    return this;\n  };\n\n  PersistentConversation.prototype._buildCurrentAttributes = function _buildCurrentAttributes() {\n    var _internal2 = internal(this),\n        pendingAttributes = _internal2.pendingAttributes;\n\n    internal(this).currentAttributes = _Object$keys(pendingAttributes).reduce(function (target, k) {\n      return setValue(target, k, pendingAttributes[k]);\n    }, cloneDeep_1(this._attributes));\n  };\n\n  PersistentConversation.prototype._updateServerAttributes = function _updateServerAttributes(attributes) {\n    var _this2 = this;\n\n    _Object$keys(attributes).forEach(function (key) {\n      return setValue(_this2._attributes, key, attributes[key]);\n    });\n    this._buildCurrentAttributes();\n  };\n\n  PersistentConversation.prototype._reset = function _reset() {\n    internal(this).pendingAttributes = {};\n    internal(this).currentAttributes = this._attributes;\n  };\n\n  /**\n   * 保存当前对话的属性至服务器\n   * @return {Promise.<this>} self\n   */\n\n\n  PersistentConversation.prototype.save = function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {\n      var attr, convMessage, resCommand;\n      return regenerator.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              this._debug('save');\n              attr = internal(this).pendingAttributes;\n\n              if (!isEmpty_1(attr)) {\n                _context.next = 5;\n                break;\n              }\n\n              this._debug('nothing touched, resolve with self');\n              return _context.abrupt('return', this);\n\n            case 5:\n              this._debug('attr: %O', attr);\n              convMessage = new ConvCommand({\n                attr: new JsonObjectMessage({\n                  data: _JSON$stringify(encode$1(attr))\n                })\n              });\n              _context.next = 9;\n              return this._send(new GenericCommand({\n                op: 'update',\n                convMessage: convMessage\n              }));\n\n            case 9:\n              resCommand = _context.sent;\n\n              this.updatedAt = resCommand.convMessage.udate;\n              this._attributes = internal(this).currentAttributes;\n              internal(this).pendingAttributes = {};\n              return _context.abrupt('return', this);\n\n            case 14:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function save() {\n      return _ref4.apply(this, arguments);\n    }\n\n    return save;\n  }();\n\n  /**\n   * 从服务器更新对话的属性\n   * @return {Promise.<this>} self\n   */\n\n\n  PersistentConversation.prototype.fetch = function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {\n      var query;\n      return regenerator.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              query = this._client.getQuery().equalTo('objectId', this.id);\n              _context2.next = 3;\n              return query.find();\n\n            case 3:\n              return _context2.abrupt('return', this);\n\n            case 4:\n            case 'end':\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    function fetch() {\n      return _ref5.apply(this, arguments);\n    }\n\n    return fetch;\n  }();\n\n  /**\n   * 静音，客户端拒绝收到服务器端的离线推送通知\n   * @return {Promise.<this>} self\n   */\n\n\n  PersistentConversation.prototype.mute = function () {\n    var _ref6 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {\n      return regenerator.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              this._debug('mute');\n              _context3.next = 3;\n              return this._send(new GenericCommand({\n                op: 'mute'\n              }));\n\n            case 3:\n              if (!this.transient) {\n                this.muted = true;\n                this.mutedMembers = union(this.mutedMembers, [this._client.id]);\n              }\n              return _context3.abrupt('return', this);\n\n            case 5:\n            case 'end':\n              return _context3.stop();\n          }\n        }\n      }, _callee3, this);\n    }));\n\n    function mute() {\n      return _ref6.apply(this, arguments);\n    }\n\n    return mute;\n  }();\n\n  /**\n   * 取消静音\n   * @return {Promise.<this>} self\n   */\n\n\n  PersistentConversation.prototype.unmute = function () {\n    var _ref7 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {\n      return regenerator.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              this._debug('unmute');\n              _context4.next = 3;\n              return this._send(new GenericCommand({\n                op: 'unmute'\n              }));\n\n            case 3:\n              if (!this.transient) {\n                this.muted = false;\n                this.mutedMembers = difference(this.mutedMembers, [this._client.id]);\n              }\n              return _context4.abrupt('return', this);\n\n            case 5:\n            case 'end':\n              return _context4.stop();\n          }\n        }\n      }, _callee4, this);\n    }));\n\n    function unmute() {\n      return _ref7.apply(this, arguments);\n    }\n\n    return unmute;\n  }();\n\n  PersistentConversation.prototype._appendConversationSignature = function () {\n    var _ref8 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(command, action, clientIds) {\n      var params, signatureResult;\n      return regenerator.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!this._client.options.conversationSignatureFactory) {\n                _context5.next = 6;\n                break;\n              }\n\n              params = [this.id, this._client.id, clientIds.sort(), action];\n              _context5.next = 4;\n              return runSignatureFactory(this._client.options.conversationSignatureFactory, params);\n\n            case 4:\n              signatureResult = _context5.sent;\n\n              _Object$assign(command.convMessage, keyRemap({\n                signature: 's',\n                timestamp: 't',\n                nonce: 'n'\n              }, signatureResult));\n\n            case 6:\n            case 'end':\n              return _context5.stop();\n          }\n        }\n      }, _callee5, this);\n    }));\n\n    function _appendConversationSignature(_x, _x2, _x3) {\n      return _ref8.apply(this, arguments);\n    }\n\n    return _appendConversationSignature;\n  }();\n\n  PersistentConversation.prototype._appendBlacklistSignature = function () {\n    var _ref9 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6(command, action, clientIds) {\n      var params, signatureResult;\n      return regenerator.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!this._client.options.blacklistSignatureFactory) {\n                _context6.next = 6;\n                break;\n              }\n\n              params = [this._client.id, this.id, clientIds.sort(), action];\n              _context6.next = 4;\n              return runSignatureFactory(this._client.options.blacklistSignatureFactory, params);\n\n            case 4:\n              signatureResult = _context6.sent;\n\n              _Object$assign(command.blacklistMessage, keyRemap({\n                signature: 's',\n                timestamp: 't',\n                nonce: 'n'\n              }, signatureResult));\n\n            case 6:\n            case 'end':\n              return _context6.stop();\n          }\n        }\n      }, _callee6, this);\n    }));\n\n    function _appendBlacklistSignature(_x4, _x5, _x6) {\n      return _ref9.apply(this, arguments);\n    }\n\n    return _appendBlacklistSignature;\n  }();\n\n  /**\n   * 增加成员\n   * @param {String|String[]} clientIds 新增成员 client id\n   * @return {Promise.<PartiallySuccess>} 部分成功结果，包含了成功的 id 列表、失败原因与对应的 id 列表\n   */\n\n\n  PersistentConversation.prototype.add = function () {\n    var _ref10 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7(clientIds) {\n      var command, _ref11, convMessage, allowedPids;\n\n      return regenerator.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              this._debug('add', clientIds);\n              if (typeof clientIds === 'string') {\n                clientIds = [clientIds]; // eslint-disable-line no-param-reassign\n              }\n              command = new GenericCommand({\n                op: 'add',\n                convMessage: new ConvCommand({\n                  m: clientIds\n                })\n              });\n              _context7.next = 5;\n              return this._appendConversationSignature(command, 'add', clientIds);\n\n            case 5:\n              _context7.next = 7;\n              return this._send(command);\n\n            case 7:\n              _ref11 = _context7.sent;\n              convMessage = _ref11.convMessage;\n              allowedPids = _ref11.convMessage.allowedPids;\n\n              if (!this.transient && !this.system) {\n                this.members = union(this.members, allowedPids);\n              }\n              return _context7.abrupt('return', createPartiallySuccess(convMessage));\n\n            case 12:\n            case 'end':\n              return _context7.stop();\n          }\n        }\n      }, _callee7, this);\n    }));\n\n    function add(_x7) {\n      return _ref10.apply(this, arguments);\n    }\n\n    return add;\n  }();\n\n  /**\n   * 剔除成员\n   * @param {String|String[]} clientIds 成员 client id\n   * @return {Promise.<PartiallySuccess>} 部分成功结果，包含了成功的 id 列表、失败原因与对应的 id 列表\n   */\n\n\n  PersistentConversation.prototype.remove = function () {\n    var _ref12 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8(clientIds) {\n      var command, _ref13, convMessage, allowedPids;\n\n      return regenerator.wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              this._debug('remove', clientIds);\n              if (typeof clientIds === 'string') {\n                clientIds = [clientIds]; // eslint-disable-line no-param-reassign\n              }\n              command = new GenericCommand({\n                op: 'remove',\n                convMessage: new ConvCommand({\n                  m: clientIds\n                })\n              });\n              _context8.next = 5;\n              return this._appendConversationSignature(command, 'remove', clientIds);\n\n            case 5:\n              _context8.next = 7;\n              return this._send(command);\n\n            case 7:\n              _ref13 = _context8.sent;\n              convMessage = _ref13.convMessage;\n              allowedPids = _ref13.convMessage.allowedPids;\n\n              if (!this.transient && !this.system) {\n                this.members = difference(this.members, allowedPids);\n              }\n              return _context8.abrupt('return', createPartiallySuccess(convMessage));\n\n            case 12:\n            case 'end':\n              return _context8.stop();\n          }\n        }\n      }, _callee8, this);\n    }));\n\n    function remove(_x8) {\n      return _ref12.apply(this, arguments);\n    }\n\n    return remove;\n  }();\n\n  /**\n   * （当前用户）加入该对话\n   * @return {Promise.<this>} self\n   */\n\n\n  PersistentConversation.prototype.join = function () {\n    var _ref14 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee9() {\n      var _this3 = this;\n\n      return regenerator.wrap(function _callee9$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              this._debug('join');\n              return _context9.abrupt('return', this.add(this._client.id).then(function (_ref15) {\n                var failures = _ref15.failures;\n\n                if (failures[0]) throw failures[0];\n                return _this3;\n              }));\n\n            case 2:\n            case 'end':\n              return _context9.stop();\n          }\n        }\n      }, _callee9, this);\n    }));\n\n    function join() {\n      return _ref14.apply(this, arguments);\n    }\n\n    return join;\n  }();\n\n  /**\n   * （当前用户）退出该对话\n   * @return {Promise.<this>} self\n   */\n\n\n  PersistentConversation.prototype.quit = function () {\n    var _ref16 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee10() {\n      var _this4 = this;\n\n      return regenerator.wrap(function _callee10$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              this._debug('quit');\n              return _context10.abrupt('return', this.remove(this._client.id).then(function (_ref17) {\n                var failures = _ref17.failures;\n\n                if (failures[0]) throw failures[0];\n                return _this4;\n              }));\n\n            case 2:\n            case 'end':\n              return _context10.stop();\n          }\n        }\n      }, _callee10, this);\n    }));\n\n    function quit() {\n      return _ref16.apply(this, arguments);\n    }\n\n    return quit;\n  }();\n\n  /**\n   * 在该对话中禁言成员\n   * @param {String|String[]} clientIds 成员 client id\n   * @return {Promise.<PartiallySuccess>} 部分成功结果，包含了成功的 id 列表、失败原因与对应的 id 列表\n   */\n\n\n  PersistentConversation.prototype.muteMembers = function () {\n    var _ref18 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee11(clientIds) {\n      var command, _ref19, convMessage;\n\n      return regenerator.wrap(function _callee11$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              this._debug('mute', clientIds);\n              clientIds = ensureArray(clientIds); // eslint-disable-line no-param-reassign\n              command = new GenericCommand({\n                op: OpType.add_shutup,\n                convMessage: new ConvCommand({\n                  m: clientIds\n                })\n              });\n              _context11.next = 5;\n              return this._send(command);\n\n            case 5:\n              _ref19 = _context11.sent;\n              convMessage = _ref19.convMessage;\n              return _context11.abrupt('return', createPartiallySuccess(convMessage));\n\n            case 8:\n            case 'end':\n              return _context11.stop();\n          }\n        }\n      }, _callee11, this);\n    }));\n\n    function muteMembers(_x9) {\n      return _ref18.apply(this, arguments);\n    }\n\n    return muteMembers;\n  }();\n\n  /**\n   * 在该对话中解除成员禁言\n   * @param {String|String[]} clientIds 成员 client id\n   * @return {Promise.<PartiallySuccess>} 部分成功结果，包含了成功的 id 列表、失败原因与对应的 id 列表\n   */\n\n\n  PersistentConversation.prototype.unmuteMembers = function () {\n    var _ref20 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee12(clientIds) {\n      var command, _ref21, convMessage;\n\n      return regenerator.wrap(function _callee12$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              this._debug('unmute', clientIds);\n              clientIds = ensureArray(clientIds); // eslint-disable-line no-param-reassign\n              command = new GenericCommand({\n                op: OpType.remove_shutup,\n                convMessage: new ConvCommand({\n                  m: clientIds\n                })\n              });\n              _context12.next = 5;\n              return this._send(command);\n\n            case 5:\n              _ref21 = _context12.sent;\n              convMessage = _ref21.convMessage;\n              return _context12.abrupt('return', createPartiallySuccess(convMessage));\n\n            case 8:\n            case 'end':\n              return _context12.stop();\n          }\n        }\n      }, _callee12, this);\n    }));\n\n    function unmuteMembers(_x10) {\n      return _ref20.apply(this, arguments);\n    }\n\n    return unmuteMembers;\n  }();\n\n  /**\n   * 查询该对话禁言成员列表\n   * @param {Object} [options]\n   * @param {Number} [options.limit] 返回的成员数量，服务器默认值 10\n   * @param {String} [options.next] 从指定 next 开始查询，与 limit 一起使用可以完成翻页。\n   * @return {PagedResults.<string>} 查询结果。其中的 cureser 存在表示还有更多结果。\n   */\n\n\n  PersistentConversation.prototype.queryMutedMembers = function () {\n    var _ref22 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee13() {\n      var _ref23 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          limit = _ref23.limit,\n          next = _ref23.next;\n\n      var command, _ref24, _ref24$convMessage, m, newNext;\n\n      return regenerator.wrap(function _callee13$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              this._debug('query muted: limit %O, next: %O', limit, next);\n              command = new GenericCommand({\n                op: OpType.query_shutup,\n                convMessage: new ConvCommand({\n                  limit: limit,\n                  next: next\n                })\n              });\n              _context13.next = 4;\n              return this._send(command);\n\n            case 4:\n              _ref24 = _context13.sent;\n              _ref24$convMessage = _ref24.convMessage;\n              m = _ref24$convMessage.m;\n              newNext = _ref24$convMessage.next;\n              return _context13.abrupt('return', {\n                results: m,\n                next: newNext\n              });\n\n            case 9:\n            case 'end':\n              return _context13.stop();\n          }\n        }\n      }, _callee13, this);\n    }));\n\n    function queryMutedMembers() {\n      return _ref22.apply(this, arguments);\n    }\n\n    return queryMutedMembers;\n  }();\n\n  /**\n   * 将用户加入该对话黑名单\n   * @param {String|String[]} clientIds 成员 client id\n   * @return {Promise.<PartiallySuccess>} 部分成功结果，包含了成功的 id 列表、失败原因与对应的 id 列表\n   */\n\n\n  PersistentConversation.prototype.blockMembers = function () {\n    var _ref25 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee14(clientIds) {\n      var command, _ref26, blacklistMessage;\n\n      return regenerator.wrap(function _callee14$(_context14) {\n        while (1) {\n          switch (_context14.prev = _context14.next) {\n            case 0:\n              this._debug('block', clientIds);\n              clientIds = ensureArray(clientIds); // eslint-disable-line no-param-reassign\n              command = new GenericCommand({\n                cmd: 'blacklist',\n                op: OpType.block,\n                blacklistMessage: new BlacklistCommand({\n                  srcCid: this.id,\n                  toPids: clientIds\n                })\n              });\n              _context14.next = 5;\n              return this._appendBlacklistSignature(command, 'conversation-block-clients', clientIds);\n\n            case 5:\n              _context14.next = 7;\n              return this._send(command);\n\n            case 7:\n              _ref26 = _context14.sent;\n              blacklistMessage = _ref26.blacklistMessage;\n              return _context14.abrupt('return', createPartiallySuccess(blacklistMessage));\n\n            case 10:\n            case 'end':\n              return _context14.stop();\n          }\n        }\n      }, _callee14, this);\n    }));\n\n    function blockMembers(_x12) {\n      return _ref25.apply(this, arguments);\n    }\n\n    return blockMembers;\n  }();\n\n  /**\n   * 将用户移出该对话黑名单\n   * @param {String|String[]} clientIds 成员 client id\n   * @return {Promise.<PartiallySuccess>} 部分成功结果，包含了成功的 id 列表、失败原因与对应的 id 列表\n   */\n\n\n  PersistentConversation.prototype.unblockMembers = function () {\n    var _ref27 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee15(clientIds) {\n      var command, _ref28, blacklistMessage;\n\n      return regenerator.wrap(function _callee15$(_context15) {\n        while (1) {\n          switch (_context15.prev = _context15.next) {\n            case 0:\n              this._debug('unblock', clientIds);\n              clientIds = ensureArray(clientIds); // eslint-disable-line no-param-reassign\n              command = new GenericCommand({\n                cmd: 'blacklist',\n                op: OpType.unblock,\n                blacklistMessage: new BlacklistCommand({\n                  srcCid: this.id,\n                  toPids: clientIds\n                })\n              });\n              _context15.next = 5;\n              return this._appendBlacklistSignature(command, 'conversation-unblock-clients', clientIds);\n\n            case 5:\n              _context15.next = 7;\n              return this._send(command);\n\n            case 7:\n              _ref28 = _context15.sent;\n              blacklistMessage = _ref28.blacklistMessage;\n              return _context15.abrupt('return', createPartiallySuccess(blacklistMessage));\n\n            case 10:\n            case 'end':\n              return _context15.stop();\n          }\n        }\n      }, _callee15, this);\n    }));\n\n    function unblockMembers(_x13) {\n      return _ref27.apply(this, arguments);\n    }\n\n    return unblockMembers;\n  }();\n\n  /**\n   * 查询该对话黑名单\n   * @param {Object} [options]\n   * @param {Number} [options.limit] 返回的成员数量，服务器默认值 10\n   * @param {String} [options.next] 从指定 next 开始查询，与 limit 一起使用可以完成翻页\n   * @return {PagedResults.<string>} 查询结果。其中的 cureser 存在表示还有更多结果。\n   */\n\n\n  PersistentConversation.prototype.queryBlockedMembers = function () {\n    var _ref29 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee16() {\n      var _ref30 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          limit = _ref30.limit,\n          next = _ref30.next;\n\n      var command, _ref31, _ref31$blacklistMessa, blockedPids, newNext;\n\n      return regenerator.wrap(function _callee16$(_context16) {\n        while (1) {\n          switch (_context16.prev = _context16.next) {\n            case 0:\n              this._debug('query blocked: limit %O, next: %O', limit, next);\n              command = new GenericCommand({\n                cmd: 'blacklist',\n                op: OpType.query,\n                blacklistMessage: new BlacklistCommand({\n                  srcCid: this.id,\n                  limit: limit,\n                  next: next\n                })\n              });\n              _context16.next = 4;\n              return this._send(command);\n\n            case 4:\n              _ref31 = _context16.sent;\n              _ref31$blacklistMessa = _ref31.blacklistMessage;\n              blockedPids = _ref31$blacklistMessa.blockedPids;\n              newNext = _ref31$blacklistMessa.next;\n              return _context16.abrupt('return', {\n                results: blockedPids,\n                next: newNext\n              });\n\n            case 9:\n            case 'end':\n              return _context16.stop();\n          }\n        }\n      }, _callee16, this);\n    }));\n\n    function queryBlockedMembers() {\n      return _ref29.apply(this, arguments);\n    }\n\n    return queryBlockedMembers;\n  }();\n\n  /**\n   * 获取所有成员的对话属性\n   * @since 4.0.0\n   * @return {Promise.<ConversationMemberInfo[]>} 所有成员的对话属性列表\n   */\n\n\n  PersistentConversation.prototype.getAllMemberInfo = function () {\n    var _ref32 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee17() {\n      var _this5 = this;\n\n      var response, memberInfos, memberInfoMap;\n      return regenerator.wrap(function _callee17$(_context17) {\n        while (1) {\n          switch (_context17.prev = _context17.next) {\n            case 0:\n              _context17.next = 2;\n              return this._client._requestWithSessionToken({\n                method: 'GET',\n                path: '/classes/_ConversationMemberInfo',\n                query: {\n                  where: { cid: this.id }\n                }\n              });\n\n            case 2:\n              response = _context17.sent;\n              memberInfos = response.results.map(function (info) {\n                return new ConversationMemberInfo({\n                  conversation: _this5,\n                  memberId: info.clientId,\n                  role: info.role\n                });\n              });\n              memberInfoMap = {};\n\n              memberInfos.forEach(function (memberInfo) {\n                memberInfoMap[memberInfo.memberId] = memberInfo;\n              });\n              this.members.forEach(function (memberId) {\n                memberInfoMap[memberId] = new ConversationMemberInfo({\n                  conversation: _this5,\n                  memberId: memberId,\n                  role: ConversationMemberRole.MEMBER\n                });\n              });\n              internal(this).memberInfoMap = memberInfoMap;\n              return _context17.abrupt('return', this.members.map(function (memberId) {\n                return memberInfoMap[memberId];\n              }));\n\n            case 9:\n            case 'end':\n              return _context17.stop();\n          }\n        }\n      }, _callee17, this);\n    }));\n\n    function getAllMemberInfo() {\n      return _ref32.apply(this, arguments);\n    }\n\n    return getAllMemberInfo;\n  }();\n\n  /**\n   * 获取指定成员的对话属性\n   * @since 4.0.0\n   * @return {Promise.<ConversationMemberInfo>} 指定成员的对话属性\n   */\n\n\n  PersistentConversation.prototype.getMemberInfo = function () {\n    var _ref33 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee18(memberId) {\n      var _internal3, memberInfoMap;\n\n      return regenerator.wrap(function _callee18$(_context18) {\n        while (1) {\n          switch (_context18.prev = _context18.next) {\n            case 0:\n              if (!(this.members.indexOf(memberId) === -1)) {\n                _context18.next = 2;\n                break;\n              }\n\n              throw new Error(memberId + ' is not the mumber of conversation[' + this.id + ']');\n\n            case 2:\n              _internal3 = internal(this), memberInfoMap = _internal3.memberInfoMap;\n\n              if (memberInfoMap && memberInfoMap[memberId]) {\n                _context18.next = 6;\n                break;\n              }\n\n              _context18.next = 6;\n              return this.getAllMemberInfo();\n\n            case 6:\n              return _context18.abrupt('return', internal(this).memberInfoMap[memberId]);\n\n            case 7:\n            case 'end':\n              return _context18.stop();\n          }\n        }\n      }, _callee18, this);\n    }));\n\n    function getMemberInfo(_x15) {\n      return _ref33.apply(this, arguments);\n    }\n\n    return getMemberInfo;\n  }();\n\n  /**\n   * 更新指定用户的角色\n   * @since 4.0.0\n   * @param {String} memberId 成员 Id\n   * @param {module:leancloud-realtime.ConversationMemberRole | String} role 角色\n   * @return {Promise.<this>} self\n   */\n\n\n  PersistentConversation.prototype.updateMemberRole = function () {\n    var _ref34 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee19(memberId, role) {\n      var _internal4, memberInfos;\n\n      return regenerator.wrap(function _callee19$(_context19) {\n        while (1) {\n          switch (_context19.prev = _context19.next) {\n            case 0:\n              this._debug('mute');\n              _context19.next = 3;\n              return this._send(new GenericCommand({\n                op: OpType.member_info_update,\n                convMessage: new ConvCommand({\n                  targetClientId: memberId,\n                  info: new ConvMemberInfo({\n                    pid: memberId,\n                    role: role\n                  })\n                })\n              }));\n\n            case 3:\n              _internal4 = internal(this), memberInfos = _internal4.memberInfos;\n\n              if (memberInfos && memberInfos[memberId]) {\n                internal(memberInfos[memberId]).role = role;\n              }\n              return _context19.abrupt('return', this);\n\n            case 6:\n            case 'end':\n              return _context19.stop();\n          }\n        }\n      }, _callee19, this);\n    }));\n\n    function updateMemberRole(_x16, _x17) {\n      return _ref34.apply(this, arguments);\n    }\n\n    return updateMemberRole;\n  }();\n\n  PersistentConversation.prototype.toFullJSON = function toFullJSON() {\n    var creator = this.creator,\n        system = this.system,\n        transient = this.transient,\n        createdAt = this.createdAt,\n        updatedAt = this.updatedAt,\n        _attributes = this._attributes;\n\n    return _extends$1({}, _ConversationBase.prototype.toFullJSON.call(this), {\n      creator: creator,\n      system: system,\n      transient: transient,\n      createdAt: getTime(createdAt),\n      updatedAt: getTime(updatedAt)\n    }, _attributes);\n  };\n\n  PersistentConversation.prototype.toJSON = function toJSON() {\n    var creator = this.creator,\n        system = this.system,\n        transient = this.transient,\n        muted = this.muted,\n        mutedMembers = this.mutedMembers,\n        createdAt = this.createdAt,\n        updatedAt = this.updatedAt,\n        _attributes = this._attributes;\n\n    return _extends$1({}, _ConversationBase.prototype.toJSON.call(this), {\n      creator: creator,\n      system: system,\n      transient: transient,\n      muted: muted,\n      mutedMembers: mutedMembers,\n      createdAt: createdAt,\n      updatedAt: updatedAt\n    }, _attributes);\n  };\n\n  _createClass(PersistentConversation, [{\n    key: 'createdAt',\n    set: function set(value) {\n      this._createdAt = decodeDate(value);\n    },\n    get: function get() {\n      return this._createdAt;\n    }\n  }, {\n    key: 'updatedAt',\n    set: function set(value) {\n      this._updatedAt = decodeDate(value);\n    },\n    get: function get() {\n      return this._updatedAt;\n    }\n\n    /**\n     * 对话名字，对应 _Conversation 表中的 name\n     * @type {String}\n     */\n\n  }, {\n    key: 'name',\n    get: function get() {\n      return this.get('name');\n    },\n    set: function set(value) {\n      this.set('name', value);\n    }\n  }]);\n\n  return PersistentConversation;\n}(ConversationBase);\n\n/**\n * 普通对话\n *\n * 无法直接实例化，请使用 {@link IMClient#createConversation} 创建新的普通对话。\n * @extends PersistentConversation\n * @public\n */\n\nvar Conversation = function (_PersistentConversati) {\n  _inherits(Conversation, _PersistentConversati);\n\n  function Conversation() {\n    _classCallCheck(this, Conversation);\n\n    return _possibleConstructorReturn(this, _PersistentConversati.apply(this, arguments));\n  }\n\n  return Conversation;\n}(PersistentConversation);\n\n/**\n * 聊天室。\n *\n * 无法直接实例化，请使用 {@link IMClient#createChatRoom} 创建新的聊天室。\n * @since 4.0.0\n * @extends PersistentConversation\n * @public\n */\n\nvar ChatRoom = function (_PersistentConversati) {\n  _inherits(ChatRoom, _PersistentConversati);\n\n  function ChatRoom() {\n    _classCallCheck(this, ChatRoom);\n\n    return _possibleConstructorReturn(this, _PersistentConversati.apply(this, arguments));\n  }\n\n  return ChatRoom;\n}(PersistentConversation);\n\n/**\n * 服务号。\n *\n * 服务号不支持在客户端创建。\n * @since 4.0.0\n * @extends PersistentConversation\n * @public\n */\n\nvar ServiceConversation = function (_PersistentConversati) {\n  _inherits(ServiceConversation, _PersistentConversati);\n\n  function ServiceConversation() {\n    _classCallCheck(this, ServiceConversation);\n\n    return _possibleConstructorReturn(this, _PersistentConversati.apply(this, arguments));\n  }\n\n  /**\n   * 订阅该服务号\n   * @return {Promise.<this>} self\n   */\n  ServiceConversation.prototype.subscribe = function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {\n      return regenerator.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt('return', this.join());\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function subscribe() {\n      return _ref.apply(this, arguments);\n    }\n\n    return subscribe;\n  }();\n\n  /**\n   * 退订该服务号\n   * @return {Promise.<this>} self\n   */\n\n\n  ServiceConversation.prototype.unsubscribe = function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {\n      return regenerator.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt('return', this.quit());\n\n            case 1:\n            case 'end':\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    function unsubscribe() {\n      return _ref2.apply(this, arguments);\n    }\n\n    return unsubscribe;\n  }();\n\n  return ServiceConversation;\n}(PersistentConversation);\n\nvar transformNotFoundError = function transformNotFoundError(error$$1) {\n  return error$$1.code === ErrorCode.CONVERSATION_NOT_FOUND ? createError$1({ code: ErrorCode.TEMPORARY_CONVERSATION_EXPIRED }) : error$$1;\n};\n\n/**\n * 临时对话\n * @since 4.0.0\n * @extends ConversationBase\n * @public\n */\n\nvar TemporaryConversation = function (_ConversationBase) {\n  _inherits(TemporaryConversation, _ConversationBase);\n\n  /**\n   * 无法直接实例化，请使用 {@link IMClient#createTemporaryConversation} 创建新的临时对话。\n   */\n  function TemporaryConversation(data, _ref, client) {\n    var expiredAt = _ref.expiredAt;\n\n    _classCallCheck(this, TemporaryConversation);\n\n    return _possibleConstructorReturn(this, _ConversationBase.call(this, _extends$1({}, data, {\n      expiredAt: expiredAt\n    }), client));\n  }\n\n  /**\n   * 对话失效时间\n   * @type {Date}\n   */\n\n\n  TemporaryConversation.prototype._send = function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {\n      var _ConversationBase$pro,\n          _len,\n          args,\n          _key,\n          _args = arguments;\n\n      return regenerator.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!this.expired) {\n                _context.next = 2;\n                break;\n              }\n\n              throw createError$1({ code: ErrorCode.TEMPORARY_CONVERSATION_EXPIRED });\n\n            case 2:\n              _context.prev = 2;\n\n              for (_len = _args.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = _args[_key];\n              }\n\n              _context.next = 6;\n              return (_ConversationBase$pro = _ConversationBase.prototype._send).call.apply(_ConversationBase$pro, [this].concat(_toConsumableArray(args)));\n\n            case 6:\n              return _context.abrupt('return', _context.sent);\n\n            case 9:\n              _context.prev = 9;\n              _context.t0 = _context['catch'](2);\n              throw transformNotFoundError(_context.t0);\n\n            case 12:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, this, [[2, 9]]);\n    }));\n\n    function _send() {\n      return _ref2.apply(this, arguments);\n    }\n\n    return _send;\n  }();\n\n  TemporaryConversation.prototype.send = function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {\n      var _ConversationBase$pro2,\n          _len2,\n          args,\n          _key2,\n          _args2 = arguments;\n\n      return regenerator.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n\n              for (_len2 = _args2.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                args[_key2] = _args2[_key2];\n              }\n\n              _context2.next = 4;\n              return (_ConversationBase$pro2 = _ConversationBase.prototype.send).call.apply(_ConversationBase$pro2, [this].concat(_toConsumableArray(args)));\n\n            case 4:\n              return _context2.abrupt('return', _context2.sent);\n\n            case 7:\n              _context2.prev = 7;\n              _context2.t0 = _context2['catch'](0);\n              throw transformNotFoundError(_context2.t0);\n\n            case 10:\n            case 'end':\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this, [[0, 7]]);\n    }));\n\n    function send() {\n      return _ref3.apply(this, arguments);\n    }\n\n    return send;\n  }();\n\n  TemporaryConversation.prototype.toFullJSON = function toFullJSON() {\n    var expiredAt = this.expiredAt;\n\n    return _extends$1({}, _ConversationBase.prototype.toFullJSON.call(this), {\n      expiredAt: getTime(expiredAt)\n    });\n  };\n\n  TemporaryConversation.prototype.toJSON = function toJSON() {\n    var expiredAt = this.expiredAt,\n        expired = this.expired;\n\n    return _extends$1({}, _ConversationBase.prototype.toJSON.call(this), {\n      expiredAt: expiredAt,\n      expired: expired\n    });\n  };\n\n  _createClass(TemporaryConversation, [{\n    key: 'expiredAt',\n    set: function set(value) {\n      this._expiredAt = decodeDate(value);\n    },\n    get: function get() {\n      return this._expiredAt;\n    }\n\n    /**\n     * 对话是否已失效\n     * @type {Boolean}\n     */\n\n  }, {\n    key: 'expired',\n    get: function get() {\n      return this.expiredAt < new Date();\n    }\n  }]);\n\n  return TemporaryConversation;\n}(ConversationBase);\n\nvar debug$8 = browser('LC:ConversationQuery');\n\nvar ConversationQuery = function () {\n  ConversationQuery._encode = function _encode(value) {\n    if (value instanceof Date) {\n      return { __type: 'Date', iso: value.toJSON() };\n    }\n    if (value instanceof RegExp) {\n      return value.source;\n    }\n    return value;\n  };\n\n  ConversationQuery._quote = function _quote(s) {\n    return '\\\\Q' + s.replace('\\\\E', '\\\\E\\\\\\\\E\\\\Q') + '\\\\E';\n  };\n\n  ConversationQuery._calculateFlag = function _calculateFlag(options) {\n    return ['withLastMessagesRefreshed', 'compact'].reduce(\n    // eslint-disable-next-line no-bitwise\n    function (prev, key) {\n      return (prev << 1) + Boolean(options[key]);\n    }, 0);\n  };\n\n  /**\n   * Create a ConversationQuery\n   * @param  {IMClient} client\n   */\n\n\n  function ConversationQuery(client) {\n    _classCallCheck(this, ConversationQuery);\n\n    this._client = client;\n    this._where = {};\n    this._extraOptions = {};\n  }\n\n  ConversationQuery.prototype._addCondition = function _addCondition(key, condition, value) {\n    // Check if we already have a condition\n    if (!this._where[key]) {\n      this._where[key] = {};\n    }\n    this._where[key][condition] = this.constructor._encode(value);\n    return this;\n  };\n\n  ConversationQuery.prototype.toJSON = function toJSON() {\n    var json = {\n      where: this._where,\n      flag: this.constructor._calculateFlag(this._extraOptions)\n    };\n    if (typeof this._skip !== 'undefined') json.skip = this._skip;\n    if (typeof this._limit !== 'undefined') json.limit = this._limit;\n    if (typeof this._order !== 'undefined') json.sort = this._order;\n    debug$8(json);\n    return json;\n  };\n\n  /**\n   * 增加查询条件，指定聊天室的组员包含某些成员即可返回\n   * @param {string[]} peerIds - 成员 ID 列表\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.containsMembers = function containsMembers(peerIds) {\n    return this.containsAll('m', peerIds);\n  };\n\n  /**\n   * 增加查询条件，指定聊天室的组员条件满足条件的才返回\n   *\n   * @param {string[]} - 成员 ID 列表\n   * @param {Boolean} includeSelf - 是否包含自己\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.withMembers = function withMembers(peerIds, includeSelf) {\n    var peerIdsSet = new _Set(peerIds);\n    if (includeSelf) {\n      peerIdsSet.add(this._client.id);\n    }\n    this.sizeEqualTo('m', peerIdsSet.size);\n    return this.containsMembers(_Array$from(peerIdsSet));\n  };\n\n  /**\n   * 增加查询条件，当 conversation 的属性中对应的字段满足等于条件时即可返回\n   *\n   * @param {string} key\n   * @param value\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.equalTo = function equalTo(key, value) {\n    this._where[key] = this.constructor._encode(value);\n    return this;\n  };\n\n  /**\n   * 增加查询条件，当 conversation 的属性中对应的字段满足小于条件时即可返回\n   * @param {string} key\n   * @param value\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.lessThan = function lessThan(key, value) {\n    return this._addCondition(key, '$lt', value);\n  };\n\n  /**\n   * 增加查询条件，当 conversation 的属性中对应的字段满足小于等于条件时即可返回\n    * @param {string} key\n   * @param value\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.lessThanOrEqualTo = function lessThanOrEqualTo(key, value) {\n    return this._addCondition(key, '$lte', value);\n  };\n\n  /**\n   * 增加查询条件，当 conversation 的属性中对应的字段满足大于条件时即可返回\n   *\n   * @param {string} key\n   * @param value\n   * @return {ConversationQuery} self\n   */\n\n  ConversationQuery.prototype.greaterThan = function greaterThan(key, value) {\n    return this._addCondition(key, '$gt', value);\n  };\n\n  /**\n   * 增加查询条件，当 conversation 的属性中对应的字段满足大于等于条件时即可返回\n   *\n   * @param {string} key\n   * @param value\n   * @return {ConversationQuery} self\n   */\n\n  ConversationQuery.prototype.greaterThanOrEqualTo = function greaterThanOrEqualTo(key, value) {\n    return this._addCondition(key, '$gte', value);\n  };\n\n  /**\n   * 增加查询条件，当 conversation 的属性中对应的字段满足不等于条件时即可返回\n   *\n   * @param {string} key\n   * @param value\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.notEqualTo = function notEqualTo(key, value) {\n    return this._addCondition(key, '$ne', value);\n  };\n\n  /**\n   * 增加查询条件，当 conversation 存在指定的字段时即可返回\n   *\n   * @since 3.5.0\n   * @param {string} key\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.exists = function exists(key) {\n    return this._addCondition(key, '$exists', true);\n  };\n\n  /**\n   * 增加查询条件，当 conversation 不存在指定的字段时即可返回\n   *\n   * @since 3.5.0\n   * @param {string} key\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.doesNotExist = function doesNotExist(key) {\n    return this._addCondition(key, '$exists', false);\n  };\n\n  /**\n   * 增加查询条件，当 conversation 的属性中对应的字段对应的值包含在指定值中时即可返回\n   *\n   * @param {string} key\n   * @param values\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.containedIn = function containedIn(key, values) {\n    return this._addCondition(key, '$in', values);\n  };\n\n  /**\n   * 增加查询条件，当 conversation 的属性中对应的字段对应的值不包含在指定值中时即可返回\n   *\n   * @param {string} key\n   * @param values\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.notContainsIn = function notContainsIn(key, values) {\n    return this._addCondition(key, '$nin', values);\n  };\n  /**\n   * 增加查询条件，当conversation的属性中对应的字段中的元素包含所有的值才可返回\n   *\n   * @param {string} key\n   * @param values\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.containsAll = function containsAll(key, values) {\n    return this._addCondition(key, '$all', values);\n  };\n\n  /**\n   * 增加查询条件，当 conversation 的属性中对应的字段对应的值包含此字符串即可返回\n   *\n   * @param {string} key\n   * @param {string} subString\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.contains = function contains(key, subString) {\n    return this._addCondition(key, '$regex', ConversationQuery._quote(subString));\n  };\n\n  /**\n   * 增加查询条件，当 conversation 的属性中对应的字段对应的值以此字符串起始即可返回\n   *\n   * @param {string} key\n   * @param {string} prefix\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.startsWith = function startsWith(key, prefix) {\n    return this._addCondition(key, '$regex', '^' + ConversationQuery._quote(prefix));\n  };\n\n  /**\n   * 增加查询条件，当 conversation 的属性中对应的字段对应的值以此字符串结束即可返回\n   *\n   * @param {string} key\n   * @param {string} suffix\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.endsWith = function endsWith(key, suffix) {\n    return this._addCondition(key, '$regex', ConversationQuery._quote(suffix) + '$');\n  };\n\n  /**\n   * 增加查询条件，当 conversation 的属性中对应的字段对应的值满足提供的正则表达式即可返回\n   *\n   * @param {string} key\n   * @param {RegExp} regex\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.matches = function matches(key, regex) {\n    this._addCondition(key, '$regex', regex);\n    // Javascript regex options support mig as inline options but store them\n    // as properties of the object. We support mi & should migrate them to\n    // modifiers\n    var _modifiers = '';\n    if (regex.ignoreCase) {\n      _modifiers += 'i';\n    }\n    if (regex.multiline) {\n      _modifiers += 'm';\n    }\n\n    if (_modifiers && _modifiers.length) {\n      this._addCondition(key, '$options', _modifiers);\n    }\n    return this;\n  };\n\n  /**\n   * 添加查询约束条件，查找 key 类型是数组，该数组的长度匹配提供的数值\n   *\n   * @param {string} key\n   * @param {Number} length\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.sizeEqualTo = function sizeEqualTo(key, length) {\n    return this._addCondition(key, '$size', length);\n  };\n\n  /**\n   * 设置返回集合的大小上限\n   *\n   * @param {Number} limit - 上限\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.limit = function limit(_limit) {\n    this._limit = _limit;\n    return this;\n  };\n\n  /**\n   * 设置返回集合的起始位置，一般用于分页\n   *\n   * @param {Number} skip - 起始位置跳过几个对象\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.skip = function skip(_skip) {\n    this._skip = _skip;\n    return this;\n  };\n\n  /**\n   * 设置返回集合按照指定key进行增序排列\n   *\n   * @param {string} key\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.ascending = function ascending(key) {\n    this._order = key;\n    return this;\n  };\n\n  /**\n   * 设置返回集合按照指定key进行增序排列，如果已设置其他排序，原排序的优先级较高\n   *\n   * @param {string} key\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.addAscending = function addAscending(key) {\n    if (this._order) {\n      this._order += ',' + key;\n    } else {\n      this._order = key;\n    }\n    return this;\n  };\n\n  /**\n   * 设置返回集合按照指定 key 进行降序排列\n   *\n   * @param {string} key\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.descending = function descending(key) {\n    this._order = '-' + key;\n    return this;\n  };\n\n  /**\n   * 设置返回集合按照指定 key 进行降序排列，如果已设置其他排序，原排序的优先级较高\n   *\n   * @param {string} key\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.addDescending = function addDescending(key) {\n    if (this._order) {\n      this._order += ',-' + key;\n    } else {\n      this._order = '-' + key;\n    }\n    return this;\n  };\n\n  /**\n   * 设置返回的 conversations 刷新最后一条消息\n   * @param  {Boolean} [enabled=true]\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.withLastMessagesRefreshed = function withLastMessagesRefreshed() {\n    var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    this._extraOptions.withLastMessagesRefreshed = enabled;\n    return this;\n  };\n\n  /**\n   * 设置返回的 conversations 为精简模式，即不含成员列表\n   * @param  {Boolean} [enabled=true]\n   * @return {ConversationQuery} self\n   */\n\n\n  ConversationQuery.prototype.compact = function compact() {\n    var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    this._extraOptions.compact = enabled;\n    return this;\n  };\n\n  /**\n   * 执行查询\n   * @return {Promise.<ConversationBase[]>}\n   */\n\n\n  ConversationQuery.prototype.find = function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {\n      return regenerator.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt('return', this._client._executeQuery(this));\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function find() {\n      return _ref.apply(this, arguments);\n    }\n\n    return find;\n  }();\n\n  return ConversationQuery;\n}();\n\nvar debug$9 = browser('LC:SessionManager');\n\nvar SessionManager = function () {\n  function SessionManager() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        refresh = _ref.refresh,\n        onBeforeGetSessionToken = _ref.onBeforeGetSessionToken;\n\n    _classCallCheck(this, SessionManager);\n\n    this.refresh = refresh;\n    this._onBeforeGetSessionToken = onBeforeGetSessionToken;\n    this.setSessionToken(null, 0);\n  }\n\n  SessionManager.prototype.setSessionToken = function setSessionToken(token, ttl) {\n    debug$9('set session token', token, ttl);\n    var sessionToken = new Expirable(token, ttl * 1000);\n    this._sessionToken = sessionToken;\n    delete this._pendingSessionTokenPromise;\n    return sessionToken;\n  };\n\n  SessionManager.prototype.setSessionTokenAsync = function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(promise) {\n      var _this = this;\n\n      var currentSessionToken;\n      return regenerator.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              currentSessionToken = this._sessionToken;\n\n              this._pendingSessionTokenPromise = promise.catch(function (error) {\n                // revert, otherwise the following getSessionToken calls\n                // will all be rejected\n                _this._sessionToken = currentSessionToken;\n                throw error;\n              });\n              _context.t0 = this.setSessionToken;\n              _context.t1 = this;\n              _context.t2 = _toConsumableArray;\n              _context.next = 7;\n              return this._pendingSessionTokenPromise;\n\n            case 7:\n              _context.t3 = _context.sent;\n              _context.t4 = (0, _context.t2)(_context.t3);\n              return _context.abrupt('return', _context.t0.apply.call(_context.t0, _context.t1, _context.t4));\n\n            case 10:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function setSessionTokenAsync(_x2) {\n      return _ref2.apply(this, arguments);\n    }\n\n    return setSessionTokenAsync;\n  }();\n\n  SessionManager.prototype.getSessionToken = function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$autoRefresh = _ref4.autoRefresh,\n          autoRefresh = _ref4$autoRefresh === undefined ? true : _ref4$autoRefresh;\n\n      var _ref5, value, originalValue, _ref6, newValue;\n\n      return regenerator.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              debug$9('get session token');\n              if (this._onBeforeGetSessionToken) {\n                this._onBeforeGetSessionToken(this);\n              }\n              _context2.t0 = this._sessionToken;\n\n              if (_context2.t0) {\n                _context2.next = 7;\n                break;\n              }\n\n              _context2.next = 6;\n              return this._pendingSessionTokenPromise;\n\n            case 6:\n              _context2.t0 = _context2.sent;\n\n            case 7:\n              _ref5 = _context2.t0;\n              value = _ref5.value;\n              originalValue = _ref5.originalValue;\n\n              if (!(value === Expirable.EXPIRED && autoRefresh && this.refresh)) {\n                _context2.next = 18;\n                break;\n              }\n\n              debug$9('refresh expired session token');\n              _context2.next = 14;\n              return this.setSessionTokenAsync(this.refresh(this, originalValue));\n\n            case 14:\n              _ref6 = _context2.sent;\n              newValue = _ref6.value;\n\n              debug$9('session token', newValue);\n              return _context2.abrupt('return', newValue);\n\n            case 18:\n              debug$9('session token', value);\n              return _context2.abrupt('return', value);\n\n            case 20:\n            case 'end':\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    function getSessionToken() {\n      return _ref3.apply(this, arguments);\n    }\n\n    return getSessionToken;\n  }();\n\n  SessionManager.prototype.revoke = function revoke() {\n    if (this._sessionToken) this._sessionToken.expiredAt = -1;\n  };\n\n  return SessionManager;\n}();\n\nvar _dec$2, _dec2, _class$3;\n\nfunction _applyDecoratedDescriptor$1(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n\nvar debug$10 = browser('LC:IMClient');\n\nvar INVITED$1 = INVITED,\n    KICKED$1 = KICKED,\n    MEMBERS_JOINED$1 = MEMBERS_JOINED,\n    MEMBERS_LEFT$1 = MEMBERS_LEFT,\n    MEMBER_INFO_UPDATED$1 = MEMBER_INFO_UPDATED,\n    BLOCKED$1 = BLOCKED,\n    UNBLOCKED$1 = UNBLOCKED,\n    MEMBERS_BLOCKED$1 = MEMBERS_BLOCKED,\n    MEMBERS_UNBLOCKED$1 = MEMBERS_UNBLOCKED,\n    MUTED$1 = MUTED,\n    UNMUTED$1 = UNMUTED,\n    MEMBERS_MUTED$1 = MEMBERS_MUTED,\n    MEMBERS_UNMUTED$1 = MEMBERS_UNMUTED,\n    MESSAGE$2 = MESSAGE$1,\n    UNREAD_MESSAGES_COUNT_UPDATE$1 = UNREAD_MESSAGES_COUNT_UPDATE,\n    CLOSE$1 = CLOSE,\n    CONFLICT$1 = CONFLICT,\n    UNHANDLED_MESSAGE$1 = UNHANDLED_MESSAGE,\n    CONVERSATION_INFO_UPDATED$1 = CONVERSATION_INFO_UPDATED,\n    MESSAGE_RECALL$1 = MESSAGE_RECALL,\n    MESSAGE_UPDATE$1 = MESSAGE_UPDATE,\n    INFO_UPDATED$1 = INFO_UPDATED;\n\n\nvar isTemporaryConversatrionId = function isTemporaryConversatrionId(id) {\n  return (/^_tmp:/.test(id)\n  );\n};\n\n/**\n * 1 patch-msg\n * 1 temp-conv-msg\n * 0 auto-bind-deviceid-and-installation\n * 1 transient-msg-ack\n * 1 keep-notification\n * 1 partial-failed-msg\n * @ignore\n */\nvar configBitmap = 59;\n\nvar IMClient = (_dec$2 = throttle(1000), _dec2 = throttle(1000), _class$3 = function (_EventEmitter) {\n  _inherits(IMClient, _EventEmitter);\n\n  /**\n   * 无法直接实例化，请使用 {@link Realtime#createIMClient} 创建新的 IMClient。\n   *\n   * @extends EventEmitter\n   */\n  function IMClient(id) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var props = arguments[2];\n\n    _classCallCheck(this, IMClient);\n\n    if (!(id === undefined || typeof id === 'string')) {\n      throw new TypeError('Client id [' + id + '] is not a String');\n    }\n\n    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));\n\n    _Object$assign(_this, {\n      /**\n       * @var id {String} 客户端 id\n       * @memberof IMClient#\n       */\n      id: id,\n      options: options\n    }, props);\n\n    if (!_this._messageParser) {\n      throw new Error('IMClient must be initialized with a MessageParser');\n    }\n    _this._conversationCache = new Cache('client:' + _this.id);\n    _this._ackMessageBuffer = {};\n    internal(_this).lastPatchTime = Date.now();\n    internal(_this).lastNotificationTime = undefined;\n    internal(_this)._eventemitter = new eventemitter3();\n    if (debug$10.enabled) {\n      _Object$values(Event).forEach(function (event) {\n        return _this.on(event, function () {\n          for (var _len = arguments.length, payload = Array(_len), _key = 0; _key < _len; _key++) {\n            payload[_key] = arguments[_key];\n          }\n\n          return _this._debug(event + ' event emitted. %o', payload);\n        });\n      });\n    }\n    // onIMClientCreate hook\n    applyDecorators(_this._plugins.onIMClientCreate, _this);\n    return _this;\n  }\n\n  IMClient.prototype._debug = function _debug() {\n    for (var _len2 = arguments.length, params = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      params[_key2] = arguments[_key2];\n    }\n\n    debug$10.apply(undefined, params.concat(['[' + this.id + ']']));\n  };\n\n  /**\n   * @override\n   * @private\n   */\n\n\n  IMClient.prototype._dispatchCommand = function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(command) {\n      return regenerator.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              this._debug(trim$1(command), 'received');\n              if (command.serverTs) {\n                internal(this).lastNotificationTime = getTime(decodeDate(command.serverTs));\n              }\n              _context.t0 = command.cmd;\n              _context.next = _context.t0 === CommandType.conv ? 5 : _context.t0 === CommandType.direct ? 6 : _context.t0 === CommandType.session ? 7 : _context.t0 === CommandType.unread ? 8 : _context.t0 === CommandType.rcp ? 9 : _context.t0 === CommandType.patch ? 10 : 11;\n              break;\n\n            case 5:\n              return _context.abrupt('return', this._dispatchConvMessage(command));\n\n            case 6:\n              return _context.abrupt('return', this._dispatchDirectMessage(command));\n\n            case 7:\n              return _context.abrupt('return', this._dispatchSessionMessage(command));\n\n            case 8:\n              return _context.abrupt('return', this._dispatchUnreadMessage(command));\n\n            case 9:\n              return _context.abrupt('return', this._dispatchRcpMessage(command));\n\n            case 10:\n              return _context.abrupt('return', this._dispatchPatchMessage(command));\n\n            case 11:\n              return _context.abrupt('return', this.emit(UNHANDLED_MESSAGE$1, command));\n\n            case 12:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function _dispatchCommand(_x2) {\n      return _ref.apply(this, arguments);\n    }\n\n    return _dispatchCommand;\n  }();\n\n  IMClient.prototype._dispatchSessionMessage = function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(message) {\n      var _message$sessionMessa, code, reason;\n\n      return regenerator.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _message$sessionMessa = message.sessionMessage, code = _message$sessionMessa.code, reason = _message$sessionMessa.reason;\n              _context2.t0 = message.op;\n              _context2.next = _context2.t0 === OpType.closed ? 4 : 8;\n              break;\n\n            case 4:\n              internal(this)._eventemitter.emit('close');\n\n              if (!(code === ErrorCode.SESSION_CONFLICT)) {\n                _context2.next = 7;\n                break;\n              }\n\n              return _context2.abrupt('return', this.emit(CONFLICT$1, {\n                reason: reason\n              }));\n\n            case 7:\n              return _context2.abrupt('return', this.emit(CLOSE$1, {\n                code: code,\n                reason: reason\n              }));\n\n            case 8:\n              this.emit(UNHANDLED_MESSAGE$1, message);\n              throw new Error('Unrecognized session command');\n\n            case 10:\n            case 'end':\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    function _dispatchSessionMessage(_x3) {\n      return _ref2.apply(this, arguments);\n    }\n\n    return _dispatchSessionMessage;\n  }();\n\n  IMClient.prototype._dispatchUnreadMessage = function _dispatchUnreadMessage(_ref3) {\n    var _this2 = this;\n\n    var _ref3$unreadMessage = _ref3.unreadMessage,\n        convs = _ref3$unreadMessage.convs,\n        notifTime = _ref3$unreadMessage.notifTime;\n\n    internal(this).lastUnreadNotifTime = notifTime;\n    // ensure all converstions are cached\n    return this.getConversations(convs.map(function (conv) {\n      return conv.cid;\n    })).then(function () {\n      return (\n        // update conversations data\n        _Promise.all(convs.map(function (_ref4) {\n          var cid = _ref4.cid,\n              unread = _ref4.unread,\n              mid = _ref4.mid,\n              ts = _ref4.timestamp,\n              from = _ref4.from,\n              data = _ref4.data,\n              binaryMsg = _ref4.binaryMsg,\n              patchTimestamp = _ref4.patchTimestamp,\n              mentioned = _ref4.mentioned;\n\n          var conversation = _this2._conversationCache.get(cid);\n          // deleted conversation\n          if (!conversation) return null;\n          var timestamp = void 0;\n          if (ts) {\n            timestamp = decodeDate(ts);\n            conversation.lastMessageAt = timestamp; // eslint-disable-line no-param-reassign\n          }\n          return (mid ? _this2._messageParser.parse(binaryMsg || data).then(function (message) {\n            var messageProps = {\n              id: mid,\n              cid: cid,\n              timestamp: timestamp,\n              updatedAt: patchTimestamp,\n              from: from\n            };\n            _Object$assign(message, messageProps);\n            conversation.lastMessage = message; // eslint-disable-line no-param-reassign\n          }) : _Promise.resolve()).then(function () {\n            conversation._setUnreadMessagesMentioned(mentioned);\n            var countNotUpdated = unread === internal(conversation).unreadMessagesCount;\n            if (countNotUpdated) return null; // to be filtered\n            // manipulate internal property directly to skip unreadmessagescountupdate event\n            internal(conversation).unreadMessagesCount = unread;\n            return conversation;\n          });\n          // filter conversations without unread count update\n        })).then(function (conversations) {\n          return conversations.filter(function (conversation) {\n            return conversation;\n          });\n        })\n      );\n    }).then(function (conversations) {\n      if (conversations.length) {\n        /**\n         * 未读消息数目更新\n         * @event IMClient#UNREAD_MESSAGES_COUNT_UPDATE\n         * @since 3.4.0\n         * @param {Conversation[]} conversations 未读消息数目有更新的对话列表\n         */\n        _this2.emit(UNREAD_MESSAGES_COUNT_UPDATE$1, conversations);\n      }\n    });\n  };\n\n  IMClient.prototype._dispatchRcpMessage = function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(message) {\n      var rcpMessage, read, conversationId, messageId, timestamp, conversation;\n      return regenerator.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              rcpMessage = message.rcpMessage, read = message.rcpMessage.read;\n              conversationId = rcpMessage.cid;\n              messageId = rcpMessage.id;\n              timestamp = decodeDate(rcpMessage.t);\n              conversation = this._conversationCache.get(conversationId);\n              // conversation not cached means the client does not send the message\n              // during this session\n\n              if (conversation) {\n                _context3.next = 7;\n                break;\n              }\n\n              return _context3.abrupt('return');\n\n            case 7:\n              conversation._handleReceipt({ messageId: messageId, timestamp: timestamp, read: read });\n\n            case 8:\n            case 'end':\n              return _context3.stop();\n          }\n        }\n      }, _callee3, this);\n    }));\n\n    function _dispatchRcpMessage(_x4) {\n      return _ref5.apply(this, arguments);\n    }\n\n    return _dispatchRcpMessage;\n  }();\n\n  IMClient.prototype._dispatchPatchMessage = function _dispatchPatchMessage(_ref6) {\n    var _this3 = this;\n\n    var patches = _ref6.patchMessage.patches;\n\n    // ensure all converstions are cached\n    return this.getConversations(patches.map(function (patch) {\n      return patch.cid;\n    })).then(function () {\n      return _Promise.all(patches.map(function (_ref7) {\n        var cid = _ref7.cid,\n            mid = _ref7.mid,\n            timestamp = _ref7.timestamp,\n            recall = _ref7.recall,\n            data = _ref7.data,\n            patchTimestamp = _ref7.patchTimestamp,\n            from = _ref7.from,\n            binaryMsg = _ref7.binaryMsg,\n            mentionAll = _ref7.mentionAll,\n            mentionPids = _ref7.mentionPids;\n\n        var conversation = _this3._conversationCache.get(cid);\n        // deleted conversation\n        if (!conversation) return null;\n        return _this3._messageParser.parse(binaryMsg || data).then(function (message) {\n          var patchTime = getTime(decodeDate(patchTimestamp));\n          var messageProps = {\n            id: mid,\n            cid: cid,\n            timestamp: timestamp,\n            updatedAt: patchTime,\n            from: from,\n            mentionList: mentionPids,\n            mentionedAll: mentionAll\n          };\n          _Object$assign(message, messageProps);\n          message._setStatus(MessageStatus.SENT);\n          message._updateMentioned(_this3.id);\n          if (internal(_this3).lastPatchTime < patchTime) {\n            internal(_this3).lastPatchTime = patchTime;\n          }\n          // update conversation lastMessage\n          if (conversation.lastMessage && conversation.lastMessage.id === mid) {\n            conversation.lastMessage = message; // eslint-disable-line no-param-reassign\n          }\n          if (recall) {\n            /**\n             * 消息被撤回\n             * @event IMClient#MESSAGE_RECALL\n             * @param {AVMessage} message 被撤回的消息\n             * @param {ConversationBase} conversation 消息所在的会话\n             */\n            _this3.emit(MESSAGE_RECALL$1, message, conversation);\n            /**\n             * 消息被撤回\n             * @event ConversationBase#MESSAGE_RECALL\n             * @param {AVMessage} message 被撤回的消息\n             */\n            conversation.emit(MESSAGE_RECALL$1, message);\n          } else {\n            /**\n             * 消息被修改\n             * @event IMClient#MESSAGE_UPDATE\n             * @param {AVMessage} message 被修改的消息\n             * @param {ConversationBase} conversation 消息所在的会话\n             */\n            _this3.emit(MESSAGE_UPDATE$1, message, conversation);\n            /**\n             * 消息被修改\n             * @event ConversationBase#MESSAGE_UPDATE\n             * @param {AVMessage} message 被修改的消息\n             */\n            conversation.emit(MESSAGE_UPDATE$1, message);\n          }\n        });\n      }));\n    });\n  };\n\n  IMClient.prototype._dispatchConvMessage = function () {\n    var _ref8 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(message) {\n      var convMessage, _message$convMessage, initBy, m, info, attr, conversation, payload, _payload, _payload2, _payload3, _payload4, _payload5, _payload6, _payload7, _payload8, _payload9, _payload10, _payload11, pid, role, _internal, memberInfoMap, memberInfo, _payload12, attributes, _payload13;\n\n      return regenerator.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              convMessage = message.convMessage, _message$convMessage = message.convMessage, initBy = _message$convMessage.initBy, m = _message$convMessage.m, info = _message$convMessage.info, attr = _message$convMessage.attr;\n              _context4.next = 3;\n              return this.getConversation(convMessage.cid);\n\n            case 3:\n              conversation = _context4.sent;\n              _context4.t0 = message.op;\n              _context4.next = _context4.t0 === OpType.joined ? 7 : _context4.t0 === OpType.left ? 12 : _context4.t0 === OpType.members_joined ? 17 : _context4.t0 === OpType.members_left ? 22 : _context4.t0 === OpType.members_blocked ? 27 : _context4.t0 === OpType.members_unblocked ? 31 : _context4.t0 === OpType.blocked ? 35 : _context4.t0 === OpType.unblocked ? 39 : _context4.t0 === OpType.members_shutuped ? 43 : _context4.t0 === OpType.members_unshutuped ? 47 : _context4.t0 === OpType.shutuped ? 51 : _context4.t0 === OpType.unshutuped ? 55 : _context4.t0 === OpType.member_info_changed ? 59 : _context4.t0 === OpType.updated ? 71 : 77;\n              break;\n\n            case 7:\n              if (!conversation.transient) {\n                // eslint-disable-next-line no-param-reassign\n                conversation.members = union(conversation.members, [this.id]);\n              }\n              payload = {\n                invitedBy: initBy\n              };\n              /**\n               * 当前用户被添加至某个对话\n               * @event IMClient#INVITED\n               * @param {Object} payload\n               * @param {String} payload.invitedBy 邀请者 id\n               * @param {ConversationBase} conversation\n               */\n\n              this.emit(INVITED$1, payload, conversation);\n              /**\n               * 当前用户被添加至当前对话\n               * @event ConversationBase#INVITED\n               * @param {Object} payload\n               * @param {String} payload.invitedBy 该移除操作的发起者 id\n               */\n              conversation.emit(INVITED$1, payload);\n              return _context4.abrupt('return');\n\n            case 12:\n              if (!conversation.transient) {\n                // eslint-disable-next-line no-param-reassign\n                conversation.members = difference(conversation.members, [this.id]);\n              }\n              _payload = {\n                kickedBy: initBy\n              };\n              /**\n               * 当前用户被从某个对话中移除\n               * @event IMClient#KICKED\n               * @param {Object} payload\n               * @param {String} payload.kickedBy 该移除操作的发起者 id\n               * @param {ConversationBase} conversation\n               */\n\n              this.emit(KICKED$1, _payload, conversation);\n              /**\n               * 当前用户被从当前对话中移除\n               * @event ConversationBase#KICKED\n               * @param {Object} payload\n               * @param {String} payload.kickedBy 该移除操作的发起者 id\n               */\n              conversation.emit(KICKED$1, _payload);\n              return _context4.abrupt('return');\n\n            case 17:\n              if (!conversation.transient) {\n                // eslint-disable-next-line no-param-reassign\n                conversation.members = union(conversation.members, convMessage.m);\n              }\n              _payload2 = {\n                invitedBy: initBy,\n                members: m\n              };\n              /**\n               * 有用户被添加至某个对话\n               * @event IMClient#MEMBERS_JOINED\n               * @param {Object} payload\n               * @param {String[]} payload.members 被添加的用户 id 列表\n               * @param {String} payload.invitedBy 邀请者 id\n               * @param {ConversationBase} conversation\n               */\n\n              this.emit(MEMBERS_JOINED$1, _payload2, conversation);\n              /**\n               * 有成员被添加至当前对话\n               * @event ConversationBase#MEMBERS_JOINED\n               * @param {Object} payload\n               * @param {String[]} payload.members 被添加的成员 id 列表\n               * @param {String} payload.invitedBy 邀请者 id\n               */\n              conversation.emit(MEMBERS_JOINED$1, _payload2);\n              return _context4.abrupt('return');\n\n            case 22:\n              if (!conversation.transient) {\n                // eslint-disable-next-line no-param-reassign\n                conversation.members = difference(conversation.members, convMessage.m);\n              }\n              _payload3 = {\n                kickedBy: initBy,\n                members: m\n              };\n              /**\n               * 有成员被从某个对话中移除\n               * @event IMClient#MEMBERS_LEFT\n               * @param {Object} payload\n               * @param {String[]} payload.members 被移除的成员 id 列表\n               * @param {String} payload.kickedBy 该移除操作的发起者 id\n               * @param {ConversationBase} conversation\n               */\n\n              this.emit(MEMBERS_LEFT$1, _payload3, conversation);\n              /**\n               * 有成员被从当前对话中移除\n               * @event ConversationBase#MEMBERS_LEFT\n               * @param {Object} payload\n               * @param {String[]} payload.members 被移除的成员 id 列表\n               * @param {String} payload.kickedBy 该移除操作的发起者 id\n               */\n              conversation.emit(MEMBERS_LEFT$1, _payload3);\n              return _context4.abrupt('return');\n\n            case 27:\n              _payload4 = {\n                blockedBy: initBy,\n                members: m\n              };\n              /**\n               * 有成员被加入某个对话的黑名单\n               * @event IMClient#MEMBERS_BLOCKED\n               * @param {Object} payload\n               * @param {String[]} payload.members 成员 id 列表\n               * @param {String} payload.blockedBy 该操作的发起者 id\n               * @param {ConversationBase} conversation\n               */\n\n              this.emit(MEMBERS_BLOCKED$1, _payload4, conversation);\n              /**\n               * 有成员被加入当前对话的黑名单\n               * @event ConversationBase#MEMBERS_BLOCKED\n               * @param {Object} payload\n               * @param {String[]} payload.members 成员 id 列表\n               * @param {String} payload.blockedBy 该操作的发起者 id\n               */\n              conversation.emit(MEMBERS_BLOCKED$1, _payload4);\n              return _context4.abrupt('return');\n\n            case 31:\n              _payload5 = {\n                unblockedBy: initBy,\n                members: m\n              };\n              /**\n               * 有成员被移出某个对话的黑名单\n               * @event IMClient#MEMBERS_UNBLOCKED\n               * @param {Object} payload\n               * @param {String[]} payload.members 成员 id 列表\n               * @param {String} payload.unblockedBy 该操作的发起者 id\n               * @param {ConversationBase} conversation\n               */\n\n              this.emit(MEMBERS_UNBLOCKED$1, _payload5, conversation);\n              /**\n               * 有成员被移出当前对话的黑名单\n               * @event ConversationBase#MEMBERS_UNBLOCKED\n               * @param {Object} payload\n               * @param {String[]} payload.members 成员 id 列表\n               * @param {String} payload.unblockedBy 该操作的发起者 id\n               */\n              conversation.emit(MEMBERS_UNBLOCKED$1, _payload5);\n              return _context4.abrupt('return');\n\n            case 35:\n              _payload6 = {\n                blockedBy: initBy\n              };\n              /**\n               * 当前用户被加入某个对话的黑名单\n               * @event IMClient#BLOCKED\n               * @param {Object} payload\n               * @param {String} payloadblockedBy 该操作的发起者 id\n               * @param {ConversationBase} conversation\n               */\n\n              this.emit(BLOCKED$1, _payload6, conversation);\n              /**\n               * 当前用户被加入当前对话的黑名单\n               * @event ConversationBase#BLOCKED\n               * @param {Object} payload\n               * @param {String} payload.blockedBy 该操作的发起者 id\n               */\n              conversation.emit(BLOCKED$1, _payload6);\n              return _context4.abrupt('return');\n\n            case 39:\n              _payload7 = {\n                unblockedBy: initBy\n              };\n              /**\n               * 当前用户被移出某个对话的黑名单\n               * @event IMClient#UNBLOCKED\n               * @param {Object} payload\n               * @param {String} payload.unblockedBy 该操作的发起者 id\n               * @param {ConversationBase} conversation\n               */\n\n              this.emit(UNBLOCKED$1, _payload7, conversation);\n              /**\n               * 当前用户被移出当前对话的黑名单\n               * @event ConversationBase#UNBLOCKED\n               * @param {Object} payload\n               * @param {String} payload.unblockedBy 该操作的发起者 id\n               */\n              conversation.emit(UNBLOCKED$1, _payload7);\n              return _context4.abrupt('return');\n\n            case 43:\n              _payload8 = {\n                mutedBy: initBy,\n                members: m\n              };\n              /**\n               * 有成员在某个对话中被禁言\n               * @event IMClient#MEMBERS_MUTED\n               * @param {Object} payload\n               * @param {String[]} payload.members 成员 id 列表\n               * @param {String} payload.mutedBy 该操作的发起者 id\n               * @param {ConversationBase} conversation\n               */\n\n              this.emit(MEMBERS_MUTED$1, _payload8, conversation);\n              /**\n               * 有成员在当前对话中被禁言\n               * @event ConversationBase#MEMBERS_MUTED\n               * @param {Object} payload\n               * @param {String[]} payload.members 成员 id 列表\n               * @param {String} payload.mutedBy 该操作的发起者 id\n               */\n              conversation.emit(MEMBERS_MUTED$1, _payload8);\n              return _context4.abrupt('return');\n\n            case 47:\n              _payload9 = {\n                unmutedBy: initBy,\n                members: m\n              };\n              /**\n               * 有成员在某个对话中被解除禁言\n               * @event IMClient#MEMBERS_UNMUTED\n               * @param {Object} payload\n               * @param {String[]} payload.members 成员 id 列表\n               * @param {String} payload.unmutedBy 该操作的发起者 id\n               * @param {ConversationBase} conversation\n               */\n\n              this.emit(MEMBERS_UNMUTED$1, _payload9, conversation);\n              /**\n               * 有成员在当前对话中被解除禁言\n               * @event ConversationBase#MEMBERS_UNMUTED\n               * @param {Object} payload\n               * @param {String[]} payload.members 成员 id 列表\n               * @param {String} payload.unmutedBy 该操作的发起者 id\n               */\n              conversation.emit(MEMBERS_UNMUTED$1, _payload9);\n              return _context4.abrupt('return');\n\n            case 51:\n              _payload10 = {\n                mutedBy: initBy\n              };\n              /**\n               * 有成员在某个对话中被禁言\n               * @event IMClient#MUTED\n               * @param {Object} payload\n               * @param {String} payload.mutedBy 该操作的发起者 id\n               * @param {ConversationBase} conversation\n               */\n\n              this.emit(MUTED$1, _payload10, conversation);\n              /**\n               * 有成员在当前对话中被禁言\n               * @event ConversationBase#MUTED\n               * @param {Object} payload\n               * @param {String} payload.mutedBy 该操作的发起者 id\n               */\n              conversation.emit(MUTED$1, _payload10);\n              return _context4.abrupt('return');\n\n            case 55:\n              _payload11 = {\n                unmutedBy: initBy\n              };\n              /**\n               * 有成员在某个对话中被解除禁言\n               * @event IMClient#UNMUTED\n               * @param {Object} payload\n               * @param {String} payload.unmutedBy 该操作的发起者 id\n               * @param {ConversationBase} conversation\n               */\n\n              this.emit(UNMUTED$1, _payload11, conversation);\n              /**\n               * 有成员在当前对话中被解除禁言\n               * @event ConversationBase#UNMUTED\n               * @param {Object} payload\n               * @param {String} payload.unmutedBy 该操作的发起者 id\n               */\n              conversation.emit(UNMUTED$1, _payload11);\n              return _context4.abrupt('return');\n\n            case 59:\n              pid = info.pid, role = info.role;\n              _internal = internal(conversation), memberInfoMap = _internal.memberInfoMap;\n              // 如果不存在缓存，且不是 role 的更新，则不通知\n\n              if (!(!memberInfoMap && !role)) {\n                _context4.next = 63;\n                break;\n              }\n\n              return _context4.abrupt('return');\n\n            case 63:\n              _context4.next = 65;\n              return conversation.getMemberInfo(pid);\n\n            case 65:\n              memberInfo = _context4.sent;\n\n              internal(memberInfo).role = role;\n              _payload12 = {\n                member: pid,\n                memberInfo: memberInfo,\n                updatedBy: initBy\n              };\n              /**\n               * 有成员的对话信息被更新\n               * @event IMClient#MEMBER_INFO_UPDATED\n               * @param {Object} payload\n               * @param {String[]} payload.member 被更新对话信息的成员 id\n               * @param {ConversationMumberInfo} payload.memberInfo 被更新的成员对话信息\n               * @param {String} payload.updatedBy 该操作的发起者 id\n               * @param {ConversationBase} conversation\n               */\n\n              this.emit(MEMBER_INFO_UPDATED$1, _payload12, conversation);\n              /**\n               * 有成员的对话信息被更新\n               * @event ConversationBase#MEMBER_INFO_UPDATED\n               * @param {Object} payload\n               * @param {String[]} payload.member 被更新对话信息的成员 id\n               * @param {ConversationMumberInfo} payload.memberInfo 被更新的成员对话信息\n               * @param {String} payload.updatedBy 该操作的发起者 id\n               */\n              conversation.emit(MEMBER_INFO_UPDATED$1, _payload12);\n              return _context4.abrupt('return');\n\n            case 71:\n              attributes = decode(JSON.parse(attr.data));\n\n              conversation._updateServerAttributes(attributes);\n              _payload13 = {\n                attributes: attributes,\n                updatedBy: initBy\n              };\n              /**\n               * 该对话信息被更新\n               * @event IMClient#CONVERSATION_INFO_UPDATED\n               * @param {Object} payload\n               * @param {Object} payload.attributes 被更新的属性\n               * @param {String} payload.updatedBy 该操作的发起者 id\n               * @param {ConversationBase} conversation\n               */\n\n              this.emit(CONVERSATION_INFO_UPDATED$1, _payload13, conversation);\n              /**\n               * 有对话信息被更新\n               * @event ConversationBase#INFO_UPDATED\n               * @param {Object} payload\n               * @param {Object} payload.attributes 被更新的属性\n               * @param {String} payload.updatedBy 该操作的发起者 id\n               */\n              conversation.emit(INFO_UPDATED$1, _payload13);\n              return _context4.abrupt('return');\n\n            case 77:\n              this.emit(UNHANDLED_MESSAGE$1, message);\n              throw new Error('Unrecognized conversation command');\n\n            case 79:\n            case 'end':\n              return _context4.stop();\n          }\n        }\n      }, _callee4, this);\n    }));\n\n    function _dispatchConvMessage(_x5) {\n      return _ref8.apply(this, arguments);\n    }\n\n    return _dispatchConvMessage;\n  }();\n\n  IMClient.prototype._dispatchDirectMessage = function _dispatchDirectMessage(originalMessage) {\n    var _this4 = this;\n\n    var directMessage = originalMessage.directMessage,\n        _originalMessage$dire = originalMessage.directMessage,\n        id = _originalMessage$dire.id,\n        cid = _originalMessage$dire.cid,\n        fromPeerId = _originalMessage$dire.fromPeerId,\n        timestamp = _originalMessage$dire.timestamp,\n        transient = _originalMessage$dire.transient,\n        patchTimestamp = _originalMessage$dire.patchTimestamp,\n        mentionPids = _originalMessage$dire.mentionPids,\n        mentionAll = _originalMessage$dire.mentionAll,\n        binaryMsg = _originalMessage$dire.binaryMsg,\n        msg = _originalMessage$dire.msg;\n\n    var content = binaryMsg ? binaryMsg.toArrayBuffer() : msg;\n    return _Promise.all([this.getConversation(directMessage.cid), this._messageParser.parse(content)]).then(function (_ref9) {\n      var _ref10 = _slicedToArray(_ref9, 2),\n          conversation = _ref10[0],\n          message = _ref10[1];\n\n      // deleted conversation\n      if (!conversation) return undefined;\n      var messageProps = {\n        id: id,\n        cid: cid,\n        timestamp: timestamp,\n        updatedAt: patchTimestamp,\n        from: fromPeerId,\n        mentionList: mentionPids,\n        mentionedAll: mentionAll\n      };\n      _Object$assign(message, messageProps);\n      message._updateMentioned(_this4.id);\n      message._setStatus(MessageStatus.SENT);\n      // filter outgoing message sent from another device\n      if (message.from !== _this4.id) {\n        if (!(transient || conversation.transient)) {\n          _this4._sendAck(message);\n        }\n      }\n      return _this4._dispatchParsedMessage(message, conversation);\n    });\n  };\n\n  IMClient.prototype._dispatchParsedMessage = function _dispatchParsedMessage(message, conversation) {\n    var _this5 = this;\n\n    // beforeMessageDispatch hook\n    return applyDispatcher(this._plugins.beforeMessageDispatch, [message, conversation]).then(function (shouldDispatch) {\n      if (shouldDispatch === false) return;\n      conversation.lastMessage = message; // eslint-disable-line no-param-reassign\n      conversation.lastMessageAt = message.timestamp; // eslint-disable-line no-param-reassign\n      // filter outgoing message sent from another device\n      if (message.from !== _this5.id) {\n        conversation.unreadMessagesCount += 1; // eslint-disable-line no-param-reassign\n        if (message.mentioned) conversation._setUnreadMessagesMentioned(true);\n      }\n      /**\n       * 当前用户收到消息\n       * @event IMClient#MESSAGE\n       * @param {Message} message\n       * @param {ConversationBase} conversation 收到消息的对话\n       */\n      _this5.emit(MESSAGE$2, message, conversation);\n      /**\n       * 当前对话收到消息\n       * @event ConversationBase#MESSAGE\n       * @param {Message} message\n       */\n      conversation.emit(MESSAGE$2, message);\n    });\n  };\n\n  IMClient.prototype._sendAck = function _sendAck(message) {\n    this._debug('send ack for %O', message);\n    var cid = message.cid;\n\n    if (!cid) {\n      throw new Error('missing cid');\n    }\n    if (!this._ackMessageBuffer[cid]) {\n      this._ackMessageBuffer[cid] = [];\n    }\n    this._ackMessageBuffer[cid].push(message);\n    return this._doSendAck();\n  };\n\n  // jsdoc-ignore-start\n\n\n  // jsdoc-ignore-end\n  IMClient.prototype._doSendAck = function _doSendAck() {\n    var _this6 = this;\n\n    // if not connected, just skip everything\n    if (!this._connection.is('connected')) return;\n    this._debug('do send ack %O', this._ackMessageBuffer);\n    _Promise.all(_Object$keys(this._ackMessageBuffer).map(function (cid) {\n      var convAckMessages = _this6._ackMessageBuffer[cid];\n      var timestamps = convAckMessages.map(function (message) {\n        return message.timestamp;\n      });\n      var command = new GenericCommand({\n        cmd: 'ack',\n        peerId: _this6.id,\n        ackMessage: new AckCommand({\n          cid: cid,\n          fromts: Math.min.apply(null, timestamps),\n          tots: Math.max.apply(null, timestamps)\n        })\n      });\n      delete _this6._ackMessageBuffer[cid];\n      return _this6._send(command, false).catch(function (error$$1) {\n        _this6._debug('send ack failed: %O', error$$1);\n        _this6._ackMessageBuffer[cid] = convAckMessages;\n      });\n    }));\n  };\n\n  IMClient.prototype._omitPeerId = function _omitPeerId(value) {\n    internal(this).peerIdOmittable = value;\n  };\n\n  IMClient.prototype._send = function _send(cmd) {\n    var _connection;\n\n    var command = cmd;\n    if (!internal(this).peerIdOmittable && this.id) {\n      command.peerId = this.id;\n    }\n\n    for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    return (_connection = this._connection).send.apply(_connection, [command].concat(args));\n  };\n\n  IMClient.prototype._open = function () {\n    var _ref11 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(appId, tag, deviceId) {\n      var isReconnect = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n      var _internal2, lastUnreadNotifTime, lastPatchTime, command, signatureResult, sessionToken, resCommand, _resCommand, peerId, sessionMessage, _resCommand$sessionMe, token, tokenTTL, code;\n\n      return regenerator.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              this._debug('open session');\n              _internal2 = internal(this), lastUnreadNotifTime = _internal2.lastUnreadNotifTime, lastPatchTime = _internal2.lastPatchTime;\n              command = new GenericCommand({\n                cmd: 'session',\n                op: 'open',\n                appId: appId,\n                peerId: this.id,\n                sessionMessage: new SessionCommand({\n                  ua: 'js/' + version,\n                  r: isReconnect,\n                  lastUnreadNotifTime: lastUnreadNotifTime,\n                  lastPatchTime: lastPatchTime,\n                  configBitmap: configBitmap\n                })\n              });\n\n              if (isReconnect) {\n                _context5.next = 12;\n                break;\n              }\n\n              _Object$assign(command.sessionMessage, trim$1({\n                tag: tag,\n                deviceId: deviceId\n              }));\n\n              if (!this.options.signatureFactory) {\n                _context5.next = 10;\n                break;\n              }\n\n              _context5.next = 8;\n              return runSignatureFactory(this.options.signatureFactory, [this._identity]);\n\n            case 8:\n              signatureResult = _context5.sent;\n\n              _Object$assign(command.sessionMessage, keyRemap({\n                signature: 's',\n                timestamp: 't',\n                nonce: 'n'\n              }, signatureResult));\n\n            case 10:\n              _context5.next = 16;\n              break;\n\n            case 12:\n              _context5.next = 14;\n              return this._sessionManager.getSessionToken({\n                autoRefresh: false\n              });\n\n            case 14:\n              sessionToken = _context5.sent;\n\n              if (sessionToken && sessionToken !== Expirable.EXPIRED) {\n                _Object$assign(command.sessionMessage, {\n                  st: sessionToken\n                });\n              }\n\n            case 16:\n              resCommand = void 0;\n              _context5.prev = 17;\n              _context5.next = 20;\n              return this._send(command);\n\n            case 20:\n              resCommand = _context5.sent;\n              _context5.next = 32;\n              break;\n\n            case 23:\n              _context5.prev = 23;\n              _context5.t0 = _context5['catch'](17);\n\n              if (!(_context5.t0.code === ErrorCode.SESSION_TOKEN_EXPIRED)) {\n                _context5.next = 31;\n                break;\n              }\n\n              if (this._sessionManager) {\n                _context5.next = 28;\n                break;\n              }\n\n              throw new Error('Unexpected session expiration');\n\n            case 28:\n              debug$10('Session token expired, reopening');\n              this._sessionManager.revoke();\n              return _context5.abrupt('return', this._open(appId, tag, deviceId, isReconnect));\n\n            case 31:\n              throw _context5.t0;\n\n            case 32:\n              _resCommand = resCommand, peerId = _resCommand.peerId, sessionMessage = _resCommand.sessionMessage, _resCommand$sessionMe = _resCommand.sessionMessage, token = _resCommand$sessionMe.st, tokenTTL = _resCommand$sessionMe.stTtl, code = _resCommand$sessionMe.code;\n\n              if (!code) {\n                _context5.next = 35;\n                break;\n              }\n\n              throw createError$1(sessionMessage);\n\n            case 35:\n              if (peerId) {\n                this.id = peerId;\n                if (!this._identity) this._identity = peerId;\n                if (token) {\n                  this._sessionManager = this._sessionManager || this._createSessionManager();\n                  this._sessionManager.setSessionToken(token, tokenTTL);\n                }\n                if (internal(this).lastNotificationTime) {\n                  // Do not await for it as this is failable\n                  this._syncNotifications(internal(this).lastNotificationTime).catch(function (error$$1) {\n                    return console.warn('Syncing notifications failed:', error$$1);\n                  });\n                } else {\n                  // Set timestamp to now for next reconnection\n                  internal(this).lastNotificationTime = Date.now();\n                }\n              } else {\n                console.warn('Unexpected session opened without peerId.');\n              }\n              return _context5.abrupt('return', undefined);\n\n            case 37:\n            case 'end':\n              return _context5.stop();\n          }\n        }\n      }, _callee5, this, [[17, 23]]);\n    }));\n\n    function _open(_x7, _x8, _x9) {\n      return _ref11.apply(this, arguments);\n    }\n\n    return _open;\n  }();\n\n  IMClient.prototype._syncNotifications = function () {\n    var _ref12 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6(timestamp) {\n      var _this7 = this;\n\n      var _ref13, hasMore, notifications;\n\n      return regenerator.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return this._fetchNotifications(timestamp);\n\n            case 2:\n              _ref13 = _context6.sent;\n              hasMore = _ref13.hasMore;\n              notifications = _ref13.notifications;\n\n              notifications.forEach(function (notification) {\n                var cmd = notification.cmd,\n                    op = notification.op,\n                    serverTs = notification.serverTs,\n                    payload = _objectWithoutProperties(notification, ['cmd', 'op', 'serverTs']);\n\n                _this7._dispatchCommand(_defineProperty({\n                  cmd: CommandType[cmd],\n                  op: OpType[op],\n                  serverTs: serverTs\n                }, cmd + 'Message', payload));\n              });\n\n              if (!hasMore) {\n                _context6.next = 8;\n                break;\n              }\n\n              return _context6.abrupt('return', this._syncNotifications(internal(this).lastNotificationTime));\n\n            case 8:\n              return _context6.abrupt('return', undefined);\n\n            case 9:\n            case 'end':\n              return _context6.stop();\n          }\n        }\n      }, _callee6, this);\n    }));\n\n    function _syncNotifications(_x10) {\n      return _ref12.apply(this, arguments);\n    }\n\n    return _syncNotifications;\n  }();\n\n  IMClient.prototype._fetchNotifications = function () {\n    var _ref14 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7(timestamp) {\n      return regenerator.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              return _context7.abrupt('return', this._requestWithSessionToken({\n                method: 'GET',\n                path: '/rtm/notifications',\n                query: {\n                  start_ts: timestamp,\n                  notification_type: 'permanent'\n                }\n              }));\n\n            case 1:\n            case 'end':\n              return _context7.stop();\n          }\n        }\n      }, _callee7, this);\n    }));\n\n    function _fetchNotifications(_x11) {\n      return _ref14.apply(this, arguments);\n    }\n\n    return _fetchNotifications;\n  }();\n\n  IMClient.prototype._createSessionManager = function _createSessionManager() {\n    var _this8 = this;\n\n    debug$10('create SessionManager');\n    return new SessionManager({\n      onBeforeGetSessionToken: this._connection.checkConnectionAvailability.bind(this._connection),\n      refresh: function refresh(manager, expiredSessionToken) {\n        return manager.setSessionTokenAsync(_Promise.resolve(new GenericCommand({\n          cmd: 'session',\n          op: 'refresh',\n          sessionMessage: new SessionCommand({\n            ua: 'js/' + version,\n            st: expiredSessionToken\n          })\n        })).then(function () {\n          var _ref15 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8(command) {\n            var signatureResult;\n            return regenerator.wrap(function _callee8$(_context8) {\n              while (1) {\n                switch (_context8.prev = _context8.next) {\n                  case 0:\n                    if (!_this8.options.signatureFactory) {\n                      _context8.next = 5;\n                      break;\n                    }\n\n                    _context8.next = 3;\n                    return runSignatureFactory(_this8.options.signatureFactory, [_this8._identity]);\n\n                  case 3:\n                    signatureResult = _context8.sent;\n\n                    _Object$assign(command.sessionMessage, keyRemap({\n                      signature: 's',\n                      timestamp: 't',\n                      nonce: 'n'\n                    }, signatureResult));\n\n                  case 5:\n                    return _context8.abrupt('return', command);\n\n                  case 6:\n                  case 'end':\n                    return _context8.stop();\n                }\n              }\n            }, _callee8, _this8);\n          }));\n\n          return function (_x12) {\n            return _ref15.apply(this, arguments);\n          };\n        }()).then(_this8._send.bind(_this8)).then(function (_ref16) {\n          var _ref16$sessionMessage = _ref16.sessionMessage,\n              token = _ref16$sessionMessage.st,\n              ttl = _ref16$sessionMessage.stTtl;\n          return [token, ttl];\n        }));\n      }\n    });\n  };\n\n  IMClient.prototype._requestWithSessionToken = function () {\n    var _ref18 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee9(_ref17) {\n      var headers = _ref17.headers,\n          query = _ref17.query,\n          params = _objectWithoutProperties(_ref17, ['headers', 'query']);\n\n      var sessionToken;\n      return regenerator.wrap(function _callee9$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.next = 2;\n              return this._sessionManager.getSessionToken();\n\n            case 2:\n              sessionToken = _context9.sent;\n              return _context9.abrupt('return', this._request(_extends$1({\n                headers: _extends$1({\n                  'X-LC-IM-Session-Token': sessionToken\n                }, headers),\n                query: _extends$1({\n                  client_id: this.id\n                }, query)\n              }, params)));\n\n            case 4:\n            case 'end':\n              return _context9.stop();\n          }\n        }\n      }, _callee9, this);\n    }));\n\n    function _requestWithSessionToken(_x13) {\n      return _ref18.apply(this, arguments);\n    }\n\n    return _requestWithSessionToken;\n  }();\n\n  /**\n   * 关闭客户端\n   * @return {Promise}\n   */\n\n\n  IMClient.prototype.close = function () {\n    var _ref19 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee10() {\n      var _ee, command;\n\n      return regenerator.wrap(function _callee10$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              this._debug('close session');\n              _ee = internal(this)._eventemitter;\n\n              _ee.emit('beforeclose');\n\n              if (!this._connection.is('connected')) {\n                _context10.next = 7;\n                break;\n              }\n\n              command = new GenericCommand({\n                cmd: 'session',\n                op: 'close'\n              });\n              _context10.next = 7;\n              return this._send(command);\n\n            case 7:\n              _ee.emit('close');\n              this.emit(CLOSE$1, {\n                code: 0\n              });\n\n            case 9:\n            case 'end':\n              return _context10.stop();\n          }\n        }\n      }, _callee10, this);\n    }));\n\n    function close() {\n      return _ref19.apply(this, arguments);\n    }\n\n    return close;\n  }();\n  /**\n   * 获取 client 列表中在线的 client，每次查询最多 20 个 clientId，超出部分会被忽略\n   * @param  {String[]} clientIds 要查询的 client ids\n   * @return {Primse.<String[]>} 在线的 client ids\n   */\n\n\n  IMClient.prototype.ping = function () {\n    var _ref20 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee11(clientIds) {\n      var command, resCommand;\n      return regenerator.wrap(function _callee11$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              this._debug('ping');\n\n              if (clientIds instanceof Array) {\n                _context11.next = 3;\n                break;\n              }\n\n              throw new TypeError('clientIds ' + clientIds + ' is not an Array');\n\n            case 3:\n              if (clientIds.length) {\n                _context11.next = 5;\n                break;\n              }\n\n              return _context11.abrupt('return', _Promise.resolve([]));\n\n            case 5:\n              command = new GenericCommand({\n                cmd: 'session',\n                op: 'query',\n                sessionMessage: new SessionCommand({\n                  sessionPeerIds: clientIds\n                })\n              });\n              _context11.next = 8;\n              return this._send(command);\n\n            case 8:\n              resCommand = _context11.sent;\n              return _context11.abrupt('return', resCommand.sessionMessage.onlineSessionPeerIds);\n\n            case 10:\n            case 'end':\n              return _context11.stop();\n          }\n        }\n      }, _callee11, this);\n    }));\n\n    function ping(_x14) {\n      return _ref20.apply(this, arguments);\n    }\n\n    return ping;\n  }();\n\n  /**\n   * 获取某个特定的对话\n   * @param  {String} id 对话 id，对应 _Conversation 表中的 objectId\n   * @param  {Boolean} [noCache=false] 强制不从缓存中获取\n   * @return {Promise.<ConversationBase>} 如果 id 对应的对话不存在则返回 null\n   */\n\n\n  IMClient.prototype.getConversation = function () {\n    var _ref21 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee12(id) {\n      var noCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var cachedConversation;\n      return regenerator.wrap(function _callee12$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              if (!(typeof id !== 'string')) {\n                _context12.next = 2;\n                break;\n              }\n\n              throw new TypeError(id + ' is not a String');\n\n            case 2:\n              if (noCache) {\n                _context12.next = 6;\n                break;\n              }\n\n              cachedConversation = this._conversationCache.get(id);\n\n              if (!cachedConversation) {\n                _context12.next = 6;\n                break;\n              }\n\n              return _context12.abrupt('return', cachedConversation);\n\n            case 6:\n              if (!isTemporaryConversatrionId(id)) {\n                _context12.next = 13;\n                break;\n              }\n\n              _context12.next = 9;\n              return this._getTemporaryConversations([id]);\n\n            case 9:\n              _context12.t0 = _context12.sent[0];\n\n              if (_context12.t0) {\n                _context12.next = 12;\n                break;\n              }\n\n              _context12.t0 = null;\n\n            case 12:\n              return _context12.abrupt('return', _context12.t0);\n\n            case 13:\n              return _context12.abrupt('return', this.getQuery().equalTo('objectId', id).find().then(function (conversations) {\n                return conversations[0] || null;\n              }));\n\n            case 14:\n            case 'end':\n              return _context12.stop();\n          }\n        }\n      }, _callee12, this);\n    }));\n\n    function getConversation(_x16) {\n      return _ref21.apply(this, arguments);\n    }\n\n    return getConversation;\n  }();\n\n  /**\n   * 通过 id 批量获取某个特定的对话\n   * @since 3.4.0\n   * @param  {String[]} ids 对话 id 列表，对应 _Conversation 表中的 objectId\n   * @param  {Boolean} [noCache=false] 强制不从缓存中获取\n   * @return {Promise.<ConversationBase[]>} 如果 id 对应的对话不存在则返回 null\n   */\n\n\n  IMClient.prototype.getConversations = function () {\n    var _ref22 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee13(ids) {\n      var _this9 = this;\n\n      var noCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var remoteConversationIds, remoteTemporaryConversationIds, query, remoteTemporaryConversationsPromise;\n      return regenerator.wrap(function _callee13$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              remoteConversationIds = noCache ? ids : ids.filter(function (id) {\n                return _this9._conversationCache.get(id) === null;\n              });\n\n              if (!remoteConversationIds.length) {\n                _context13.next = 8;\n                break;\n              }\n\n              remoteTemporaryConversationIds = remove_1(remoteConversationIds, isTemporaryConversatrionId);\n              query = [];\n\n              if (remoteConversationIds.length) {\n                query.push(this.getQuery().containedIn('objectId', remoteConversationIds).limit(999).find());\n              }\n              if (remoteTemporaryConversationIds.length) {\n                remoteTemporaryConversationsPromise = remoteTemporaryConversationIds.map(this._getTemporaryConversations.bind(this));\n\n                query.push.apply(query, _toConsumableArray(remoteTemporaryConversationsPromise));\n              }\n              _context13.next = 8;\n              return _Promise.all(query);\n\n            case 8:\n              return _context13.abrupt('return', ids.map(function (id) {\n                return _this9._conversationCache.get(id);\n              }));\n\n            case 9:\n            case 'end':\n              return _context13.stop();\n          }\n        }\n      }, _callee13, this);\n    }));\n\n    function getConversations(_x18) {\n      return _ref22.apply(this, arguments);\n    }\n\n    return getConversations;\n  }();\n\n  IMClient.prototype._getTemporaryConversations = function () {\n    var _ref23 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee14(ids) {\n      var command, resCommand;\n      return regenerator.wrap(function _callee14$(_context14) {\n        while (1) {\n          switch (_context14.prev = _context14.next) {\n            case 0:\n              command = new GenericCommand({\n                cmd: 'conv',\n                op: 'query',\n                convMessage: new ConvCommand({\n                  tempConvIds: ids\n                })\n              });\n              _context14.next = 3;\n              return this._send(command);\n\n            case 3:\n              resCommand = _context14.sent;\n              return _context14.abrupt('return', this._handleQueryResults(resCommand));\n\n            case 5:\n            case 'end':\n              return _context14.stop();\n          }\n        }\n      }, _callee14, this);\n    }));\n\n    function _getTemporaryConversations(_x19) {\n      return _ref23.apply(this, arguments);\n    }\n\n    return _getTemporaryConversations;\n  }();\n\n  /**\n   * 构造一个 ConversationQuery 来查询对话\n   * @return {ConversationQuery.<PersistentConversation>}\n   */\n\n\n  IMClient.prototype.getQuery = function getQuery() {\n    return new ConversationQuery(this);\n  };\n\n  /**\n   * 构造一个 ConversationQuery 来查询聊天室\n   * @return {ConversationQuery.<ChatRoom>}\n   */\n\n\n  IMClient.prototype.getChatRoomQuery = function getChatRoomQuery() {\n    return this.getQuery().equalTo('tr', true);\n  };\n\n  /**\n   * 构造一个 ConversationQuery 来查询服务号\n   * @return {ConversationQuery.<ServiceConversation>}\n   */\n\n\n  IMClient.prototype.getServiceConversationQuery = function getServiceConversationQuery() {\n    return this.getQuery().equalTo('sys', true);\n  };\n\n  IMClient.prototype._executeQuery = function () {\n    var _ref24 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee15(query) {\n      var queryJSON, command, resCommand;\n      return regenerator.wrap(function _callee15$(_context15) {\n        while (1) {\n          switch (_context15.prev = _context15.next) {\n            case 0:\n              queryJSON = query.toJSON();\n\n              queryJSON.where = new JsonObjectMessage({\n                data: _JSON$stringify(encode$1(queryJSON.where))\n              });\n              command = new GenericCommand({\n                cmd: 'conv',\n                op: 'query',\n                convMessage: new ConvCommand(queryJSON)\n              });\n              _context15.next = 5;\n              return this._send(command);\n\n            case 5:\n              resCommand = _context15.sent;\n              return _context15.abrupt('return', this._handleQueryResults(resCommand));\n\n            case 7:\n            case 'end':\n              return _context15.stop();\n          }\n        }\n      }, _callee15, this);\n    }));\n\n    function _executeQuery(_x20) {\n      return _ref24.apply(this, arguments);\n    }\n\n    return _executeQuery;\n  }();\n\n  IMClient.prototype._handleQueryResults = function () {\n    var _ref25 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee16(resCommand) {\n      var conversations, commandString;\n      return regenerator.wrap(function _callee16$(_context16) {\n        while (1) {\n          switch (_context16.prev = _context16.next) {\n            case 0:\n              conversations = void 0;\n              _context16.prev = 1;\n\n              conversations = decode(JSON.parse(resCommand.convMessage.results.data));\n              _context16.next = 9;\n              break;\n\n            case 5:\n              _context16.prev = 5;\n              _context16.t0 = _context16['catch'](1);\n              commandString = _JSON$stringify(trim$1(resCommand));\n              throw new Error('Parse query result failed: ' + _context16.t0.message + '. Command: ' + commandString);\n\n            case 9:\n              _context16.next = 11;\n              return _Promise.all(conversations.map(this._parseConversationFromRawData.bind(this)));\n\n            case 11:\n              conversations = _context16.sent;\n              return _context16.abrupt('return', conversations.map(this._upsertConversationToCache.bind(this)));\n\n            case 13:\n            case 'end':\n              return _context16.stop();\n          }\n        }\n      }, _callee16, this, [[1, 5]]);\n    }));\n\n    function _handleQueryResults(_x21) {\n      return _ref25.apply(this, arguments);\n    }\n\n    return _handleQueryResults;\n  }();\n\n  IMClient.prototype._upsertConversationToCache = function _upsertConversationToCache(fetchedConversation) {\n    var conversation = this._conversationCache.get(fetchedConversation.id);\n    if (!conversation) {\n      conversation = fetchedConversation;\n      this._debug('no match, set cache');\n      this._conversationCache.set(fetchedConversation.id, fetchedConversation);\n    } else {\n      this._debug('update cached conversation');\n      ['creator', 'createdAt', 'updatedAt', 'lastMessageAt', 'lastMessage', 'mutedMembers', 'members', '_attributes', 'transient', 'muted'].forEach(function (key) {\n        var value = fetchedConversation[key];\n        if (value !== undefined) conversation[key] = value;\n      });\n      if (conversation._reset) conversation._reset();\n    }\n    return conversation;\n  };\n\n  /**\n   * 反序列化消息，与 {@link Message#toFullJSON} 相对。\n   * @param {Object}\n   * @return {AVMessage} 解析后的消息\n   * @since 4.0.0\n   */\n\n\n  IMClient.prototype.parseMessage = function () {\n    var _ref27 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee17(_ref26) {\n      var data = _ref26.data,\n          _ref26$bin = _ref26.bin,\n          bin = _ref26$bin === undefined ? false : _ref26$bin,\n          properties = _objectWithoutProperties(_ref26, ['data', 'bin']);\n\n      var content, message;\n      return regenerator.wrap(function _callee17$(_context17) {\n        while (1) {\n          switch (_context17.prev = _context17.next) {\n            case 0:\n              content = bin ? base64Arraybuffer_2(data) : data;\n              _context17.next = 3;\n              return this._messageParser.parse(content);\n\n            case 3:\n              message = _context17.sent;\n\n              _Object$assign(message, properties);\n              message._updateMentioned(this.id);\n              return _context17.abrupt('return', message);\n\n            case 7:\n            case 'end':\n              return _context17.stop();\n          }\n        }\n      }, _callee17, this);\n    }));\n\n    function parseMessage(_x22) {\n      return _ref27.apply(this, arguments);\n    }\n\n    return parseMessage;\n  }();\n\n  /**\n   * 反序列化对话，与 {@link Conversation#toFullJSON} 相对。\n   * @param {Object}\n   * @return {ConversationBase} 解析后的对话\n   * @since 4.0.0\n   */\n\n\n  IMClient.prototype.parseConversation = function () {\n    var _ref29 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee18(_ref28) {\n      var id = _ref28.id,\n          lastMessageAt = _ref28.lastMessageAt,\n          lastMessage = _ref28.lastMessage,\n          lastDeliveredAt = _ref28.lastDeliveredAt,\n          lastReadAt = _ref28.lastReadAt,\n          unreadMessagesCount = _ref28.unreadMessagesCount,\n          members = _ref28.members,\n          mentioned = _ref28.mentioned,\n          properties = _objectWithoutProperties(_ref28, ['id', 'lastMessageAt', 'lastMessage', 'lastDeliveredAt', 'lastReadAt', 'unreadMessagesCount', 'members', 'mentioned']);\n\n      var conversationData, transient, system, expiredAt;\n      return regenerator.wrap(function _callee18$(_context18) {\n        while (1) {\n          switch (_context18.prev = _context18.next) {\n            case 0:\n              conversationData = {\n                id: id,\n                lastMessageAt: lastMessageAt,\n                lastMessage: lastMessage,\n                lastDeliveredAt: lastDeliveredAt,\n                lastReadAt: lastReadAt,\n                unreadMessagesCount: unreadMessagesCount,\n                members: members,\n                mentioned: mentioned\n              };\n\n              if (!lastMessage) {\n                _context18.next = 6;\n                break;\n              }\n\n              _context18.next = 4;\n              return this.parseMessage(lastMessage);\n\n            case 4:\n              conversationData.lastMessage = _context18.sent;\n\n              conversationData.lastMessage._setStatus(MessageStatus.SENT);\n\n            case 6:\n              transient = properties.transient, system = properties.system, expiredAt = properties.expiredAt;\n\n              if (!transient) {\n                _context18.next = 9;\n                break;\n              }\n\n              return _context18.abrupt('return', new ChatRoom(conversationData, properties, this));\n\n            case 9:\n              if (!system) {\n                _context18.next = 11;\n                break;\n              }\n\n              return _context18.abrupt('return', new ServiceConversation(conversationData, properties, this));\n\n            case 11:\n              if (!(expiredAt || isTemporaryConversatrionId(id))) {\n                _context18.next = 13;\n                break;\n              }\n\n              return _context18.abrupt('return', new TemporaryConversation(conversationData, { expiredAt: expiredAt }, this));\n\n            case 13:\n              return _context18.abrupt('return', new Conversation(conversationData, properties, this));\n\n            case 14:\n            case 'end':\n              return _context18.stop();\n          }\n        }\n      }, _callee18, this);\n    }));\n\n    function parseConversation(_x23) {\n      return _ref29.apply(this, arguments);\n    }\n\n    return parseConversation;\n  }();\n\n  IMClient.prototype._parseConversationFromRawData = function () {\n    var _ref30 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee19(rawData) {\n      var data, ttl;\n      return regenerator.wrap(function _callee19$(_context19) {\n        while (1) {\n          switch (_context19.prev = _context19.next) {\n            case 0:\n              data = keyRemap({\n                objectId: 'id',\n                lm: 'lastMessageAt',\n                m: 'members',\n                tr: 'transient',\n                sys: 'system',\n                c: 'creator',\n                mu: 'mutedMembers'\n              }, rawData);\n\n              if (data.msg) {\n                data.lastMessage = {\n                  data: data.msg,\n                  bin: data.bin,\n                  from: data.msg_from,\n                  id: data.msg_mid,\n                  timestamp: data.msg_timestamp,\n                  updatedAt: data.patch_timestamp\n                };\n                delete data.lastMessageFrom;\n                delete data.lastMessageId;\n                delete data.lastMessageTimestamp;\n                delete data.lastMessagePatchTimestamp;\n              }\n              ttl = data.ttl;\n\n              if (ttl) data.expiredAt = Date.now() + ttl * 1000;\n              return _context19.abrupt('return', this.parseConversation(data));\n\n            case 5:\n            case 'end':\n              return _context19.stop();\n          }\n        }\n      }, _callee19, this);\n    }));\n\n    function _parseConversationFromRawData(_x24) {\n      return _ref30.apply(this, arguments);\n    }\n\n    return _parseConversationFromRawData;\n  }();\n\n  /**\n   * 创建一个对话\n   * @param {Object} options 除了下列字段外的其他字段将被视为对话的自定义属性\n   * @param {String[]} options.members 对话的初始成员列表，默认包含当前 client\n   * @param {String} [options.name] 对话的名字\n   * @param {Boolean} [options.unique=false] 唯一对话，当其为 true 时，如果当前已经有相同成员的对话存在则返回该对话，否则会创建新的对话\n   * @return {Promise.<Conversation>}\n   */\n\n\n  IMClient.prototype.createConversation = function () {\n    var _ref32 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee20() {\n      var _ref31 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var m = _ref31.members,\n          name$$1 = _ref31.name,\n          transient = _ref31.transient,\n          unique = _ref31.unique,\n          tempConv = _ref31._tempConv,\n          tempConvTTL = _ref31._tempConvTTL,\n          properties = _objectWithoutProperties(_ref31, ['members', 'name', 'transient', 'unique', '_tempConv', '_tempConvTTL']);\n\n      var members, attr, startCommandJson, command, _params, signatureResult, _ref33, _ref33$convMessage, cid, cdate, ttl, data, conversation;\n\n      return regenerator.wrap(function _callee20$(_context20) {\n        while (1) {\n          switch (_context20.prev = _context20.next) {\n            case 0:\n              if (transient || Array.isArray(m)) {\n                _context20.next = 2;\n                break;\n              }\n\n              throw new TypeError('conversation members ' + m + ' is not an array');\n\n            case 2:\n              members = new _Set(m);\n\n              members.add(this.id);\n              members = _Array$from(members).sort();\n              attr = properties || {};\n\n              if (!name$$1) {\n                _context20.next = 10;\n                break;\n              }\n\n              if (!(typeof name$$1 !== 'string')) {\n                _context20.next = 9;\n                break;\n              }\n\n              throw new TypeError('conversation name ' + name$$1 + ' is not a string');\n\n            case 9:\n              attr.name = name$$1;\n\n            case 10:\n              attr = new JsonObjectMessage({\n                data: _JSON$stringify(encode$1(attr))\n              });\n\n              startCommandJson = {\n                m: members,\n                attr: attr,\n                transient: transient,\n                unique: unique,\n                tempConv: tempConv,\n                tempConvTTL: tempConvTTL\n              };\n              command = new GenericCommand({\n                cmd: 'conv',\n                op: 'start',\n                convMessage: new ConvCommand(startCommandJson)\n              });\n\n              if (!this.options.conversationSignatureFactory) {\n                _context20.next = 19;\n                break;\n              }\n\n              _params = [null, this._identity, members, 'create'];\n              _context20.next = 17;\n              return runSignatureFactory(this.options.conversationSignatureFactory, _params);\n\n            case 17:\n              signatureResult = _context20.sent;\n\n              _Object$assign(command.convMessage, keyRemap({\n                signature: 's',\n                timestamp: 't',\n                nonce: 'n'\n              }, signatureResult));\n\n            case 19:\n              _context20.next = 21;\n              return this._send(command);\n\n            case 21:\n              _ref33 = _context20.sent;\n              _ref33$convMessage = _ref33.convMessage;\n              cid = _ref33$convMessage.cid;\n              cdate = _ref33$convMessage.cdate;\n              ttl = _ref33$convMessage.tempConvTTL;\n              data = _extends$1({\n                name: name$$1,\n                transient: transient,\n                unique: unique,\n                id: cid,\n                createdAt: cdate,\n                updatedAt: cdate,\n                lastMessageAt: null,\n                creator: this.id,\n                members: transient ? [] : members\n              }, properties);\n\n              if (ttl) data.expiredAt = Date.now() + ttl * 1000;\n              _context20.next = 30;\n              return this.parseConversation(data);\n\n            case 30:\n              conversation = _context20.sent;\n              return _context20.abrupt('return', this._upsertConversationToCache(conversation));\n\n            case 32:\n            case 'end':\n              return _context20.stop();\n          }\n        }\n      }, _callee20, this);\n    }));\n\n    function createConversation() {\n      return _ref32.apply(this, arguments);\n    }\n\n    return createConversation;\n  }();\n\n  /**\n   * 创建一个聊天室\n   * @since 4.0.0\n   * @param {Object} options 除了下列字段外的其他字段将被视为对话的自定义属性\n   * @param {String} [options.name] 对话的名字\n   * @return {Promise.<ChatRoom>}\n   */\n\n\n  IMClient.prototype.createChatRoom = function () {\n    var _ref34 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee21(param) {\n      return regenerator.wrap(function _callee21$(_context21) {\n        while (1) {\n          switch (_context21.prev = _context21.next) {\n            case 0:\n              return _context21.abrupt('return', this.createConversation(_extends$1({}, param, {\n                transient: true,\n                members: null,\n                unique: false\n              })));\n\n            case 1:\n            case 'end':\n              return _context21.stop();\n          }\n        }\n      }, _callee21, this);\n    }));\n\n    function createChatRoom(_x26) {\n      return _ref34.apply(this, arguments);\n    }\n\n    return createChatRoom;\n  }();\n\n  /**\n   * 创建一个临时对话\n   * @since 4.0.0\n   * @param {Object} options\n   * @param {String[]} options.members 对话的初始成员列表，默认包含当前 client\n   * @param {String} [options.ttl] 对话存在时间，单位为秒，最大值与默认值均为 86400（一天），过期后该对话不再可用。\n   * @return {Promise.<TemporaryConversation>}\n   */\n\n\n  IMClient.prototype.createTemporaryConversation = function () {\n    var _ref36 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee22(_ref35) {\n      var _tempConvTTL = _ref35.ttl,\n          param = _objectWithoutProperties(_ref35, ['ttl']);\n\n      return regenerator.wrap(function _callee22$(_context22) {\n        while (1) {\n          switch (_context22.prev = _context22.next) {\n            case 0:\n              return _context22.abrupt('return', this.createConversation(_extends$1({}, param, {\n                transient: false,\n                unique: false,\n                _tempConv: true,\n                _tempConvTTL: _tempConvTTL\n              })));\n\n            case 1:\n            case 'end':\n              return _context22.stop();\n          }\n        }\n      }, _callee22, this);\n    }));\n\n    function createTemporaryConversation(_x27) {\n      return _ref36.apply(this, arguments);\n    }\n\n    return createTemporaryConversation;\n  }();\n\n  // jsdoc-ignore-start\n\n\n  // jsdoc-ignore-end\n  IMClient.prototype._doSendRead = function _doSendRead() {\n    var _this10 = this;\n\n    // if not connected, just skip everything\n    if (!this._connection.is('connected')) return;\n    var buffer = internal(this).readConversationsBuffer;\n    var conversations = _Array$from(buffer);\n    if (!conversations.length) return;\n    var ids = conversations.map(function (conversation) {\n      if (!(conversation instanceof ConversationBase)) {\n        throw new TypeError(conversation + ' is not a Conversation');\n      }\n      return conversation.id;\n    });\n    this._debug('mark [' + ids + '] as read');\n    buffer.clear();\n    this._sendReadCommand(conversations).catch(function (error$$1) {\n      _this10._debug('send read failed: %O', error$$1);\n      conversations.forEach(buffer.add.bind(buffer));\n    });\n  };\n\n  IMClient.prototype._sendReadCommand = function _sendReadCommand(conversations) {\n    var _this11 = this;\n\n    return this._send(new GenericCommand({\n      cmd: 'read',\n      readMessage: new ReadCommand({\n        convs: conversations.map(function (conversation) {\n          return new ReadTuple({\n            cid: conversation.id,\n            mid: conversation.lastMessage && conversation.lastMessage.from !== _this11.id ? conversation.lastMessage.id : undefined,\n            timestamp: (conversation.lastMessageAt || new Date()).getTime()\n          });\n        })\n      })\n    }), false);\n  };\n\n  return IMClient;\n}(eventemitter3), _applyDecoratedDescriptor$1(_class$3.prototype, '_doSendAck', [_dec$2], _Object$getOwnPropertyDescriptor(_class$3.prototype, '_doSendAck'), _class$3.prototype), _applyDecoratedDescriptor$1(_class$3.prototype, '_doSendRead', [_dec2], _Object$getOwnPropertyDescriptor(_class$3.prototype, '_doSendRead'), _class$3.prototype), _class$3);\n\nvar RECONNECT_ERROR = 'reconnecterror';\n\nvar CoreEvent = Object.freeze({\n\tRECONNECT_ERROR: RECONNECT_ERROR,\n\tDISCONNECT: DISCONNECT,\n\tRECONNECT: RECONNECT,\n\tRETRY: RETRY,\n\tSCHEDULE: SCHEDULE,\n\tOFFLINE: OFFLINE,\n\tONLINE: ONLINE\n});\n\nvar _class$4;\n// jsdoc-ignore-start\n\n// jsdoc-ignore-end\nvar BinaryMessage = IE10Compatible(_class$4 = function (_Message) {\n  _inherits(BinaryMessage, _Message);\n\n  /**\n   * 二进制消息\n   * @extends Message\n   * @param {ArrayBuffer} buffer\n   * @since 4.0.0\n   */\n  function BinaryMessage(buffer) {\n    _classCallCheck(this, BinaryMessage);\n\n    if (!(buffer instanceof ArrayBuffer)) {\n      throw new TypeError(buffer + ' is not an ArrayBuffer');\n    }\n    return _possibleConstructorReturn(this, _Message.call(this, buffer));\n  }\n\n  /**\n   * @type ArrayBuffer\n   */\n\n\n  BinaryMessage.validate = function validate(target) {\n    return target instanceof ArrayBuffer;\n  };\n\n  BinaryMessage.prototype.toJSON = function toJSON() {\n    return _extends$1({}, _Message.prototype._toJSON.call(this), {\n      data: base64Arraybuffer_1(this.content)\n    });\n  };\n\n  BinaryMessage.prototype.toFullJSON = function toFullJSON() {\n    return _extends$1({}, _Message.prototype.toFullJSON.call(this), {\n      bin: true,\n      data: base64Arraybuffer_1(this.content)\n    });\n  };\n\n  _createClass(BinaryMessage, [{\n    key: 'buffer',\n    get: function get() {\n      return this.content;\n    },\n    set: function set(buffer) {\n      this.content = buffer;\n    }\n  }]);\n\n  return BinaryMessage;\n}(Message)) || _class$4;\n\nvar _dec$3, _class$5;\n\n// jsdoc-ignore-start\n\n// jsdoc-ignore-end\nvar TextMessage = (_dec$3 = messageType(-1), _dec$3(_class$5 = IE10Compatible(_class$5 = function (_TypedMessage) {\n  _inherits(TextMessage, _TypedMessage);\n\n  /**\n   * 文类类型消息\n   * @extends TypedMessage\n   * @param  {String} [text='']\n   * @throws {TypeError} text 不是 String 类型\n   */\n  function TextMessage() {\n    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n    _classCallCheck(this, TextMessage);\n\n    if (typeof text !== 'string') {\n      throw new TypeError(text + ' is not a string');\n    }\n\n    var _this = _possibleConstructorReturn(this, _TypedMessage.call(this));\n\n    _this.setText(text);\n    return _this;\n  }\n\n  return TextMessage;\n}(TypedMessage)) || _class$5) || _class$5);\n\nvar _class$6;\n\nfunction _applyDecoratedDescriptor$2(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object['ke' + 'ys'](descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n\n  if (desc.initializer === void 0) {\n    Object['define' + 'Property'](target, property, desc);\n    desc = null;\n  }\n\n  return desc;\n}\n\nvar debug$11 = browser('LC:MessageParser');\n\nvar tryParseJson = function tryParseJson(target, key, descriptor) {\n  var fn = descriptor.value;\n  // eslint-disable-next-line no-param-reassign\n  descriptor.value = function wrapper(param) {\n    var content = void 0;\n    if (typeof param !== 'string') {\n      content = param;\n    } else {\n      try {\n        content = JSON.parse(param);\n      } catch (error) {\n        content = param;\n      }\n    }\n    return fn.call(this, content);\n  };\n};\n\nvar applyPlugins = function applyPlugins(target, key, descriptor) {\n  var fn = descriptor.value;\n  // eslint-disable-next-line no-param-reassign\n  descriptor.value = function wrapper(json) {\n    var _this = this;\n\n    return _Promise.resolve(json).then(applyMiddlewares(this._plugins.beforeMessageParse)).then(function (decoratedJson) {\n      return fn.call(_this, decoratedJson);\n    }).then(applyMiddlewares(this._plugins.afterMessageParse));\n  };\n};\n\nvar MessageParser = (_class$6 = function () {\n  function MessageParser() {\n    var plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MessageParser);\n\n    this._plugins = plugins;\n    this._messageClasses = [];\n  }\n\n  MessageParser.prototype.register = function register(messageClass) {\n    if (messageClass && messageClass.parse && messageClass.prototype && messageClass.prototype.getPayload) {\n      this._messageClasses.unshift(messageClass);\n    } else {\n      throw new TypeError('Invalid messageClass');\n    }\n  };\n\n  // jsdoc-ignore-start\n\n\n  // jsdoc-ignore-end\n  MessageParser.prototype.parse = function parse(content) {\n    debug$11('parsing message: %O', content);\n    // eslint-disable-next-line no-restricted-syntax\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = _getIterator(this._messageClasses), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var Klass = _step.value;\n\n        var contentCopy = isPlainObject_1(content) ? _Object$assign({}, content) : content;\n        var valid = void 0;\n        var result = void 0;\n        try {\n          valid = Klass.validate(contentCopy);\n        } catch (error) {\n          // eslint-disable-line no-empty\n        }\n        if (valid) {\n          try {\n            result = Klass.parse(contentCopy);\n          } catch (error) {\n            console.warn('parsing a valid message content error', {\n              error: error,\n              Klass: Klass,\n              content: contentCopy\n            });\n          }\n          if (result !== undefined) {\n            debug$11('parse result: %O', result);\n            return result;\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    throw new Error('No Message Class matched');\n  };\n\n  return MessageParser;\n}(), _applyDecoratedDescriptor$2(_class$6.prototype, 'parse', [tryParseJson, applyPlugins], _Object$getOwnPropertyDescriptor(_class$6.prototype, 'parse'), _class$6.prototype), _class$6);\n\nvar _this = undefined;\n\nvar debug$12 = browser('LC:IMPlugin');\n\n/**\n * 消息优先级枚举\n * @enum {Number}\n * @since 3.3.0\n */\nvar MessagePriority = {\n  /** 高 */\n  HIGH: 1,\n  /** 普通 */\n  NORMAL: 2,\n  /** 低 */\n  LOW: 3\n};\n_Object$freeze(MessagePriority);\n\n/**\n * 为 Conversation 定义一个新属性\n * @param {String} prop 属性名\n * @param {Object} [descriptor] 属性的描述符，参见 {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor#Description getOwnPropertyDescriptor#Description - MDN}，默认为该属性名对应的 Conversation 自定义属性的 getter/setter\n * @returns void\n * @example\n *\n * conversation.get('type');\n * conversation.set('type', 1);\n *\n * // equals to\n * defineConversationProperty('type');\n * conversation.type;\n * conversation.type = 1;\n */\nvar defineConversationProperty = function defineConversationProperty(prop) {\n  var descriptor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    get: function get() {\n      return this.get(prop);\n    },\n    set: function set(value) {\n      this.set(prop, value);\n    }\n  };\n\n  _Object$defineProperty(Conversation.prototype, prop, descriptor);\n};\n\nvar onRealtimeCreate = function onRealtimeCreate(realtime) {\n  /* eslint-disable no-param-reassign */\n  var deviceId = v4_1();\n  realtime._IMClients = {};\n  realtime._IMClientsCreationCount = 0;\n  var messageParser = new MessageParser(realtime._plugins);\n  realtime._messageParser = messageParser;\n\n  var signAVUser = function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(user) {\n      return regenerator.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt('return', realtime._request({\n                method: 'POST',\n                path: '/rtm/sign',\n                data: {\n                  session_token: user.getSessionToken()\n                }\n              }));\n\n            case 1:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, _callee, _this);\n    }));\n\n    return function signAVUser(_x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  /**\n   * 注册消息类\n   *\n   * 在接收消息、查询消息时，会按照消息类注册顺序的逆序依次尝试解析消息内容\n   *\n   * @memberof Realtime\n   * @instance\n   * @param  {Function | Function[]} messageClass 消息类，需要实现 {@link AVMessage} 接口，\n   * 建议继承自 {@link TypedMessage}\n   * @throws {TypeError} 如果 messageClass 没有实现 {@link AVMessage} 接口则抛出异常\n   */\n  var register = function register(messageClass) {\n    return ensureArray(messageClass).map(messageParser.register.bind(messageParser));\n  };\n  register(ensureArray(realtime._plugins.messageClasses));\n  /**\n   * 创建一个即时通讯客户端，多次创建相同 id 的客户端会返回同一个实例\n   * @memberof Realtime\n   * @instance\n   * @param  {String|AV.User} [identity] 客户端 identity，如果不指定该参数，服务端会随机生成一个字符串作为 identity，\n   * 如果传入一个已登录的 AV.User，则会使用该用户的 id 作为客户端 identity 登录。\n   * @param  {Object} [options]\n   * @param  {Function} [options.signatureFactory] open session 时的签名方法 // TODO need details\n   * @param  {Function} [options.conversationSignatureFactory] 对话创建、增减成员操作时的签名方法\n   * @param  {Function} [options.blacklistSignatureFactory] 黑名单操作时的签名方法\n   * @param  {String} [options.tag] 客户端类型标记，以支持单点登录功能\n   * @param  {String} [options.isReconnect=false] 单点登录时标记该次登录是不是应用启动时自动重新登录\n   * @return {Promise.<IMClient>}\n   */\n  var createIMClient = function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(identity) {\n      var _realtime$_open$then;\n\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var tag = _ref2.tag,\n          isReconnect = _ref2.isReconnect,\n          clientOptions = _objectWithoutProperties(_ref2, ['tag', 'isReconnect']);\n\n      var lagecyTag = arguments[2];\n\n      var id, buildinOptions, sessionToken, _tag, promise;\n\n      return regenerator.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              id = void 0;\n              buildinOptions = {};\n\n              if (!identity) {\n                _context2.next = 18;\n                break;\n              }\n\n              if (!(typeof identity === 'string')) {\n                _context2.next = 7;\n                break;\n              }\n\n              id = identity;\n              _context2.next = 16;\n              break;\n\n            case 7:\n              if (!(identity.id && identity.getSessionToken)) {\n                _context2.next = 15;\n                break;\n              }\n\n              id = identity.id;\n              sessionToken = identity.getSessionToken();\n\n              if (sessionToken) {\n                _context2.next = 12;\n                break;\n              }\n\n              throw new Error('User must be authenticated');\n\n            case 12:\n              buildinOptions.signatureFactory = signAVUser;\n              _context2.next = 16;\n              break;\n\n            case 15:\n              throw new TypeError('Identity must be a String or an AV.User');\n\n            case 16:\n              if (!(realtime._IMClients[id] !== undefined)) {\n                _context2.next = 18;\n                break;\n              }\n\n              return _context2.abrupt('return', realtime._IMClients[id]);\n\n            case 18:\n              if (lagecyTag) {\n                console.warn('DEPRECATION createIMClient tag param: Use options.tag instead.');\n              }\n              _tag = tag || lagecyTag;\n              promise = (_realtime$_open$then = realtime._open().then(function (connection) {\n                var client = new IMClient(id, _extends$1({}, buildinOptions, clientOptions), {\n                  _connection: connection,\n                  _request: realtime._request.bind(realtime),\n                  _messageParser: messageParser,\n                  _plugins: realtime._plugins,\n                  _identity: identity\n                });\n                connection.on(RECONNECT, function () {\n                  return client._open(realtime._options.appId, _tag, deviceId, true)\n                  /**\n                   * 客户端连接恢复正常，该事件通常在 {@link Realtime#event:RECONNECT} 之后发生\n                   * @event IMClient#RECONNECT\n                   * @see Realtime#event:RECONNECT\n                   * @since 3.2.0\n                   */\n                  /**\n                   * 客户端重新登录发生错误（网络连接已恢复，但重新登录错误）\n                   * @event IMClient#RECONNECT_ERROR\n                   * @since 3.2.0\n                   */\n                  .then(function () {\n                    return client.emit(RECONNECT);\n                  }, function (error) {\n                    return client.emit(RECONNECT_ERROR, error);\n                  });\n                });\n                internal(client)._eventemitter.on('beforeclose', function () {\n                  delete realtime._IMClients[client.id];\n                  if (realtime._firstIMClient === client) {\n                    delete realtime._firstIMClient;\n                  }\n                }, realtime);\n                internal(client)._eventemitter.on('close', function () {\n                  realtime._deregister(client);\n                }, realtime);\n                return client._open(realtime._options.appId, _tag, deviceId, isReconnect).then(function () {\n                  realtime._IMClients[client.id] = client;\n                  realtime._IMClientsCreationCount += 1;\n                  if (realtime._IMClientsCreationCount === 1) {\n                    client._omitPeerId(true);\n                    realtime._firstIMClient = client;\n                  } else if (realtime._IMClientsCreationCount > 1 && realtime._firstIMClient) {\n                    realtime._firstIMClient._omitPeerId(false);\n                  }\n                  realtime._register(client);\n                  return client;\n                }).catch(function (error) {\n                  delete realtime._IMClients[client.id];\n                  throw error;\n                });\n              })).then.apply(_realtime$_open$then, _toConsumableArray(finalize(function () {\n                realtime._deregisterPending(promise);\n              })));\n\n              if (identity) {\n                realtime._IMClients[id] = promise;\n              }\n              realtime._registerPending(promise);\n              return _context2.abrupt('return', promise);\n\n            case 24:\n            case 'end':\n              return _context2.stop();\n          }\n        }\n      }, _callee2, _this);\n    }));\n\n    return function createIMClient(_x4) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  _Object$assign(realtime, {\n    register: register,\n    createIMClient: createIMClient\n  });\n  /* eslint-enable no-param-reassign */\n};\n\nvar beforeCommandDispatch = function beforeCommandDispatch(command, realtime) {\n  var isIMCommand = command.service === null || command.service === 2;\n  if (!isIMCommand) return true;\n  var targetClient = command.peerId ? realtime._IMClients[command.peerId] : realtime._firstIMClient;\n  if (targetClient) {\n    _Promise.resolve(targetClient).then(function (client) {\n      return client._dispatchCommand(command);\n    }).catch(debug$12);\n  } else {\n    debug$12('[WARN] Unexpected message received without any live client match: %O', trim$1(command));\n  }\n  return false;\n};\n\nvar IMPlugin = {\n  name: 'leancloud-realtime-plugin-im',\n  onRealtimeCreate: onRealtimeCreate,\n  beforeCommandDispatch: beforeCommandDispatch,\n  messageClasses: [Message, BinaryMessage, RecalledMessage, TextMessage]\n};\n\nRealtime.defineConversationProperty = defineConversationProperty;\nRealtime.__preRegisteredPlugins = [IMPlugin];\n\nvar Event$1 = _extends$1({}, CoreEvent, Event);\n\nexports.Event = Event$1;\nexports.ErrorCode = ErrorCode;\nexports.Protocals = message;\nexports.Promise = _Promise;\nexports.EventEmitter = eventemitter3;\nexports.Realtime = Realtime;\nexports.Message = Message;\nexports.BinaryMessage = BinaryMessage;\nexports.TypedMessage = TypedMessage;\nexports.TextMessage = TextMessage;\nexports.RecalledMessage = RecalledMessage;\nexports.MessagePriority = MessagePriority;\nexports.MessageStatus = MessageStatus;\nexports.MessageQueryDirection = MessageQueryDirection;\nexports.defineConversationProperty = defineConversationProperty;\nexports.IMPlugin = IMPlugin;\nexports.messageType = messageType;\nexports.messageField = messageField;\nexports.IE10Compatible = IE10Compatible;\nexports.ConversationMemberRole = ConversationMemberRole;\nexports.Conversation = Conversation;\nexports.ChatRoom = ChatRoom;\nexports.ServiceConversation = ServiceConversation;\nexports.TemporaryConversation = TemporaryConversation;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=realtime.browser.js.map\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhbmNsb3VkLXJlYWx0aW1lL2Rpc3QvcmVhbHRpbWUuYnJvd3Nlci5qcz80ZmUzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxVQUNzQztBQUN0QyxDQUFDLDRCQUE0Qjs7QUFFN0I7QUFDQSx1Q0FBdUM7Ozs7QUFJdkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFlBQVksRUFBRTtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsQ0FBQzs7QUFFRDtBQUNBLDZCQUE2QjtBQUM3Qix1Q0FBdUM7QUFDdkMsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVEsbUJBQW1CLFVBQVUsRUFBRSxFQUFFO0FBQzFFLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0RBQXdELG1CQUFtQixVQUFVLEVBQUUsRUFBRTtBQUN6RixDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1Q0FBdUMsc0JBQXNCLEVBQUU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLEdBQUc7QUFDSCxZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFD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QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCLGdEQUFnRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNB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QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCO0FBQ3JCO0FBQ0E7QUFD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QUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QyxLQUFLOztBQUVMO0FBQ0Esd0RBQXdELHdCQUF3QjtBQUNoRjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdF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QUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsTUFBTTtBQUNu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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQSxxRUFBcUUsYUFBYTtBQUNsRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0EsNkZBQTZGLGVBQWU7QUFDNUc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0Esa0RBQWtEO0FBQ2xELENBQUMsSUFBSTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztB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TztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVMsR0FBRyxTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUEs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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLGtCQUFrQjtBQUNoQzs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsa0JBQWtCO0FBQ2hDOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsa0JBQWtCO0FBQ2hDOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixjQUFjLGtCQUFrQjtBQUNoQzs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYyxrQkFBa0I7QUFDaEM7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsa0JBQWtCO0FBQ2hDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsU0FBUztBQUNsQyx5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsaUJBQWlCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCLFNBQVM7QUFDbEMseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsU0FBUztBQUNsQyx5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsaUJBQWlCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCLFNBQVM7QUFDbEMseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsU0FBUztBQUNsQyx5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsaUJBQWlCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCLFNBQVM7QUFDbEMseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCLGlCQUFpQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixpQkFBaUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixTQUFTO0FBQ2xDLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixpQkFBaUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsU0FBUztBQUNsQyx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixTQUFTO0FBQ2xDLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixpQkFBaUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsU0FBUztBQUNsQyx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsT0FBTztBQUNoQyx5QkFBeUIsaUJBQWlCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCLE9BQU87QUFDaEMseUJBQXlCLGlCQUFpQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7O0FBRTVELENBQUM7QUFDRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9sZWFuY2xvdWQtcmVhbHRpbWUvZGlzdC9yZWFsdGltZS5icm93c2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgnbGVhbmNsb3VkLXJlYWx0aW1lJywgWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5BViA9IGdsb2JhbC5BViB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHVuZGVmaW5lZDtcbnZhciByZXF1aXJlID0gcmVxdWlyZSB8fCBmdW5jdGlvbihpZCkge3Rocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCByZXF1aXJlZCAnICsgaWQpfTtcblxuXG5cbnZhciBwcm9jZXNzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzKSB8fCB7fTtcbnByb2Nlc3MuZW52ID0gcHJvY2Vzcy5lbnYgfHwge307XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIGNvbW1vbmpzUmVxdWlyZSAoKSB7XG5cdHRocm93IG5ldyBFcnJvcignRHluYW1pYyByZXF1aXJlcyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgcm9sbHVwLXBsdWdpbi1jb21tb25qcycpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBFeHBvcnRzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG52YXIgX2dsb2JhbCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbn0pO1xuXG52YXIgX2NvcmUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG52YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjcnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxufSk7XG52YXIgX2NvcmVfMSA9IF9jb3JlLnZlcnNpb247XG5cbnZhciBfYUZ1bmN0aW9uID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5cbnZhciBfY3R4ID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgX2FGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciBfaXNPYmplY3QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBfYW5PYmplY3QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFfaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cbnZhciBfZmFpbHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG52YXIgX2Rlc2NyaXB0b3JzID0gIV9mYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cbnZhciBkb2N1bWVudCQxID0gX2dsb2JhbC5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gX2lzT2JqZWN0KGRvY3VtZW50JDEpICYmIF9pc09iamVjdChkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQpO1xudmFyIF9kb21DcmVhdGUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxudmFyIF9pZThEb21EZWZpbmUgPSAhX2Rlc2NyaXB0b3JzICYmICFfZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KF9kb21DcmVhdGUoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuXG4vLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcblxuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG52YXIgX3RvUHJpbWl0aXZlID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghX2lzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFfaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIV9pc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIV9pc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIGYgPSBfZGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIF9hbk9iamVjdChPKTtcbiAgUCA9IF90b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgX2FuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoX2llOERvbURlZmluZSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgX29iamVjdERwID0ge1xuXHRmOiBmXG59O1xuXG52YXIgX3Byb3BlcnR5RGVzYyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG52YXIgX2hpZGUgPSBfZGVzY3JpcHRvcnMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBfb2JqZWN0RHAuZihvYmplY3QsIGtleSwgX3Byb3BlcnR5RGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xudmFyIF9oYXMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIElTX1dSQVAgPSB0eXBlICYgJGV4cG9ydC5XO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IF9jb3JlIDogX2NvcmVbbmFtZV0gfHwgKF9jb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV07XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBfZ2xvYmFsIDogSVNfU1RBVElDID8gX2dsb2JhbFtuYW1lXSA6IChfZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIga2V5LCBvd24sIG91dDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAob3duICYmIF9oYXMoZXhwb3J0cywga2V5KSkgY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gX2N0eChvdXQsIF9nbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uIChDKSB7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQykge1xuICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEMoKTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gX2N0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmIChJU19QUk9UTykge1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmICh0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKSBfaGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbnZhciBfZXhwb3J0ID0gJGV4cG9ydDtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciBfY29mID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG52YXIgX2lvYmplY3QgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gX2NvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbnZhciBfZGVmaW5lZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xuXG5cbnZhciBfdG9Jb2JqZWN0ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBfaW9iamVjdChfZGVmaW5lZChpdCkpO1xufTtcblxuLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgX3RvSW50ZWdlciA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cbi8vIDcuMS4xNSBUb0xlbmd0aFxuXG52YXIgbWluID0gTWF0aC5taW47XG52YXIgX3RvTGVuZ3RoID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4oX3RvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiQxID0gTWF0aC5taW47XG52YXIgX3RvQWJzb2x1dGVJbmRleCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gX3RvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluJDEoaW5kZXgsIGxlbmd0aCk7XG59O1xuXG4vLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xuXG5cblxudmFyIF9hcnJheUluY2x1ZGVzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IF90b0lvYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSBfdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IF90b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG52YXIgX2xpYnJhcnkgPSB0cnVlO1xuXG52YXIgX3NoYXJlZCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IF9nbG9iYWxbU0hBUkVEXSB8fCAoX2dsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogX2NvcmUudmVyc2lvbixcbiAgbW9kZTogX2xpYnJhcnkgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxOCBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xufSk7XG5cbnZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xudmFyIF91aWQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG52YXIgc2hhcmVkID0gX3NoYXJlZCgna2V5cycpO1xuXG52YXIgX3NoYXJlZEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IF91aWQoa2V5KSk7XG59O1xuXG52YXIgYXJyYXlJbmRleE9mID0gX2FycmF5SW5jbHVkZXMoZmFsc2UpO1xudmFyIElFX1BST1RPID0gX3NoYXJlZEtleSgnSUVfUFJPVE8nKTtcblxudmFyIF9vYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IF90b0lvYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIF9oYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoX2hhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbnZhciBfZW51bUJ1Z0tleXMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7XG5cbi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxuXG5cblxudmFyIF9vYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiBfb2JqZWN0S2V5c0ludGVybmFsKE8sIF9lbnVtQnVnS2V5cyk7XG59O1xuXG52YXIgZiQxID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxudmFyIF9vYmplY3RHb3BzID0ge1xuXHRmOiBmJDFcbn07XG5cbnZhciBmJDIgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxudmFyIF9vYmplY3RQaWUgPSB7XG5cdGY6IGYkMlxufTtcblxuLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxuXG52YXIgX3RvT2JqZWN0ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoX2RlZmluZWQoaXQpKTtcbn07XG5cbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcblxuXG5cblxuXG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxudmFyIF9vYmplY3RBc3NpZ24gPSAhJGFzc2lnbiB8fCBfZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIFMgPSBTeW1ib2woKTtcbiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IF90b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gX29iamVjdEdvcHMuZjtcbiAgdmFyIGlzRW51bSA9IF9vYmplY3RQaWUuZjtcbiAgd2hpbGUgKGFMZW4gPiBpbmRleCkge1xuICAgIHZhciBTID0gX2lvYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBfb2JqZWN0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBfb2JqZWN0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIGlmIChpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKSBUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxuLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcblxuXG5fZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiBfb2JqZWN0QXNzaWduIH0pO1xuXG52YXIgYXNzaWduID0gX2NvcmUuT2JqZWN0LmFzc2lnbjtcblxudmFyIGFzc2lnbiQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBhc3NpZ24sIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0pO1xuXG52YXIgX09iamVjdCRhc3NpZ24gPSB1bndyYXBFeHBvcnRzKGFzc2lnbiQxKTtcblxudmFyIF9leHRlbmRzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cblxudmFyIF9hc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChhc3NpZ24kMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9hc3NpZ24yLmRlZmF1bHQgfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xufSk7XG5cbnZhciBfZXh0ZW5kcyQxID0gdW53cmFwRXhwb3J0cyhfZXh0ZW5kcyk7XG5cbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG52YXIgX3N0cmluZ0F0ID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKF9kZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IF90b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG52YXIgX3JlZGVmaW5lID0gX2hpZGU7XG5cbnZhciBfaXRlcmF0b3JzID0ge307XG5cbnZhciBfb2JqZWN0RHBzID0gX2Rlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgX2FuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IF9vYmplY3RLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBfb2JqZWN0RHAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgZG9jdW1lbnQkMiA9IF9nbG9iYWwuZG9jdW1lbnQ7XG52YXIgX2h0bWwgPSBkb2N1bWVudCQyICYmIGRvY3VtZW50JDIuZG9jdW1lbnRFbGVtZW50O1xuXG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcblxuXG5cbnZhciBJRV9QUk9UTyQxID0gX3NoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUkMSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IF9kb21DcmVhdGUoJ2lmcmFtZScpO1xuICB2YXIgaSA9IF9lbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBfaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEUkMV1bX2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbnZhciBfb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRSQxXSA9IF9hbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEUkMV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE8kMV0gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogX29iamVjdERwcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxudmFyIF93a3MgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG52YXIgc3RvcmUgPSBfc2hhcmVkKCd3a3MnKTtcblxudmFyIFN5bWJvbCA9IF9nbG9iYWwuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiBfdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xufSk7XG5cbnZhciBkZWYgPSBfb2JqZWN0RHAuZjtcblxudmFyIFRBRyA9IF93a3MoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBfc2V0VG9TdHJpbmdUYWcgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIV9oYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxuX2hpZGUoSXRlcmF0b3JQcm90b3R5cGUsIF93a3MoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG52YXIgX2l0ZXJDcmVhdGUgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gX29iamVjdENyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBfcHJvcGVydHlEZXNjKDEsIG5leHQpIH0pO1xuICBfc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuXG4vLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxuXG5cbnZhciBJRV9QUk9UTyQyID0gX3NoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbnZhciBfb2JqZWN0R3BvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSBfdG9PYmplY3QoTyk7XG4gIGlmIChfaGFzKE8sIElFX1BST1RPJDIpKSByZXR1cm4gT1tJRV9QUk9UTyQyXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuXG52YXIgSVRFUkFUT1IgPSBfd2tzKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG52YXIgX2l0ZXJEZWZpbmUgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIF9pdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gX29iamVjdEdwbygkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBfc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghX2xpYnJhcnkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBfaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghX2xpYnJhcnkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIF9oaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgX2l0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBfaXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgX3JlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlIF9leHBvcnQoX2V4cG9ydC5QICsgX2V4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cbnZhciAkYXQgPSBfc3RyaW5nQXQodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbl9pdGVyRGVmaW5lKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGluZGV4ID0gdGhpcy5faTtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG5cbnZhciBfaXRlclN0ZXAgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnZhciBlczZfYXJyYXlfaXRlcmF0b3IgPSBfaXRlckRlZmluZShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSBfdG9Jb2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gX2l0ZXJTdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIF9pdGVyU3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gX2l0ZXJTdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIF9pdGVyU3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbl9pdGVyYXRvcnMuQXJndW1lbnRzID0gX2l0ZXJhdG9ycy5BcnJheTtcblxudmFyIFRPX1NUUklOR19UQUcgPSBfd2tzKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgRE9NSXRlcmFibGVzID0gKCdDU1NSdWxlTGlzdCxDU1NTdHlsZURlY2xhcmF0aW9uLENTU1ZhbHVlTGlzdCxDbGllbnRSZWN0TGlzdCxET01SZWN0TGlzdCxET01TdHJpbmdMaXN0LCcgK1xuICAnRE9NVG9rZW5MaXN0LERhdGFUcmFuc2Zlckl0ZW1MaXN0LEZpbGVMaXN0LEhUTUxBbGxDb2xsZWN0aW9uLEhUTUxDb2xsZWN0aW9uLEhUTUxGb3JtRWxlbWVudCxIVE1MU2VsZWN0RWxlbWVudCwnICtcbiAgJ01lZGlhTGlzdCxNaW1lVHlwZUFycmF5LE5hbWVkTm9kZU1hcCxOb2RlTGlzdCxQYWludFJlcXVlc3RMaXN0LFBsdWdpbixQbHVnaW5BcnJheSxTVkdMZW5ndGhMaXN0LFNWR051bWJlckxpc3QsJyArXG4gICdTVkdQYXRoU2VnTGlzdCxTVkdQb2ludExpc3QsU1ZHU3RyaW5nTGlzdCxTVkdUcmFuc2Zvcm1MaXN0LFNvdXJjZUJ1ZmZlckxpc3QsU3R5bGVTaGVldExpc3QsVGV4dFRyYWNrQ3VlTGlzdCwnICtcbiAgJ1RleHRUcmFja0xpc3QsVG91Y2hMaXN0Jykuc3BsaXQoJywnKTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBET01JdGVyYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBET01JdGVyYWJsZXNbaV07XG4gIHZhciBDb2xsZWN0aW9uID0gX2dsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSkgX2hpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBfaXRlcmF0b3JzW05BTUVdID0gX2l0ZXJhdG9ycy5BcnJheTtcbn1cblxuLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcblxudmFyIFRBRyQxID0gX3drcygndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gX2NvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG52YXIgX2NsYXNzb2YgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUQUckMSkpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gX2NvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gX2NvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG52YXIgX2FuSW5zdGFuY2UgPSBmdW5jdGlvbiAoaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCkge1xuICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07XG5cbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcblxudmFyIF9pdGVyQ2FsbCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihfYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgX2FuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcblxuLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxuXG52YXIgSVRFUkFUT1IkMSA9IF93a3MoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIF9pc0FycmF5SXRlciA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoX2l0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUiQxXSA9PT0gaXQpO1xufTtcblxudmFyIElURVJBVE9SJDIgPSBfd2tzKCdpdGVyYXRvcicpO1xuXG52YXIgY29yZV9nZXRJdGVyYXRvck1ldGhvZCA9IF9jb3JlLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUiQyXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBfaXRlcmF0b3JzW19jbGFzc29mKGl0KV07XG59O1xuXG52YXIgX2Zvck9mID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xudmFyIEJSRUFLID0ge307XG52YXIgUkVUVVJOID0ge307XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1IpIHtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcmFibGU7IH0gOiBjb3JlX2dldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcbiAgdmFyIGYgPSBfY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChfaXNBcnJheUl0ZXIoaXRlckZuKSkgZm9yIChsZW5ndGggPSBfdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihfYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IF9pdGVyQ2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcbn0pO1xuXG4vLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcblxuXG52YXIgU1BFQ0lFUyA9IF93a3MoJ3NwZWNpZXMnKTtcbnZhciBfc3BlY2llc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gKE8sIEQpIHtcbiAgdmFyIEMgPSBfYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gX2FuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogX2FGdW5jdGlvbihTKTtcbn07XG5cbi8vIGZhc3QgYXBwbHksIGh0dHA6Ly9qc3BlcmYubG5raXQuY29tL2Zhc3QtYXBwbHkvNVxudmFyIF9pbnZva2UgPSBmdW5jdGlvbiAoZm4sIGFyZ3MsIHRoYXQpIHtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xufTtcblxudmFyIHByb2Nlc3MkMSA9IF9nbG9iYWwucHJvY2VzcztcbnZhciBzZXRUYXNrID0gX2dsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXJUYXNrID0gX2dsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IF9nbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBfZ2xvYmFsLkRpc3BhdGNoO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQgPSArdGhpcztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICBpZiAocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldFRhc2sgfHwgIWNsZWFyVGFzaykge1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDE7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgIF9pbnZva2UodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXJUYXNrID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYgKF9jb2YocHJvY2VzcyQxKSA9PSAncHJvY2VzcycpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2VzcyQxLm5leHRUaWNrKF9jdHgocnVuLCBpZCwgMSkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3coX2N0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBfY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChfZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIHBvc3RNZXNzYWdlID09ICdmdW5jdGlvbicgJiYgIV9nbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBfZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsICcqJyk7XG4gICAgfTtcbiAgICBfZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAvLyBJRTgtXG4gIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIF9kb21DcmVhdGUoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIF9odG1sLmFwcGVuZENoaWxkKF9kb21DcmVhdGUoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KF9jdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbnZhciBfdGFzayA9IHtcbiAgc2V0OiBzZXRUYXNrLFxuICBjbGVhcjogY2xlYXJUYXNrXG59O1xuXG52YXIgbWFjcm90YXNrID0gX3Rhc2suc2V0O1xudmFyIE9ic2VydmVyID0gX2dsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IF9nbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBwcm9jZXNzJDIgPSBfZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSQxID0gX2dsb2JhbC5Qcm9taXNlO1xudmFyIGlzTm9kZSA9IF9jb2YocHJvY2VzcyQyKSA9PSAncHJvY2Vzcyc7XG5cbnZhciBfbWljcm90YXNrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCwgbGFzdCwgbm90aWZ5O1xuXG4gIHZhciBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoaXNOb2RlICYmIChwYXJlbnQgPSBwcm9jZXNzJDIuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmIChpc05vZGUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzJDIubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyBTYWZhcmkgLSBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzM5XG4gIH0gZWxzZSBpZiAoT2JzZXJ2ZXIgJiYgIShfZ2xvYmFsLm5hdmlnYXRvciAmJiBfZ2xvYmFsLm5hdmlnYXRvci5zdGFuZGFsb25lKSkge1xuICAgIHZhciB0b2dnbGUgPSB0cnVlO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBPYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UkMSAmJiBQcm9taXNlJDEucmVzb2x2ZSkge1xuICAgIC8vIFByb21pc2UucmVzb2x2ZSB3aXRob3V0IGFuIGFyZ3VtZW50IHRocm93cyBhbiBlcnJvciBpbiBMRyBXZWJPUyAyXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlJDEucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKF9nbG9iYWwsIGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIHZhciB0YXNrID0geyBmbjogZm4sIG5leHQ6IHVuZGVmaW5lZCB9O1xuICAgIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICAgIGlmICghaGVhZCkge1xuICAgICAgaGVhZCA9IHRhc2s7XG4gICAgICBub3RpZnkoKTtcbiAgICB9IGxhc3QgPSB0YXNrO1xuICB9O1xufTtcblxuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcblxuXG5mdW5jdGlvbiBQcm9taXNlQ2FwYWJpbGl0eShDKSB7XG4gIHZhciByZXNvbHZlLCByZWplY3Q7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gICAgaWYgKHJlc29sdmUgIT09IHVuZGVmaW5lZCB8fCByZWplY3QgIT09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCdCYWQgUHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gICAgcmVqZWN0ID0gJCRyZWplY3Q7XG4gIH0pO1xuICB0aGlzLnJlc29sdmUgPSBfYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IF9hRnVuY3Rpb24ocmVqZWN0KTtcbn1cblxudmFyIGYkMyA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuXG52YXIgX25ld1Byb21pc2VDYXBhYmlsaXR5ID0ge1xuXHRmOiBmJDNcbn07XG5cbnZhciBfcGVyZm9ybSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZTogZmFsc2UsIHY6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgZTogdHJ1ZSwgdjogZSB9O1xuICB9XG59O1xuXG52YXIgbmF2aWdhdG9yJDEgPSBfZ2xvYmFsLm5hdmlnYXRvcjtcblxudmFyIF91c2VyQWdlbnQgPSBuYXZpZ2F0b3IkMSAmJiBuYXZpZ2F0b3IkMS51c2VyQWdlbnQgfHwgJyc7XG5cbnZhciBfcHJvbWlzZVJlc29sdmUgPSBmdW5jdGlvbiAoQywgeCkge1xuICBfYW5PYmplY3QoQyk7XG4gIGlmIChfaXNPYmplY3QoeCkgJiYgeC5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIHg7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IF9uZXdQcm9taXNlQ2FwYWJpbGl0eS5mKEMpO1xuICB2YXIgcmVzb2x2ZSA9IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmU7XG4gIHJlc29sdmUoeCk7XG4gIHJldHVybiBwcm9taXNlQ2FwYWJpbGl0eS5wcm9taXNlO1xufTtcblxudmFyIF9yZWRlZmluZUFsbCA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgc2FmZSkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgaWYgKHNhZmUgJiYgdGFyZ2V0W2tleV0pIHRhcmdldFtrZXldID0gc3JjW2tleV07XG4gICAgZWxzZSBfaGlkZSh0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9IHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgU1BFQ0lFUyQxID0gX3drcygnc3BlY2llcycpO1xuXG52YXIgX3NldFNwZWNpZXMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gdHlwZW9mIF9jb3JlW0tFWV0gPT0gJ2Z1bmN0aW9uJyA/IF9jb3JlW0tFWV0gOiBfZ2xvYmFsW0tFWV07XG4gIGlmIChfZGVzY3JpcHRvcnMgJiYgQyAmJiAhQ1tTUEVDSUVTJDFdKSBfb2JqZWN0RHAuZihDLCBTUEVDSUVTJDEsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcblxudmFyIElURVJBVE9SJDMgPSBfd2tzKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1IkM10oKTtcbiAgcml0ZXJbJ3JldHVybiddID0gZnVuY3Rpb24gKCkgeyBTQUZFX0NMT1NJTkcgPSB0cnVlOyB9O1xufSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG5cbnZhciBfaXRlckRldGVjdCA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SJDNdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4geyBkb25lOiBzYWZlID0gdHJ1ZSB9OyB9O1xuICAgIGFycltJVEVSQVRPUiQzXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuXG52YXIgdGFzayA9IF90YXNrLnNldDtcbnZhciBtaWNyb3Rhc2sgPSBfbWljcm90YXNrKCk7XG5cblxuXG5cbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIFR5cGVFcnJvciQxID0gX2dsb2JhbC5UeXBlRXJyb3I7XG52YXIgcHJvY2VzcyQzID0gX2dsb2JhbC5wcm9jZXNzO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyQzICYmIHByb2Nlc3MkMy52ZXJzaW9ucztcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4IHx8ICcnO1xudmFyICRQcm9taXNlID0gX2dsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUkMSA9IF9jbGFzc29mKHByb2Nlc3MkMykgPT0gJ3Byb2Nlc3MnO1xudmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIEludGVybmFsLCBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHksIE93blByb21pc2VDYXBhYmlsaXR5LCBXcmFwcGVyO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5ID0gX25ld1Byb21pc2VDYXBhYmlsaXR5LmY7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgPSAkUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW193a3MoJ3NwZWNpZXMnKV0gPSBmdW5jdGlvbiAoZXhlYykge1xuICAgICAgZXhlYyhlbXB0eSwgZW1wdHkpO1xuICAgIH07XG4gICAgLy8gdW5oYW5kbGVkIHJlamVjdGlvbnMgdHJhY2tpbmcgc3VwcG9ydCwgTm9kZUpTIFByb21pc2Ugd2l0aG91dCBpdCBmYWlscyBAQHNwZWNpZXMgdGVzdFxuICAgIHJldHVybiAoaXNOb2RlJDEgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKVxuICAgICAgJiYgcHJvbWlzZS50aGVuKGVtcHR5KSBpbnN0YW5jZW9mIEZha2VQcm9taXNlXG4gICAgICAvLyB2OCA2LjYgKE5vZGUgMTAgYW5kIENocm9tZSA2NikgaGF2ZSBhIGJ1ZyB3aXRoIHJlc29sdmluZyBjdXN0b20gdGhlbmFibGVzXG4gICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcbiAgICAgIC8vIHdlIGNhbid0IGRldGVjdCBpdCBzeW5jaHJvbm91c2x5LCBzbyBqdXN0IGNoZWNrIHZlcnNpb25zXG4gICAgICAmJiB2OC5pbmRleE9mKCc2LjYnKSAhPT0gMFxuICAgICAgJiYgX3VzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUvNjYnKSA9PT0gLTE7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxufSgpO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIF9pc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24gKHByb21pc2UsIGlzUmVqZWN0KSB7XG4gIGlmIChwcm9taXNlLl9uKSByZXR1cm47XG4gIHByb21pc2UuX24gPSB0cnVlO1xuICB2YXIgY2hhaW4gPSBwcm9taXNlLl9jO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIG9rID0gcHJvbWlzZS5fcyA9PSAxO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHJlYWN0aW9uKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgICAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICAgICB2YXIgcmVzdWx0LCB0aGVuLCBleGl0ZWQ7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9oID09IDIpIG9uSGFuZGxlVW5oYW5kbGVkKHByb21pc2UpO1xuICAgICAgICAgICAgcHJvbWlzZS5faCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkb21haW4pIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7IC8vIG1heSB0aHJvd1xuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICBleGl0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yJDEoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwocmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSByZWplY3QodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpKSBydW4oY2hhaW5baSsrXSk7IC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgcHJvbWlzZS5fYyA9IFtdO1xuICAgIHByb21pc2UuX24gPSBmYWxzZTtcbiAgICBpZiAoaXNSZWplY3QgJiYgIXByb21pc2UuX2gpIG9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoX2dsb2JhbCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3Y7XG4gICAgdmFyIHVuaGFuZGxlZCA9IGlzVW5oYW5kbGVkKHByb21pc2UpO1xuICAgIHZhciByZXN1bHQsIGhhbmRsZXIsIGNvbnNvbGU7XG4gICAgaWYgKHVuaGFuZGxlZCkge1xuICAgICAgcmVzdWx0ID0gX3BlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNOb2RlJDEpIHtcbiAgICAgICAgICBwcm9jZXNzJDMuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPSBfZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKSB7XG4gICAgICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogdmFsdWUgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKGNvbnNvbGUgPSBfZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUkMSB8fCBpc1VuaGFuZGxlZChwcm9taXNlKSA/IDIgOiAxO1xuICAgIH0gcHJvbWlzZS5fYSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodW5oYW5kbGVkICYmIHJlc3VsdC5lKSB0aHJvdyByZXN1bHQudjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgcmV0dXJuIHByb21pc2UuX2ggIT09IDEgJiYgKHByb21pc2UuX2EgfHwgcHJvbWlzZS5fYykubGVuZ3RoID09PSAwO1xufTtcbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChfZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKGlzTm9kZSQxKSB7XG4gICAgICBwcm9jZXNzJDMuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IF9nbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKSB7XG4gICAgICBoYW5kbGVyKHsgcHJvbWlzZTogcHJvbWlzZSwgcmVhc29uOiBwcm9taXNlLl92IH0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fcyA9IDI7XG4gIGlmICghcHJvbWlzZS5fYSkgcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gIHZhciB0aGVuO1xuICBpZiAocHJvbWlzZS5fZCkgcmV0dXJuO1xuICBwcm9taXNlLl9kID0gdHJ1ZTtcbiAgcHJvbWlzZSA9IHByb21pc2UuX3cgfHwgcHJvbWlzZTsgLy8gdW53cmFwXG4gIHRyeSB7XG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB0aHJvdyBUeXBlRXJyb3IkMShcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmICh0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSkpIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0geyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIF9jdHgoJHJlc29sdmUsIHdyYXBwZXIsIDEpLCBfY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoeyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgX2FuSW5zdGFuY2UodGhpcywgJFByb21pc2UsIFBST01JU0UsICdfaCcpO1xuICAgIF9hRnVuY3Rpb24oZXhlY3V0b3IpO1xuICAgIEludGVybmFsLmNhbGwodGhpcyk7XG4gICAgdHJ5IHtcbiAgICAgIGV4ZWN1dG9yKF9jdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBfY3R4KCRyZWplY3QsIHRoaXMsIDEpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICRyZWplY3QuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH1cbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHRoaXMuX2MgPSBbXTsgICAgICAgICAgICAgLy8gPC0gYXdhaXRpbmcgcmVhY3Rpb25zXG4gICAgdGhpcy5fYSA9IHVuZGVmaW5lZDsgICAgICAvLyA8LSBjaGVja2VkIGluIGlzVW5oYW5kbGVkIHJlYWN0aW9uc1xuICAgIHRoaXMuX3MgPSAwOyAgICAgICAgICAgICAgLy8gPC0gc3RhdGVcbiAgICB0aGlzLl9kID0gZmFsc2U7ICAgICAgICAgIC8vIDwtIGRvbmVcbiAgICB0aGlzLl92ID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIHZhbHVlXG4gICAgdGhpcy5faCA9IDA7ICAgICAgICAgICAgICAvLyA8LSByZWplY3Rpb24gc3RhdGUsIDAgLSBkZWZhdWx0LCAxIC0gaGFuZGxlZCwgMiAtIHVuaGFuZGxlZFxuICAgIHRoaXMuX24gPSBmYWxzZTsgICAgICAgICAgLy8gPC0gbm90aWZ5XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IF9yZWRlZmluZUFsbCgkUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICAvLyAyNS40LjUuMyBQcm9taXNlLnByb3RvdHlwZS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKVxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KF9zcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlJDEgPyBwcm9jZXNzJDMuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fYy5wdXNoKHJlYWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLl9hKSB0aGlzLl9hLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX3MpIG5vdGlmeSh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gX2N0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgPSBfY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuICBfbmV3UHJvbWlzZUNhcGFiaWxpdHkuZiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiAgICByZXR1cm4gQyA9PT0gJFByb21pc2UgfHwgQyA9PT0gV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xufVxuXG5fZXhwb3J0KF9leHBvcnQuRyArIF9leHBvcnQuVyArIF9leHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFByb21pc2U6ICRQcm9taXNlIH0pO1xuX3NldFRvU3RyaW5nVGFnKCRQcm9taXNlLCBQUk9NSVNFKTtcbl9zZXRTcGVjaWVzKFBST01JU0UpO1xuV3JhcHBlciA9IF9jb3JlW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG5fZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuX2V4cG9ydChfZXhwb3J0LlMgKyBfZXhwb3J0LkYgKiAoX2xpYnJhcnkgfHwgIVVTRV9OQVRJVkUpLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC42IFByb21pc2UucmVzb2x2ZSh4KVxuICByZXNvbHZlOiBmdW5jdGlvbiByZXNvbHZlKHgpIHtcbiAgICByZXR1cm4gX3Byb21pc2VSZXNvbHZlKF9saWJyYXJ5ICYmIHRoaXMgPT09IFdyYXBwZXIgPyAkUHJvbWlzZSA6IHRoaXMsIHgpO1xuICB9XG59KTtcbl9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIF9pdGVyRGV0ZWN0KGZ1bmN0aW9uIChpdGVyKSB7XG4gICRQcm9taXNlLmFsbChpdGVyKVsnY2F0Y2gnXShlbXB0eSk7XG59KSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjEgUHJvbWlzZS5hbGwoaXRlcmFibGUpXG4gIGFsbDogZnVuY3Rpb24gYWxsKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBfcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IDE7XG4gICAgICBfZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgJGluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBfcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICBfZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbl9leHBvcnQoX2V4cG9ydC5QICsgX2V4cG9ydC5SLCAnUHJvbWlzZScsIHsgJ2ZpbmFsbHknOiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gIHZhciBDID0gX3NwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBfY29yZS5Qcm9taXNlIHx8IF9nbG9iYWwuUHJvbWlzZSk7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIF9wcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB4OyB9KTtcbiAgICB9IDogb25GaW5hbGx5LFxuICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIF9wcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHRocm93IGU7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHlcbiAgKTtcbn0gfSk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2UtdHJ5XG5cblxuXG5cbl9leHBvcnQoX2V4cG9ydC5TLCAnUHJvbWlzZScsIHsgJ3RyeSc6IGZ1bmN0aW9uIChjYWxsYmFja2ZuKSB7XG4gIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IF9uZXdQcm9taXNlQ2FwYWJpbGl0eS5mKHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gX3BlcmZvcm0oY2FsbGJhY2tmbik7XG4gIChyZXN1bHQuZSA/IHByb21pc2VDYXBhYmlsaXR5LnJlamVjdCA6IHByb21pc2VDYXBhYmlsaXR5LnJlc29sdmUpKHJlc3VsdC52KTtcbiAgcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59IH0pO1xuXG52YXIgcHJvbWlzZSA9IF9jb3JlLlByb21pc2U7XG5cbnZhciBwcm9taXNlJDEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHByb21pc2UsIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0pO1xuXG52YXIgX1Byb21pc2UgPSB1bndyYXBFeHBvcnRzKHByb21pc2UkMSk7XG5cbnZhciBsb25nXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4vKlxyXG4gQ29weXJpZ2h0IDIwMTMgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuIENvcHlyaWdodCAyMDA5IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuXHJcbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG4gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxyXG4gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG4vKipcclxuICogQGxpY2Vuc2UgbG9uZy5qcyAoYykgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vbG9uZy5qcyBmb3IgZGV0YWlsc1xyXG4gKi9cclxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xyXG5cclxuICAgIC8qIEFNRCAqLyBpZiAodHlwZW9mIHVuZGVmaW5lZCA9PT0gJ2Z1bmN0aW9uJyAmJiB1bmRlZmluZWRbXCJhbWRcIl0pXHJcbiAgICAgICAgdW5kZWZpbmVkKFtdLCBmYWN0b3J5KTtcclxuICAgIC8qIENvbW1vbkpTICovIGVsc2UgaWYgKHR5cGVvZiBjb21tb25qc1JlcXVpcmUgPT09ICdmdW5jdGlvbicgJiYgJ29iamVjdCcgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlICYmIG1vZHVsZVtcImV4cG9ydHNcIl0pXHJcbiAgICAgICAgbW9kdWxlW1wiZXhwb3J0c1wiXSA9IGZhY3RvcnkoKTtcclxuICAgIC8qIEdsb2JhbCAqLyBlbHNlXHJcbiAgICAgICAgKGdsb2JhbFtcImRjb2RlSU9cIl0gPSBnbG9iYWxbXCJkY29kZUlPXCJdIHx8IHt9KVtcIkxvbmdcIl0gPSBmYWN0b3J5KCk7XHJcblxyXG59KShjb21tb25qc0dsb2JhbCwgZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMiBiaXQgdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLlxyXG4gICAgICogIFNlZSB0aGUgZnJvbSogZnVuY3Rpb25zIGJlbG93IGZvciBtb3JlIGNvbnZlbmllbnQgd2F5cyBvZiBjb25zdHJ1Y3RpbmcgTG9uZ3MuXHJcbiAgICAgKiBAZXhwb3J0cyBMb25nXHJcbiAgICAgKiBAY2xhc3MgQSBMb25nIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHtcclxuICAgICAgICB2YWx1ZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0xvbmcob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIChvYmogJiYgb2JqW1wiX19pc0xvbmdfX1wiXSkgPT09IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIExvbmcuXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmcuaXNMb25nID0gaXNMb25nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgaW50ZWdlciB2YWx1ZXMuXHJcbiAgICAgKiBAdHlwZSB7IU9iamVjdH1cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgSU5UX0NBQ0hFID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy5cclxuICAgICAqIEB0eXBlIHshT2JqZWN0fVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBVSU5UX0NBQ0hFID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbUludCh2YWx1ZSwgdW5zaWduZWQpIHtcclxuICAgICAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xyXG4gICAgICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA+Pj49IDA7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZSA9ICgwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkT2JqKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsICh2YWx1ZSB8IDApIDwgMCA/IC0xIDogMCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZSlcclxuICAgICAgICAgICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlIHw9IDA7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZSA9ICgtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSkge1xyXG4gICAgICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChjYWNoZSlcclxuICAgICAgICAgICAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiAzMiBiaXQgaW50ZWdlciB2YWx1ZS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMiBiaXQgaW50ZWdlciBpbiBxdWVzdGlvblxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIHNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbUludCA9IGZyb21JbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQpIHtcclxuICAgICAgICBpZiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpXHJcbiAgICAgICAgICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgICAgICBpZiAodW5zaWduZWQpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBVWkVSTztcclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgICAgIHJldHVybiBNQVhfVkFMVUU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZSwgdW5zaWduZWQpLm5lZygpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cygodmFsdWUgJSBUV09fUFdSXzMyX0RCTCkgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLCB1bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZhbHVlLCBwcm92aWRlZCB0aGF0IGl0IGlzIGEgZmluaXRlIG51bWJlci4gT3RoZXJ3aXNlLCB6ZXJvIGlzIHJldHVybmVkLlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBpbiBxdWVzdGlvblxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIHNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93Qml0c1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSA2NCBiaXQgaW50ZWdlciB0aGF0IGNvbWVzIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxvdyBhbmQgaGlnaCBiaXRzLiBFYWNoIGlzXHJcbiAgICAgKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHMgVGhlIGxvdyAzMiBiaXRzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIGBmYWxzZWAgZm9yIHNpZ25lZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbUJpdHMgPSBmcm9tQml0cztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJhc2VcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgcG93X2RibCA9IE1hdGgucG93OyAvLyBVc2VkIDQgdGltZXMgKDQqOCB0byAxNSs0KVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gICAgICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXhcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7XHJcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdlbXB0eSBzdHJpbmcnKTtcclxuICAgICAgICBpZiAoc3RyID09PSBcIk5hTlwiIHx8IHN0ciA9PT0gXCJJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCIrSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiLUluZmluaXR5XCIpXHJcbiAgICAgICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBnb29nLm1hdGgubG9uZyBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgICAgIHJhZGl4ID0gdW5zaWduZWQsIHVuc2lnbmVkID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdW5zaWduZWQgPSAhISB1bnNpZ25lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XHJcblxyXG4gICAgICAgIHZhciBwO1xyXG4gICAgICAgIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMClcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2ludGVyaW9yIGh5cGhlbicpO1xyXG4gICAgICAgIGVsc2UgaWYgKHAgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERvIHNldmVyYWwgKDgpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgICAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA4KSk7XHJcblxyXG4gICAgICAgIHZhciByZXN1bHQgPSBaRVJPO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XHJcbiAgICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLFxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xyXG4gICAgICAgICAgICBpZiAoc2l6ZSA8IDgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgc2l6ZSkpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLCB3cml0dGVuIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIExvbmdcclxuICAgICAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBzaWduZWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggVGhlIHJhZGl4IGluIHdoaWNoIHRoZSB0ZXh0IGlzIHdyaXR0ZW4gKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIExvbmcuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCkge1xyXG4gICAgICAgIGlmICh2YWwgLyogaXMgY29tcGF0aWJsZSAqLyBpbnN0YW5jZW9mIExvbmcpXHJcbiAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcih2YWwpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsKTtcclxuICAgICAgICAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh2YWwubG93LCB2YWwuaGlnaCwgdmFsLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gYSBMb25nLlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbCBWYWx1ZVxyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLmZyb21WYWx1ZSA9IGZyb21WYWx1ZTtcclxuXHJcbiAgICAvLyBOT1RFOiB0aGUgY29tcGlsZXIgc2hvdWxkIGlubGluZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmVsb3cgYW5kIHRoZW4gcmVtb3ZlIHRoZXNlIHZhcmlhYmxlcywgc28gdGhlcmUgc2hvdWxkIGJlXHJcbiAgICAvLyBubyBydW50aW1lIHBlbmFsdHkgZm9yIHRoZXNlLlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgWkVSTyA9IGZyb21JbnQoMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaWduZWQgemVyby5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5aRVJPID0gWkVSTztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5zaWduZWQgemVyby5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5VWkVSTyA9IFVaRVJPO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBPTkUgPSBmcm9tSW50KDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2lnbmVkIG9uZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5PTkUgPSBPTkU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVW5zaWduZWQgb25lLlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLlVPTkUgPSBVT05FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBORUdfT05FID0gZnJvbUludCgtMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaWduZWQgbmVnYXRpdmUgb25lLlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLk5FR19PTkUgPSBORUdfT05FO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBNQVhfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGfDAsIDB4N0ZGRkZGRkZ8MCwgZmFsc2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF4aW11bSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIHZhciBNQVhfVU5TSUdORURfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGfDAsIDB4RkZGRkZGRkZ8MCwgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXhpbXVtIHVuc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQHR5cGUgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMHg4MDAwMDAwMHwwLCBmYWxzZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNaW5pbXVtIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZy5NSU5fVkFMVUUgPSBNSU5fVkFMVUU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAYWxpYXMgTG9uZy5wcm90b3R5cGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgTG9uZ1Byb3RvdHlwZSA9IExvbmcucHJvdG90eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSB0aGUgbmVhcmVzdCBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZhbHVlIChkb3VibGUsIDUzIGJpdCBtYW50aXNzYSkuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgICAgIHJldHVybiAoKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCkgKyAodGhpcy5sb3cgPj4+IDApO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSBzdHJpbmcgd3JpdHRlbiBpbiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBSYWRpeCAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgcmFkaXhgIGlzIG91dCBvZiByYW5nZVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcocmFkaXgpIHtcclxuICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xyXG4gICAgICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcclxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuICcwJztcclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgYm90dG9tLW1vc3QgZGlnaXQgaW4gdGhpcyBiYXNlIGFuZCB0aGVuIHJlY3Vyc2UgdG8gZG8gdGhlIHJlc3QuXHJcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksXHJcbiAgICAgICAgICAgICAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcclxuICAgICAgICAgICAgICAgICAgICByZW0xID0gZGl2Lm11bChyYWRpeExvbmcpLnN1Yih0aGlzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJy0nICsgdGhpcy5uZWcoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAgICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXHJcbiAgICAgICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLFxyXG4gICAgICAgICAgICByZW0gPSB0aGlzO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpLFxyXG4gICAgICAgICAgICAgICAgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDAsXHJcbiAgICAgICAgICAgICAgICBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgICAgICByZW0gPSByZW1EaXY7XHJcbiAgICAgICAgICAgIGlmIChyZW0uaXNaZXJvKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChkaWdpdHMubGVuZ3RoIDwgNilcclxuICAgICAgICAgICAgICAgICAgICBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBoaWdoIGJpdHNcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0cyA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2g7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBoaWdoIGJpdHNcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgbG93IGJpdHNcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzID0gZnVuY3Rpb24gZ2V0TG93Qml0cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb3c7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGxvdyBiaXRzXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0TG93Qml0c1Vuc2lnbmVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO1xyXG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xyXG4gICAgICAgIGZvciAodmFyIGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSlcclxuICAgICAgICAgICAgaWYgKCh2YWwgJiAoMSA8PCBiaXQpKSAhPSAwKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAhPSAwID8gYml0ICsgMzMgOiBiaXQgKyAxO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbmVnYXRpdmUuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBwb3NpdGl2ZS5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG9kZC5cclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGV2ZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgICAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgKHRoaXMuaGlnaCA+Pj4gMzEpID09PSAxICYmIChvdGhlci5oaWdoID4+PiAzMSkgPT09IDEpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNlcXVhbHN9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5lcSA9IExvbmdQcm90b3R5cGUuZXF1YWxzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFscyhvdGhlcikge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5lcSgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmx0ID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPD0gMDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPiAwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW59LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID49IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxyXG4gICAgICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICAgICAgaWYgKHRoaXMuZXEob3RoZXIpKVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB2YXIgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpLFxyXG4gICAgICAgICAgICBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcclxuICAgICAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpXHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHNpZ24gYml0cyBhcmUgdGhlIHNhbWVcclxuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xyXG4gICAgICAgIC8vIEJvdGggYXJlIHBvc2l0aXZlIGlmIGF0IGxlYXN0IG9uZSBpcyB1bnNpZ25lZFxyXG4gICAgICAgIHJldHVybiAob3RoZXIuaGlnaCA+Pj4gMCkgPiAodGhpcy5oaWdoID4+PiAwKSB8fCAob3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIChvdGhlci5sb3cgPj4+IDApID4gKHRoaXMubG93ID4+PiAwKSkgPyAtMSA6IDE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY29tcGFyZX0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICAgICAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5jb21wID0gTG9uZ1Byb3RvdHlwZS5jb21wYXJlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS5cclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKE9ORSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNuZWdhdGV9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm5lZyA9IExvbmdQcm90b3R5cGUubmVnYXRlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc3VtIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gYWRkZW5kIEFkZGVuZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTdW1cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcoYWRkZW5kKSlcclxuICAgICAgICAgICAgYWRkZW5kID0gZnJvbVZhbHVlKGFkZGVuZCk7XHJcblxyXG4gICAgICAgIC8vIERpdmlkZSBlYWNoIG51bWJlciBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIHN1bSB0aGUgY2h1bmtzLlxyXG5cclxuICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgICAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2O1xyXG4gICAgICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDB4RkZGRjtcclxuICAgICAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGIwMCA9IGFkZGVuZC5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgICAgIGMwMCArPSBhMDAgKyBiMDA7XHJcbiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7XHJcbiAgICAgICAgYzAwICY9IDB4RkZGRjtcclxuICAgICAgICBjMTYgKz0gYTE2ICsgYjE2O1xyXG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzMyICs9IGEzMiArIGIzMjtcclxuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgICAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgICAgIGM0OCArPSBhNDggKyBiNDg7XHJcbiAgICAgICAgYzQ4ICY9IDB4RkZGRjtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHN1YnRyYWhlbmQpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhzdWJ0cmFoZW5kKSlcclxuICAgICAgICAgICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc3VidHJhY3R9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikge1xyXG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgICAgICByZXR1cm4gWkVSTztcclxuICAgICAgICBpZiAoIWlzTG9uZyhtdWx0aXBsaWVyKSlcclxuICAgICAgICAgICAgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTtcclxuICAgICAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XHJcbiAgICAgICAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7XHJcblxyXG4gICAgICAgIC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cclxuICAgICAgICBpZiAodGhpcy5sdChUV09fUFdSXzI0KSAmJiBtdWx0aXBsaWVyLmx0KFRXT19QV1JfMjQpKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpO1xyXG5cclxuICAgICAgICAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cclxuICAgICAgICAvLyBXZSBjYW4gc2tpcCBwcm9kdWN0cyB0aGF0IHdvdWxkIG92ZXJmbG93LlxyXG5cclxuICAgICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgICAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcclxuICAgICAgICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgMHhGRkZGO1xyXG4gICAgICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XHJcbiAgICAgICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhGRkZGO1xyXG5cclxuICAgICAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgICAgICBjMDAgKz0gYTAwICogYjAwO1xyXG4gICAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICAgICAgYzE2ICs9IGExNiAqIGIwMDtcclxuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgICAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMxNiArPSBhMDAgKiBiMTY7XHJcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICAgICAgYzE2ICY9IDB4RkZGRjtcclxuICAgICAgICBjMzIgKz0gYTMyICogYjAwO1xyXG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICAgICAgYzMyICs9IGExNiAqIGIxNjtcclxuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgICAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgICAgIGMzMiArPSBhMDAgKiBiMzI7XHJcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICAgICAgYzMyICY9IDB4RkZGRjtcclxuICAgICAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4O1xyXG4gICAgICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbXVsdGlwbHl9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhlIHJlc3VsdCBpcyBzaWduZWQgaWYgdGhpcyBMb25nIGlzIHNpZ25lZCBvclxyXG4gICAgICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gZGl2aWRlKGRpdmlzb3IpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcclxuICAgICAgICBpZiAoZGl2aXNvci5pc1plcm8oKSlcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKTtcclxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICAgICAgdmFyIGFwcHJveCwgcmVtLCByZXM7XHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgc2VjdGlvbiBpcyBvbmx5IHJlbGV2YW50IGZvciBzaWduZWQgbG9uZ3MgYW5kIGlzIGRlcml2ZWQgZnJvbSB0aGVcclxuICAgICAgICAgICAgLy8gY2xvc3VyZSBsaWJyYXJ5IGFzIGEgd2hvbGUuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkaXZpc29yLmVxKE9ORSkgfHwgZGl2aXNvci5lcShORUdfT05FKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFOyAgLy8gcmVjYWxsIHRoYXQgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUVcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT05FO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hyKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGl2aXNvci5pc05lZ2F0aXZlKCkgPyBPTkUgOiBORUdfT05FO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBhcHByb3guYWRkKHJlbS5kaXYoZGl2aXNvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xyXG4gICAgICAgICAgICByZXMgPSBaRVJPO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBhbGdvcml0aG0gYmVsb3cgaGFzIG5vdCBiZWVuIG1hZGUgZm9yIHVuc2lnbmVkIGxvbmdzLiBJdCdzIHRoZXJlZm9yZVxyXG4gICAgICAgICAgICAvLyByZXF1aXJlZCB0byB0YWtlIHNwZWNpYWwgY2FyZSBvZiB0aGUgTVNCIHByaW9yIHRvIHJ1bm5pbmcgaXQuXHJcbiAgICAgICAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZClcclxuICAgICAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVVpFUk87XHJcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVU9ORTtcclxuICAgICAgICAgICAgcmVzID0gVVpFUk87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXBlYXQgdGhlIGZvbGxvd2luZyB1bnRpbCB0aGUgcmVtYWluZGVyIGlzIGxlc3MgdGhhbiBvdGhlcjogIGZpbmQgYVxyXG4gICAgICAgIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcclxuICAgICAgICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XHJcbiAgICAgICAgLy8gdGhlIGFwcHJveGltYXRlIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcmVhbCB2YWx1ZSBzbyB0aGF0IHRoZVxyXG4gICAgICAgIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxyXG4gICAgICAgIHJlbSA9IHRoaXM7XHJcbiAgICAgICAgd2hpbGUgKHJlbS5ndGUoZGl2aXNvcikpIHtcclxuICAgICAgICAgICAgLy8gQXBwcm94aW1hdGUgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbi4gVGhpcyBtYXkgYmUgYSBsaXR0bGUgZ3JlYXRlciBvclxyXG4gICAgICAgICAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cclxuICAgICAgICAgICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIGRpdmlzb3IudG9OdW1iZXIoKSkpO1xyXG5cclxuICAgICAgICAgICAgLy8gV2Ugd2lsbCB0d2VhayB0aGUgYXBwcm94aW1hdGUgcmVzdWx0IGJ5IGNoYW5naW5nIGl0IGluIHRoZSA0OC10aCBkaWdpdCBvclxyXG4gICAgICAgICAgICAvLyB0aGUgc21hbGxlc3Qgbm9uLWZyYWN0aW9uYWwgZGlnaXQsIHdoaWNoZXZlciBpcyBsYXJnZXIuXHJcbiAgICAgICAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksXHJcbiAgICAgICAgICAgICAgICBkZWx0YSA9IChsb2cyIDw9IDQ4KSA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksXHJcblxyXG4gICAgICAgICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcclxuICAgICAgICAgICAgLy8gdGhhdCBpZiBpdCBpcyB0b28gbGFyZ2UsIHRoZSBwcm9kdWN0IG92ZXJmbG93cyBhbmQgaXMgbmVnYXRpdmUuXHJcbiAgICAgICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksXHJcbiAgICAgICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgICAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3QocmVtKSkge1xyXG4gICAgICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhO1xyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXHJcbiAgICAgICAgICAgIC8vIGluZmluaXRlIHJlY3Vyc2lvbiBzaW5jZSB3ZSB3b3VsZCBtYWtlIG5vIHByb2dyZXNzLlxyXG4gICAgICAgICAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKVxyXG4gICAgICAgICAgICAgICAgYXBwcm94UmVzID0gT05FO1xyXG5cclxuICAgICAgICAgICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xyXG4gICAgICAgICAgICByZW0gPSByZW0uc3ViKGFwcHJveFJlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgZGl2aWRlZCBieSB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2RpdmlkZX0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIG1vZHVsbyhkaXZpc29yKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE5PVCBvZiB0aGlzIExvbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkge1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UgQU5EIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cclxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikge1xyXG4gICAgICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIFhPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXHJcbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3Iob3RoZXIpIHtcclxuICAgICAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgXiBvdGhlci5sb3csIHRoaXMuaGlnaCBeIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykge1xyXG4gICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cygwLCB0aGlzLmxvdyA8PCAobnVtQml0cyAtIDMyKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdExlZnR9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykge1xyXG4gICAgICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+IChudW1CaXRzIC0gMzIpLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKSB7XHJcbiAgICAgICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgICAgICBudW1CaXRzICY9IDYzO1xyXG4gICAgICAgIGlmIChudW1CaXRzID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLmhpZ2g7XHJcbiAgICAgICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsb3cgPSB0aGlzLmxvdztcclxuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tQml0cygobG93ID4+PiBudW1CaXRzKSB8IChoaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtQml0cyA9PT0gMzIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoID4+PiAobnVtQml0cyAtIDMyKSwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICAgICAqL1xyXG4gICAgTG9uZ1Byb3RvdHlwZS5zaHJ1ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gc2lnbmVkLlxyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaWduZWQgbG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvU2lnbmVkID0gZnVuY3Rpb24gdG9TaWduZWQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byB1bnNpZ25lZC5cclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVW5zaWduZWQgbG9uZ1xyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxyXG4gICAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQnl0ZSByZXByZXNlbnRhdGlvblxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbihsZSkge1xyXG4gICAgICAgIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gICAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgKi9cclxuICAgIExvbmdQcm90b3R5cGUudG9CeXRlc0xFID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGhpID0gdGhpcy5oaWdoLFxyXG4gICAgICAgICAgICBsbyA9IHRoaXMubG93O1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICBsbyAgICAgICAgICYgMHhmZixcclxuICAgICAgICAgICAgKGxvID4+PiAgOCkgJiAweGZmLFxyXG4gICAgICAgICAgICAobG8gPj4+IDE2KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChsbyA+Pj4gMjQpICYgMHhmZixcclxuICAgICAgICAgICAgIGhpICAgICAgICAgJiAweGZmLFxyXG4gICAgICAgICAgICAoaGkgPj4+ICA4KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChoaSA+Pj4gMTYpICYgMHhmZixcclxuICAgICAgICAgICAgKGhpID4+PiAyNCkgJiAweGZmXHJcbiAgICAgICAgXTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gICAgICovXHJcbiAgICBMb25nUHJvdG90eXBlLnRvQnl0ZXNCRSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAoaGkgPj4+IDI0KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChoaSA+Pj4gMTYpICYgMHhmZixcclxuICAgICAgICAgICAgKGhpID4+PiAgOCkgJiAweGZmLFxyXG4gICAgICAgICAgICAgaGkgICAgICAgICAmIDB4ZmYsXHJcbiAgICAgICAgICAgIChsbyA+Pj4gMjQpICYgMHhmZixcclxuICAgICAgICAgICAgKGxvID4+PiAxNikgJiAweGZmLFxyXG4gICAgICAgICAgICAobG8gPj4+ICA4KSAmIDB4ZmYsXHJcbiAgICAgICAgICAgICBsbyAgICAgICAgICYgMHhmZlxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBMb25nO1xyXG59KTtcbn0pO1xuXG52YXIgYnl0ZWJ1ZmZlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbi8qXHJcbiBDb3B5cmlnaHQgMjAxMy0yMDE0IERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcblxyXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBsaWNlbnNlIGJ5dGVidWZmZXIuanMgKGMpIDIwMTUgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuICogQmFja2luZyBidWZmZXI6IEFycmF5QnVmZmVyLCBBY2Nlc3NvcjogVWludDhBcnJheVxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vYnl0ZWJ1ZmZlci5qcyBmb3IgZGV0YWlsc1xyXG4gKi9cclxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xyXG5cclxuICAgIC8qIEFNRCAqLyBpZiAodHlwZW9mIHVuZGVmaW5lZCA9PT0gJ2Z1bmN0aW9uJyAmJiB1bmRlZmluZWRbXCJhbWRcIl0pXHJcbiAgICAgICAgdW5kZWZpbmVkKFtcImxvbmdcIl0sIGZhY3RvcnkpO1xyXG4gICAgLyogQ29tbW9uSlMgKi8gZWxzZSBpZiAodHlwZW9mIGNvbW1vbmpzUmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJyAmJiAnb2JqZWN0JyA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUgJiYgbW9kdWxlW1wiZXhwb3J0c1wiXSlcclxuICAgICAgICBtb2R1bGVbJ2V4cG9ydHMnXSA9IChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIExvbmc7IHRyeSB7IExvbmcgPSBsb25nXzE7IH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KExvbmcpO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICAvKiBHbG9iYWwgKi8gZWxzZVxyXG4gICAgICAgIChnbG9iYWxbXCJkY29kZUlPXCJdID0gZ2xvYmFsW1wiZGNvZGVJT1wiXSB8fCB7fSlbXCJCeXRlQnVmZmVyXCJdID0gZmFjdG9yeShnbG9iYWxbXCJkY29kZUlPXCJdW1wiTG9uZ1wiXSk7XHJcblxyXG59KShjb21tb25qc0dsb2JhbCwgZnVuY3Rpb24oTG9uZykge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBCeXRlQnVmZmVyLlxyXG4gICAgICogQGNsYXNzIFRoZSBzd2lzcyBhcm15IGtuaWZlIGZvciBiaW5hcnkgZGF0YSBpbiBKYXZhU2NyaXB0LlxyXG4gICAgICogQGV4cG9ydHMgQnl0ZUJ1ZmZlclxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGNhcGFjaXR5IEluaXRpYWwgY2FwYWNpdHkuIERlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfQ0FQQUNJVFl9LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICB2YXIgQnl0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGNhcGFjaXR5LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjYXBhY2l0eSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIGNhcGFjaXR5ID0gQnl0ZUJ1ZmZlci5ERUZBVUxUX0NBUEFDSVRZO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgbGl0dGxlRW5kaWFuID0gQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTjtcclxuICAgICAgICBpZiAodHlwZW9mIG5vQXNzZXJ0ID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgbm9Bc3NlcnQgPSBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlQ7XHJcbiAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBjYXBhY2l0eSA9IGNhcGFjaXR5IHwgMDtcclxuICAgICAgICAgICAgaWYgKGNhcGFjaXR5IDwgMClcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIGNhcGFjaXR5XCIpO1xyXG4gICAgICAgICAgICBsaXR0bGVFbmRpYW4gPSAhIWxpdHRsZUVuZGlhbjtcclxuICAgICAgICAgICAgbm9Bc3NlcnQgPSAhIW5vQXNzZXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmFja2luZyBBcnJheUJ1ZmZlci5cclxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5QnVmZmVyfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IGNhcGFjaXR5ID09PSAwID8gRU1QVFlfQlVGRkVSIDogbmV3IEFycmF5QnVmZmVyKGNhcGFjaXR5KTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVWludDhBcnJheSB1dGlsaXplZCB0byBtYW5pcHVsYXRlIHRoZSBiYWNraW5nIGJ1ZmZlci4gQmVjb21lcyBgbnVsbGAgaWYgdGhlIGJhY2tpbmcgYnVmZmVyIGhhcyBhIGNhcGFjaXR5IG9mIGAwYC5cclxuICAgICAgICAgKiBAdHlwZSB7P1VpbnQ4QXJyYXl9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmlldyA9IGNhcGFjaXR5ID09PSAwID8gbnVsbCA6IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWJzb2x1dGUgcmVhZC93cml0ZSBvZmZzZXQuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICogQHNlZSBCeXRlQnVmZmVyI2ZsaXBcclxuICAgICAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjY2xlYXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1hcmtlZCBvZmZzZXQuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICogQHNlZSBCeXRlQnVmZmVyI21hcmtcclxuICAgICAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjcmVzZXRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1hcmtlZE9mZnNldCA9IC0xO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBYnNvbHV0ZSBsaW1pdCBvZiB0aGUgY29udGFpbmVkIGRhdGEuIFNldCB0byB0aGUgYmFja2luZyBidWZmZXIncyBjYXBhY2l0eSB1cG9uIGFsbG9jYXRpb24uXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICogQHNlZSBCeXRlQnVmZmVyI2ZsaXBcclxuICAgICAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjY2xlYXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxpbWl0ID0gY2FwYWNpdHk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlciwgZGVmYXVsdHMgdG8gYGZhbHNlYCBmb3IgYmlnIGVuZGlhbi5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5saXR0bGVFbmRpYW4gPSBsaXR0bGVFbmRpYW47XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdG8gc2tpcCBhc3NlcnRpb25zIG9mIG9mZnNldHMgYW5kIHZhbHVlcywgZGVmYXVsdHMgdG8gYGZhbHNlYC5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ub0Fzc2VydCA9IG5vQXNzZXJ0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ5dGVCdWZmZXIgdmVyc2lvbi5cclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5WRVJTSU9OID0gXCI1LjAuMVwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGl0dGxlIGVuZGlhbiBjb25zdGFudCB0aGF0IGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgaXRzIGJvb2xlYW4gdmFsdWUuIEV2YWx1YXRlcyB0byBgdHJ1ZWAuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLkxJVFRMRV9FTkRJQU4gPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQmlnIGVuZGlhbiBjb25zdGFudCB0aGF0IGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgaXRzIGJvb2xlYW4gdmFsdWUuIEV2YWx1YXRlcyB0byBgZmFsc2VgLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5CSUdfRU5ESUFOID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWZhdWx0IGluaXRpYWwgY2FwYWNpdHkgb2YgYDE2YC5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWSA9IDE2O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCBlbmRpYW5lc3Mgb2YgYGZhbHNlYCBmb3IgYmlnIGVuZGlhbi5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOID0gQnl0ZUJ1ZmZlci5CSUdfRU5ESUFOO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCBubyBhc3NlcnRpb25zIGZsYWcgb2YgYGZhbHNlYC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlQgPSBmYWxzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgYExvbmdgIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NC1iaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLiBNYXkgYmUgYG51bGxgIGlmIExvbmcuanMgaGFzIG5vdCBiZWVuIGxvYWRlZFxyXG4gICAgICogIGFuZCBpbnQ2NCBzdXBwb3J0IGlzIG5vdCBhdmFpbGFibGUuXHJcbiAgICAgKiBAdHlwZSB7P0xvbmd9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vbG9uZy5qc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLkxvbmcgPSBMb25nIHx8IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAYWxpYXMgQnl0ZUJ1ZmZlci5wcm90b3R5cGVcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICB2YXIgQnl0ZUJ1ZmZlclByb3RvdHlwZSA9IEJ5dGVCdWZmZXIucHJvdG90eXBlO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCeXRlQnVmZmVyUHJvdG90eXBlLCBcIl9faXNCeXRlQnVmZmVyX19cIiwge1xyXG4gICAgICAgIHZhbHVlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGhlbHBlcnNcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHshQXJyYXlCdWZmZXJ9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIEVNUFRZX0JVRkZFUiA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN0cmluZy5mcm9tQ2hhckNvZGUgcmVmZXJlbmNlIGZvciBjb21waWxlLXRpbWUgcmVuYW1pbmcuXHJcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oLi4ubnVtYmVyKTpzdHJpbmd9XHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgdmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgc291cmNlIGZ1bmN0aW9uIGZvciBhIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzIFN0cmluZyB0byByZWFkIGZyb21cclxuICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbigpOm51bWJlcnxudWxsfSBTb3VyY2UgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNoYXIgY29kZSByZXNwZWN0aXZlbHkgYG51bGxgIGlmIHRoZXJlIGFyZVxyXG4gICAgICogIG5vIG1vcmUgY2hhcmFjdGVycyBsZWZ0LlxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgYXJndW1lbnQgaXMgaW52YWxpZFxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHN0cmluZ1NvdXJjZShzKSB7XHJcbiAgICAgICAgdmFyIGk9MDsgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaSA8IHMubGVuZ3RoID8gcy5jaGFyQ29kZUF0KGkrKykgOiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZGVzdGluYXRpb24gZnVuY3Rpb24gZm9yIGEgc3RyaW5nLlxyXG4gICAgICogQHJldHVybnMge2Z1bmN0aW9uKG51bWJlcj0pOnVuZGVmaW5lZHxzdHJpbmd9IERlc3RpbmF0aW9uIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCB0aGUgbmV4dCBjaGFyIGNvZGUuXHJcbiAgICAgKiAgUmV0dXJucyB0aGUgZmluYWwgc3RyaW5nIHdoZW4gY2FsbGVkIHdpdGhvdXQgYXJndW1lbnRzLlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHN0cmluZ0Rlc3RpbmF0aW9uKCkge1xyXG4gICAgICAgIHZhciBjcyA9IFtdLCBwcyA9IFtdOyByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBzLmpvaW4oJycpK3N0cmluZ0Zyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNzKTtcclxuICAgICAgICAgICAgaWYgKGNzLmxlbmd0aCArIGFyZ3VtZW50cy5sZW5ndGggPiAxMDI0KVxyXG4gICAgICAgICAgICAgICAgcHMucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjcykpLCBjcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShjcywgYXJndW1lbnRzKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgYWNjZXNzb3IgdHlwZS5cclxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYEJ1ZmZlcmAgdW5kZXIgbm9kZS5qcywgYFVpbnQ4QXJyYXlgIHJlc3BlY3RpdmVseSBgRGF0YVZpZXdgIGluIHRoZSBicm93c2VyIChjbGFzc2VzKVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmFjY2Vzc29yID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvY2F0ZXMgYSBuZXcgQnl0ZUJ1ZmZlciBiYWNrZWQgYnkgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBjYXBhY2l0eS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gY2FwYWNpdHkgSW5pdGlhbCBjYXBhY2l0eS4gRGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9DQVBBQ0lUWX0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuYWxsb2NhdGUgPSBmdW5jdGlvbihjYXBhY2l0eSwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQnl0ZUJ1ZmZlcihjYXBhY2l0eSwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29uY2F0ZW5hdGVzIG11bHRpcGxlIEJ5dGVCdWZmZXJzIGludG8gb25lLlxyXG4gICAgICogQHBhcmFtIHshQXJyYXkuPCFCeXRlQnVmZmVyfCFBcnJheUJ1ZmZlcnwhVWludDhBcnJheXxzdHJpbmc+fSBidWZmZXJzIEJ1ZmZlcnMgdG8gY29uY2F0ZW5hdGVcclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xib29sZWFuKT19IGVuY29kaW5nIFN0cmluZyBlbmNvZGluZyBpZiBgYnVmZmVyc2AgY29udGFpbnMgYSBzdHJpbmcgKFwiYmFzZTY0XCIsIFwiaGV4XCIsIFwiYmluYXJ5XCIsXHJcbiAgICAgKiAgZGVmYXVsdHMgdG8gXCJ1dGY4XCIpXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlciBmb3IgdGhlIHJlc3VsdGluZyBCeXRlQnVmZmVyLiBEZWZhdWx0c1xyXG4gICAgICogIHRvIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gc2tpcCBhc3NlcnRpb25zIG9mIG9mZnNldHMgYW5kIHZhbHVlcyBmb3IgdGhlIHJlc3VsdGluZyBCeXRlQnVmZmVyLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBDb25jYXRlbmF0ZWQgQnl0ZUJ1ZmZlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uKGJ1ZmZlcnMsIGVuY29kaW5nLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgbm9Bc3NlcnQgPSBsaXR0bGVFbmRpYW47XHJcbiAgICAgICAgICAgIGxpdHRsZUVuZGlhbiA9IGVuY29kaW5nO1xyXG4gICAgICAgICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNhcGFjaXR5ID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpPTAsIGs9YnVmZmVycy5sZW5ndGgsIGxlbmd0aDsgaTxrOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKCFCeXRlQnVmZmVyLmlzQnl0ZUJ1ZmZlcihidWZmZXJzW2ldKSlcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcnNbaV0gPSBCeXRlQnVmZmVyLndyYXAoYnVmZmVyc1tpXSwgZW5jb2RpbmcpO1xyXG4gICAgICAgICAgICBsZW5ndGggPSBidWZmZXJzW2ldLmxpbWl0IC0gYnVmZmVyc1tpXS5vZmZzZXQ7XHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPiAwKSBjYXBhY2l0eSArPSBsZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYXBhY2l0eSA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCeXRlQnVmZmVyKDAsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpO1xyXG4gICAgICAgIHZhciBiYiA9IG5ldyBCeXRlQnVmZmVyKGNhcGFjaXR5LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSxcclxuICAgICAgICAgICAgYmk7XHJcbiAgICAgICAgaT0wOyB3aGlsZSAoaTxrKSB7XHJcbiAgICAgICAgICAgIGJpID0gYnVmZmVyc1tpKytdO1xyXG4gICAgICAgICAgICBsZW5ndGggPSBiaS5saW1pdCAtIGJpLm9mZnNldDtcclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA8PSAwKSBjb250aW51ZTtcclxuICAgICAgICAgICAgYmIudmlldy5zZXQoYmkudmlldy5zdWJhcnJheShiaS5vZmZzZXQsIGJpLmxpbWl0KSwgYmIub2Zmc2V0KTtcclxuICAgICAgICAgICAgYmIub2Zmc2V0ICs9IGxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmIubGltaXQgPSBiYi5vZmZzZXQ7XHJcbiAgICAgICAgYmIub2Zmc2V0ID0gMDtcclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB0eXBlIGlzIGEgQnl0ZUJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSB7Kn0gYmIgQnl0ZUJ1ZmZlciB0byB0ZXN0XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGl0IGlzIGEgQnl0ZUJ1ZmZlciwgb3RoZXJ3aXNlIGBmYWxzZWBcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIgPSBmdW5jdGlvbihiYikge1xyXG4gICAgICAgIHJldHVybiAoYmIgJiYgYmJbXCJfX2lzQnl0ZUJ1ZmZlcl9fXCJdKSA9PT0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGJhY2tpbmcgYnVmZmVyIHR5cGUuXHJcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IGBCdWZmZXJgIHVuZGVyIG5vZGUuanMsIGBBcnJheUJ1ZmZlcmAgaW4gdGhlIGJyb3dzZXIgKGNsYXNzZXMpXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIudHlwZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheUJ1ZmZlcjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFdyYXBzIGEgYnVmZmVyIG9yIGEgc3RyaW5nLiBTZXRzIHRoZSBhbGxvY2F0ZWQgQnl0ZUJ1ZmZlcidzIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gdG8gYDBgIGFuZCBpdHNcclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0gdG8gdGhlIGxlbmd0aCBvZiB0aGUgd3JhcHBlZCBkYXRhLlxyXG4gICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcnwhQXJyYXlCdWZmZXJ8IVVpbnQ4QXJyYXl8c3RyaW5nfCFBcnJheS48bnVtYmVyPn0gYnVmZmVyIEFueXRoaW5nIHRoYXQgY2FuIGJlIHdyYXBwZWRcclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xib29sZWFuKT19IGVuY29kaW5nIFN0cmluZyBlbmNvZGluZyBpZiBgYnVmZmVyYCBpcyBhIHN0cmluZyAoXCJiYXNlNjRcIiwgXCJoZXhcIiwgXCJiaW5hcnlcIiwgZGVmYXVsdHMgdG9cclxuICAgICAqICBcInV0ZjhcIilcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gc2tpcCBhc3NlcnRpb25zIG9mIG9mZnNldHMgYW5kIHZhbHVlcy4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX05PQVNTRVJUfS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQSBCeXRlQnVmZmVyIHdyYXBwaW5nIGBidWZmZXJgXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIud3JhcCA9IGZ1bmN0aW9uKGJ1ZmZlciwgZW5jb2RpbmcsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBub0Fzc2VydCA9IGxpdHRsZUVuZGlhbjtcclxuICAgICAgICAgICAgbGl0dGxlRW5kaWFuID0gZW5jb2Rpbmc7XHJcbiAgICAgICAgICAgIGVuY29kaW5nID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICBlbmNvZGluZyA9IFwidXRmOFwiO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmFzZTY0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbUJhc2U2NChidWZmZXIsIGxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiaGV4XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbUhleChidWZmZXIsIGxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbUJpbmFyeShidWZmZXIsIGxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidXRmOFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21VVEY4KGJ1ZmZlciwgbGl0dGxlRW5kaWFuKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21EZWJ1ZyhidWZmZXIsIGxpdHRsZUVuZGlhbik7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5zdXBwb3J0ZWQgZW5jb2Rpbmc6IFwiK2VuY29kaW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYnVmZmVyID09PSBudWxsIHx8IHR5cGVvZiBidWZmZXIgIT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJ1ZmZlclwiKTtcclxuICAgICAgICB2YXIgYmI7XHJcbiAgICAgICAgaWYgKEJ5dGVCdWZmZXIuaXNCeXRlQnVmZmVyKGJ1ZmZlcikpIHtcclxuICAgICAgICAgICAgYmIgPSBCeXRlQnVmZmVyUHJvdG90eXBlLmNsb25lLmNhbGwoYnVmZmVyKTtcclxuICAgICAgICAgICAgYmIubWFya2VkT2Zmc2V0ID0gLTE7XHJcbiAgICAgICAgICAgIHJldHVybiBiYjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHsgLy8gRXh0cmFjdCBBcnJheUJ1ZmZlciBmcm9tIFVpbnQ4QXJyYXlcclxuICAgICAgICAgICAgYmIgPSBuZXcgQnl0ZUJ1ZmZlcigwLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KTtcclxuICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7IC8vIEF2b2lkIHJlZmVyZW5jZXMgdG8gbW9yZSB0aGFuIG9uZSBFTVBUWV9CVUZGRVJcclxuICAgICAgICAgICAgICAgIGJiLmJ1ZmZlciA9IGJ1ZmZlci5idWZmZXI7XHJcbiAgICAgICAgICAgICAgICBiYi5vZmZzZXQgPSBidWZmZXIuYnl0ZU9mZnNldDtcclxuICAgICAgICAgICAgICAgIGJiLmxpbWl0ID0gYnVmZmVyLmJ5dGVPZmZzZXQgKyBidWZmZXIuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGJiLnZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIuYnVmZmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHsgLy8gUmV1c2UgQXJyYXlCdWZmZXJcclxuICAgICAgICAgICAgYmIgPSBuZXcgQnl0ZUJ1ZmZlcigwLCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KTtcclxuICAgICAgICAgICAgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgYmIuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgYmIub2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgIGJiLmxpbWl0ID0gYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBiYi52aWV3ID0gYnVmZmVyLmJ5dGVMZW5ndGggPiAwID8gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChidWZmZXIpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHsgLy8gQ3JlYXRlIGZyb20gb2N0ZXRzXHJcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoYnVmZmVyLmxlbmd0aCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCk7XHJcbiAgICAgICAgICAgIGJiLmxpbWl0ID0gYnVmZmVyLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGJ1ZmZlci5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgIGJiLnZpZXdbaV0gPSBidWZmZXJbaV07XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYnVmZmVyXCIpOyAvLyBPdGhlcndpc2UgZmFpbFxyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgdGhlIGFycmF5IGFzIGEgYml0c2V0LlxyXG4gICAgICogQHBhcmFtIHtBcnJheTxib29sZWFuPn0gdmFsdWUgQXJyYXkgb2YgYm9vbGVhbnMgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGBsZW5ndGhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVCaXRTZXQgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpKVxyXG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBCaXRTZXQ6IE5vdCBhbiBhcnJheVwiKTtcclxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgICBiaXRzID0gdmFsdWUubGVuZ3RoLFxyXG4gICAgICAgICAgYnl0ZXMgPSAoYml0cyA+PiAzKSxcclxuICAgICAgICAgIGJpdCA9IDAsXHJcbiAgICAgICAgICBrO1xyXG5cclxuICAgICAgb2Zmc2V0ICs9IHRoaXMud3JpdGVWYXJpbnQzMihiaXRzLG9mZnNldCk7XHJcblxyXG4gICAgICB3aGlsZShieXRlcy0tKSB7XHJcbiAgICAgICAgayA9ICghIXZhbHVlW2JpdCsrXSAmIDEpIHxcclxuICAgICAgICAgICAgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IDEpIHxcclxuICAgICAgICAgICAgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IDIpIHxcclxuICAgICAgICAgICAgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IDMpIHxcclxuICAgICAgICAgICAgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IDQpIHxcclxuICAgICAgICAgICAgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IDUpIHxcclxuICAgICAgICAgICAgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IDYpIHxcclxuICAgICAgICAgICAgKCghIXZhbHVlW2JpdCsrXSAmIDEpIDw8IDcpO1xyXG4gICAgICAgIHRoaXMud3JpdGVCeXRlKGssb2Zmc2V0KyspO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZihiaXQgPCBiaXRzKSB7XHJcbiAgICAgICAgdmFyIG0gPSAwOyBrID0gMDtcclxuICAgICAgICB3aGlsZShiaXQgPCBiaXRzKSBrID0gayB8ICgoISF2YWx1ZVtiaXQrK10gJiAxKSA8PCAobSsrKSk7XHJcbiAgICAgICAgdGhpcy53cml0ZUJ5dGUoayxvZmZzZXQrKyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIEJpdFNldCBhcyBhbiBhcnJheSBvZiBib29sZWFucy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGBsZW5ndGhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8Ym9vbGVhbj5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkQml0U2V0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcblxyXG4gICAgICB2YXIgcmV0ID0gdGhpcy5yZWFkVmFyaW50MzIob2Zmc2V0KSxcclxuICAgICAgICAgIGJpdHMgPSByZXQudmFsdWUsXHJcbiAgICAgICAgICBieXRlcyA9IChiaXRzID4+IDMpLFxyXG4gICAgICAgICAgYml0ID0gMCxcclxuICAgICAgICAgIHZhbHVlID0gW10sXHJcbiAgICAgICAgICBrO1xyXG5cclxuICAgICAgb2Zmc2V0ICs9IHJldC5sZW5ndGg7XHJcblxyXG4gICAgICB3aGlsZShieXRlcy0tKSB7XHJcbiAgICAgICAgayA9IHRoaXMucmVhZEJ5dGUob2Zmc2V0KyspO1xyXG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDAxKTtcclxuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHgwMik7XHJcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4MDQpO1xyXG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDA4KTtcclxuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHgxMCk7XHJcbiAgICAgICAgdmFsdWVbYml0KytdID0gISEoayAmIDB4MjApO1xyXG4gICAgICAgIHZhbHVlW2JpdCsrXSA9ICEhKGsgJiAweDQwKTtcclxuICAgICAgICB2YWx1ZVtiaXQrK10gPSAhIShrICYgMHg4MCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKGJpdCA8IGJpdHMpIHtcclxuICAgICAgICB2YXIgbSA9IDA7XHJcbiAgICAgICAgayA9IHRoaXMucmVhZEJ5dGUob2Zmc2V0KyspO1xyXG4gICAgICAgIHdoaWxlKGJpdCA8IGJpdHMpIHZhbHVlW2JpdCsrXSA9ICEhKChrID4+IChtKyspKSAmIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBieXRlcy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGBsZW5ndGhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEJ5dGVzID0gZnVuY3Rpb24obGVuZ3RoLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyBsZW5ndGggPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIitsZW5ndGgrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNsaWNlID0gdGhpcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gICAgICAgIHJldHVybiBzbGljZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSBwYXlsb2FkIG9mIGJ5dGVzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI2FwcGVuZH0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ8IUFycmF5QnVmZmVyfCFVaW50OEFycmF5fHN0cmluZ30gc291cmNlIERhdGEgdG8gd3JpdGUuIElmIGBzb3VyY2VgIGlzIGEgQnl0ZUJ1ZmZlciwgaXRzIG9mZnNldHNcclxuICAgICAqICB3aWxsIGJlIG1vZGlmaWVkIGFjY29yZGluZyB0byB0aGUgcGVyZm9ybWVkIHJlYWQgb3BlcmF0aW9uLlxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcik9fSBlbmNvZGluZyBFbmNvZGluZyBpZiBgZGF0YWAgaXMgYSBzdHJpbmcgKFwiYmFzZTY0XCIsIFwiaGV4XCIsIFwiYmluYXJ5XCIsIGRlZmF1bHRzIHRvIFwidXRmOFwiKVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVCeXRlcyA9IEJ5dGVCdWZmZXJQcm90b3R5cGUuYXBwZW5kO1xyXG5cclxuICAgIC8vIHR5cGVzL2ludHMvaW50OFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIDhiaXQgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgdmFyIGNhcGFjaXR5MCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTApXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkwICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkwIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDE7XG4gICAgICAgIHRoaXMudmlld1tvZmZzZXRdID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gOGJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZUludDh9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlQnl0ZSA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQ4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYW4gOGJpdCBzaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDFgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZpZXdbb2Zmc2V0XTtcclxuICAgICAgICBpZiAoKHZhbHVlICYgMHg4MCkgPT09IDB4ODApIHZhbHVlID0gLSgweEZGIC0gdmFsdWUgKyAxKTsgLy8gQ2FzdCB0byBzaWduZWRcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhbiA4Yml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRJbnQ4fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkQnl0ZSA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDg7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gOGJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDFgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICB2YWx1ZSA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgIHZhciBjYXBhY2l0eTEgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MSAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MSA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSAxO1xuICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0XSA9IHZhbHVlO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIDhiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZVVpbnQ4fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBhZHZhbmNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDFgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVJbnQ4ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQ4O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYW4gOGJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDggPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZpZXdbb2Zmc2V0XTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhbiA4Yml0IHVuc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZFVpbnQ4fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMWAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVUludDggPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50ODtcclxuXHJcbiAgICAvLyB0eXBlcy9pbnRzL2ludDE2XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAxNmJpdCBzaWduZWQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBvciBgdmFsdWVgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50MTYgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlIHw9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIHZhciBjYXBhY2l0eTIgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkyKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MiAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MiA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSAyO1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSAmIDB4RkYwMCkgPj4+IDg7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgdmFsdWUgJiAweDAwRkY7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldF0gICA9ICh2YWx1ZSAmIDB4RkYwMCkgPj4+IDg7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAgdmFsdWUgJiAweDAwRkY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMTZiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVJbnQxNn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBvciBgdmFsdWVgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlU2hvcnQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50MTY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDE2Yml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMmAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgaXMgbm90IGEgdmFsaWQgbnVtYmVyXHJcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBvdXQgb2YgYm91bmRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDE2ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMiA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzIrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gMDtcclxuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCAgXTtcclxuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCA4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgODtcclxuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh2YWx1ZSAmIDB4ODAwMCkgPT09IDB4ODAwMCkgdmFsdWUgPSAtKDB4RkZGRiAtIHZhbHVlICsgMSk7IC8vIENhc3QgdG8gc2lnbmVkXHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAxNmJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkSW50MTZ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkU2hvcnQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRJbnQxNjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDE2Yml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMmAgaWYgb21pdHRlZC5cclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgb3IgYHZhbHVlYCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQxNiA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICB2YXIgY2FwYWNpdHkzID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MylcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTMgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTMgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gMjtcbiAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAodmFsdWUgJiAweEZGMDApID4+PiA4O1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIHZhbHVlICYgMHgwMEZGO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXRdICAgPSAodmFsdWUgJiAweEZGMDApID4+PiA4O1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gIHZhbHVlICYgMHgwMEZGO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDE2Yml0IHVuc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVVaW50MTZ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgMmAgaWYgb21pdHRlZC5cclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYG9mZnNldGAgb3IgYHZhbHVlYCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVJbnQxNiA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVaW50MTY7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDE2Yml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDE2ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMiA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzIrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gMDtcclxuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgdmFsdWUgID0gdGhpcy52aWV3W29mZnNldCAgXTtcclxuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCA4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgODtcclxuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAxNmJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRVaW50MTZ9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgYWR2YW5jZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGAyYCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgb2Zmc2V0YCBpcyBub3QgYSB2YWxpZCBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG91dCBvZiBib3VuZHNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVUludDE2ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDE2O1xyXG5cclxuICAgIC8vIHR5cGVzL2ludHMvaW50MzJcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDMyYml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50MzIgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIHZhbHVlIHw9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIHZhciBjYXBhY2l0eTQgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk0KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5NCAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5NCA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSA0O1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAodmFsdWUgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKHZhbHVlID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgdmFsdWUgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKHZhbHVlID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAodmFsdWUgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIHZhbHVlICAgICAgICAgJiAweEZGO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMzJiaXQgc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVJbnQzMn0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJbnQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlSW50MzI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDMyYml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEludDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgNCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzQrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gMDtcclxuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgMTY7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8ICA4O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgIHZhbHVlICs9IHRoaXMudmlld1tvZmZzZXQrM10gPDwgMjQgPj4+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDE2O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAgODtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICB2YWx1ZSArPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDI0ID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlIHw9IDA7IC8vIENhc3QgdG8gc2lnbmVkXHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAzMmJpdCBzaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkSW50MzJ9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGFkdmFuY2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50MzI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAzMmJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVWludDMyID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICB2YWx1ZSA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIHZhciBjYXBhY2l0eTUgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk1KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5NSAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5NSA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSA0O1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAodmFsdWUgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKHZhbHVlID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgdmFsdWUgICAgICAgICAmIDB4RkY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKHZhbHVlID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAodmFsdWUgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIHZhbHVlICAgICAgICAgJiAweEZGO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMzJiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZVVpbnQzMn0uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVJbnQzMiA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVVaW50MzI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDMyYml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgNCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzQrXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gMDtcclxuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHZhbHVlICA9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgMTY7XG4gICAgICAgICAgICB2YWx1ZSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8ICA4O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgIHZhbHVlICs9IHRoaXMudmlld1tvZmZzZXQrM10gPDwgMjQgPj4+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDE2O1xuICAgICAgICAgICAgdmFsdWUgfD0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAgODtcbiAgICAgICAgICAgIHZhbHVlIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICB2YWx1ZSArPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDI0ID4+PiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGEgMzJiaXQgdW5zaWduZWQgaW50ZWdlci4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkVWludDMyfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVJbnQzMiA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFVpbnQzMjtcclxuXHJcbiAgICAvLyB0eXBlcy9pbnRzL2ludDY0XHJcblxyXG4gICAgaWYgKExvbmcpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JpdGVzIGEgNjRiaXQgc2lnbmVkIGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUludDY0ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEodmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBMb25nKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhbiBpbnRlZ2VyIG9yIExvbmcpXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICAgICAgdmFyIGNhcGFjaXR5NiA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHk2KVxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTYgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTYgOiBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0IC09IDg7XG4gICAgICAgICAgICB2YXIgbG8gPSB2YWx1ZS5sb3csXHJcbiAgICAgICAgICAgICAgICBoaSA9IHZhbHVlLmhpZ2g7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9IChsbyA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGxvID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAobG8gPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9ICBsbyAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAoaGkgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChoaSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGhpID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgaGkgICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCAgXSA9IChoaSA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGhpID4+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAoaGkgPj4+ICA4KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCszXSA9ICBoaSAgICAgICAgICYgMHhGRjtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAobG8gPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChsbyA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGxvID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgbG8gICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIDY0Yml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlSW50NjR9LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVMb25nID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUludDY0O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIDY0Yml0IHNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50NjQgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgOCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIis4K1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxvID0gMCxcclxuICAgICAgICAgICAgICAgIGhpID0gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGl0dGxlRW5kaWFuKSB7XHJcbiAgICAgICAgICAgICAgICBsbyAgPSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgIDg7XG4gICAgICAgICAgICAgICAgbG8gfD0gdGhpcy52aWV3W29mZnNldCAgXTtcbiAgICAgICAgICAgICAgICBsbyArPSB0aGlzLnZpZXdbb2Zmc2V0KzNdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgaGkgID0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGhpIHw9IHRoaXMudmlld1tvZmZzZXQgIF07XG4gICAgICAgICAgICAgICAgaGkgKz0gdGhpcy52aWV3W29mZnNldCszXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBoaSAgPSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8IDE2O1xuICAgICAgICAgICAgICAgIGhpIHw9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgIDg7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCszXTtcbiAgICAgICAgICAgICAgICBoaSArPSB0aGlzLnZpZXdbb2Zmc2V0ICBdIDw8IDI0ID4+PiAwO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgbG8gID0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICAgICAgbG8gKz0gdGhpcy52aWV3W29mZnNldCAgXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV3IExvbmcobG8sIGhpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIDY0Yml0IHNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRJbnQ2NH0uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRMb25nID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSW50NjQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyaXRlcyBhIDY0Yml0IHVuc2lnbmVkIGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgOGAgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQ2NCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgTG9uZykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlciBvciBMb25nKVwiKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHZhciBjYXBhY2l0eTcgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5NylcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHk3ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHk3IDogb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCAtPSA4O1xuICAgICAgICAgICAgdmFyIGxvID0gdmFsdWUubG93LFxyXG4gICAgICAgICAgICAgICAgaGkgPSB2YWx1ZS5oaWdoO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAobG8gPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChsbyA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gKGxvID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgbG8gICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gKGhpID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAoaGkgPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChoaSA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gIGhpICAgICAgICAgJiAweEZGO1xuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAoaGkgPj4+IDI0KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsxXSA9IChoaSA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzJdID0gKGhpID4+PiAgOCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgaGkgICAgICAgICAmIDB4RkY7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0ICBdID0gKGxvID4+PiAyNCkgJiAweEZGO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAobG8gPj4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsyXSA9IChsbyA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KzNdID0gIGxvICAgICAgICAgJiAweEZGO1xuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSA2NGJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3dyaXRlVWludDY0fS5cclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVUludDY0ID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVpbnQ2NDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVhZHMgYSA2NGJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshTG9uZ31cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVWludDY0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDggPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrOCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsbyA9IDAsXHJcbiAgICAgICAgICAgICAgICBoaSA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgICAgICAgICAgbG8gID0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0KzFdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGxvIHw9IHRoaXMudmlld1tvZmZzZXQgIF07XG4gICAgICAgICAgICAgICAgbG8gKz0gdGhpcy52aWV3W29mZnNldCszXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIGhpICA9IHRoaXMudmlld1tvZmZzZXQrMl0gPDwgMTY7XG4gICAgICAgICAgICAgICAgaGkgfD0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAgODtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0ICBdO1xuICAgICAgICAgICAgICAgIGhpICs9IHRoaXMudmlld1tvZmZzZXQrM10gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGkgID0gdGhpcy52aWV3W29mZnNldCsxXSA8PCAxNjtcbiAgICAgICAgICAgICAgICBoaSB8PSB0aGlzLnZpZXdbb2Zmc2V0KzJdIDw8ICA4O1xuICAgICAgICAgICAgICAgIGhpIHw9IHRoaXMudmlld1tvZmZzZXQrM107XG4gICAgICAgICAgICAgICAgaGkgKz0gdGhpcy52aWV3W29mZnNldCAgXSA8PCAyNCA+Pj4gMDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgIGxvICA9IHRoaXMudmlld1tvZmZzZXQrMV0gPDwgMTY7XG4gICAgICAgICAgICAgICAgbG8gfD0gdGhpcy52aWV3W29mZnNldCsyXSA8PCAgODtcbiAgICAgICAgICAgICAgICBsbyB8PSB0aGlzLnZpZXdbb2Zmc2V0KzNdO1xuICAgICAgICAgICAgICAgIGxvICs9IHRoaXMudmlld1tvZmZzZXQgIF0gPDwgMjQgPj4+IDA7XG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5ldyBMb25nKGxvLCBoaSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIDY0Yml0IHVuc2lnbmVkIGludGVnZXIuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjcmVhZFVpbnQ2NH0uXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVSW50NjQgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVaW50NjQ7XHJcblxyXG4gICAgfSAvLyBMb25nXHJcblxyXG5cclxuICAgIC8vIHR5cGVzL2Zsb2F0cy9mbG9hdDMyXHJcblxyXG4gICAgLypcclxuICAgICBpZWVlNzU0IC0gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XHJcblxyXG4gICAgIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxyXG5cclxuICAgICBDb3B5cmlnaHQgKGMpIEZlcm9zcyBBYm91a2hhZGlqZWhcclxuXHJcbiAgICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gICAgIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuICAgICBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiAgICAgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG4gICAgIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4gICAgIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXHJcbiAgICAgYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuICAgICBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuICAgICBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuICAgICBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiAgICAgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuICAgICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiAgICAgVEhFIFNPRlRXQVJFLlxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGFuIElFRUU3NTQgZmxvYXQgZnJvbSBhIGJ5dGUgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0geyFBcnJheX0gYnVmZmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTEVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtTGVuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGllZWU3NTRfcmVhZChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XHJcbiAgICAgICAgdmFyIGUsIG0sXHJcbiAgICAgICAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXHJcbiAgICAgICAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXHJcbiAgICAgICAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxyXG4gICAgICAgICAgICBuQml0cyA9IC03LFxyXG4gICAgICAgICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXHJcbiAgICAgICAgICAgIGQgPSBpc0xFID8gLTEgOiAxLFxyXG4gICAgICAgICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xyXG5cclxuICAgICAgICBpICs9IGQ7XHJcblxyXG4gICAgICAgIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xyXG4gICAgICAgIHMgPj49ICgtbkJpdHMpO1xyXG4gICAgICAgIG5CaXRzICs9IGVMZW47XHJcbiAgICAgICAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cclxuXHJcbiAgICAgICAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XHJcbiAgICAgICAgZSA+Pj0gKC1uQml0cyk7XHJcbiAgICAgICAgbkJpdHMgKz0gbUxlbjtcclxuICAgICAgICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxyXG5cclxuICAgICAgICBpZiAoZSA9PT0gMCkge1xyXG4gICAgICAgICAgICBlID0gMSAtIGVCaWFzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcclxuICAgICAgICAgICAgZSA9IGUgLSBlQmlhcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gSUVFRTc1NCBmbG9hdCB0byBhIGJ5dGUgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0geyFBcnJheX0gYnVmZmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMRVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1MZW5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQnl0ZXNcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpZWVlNzU0X3dyaXRlKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XHJcbiAgICAgICAgdmFyIGUsIG0sIGMsXHJcbiAgICAgICAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXHJcbiAgICAgICAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXHJcbiAgICAgICAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxyXG4gICAgICAgICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXHJcbiAgICAgICAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcclxuICAgICAgICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXHJcbiAgICAgICAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XHJcblxyXG4gICAgICAgIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xyXG5cclxuICAgICAgICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGUgPSBlTWF4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgZS0tO1xyXG4gICAgICAgICAgICAgICAgYyAqPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gcnQgLyBjO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xyXG4gICAgICAgICAgICAgICAgZSsrO1xyXG4gICAgICAgICAgICAgICAgYyAvPSAyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcclxuICAgICAgICAgICAgICAgIG0gPSAwO1xyXG4gICAgICAgICAgICAgICAgZSA9IGVNYXg7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcclxuICAgICAgICAgICAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcclxuICAgICAgICAgICAgICAgIGUgPSBlICsgZUJpYXM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XHJcbiAgICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cclxuXHJcbiAgICAgICAgZSA9IChlIDw8IG1MZW4pIHwgbTtcclxuICAgICAgICBlTGVuICs9IG1MZW47XHJcbiAgICAgICAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxyXG5cclxuICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSAzMmJpdCBmbG9hdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSBgNGAgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlRmxvYXQzMiA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCB2YWx1ZTogXCIrdmFsdWUrXCIgKG5vdCBhIG51bWJlcilcIik7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgdmFyIGNhcGFjaXR5OCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTgpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHk4ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHk4IDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IDQ7XG4gICAgICAgIGllZWU3NTRfd3JpdGUodGhpcy52aWV3LCB2YWx1ZSwgb2Zmc2V0LCB0aGlzLmxpdHRsZUVuZGlhbiwgMjMsIDQpO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMzJiaXQgZmxvYXQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIEJ5dGVCdWZmZXIjd3JpdGVGbG9hdDMyfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVGbG9hdCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVGbG9hdDMyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSAzMmJpdCBmbG9hdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA0YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkRmxvYXQzMiA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIis0K1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IGllZWU3NTRfcmVhZCh0aGlzLnZpZXcsIG9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4sIDIzLCA0KTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDMyYml0IGZsb2F0LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRGbG9hdDMyfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDRgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRGbG9hdCA9IEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZEZsb2F0MzI7XHJcblxyXG4gICAgLy8gdHlwZXMvZmxvYXRzL2Zsb2F0NjRcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIDY0Yml0IGZsb2F0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVGbG9hdDY0ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGEgbnVtYmVyKVwiKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICB2YXIgY2FwYWNpdHk5ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5OSlcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTkgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTkgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gODtcbiAgICAgICAgaWVlZTc1NF93cml0ZSh0aGlzLnZpZXcsIHZhbHVlLCBvZmZzZXQsIHRoaXMubGl0dGxlRW5kaWFuLCA1MiwgOCk7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCArPSA4O1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSA2NGJpdCBmbG9hdC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZUZsb2F0NjR9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZURvdWJsZSA9IEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVGbG9hdDY0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSA2NGJpdCBmbG9hdC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IGA4YCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkRmxvYXQ2NCA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDggPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIis4K1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IGllZWU3NTRfcmVhZCh0aGlzLnZpZXcsIG9mZnNldCwgdGhpcy5saXR0bGVFbmRpYW4sIDUyLCA4KTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IDg7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDY0Yml0IGZsb2F0LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3JlYWRGbG9hdDY0fS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgYDhgIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWREb3VibGUgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRGbG9hdDY0O1xyXG5cclxuXHJcbiAgICAvLyB0eXBlcy92YXJpbnRzL3ZhcmludDMyXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBhIDMyYml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLk1BWF9WQVJJTlQzMl9CWVRFUyA9IDU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkIHRvIHN0b3JlIGEgMzJiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gZW5jb2RlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQuIENhcHBlZCB0byB7QGxpbmsgQnl0ZUJ1ZmZlci5NQVhfVkFSSU5UMzJfQllURVN9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIC8vIHJlZjogc3JjL2dvb2dsZS9wcm90b2J1Zi9pby9jb2RlZF9zdHJlYW0uY2NcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlID4+PiAwO1xyXG4gICAgICAgICAgICAgaWYgKHZhbHVlIDwgMSA8PCA3ICkgcmV0dXJuIDE7XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCAxIDw8IDE0KSByZXR1cm4gMjtcclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IDEgPDwgMjEpIHJldHVybiAzO1xyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIDwgMSA8PCAyOCkgcmV0dXJuIDQ7XHJcbiAgICAgICAgZWxzZSAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBaaWd6YWcgZW5jb2RlcyBhIHNpZ25lZCAzMmJpdCBpbnRlZ2VyIHNvIHRoYXQgaXQgY2FuIGJlIGVmZmVjdGl2ZWx5IHVzZWQgd2l0aCB2YXJpbnQgZW5jb2RpbmcuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBTaWduZWQgMzJiaXQgaW50ZWdlclxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgemlnemFnIGVuY29kZWQgMzJiaXQgaW50ZWdlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTMyID0gZnVuY3Rpb24obikge1xyXG4gICAgICAgIHJldHVybiAoKChuIHw9IDApIDw8IDEpIF4gKG4gPj4gMzEpKSA+Pj4gMDsgLy8gcmVmOiBzcmMvZ29vZ2xlL3Byb3RvYnVmL3dpcmVfZm9ybWF0X2xpdGUuaFxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYSB6aWd6YWcgZW5jb2RlZCBzaWduZWQgMzJiaXQgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFVuc2lnbmVkIHppZ3phZyBlbmNvZGVkIDMyYml0IGludGVnZXJcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCAzMmJpdCBpbnRlZ2VyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlMzIgPSBmdW5jdGlvbihuKSB7XHJcbiAgICAgICAgcmV0dXJuICgobiA+Pj4gMSkgXiAtKG4gJiAxKSkgfCAwOyAvLyAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvd2lyZV9mb3JtYXRfbGl0ZS5oXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgMzJiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IHRoaXMgaWYgYG9mZnNldGAgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVWYXJpbnQzMiA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2l6ZSA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIodmFsdWUpLFxyXG4gICAgICAgICAgICBiO1xyXG4gICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgICB2YXIgY2FwYWNpdHkxMCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTEwKVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTAgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTEwIDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IHNpemU7XG4gICAgICAgIHZhbHVlID4+Pj0gMDtcclxuICAgICAgICB3aGlsZSAodmFsdWUgPj0gMHg4MCkge1xyXG4gICAgICAgICAgICBiID0gKHZhbHVlICYgMHg3ZikgfCAweDgwO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gYjtcclxuICAgICAgICAgICAgdmFsdWUgPj4+PSA3O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNpemU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgemlnLXphZyBlbmNvZGVkIChzaWduZWQpIDMyYml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSB0aGlzIGlmIGBvZmZzZXRgIGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVmFyaW50MzJaaWdaYWcgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVWYXJpbnQzMihCeXRlQnVmZmVyLnppZ1phZ0VuY29kZTMyKHZhbHVlKSwgb2Zmc2V0KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIDMyYml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8IXt2YWx1ZTogbnVtYmVyLCBsZW5ndGg6IG51bWJlcn19IFRoZSB2YWx1ZSByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSB2YWx1ZSByZWFkXHJcbiAgICAgKiAgYW5kIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuXHJcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQncyBub3QgYSB2YWxpZCB2YXJpbnQuIEhhcyBhIHByb3BlcnR5IGB0cnVuY2F0ZWQgPSB0cnVlYCBpZiB0aGVyZSBpcyBub3QgZW5vdWdoIGRhdGEgYXZhaWxhYmxlXHJcbiAgICAgKiAgdG8gZnVsbHkgZGVjb2RlIHRoZSB2YXJpbnQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFZhcmludDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGlmIChyZWxhdGl2ZSkgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzErXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGMgPSAwLFxyXG4gICAgICAgICAgICB2YWx1ZSA9IDAgPj4+IDAsXHJcbiAgICAgICAgICAgIGI7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQgJiYgb2Zmc2V0ID4gdGhpcy5saW1pdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFwiVHJ1bmNhdGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgZXJyWyd0cnVuY2F0ZWQnXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYiA9IHRoaXMudmlld1tvZmZzZXQrK107XHJcbiAgICAgICAgICAgIGlmIChjIDwgNSlcclxuICAgICAgICAgICAgICAgIHZhbHVlIHw9IChiICYgMHg3ZikgPDwgKDcqYyk7XHJcbiAgICAgICAgICAgICsrYztcclxuICAgICAgICB9IHdoaWxlICgoYiAmIDB4ODApICE9PSAwKTtcclxuICAgICAgICB2YWx1ZSB8PSAwO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLFxyXG4gICAgICAgICAgICBcImxlbmd0aFwiOiBjXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCAoc2lnbmVkKSAzMmJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfCF7dmFsdWU6IG51bWJlciwgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgdmFsdWUgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgdmFsdWUgcmVhZFxyXG4gICAgICogIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxyXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIGl0J3Mgbm90IGEgdmFsaWQgdmFyaW50XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFZhcmludDMyWmlnWmFnID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMucmVhZFZhcmludDMyKG9mZnNldCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICB2YWxbXCJ2YWx1ZVwiXSA9IEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlMzIodmFsW1widmFsdWVcIl0pO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdmFsID0gQnl0ZUJ1ZmZlci56aWdaYWdEZWNvZGUzMih2YWwpO1xyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHR5cGVzL3ZhcmludHMvdmFyaW50NjRcclxuXHJcbiAgICBpZiAoTG9uZykge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBzdG9yZSBhIDY0Yml0IGJhc2UgMTI4IHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXIuTUFYX1ZBUklOVDY0X0JZVEVTID0gMTA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVxdWlyZWQgdG8gc3RvcmUgYSA2NGJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gdmFsdWUgVmFsdWUgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHJlcXVpcmVkLiBDYXBwZWQgdG8ge0BsaW5rIEJ5dGVCdWZmZXIuTUFYX1ZBUklOVDY0X0JZVEVTfVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDY0ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvaW8vY29kZWRfc3RyZWFtLmNjXHJcbiAgICAgICAgICAgIHZhciBwYXJ0MCA9IHZhbHVlLnRvSW50KCkgPj4+IDAsXHJcbiAgICAgICAgICAgICAgICBwYXJ0MSA9IHZhbHVlLnNoaWZ0UmlnaHRVbnNpZ25lZCgyOCkudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgICAgIHBhcnQyID0gdmFsdWUuc2hpZnRSaWdodFVuc2lnbmVkKDU2KS50b0ludCgpID4+PiAwO1xyXG4gICAgICAgICAgICBpZiAocGFydDIgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcnQxID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFydDAgPCAxIDw8IDE0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydDAgPCAxIDw8IDcgPyAxIDogMjtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0MCA8IDEgPDwgMjEgPyAzIDogNDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQxIDwgMSA8PCAxNClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQxIDwgMSA8PCA3ID8gNSA6IDY7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydDEgPCAxIDw8IDIxID8gNyA6IDg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQyIDwgMSA8PCA3ID8gOSA6IDEwO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFppZ3phZyBlbmNvZGVzIGEgc2lnbmVkIDY0Yml0IGludGVnZXIgc28gdGhhdCBpdCBjYW4gYmUgZWZmZWN0aXZlbHkgdXNlZCB3aXRoIHZhcmludCBlbmNvZGluZy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gdmFsdWUgU2lnbmVkIGxvbmdcclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIHppZ3phZyBlbmNvZGVkIGxvbmdcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlci56aWdaYWdFbmNvZGU2NCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tTnVtYmVyKHZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS51bnNpZ25lZCAhPT0gZmFsc2UpIHZhbHVlID0gdmFsdWUudG9TaWduZWQoKTtcbiAgICAgICAgICAgIC8vIHJlZjogc3JjL2dvb2dsZS9wcm90b2J1Zi93aXJlX2Zvcm1hdF9saXRlLmhcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNoaWZ0TGVmdCgxKS54b3IodmFsdWUuc2hpZnRSaWdodCg2MykpLnRvVW5zaWduZWQoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIGEgemlnemFnIGVuY29kZWQgc2lnbmVkIDY0Yml0IGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ9IHZhbHVlIFVuc2lnbmVkIHppZ3phZyBlbmNvZGVkIGxvbmcgb3IgSmF2YVNjcmlwdCBudW1iZXJcclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNpZ25lZCBsb25nXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlNjQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbU51bWJlcih2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExvbmcuZnJvbVN0cmluZyh2YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUudW5zaWduZWQgIT09IGZhbHNlKSB2YWx1ZSA9IHZhbHVlLnRvU2lnbmVkKCk7XG4gICAgICAgICAgICAvLyByZWY6IHNyYy9nb29nbGUvcHJvdG9idWYvd2lyZV9mb3JtYXRfbGl0ZS5oXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zaGlmdFJpZ2h0VW5zaWduZWQoMSkueG9yKHZhbHVlLmFuZChMb25nLk9ORSkudG9TaWduZWQoKS5uZWdhdGUoKSkudG9TaWduZWQoKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSA2NGJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcnxMb25nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gYHRoaXNgIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4uXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVWYXJpbnQ2NCA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgTG9uZykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdmFsdWU6IFwiK3ZhbHVlK1wiIChub3QgYW4gaW50ZWdlciBvciBMb25nKVwiKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21OdW1iZXIodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBMb25nLmZyb21TdHJpbmcodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLnVuc2lnbmVkICE9PSBmYWxzZSkgdmFsdWUgPSB2YWx1ZS50b1NpZ25lZCgpO1xuICAgICAgICAgICAgdmFyIHNpemUgPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDY0KHZhbHVlKSxcclxuICAgICAgICAgICAgICAgIHBhcnQwID0gdmFsdWUudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgICAgIHBhcnQxID0gdmFsdWUuc2hpZnRSaWdodFVuc2lnbmVkKDI4KS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICAgICAgcGFydDIgPSB2YWx1ZS5zaGlmdFJpZ2h0VW5zaWduZWQoNTYpLnRvSW50KCkgPj4+IDA7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSBzaXplO1xuICAgICAgICAgICAgdmFyIGNhcGFjaXR5MTEgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MTEpXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTEgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTExIDogb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCAtPSBzaXplO1xuICAgICAgICAgICAgc3dpdGNoIChzaXplKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiB0aGlzLnZpZXdbb2Zmc2V0KzldID0gKHBhcnQyID4+PiAgNykgJiAweDAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA5IDogdGhpcy52aWV3W29mZnNldCs4XSA9IHNpemUgIT09IDkgPyAocGFydDIgICAgICAgKSB8IDB4ODAgOiAocGFydDIgICAgICAgKSAmIDB4N0Y7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDggOiB0aGlzLnZpZXdbb2Zmc2V0KzddID0gc2l6ZSAhPT0gOCA/IChwYXJ0MSA+Pj4gMjEpIHwgMHg4MCA6IChwYXJ0MSA+Pj4gMjEpICYgMHg3RjtcclxuICAgICAgICAgICAgICAgIGNhc2UgNyA6IHRoaXMudmlld1tvZmZzZXQrNl0gPSBzaXplICE9PSA3ID8gKHBhcnQxID4+PiAxNCkgfCAweDgwIDogKHBhcnQxID4+PiAxNCkgJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2IDogdGhpcy52aWV3W29mZnNldCs1XSA9IHNpemUgIT09IDYgPyAocGFydDEgPj4+ICA3KSB8IDB4ODAgOiAocGFydDEgPj4+ICA3KSAmIDB4N0Y7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDUgOiB0aGlzLnZpZXdbb2Zmc2V0KzRdID0gc2l6ZSAhPT0gNSA/IChwYXJ0MSAgICAgICApIHwgMHg4MCA6IChwYXJ0MSAgICAgICApICYgMHg3RjtcclxuICAgICAgICAgICAgICAgIGNhc2UgNCA6IHRoaXMudmlld1tvZmZzZXQrM10gPSBzaXplICE9PSA0ID8gKHBhcnQwID4+PiAyMSkgfCAweDgwIDogKHBhcnQwID4+PiAyMSkgJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzIDogdGhpcy52aWV3W29mZnNldCsyXSA9IHNpemUgIT09IDMgPyAocGFydDAgPj4+IDE0KSB8IDB4ODAgOiAocGFydDAgPj4+IDE0KSAmIDB4N0Y7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDIgOiB0aGlzLnZpZXdbb2Zmc2V0KzFdID0gc2l6ZSAhPT0gMiA/IChwYXJ0MCA+Pj4gIDcpIHwgMHg4MCA6IChwYXJ0MCA+Pj4gIDcpICYgMHg3RjtcclxuICAgICAgICAgICAgICAgIGNhc2UgMSA6IHRoaXMudmlld1tvZmZzZXQgIF0gPSBzaXplICE9PSAxID8gKHBhcnQwICAgICAgICkgfCAweDgwIDogKHBhcnQwICAgICAgICkgJiAweDdGO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc2l6ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcml0ZXMgYSB6aWctemFnIGVuY29kZWQgNjRiaXQgYmFzZSAxMjggdmFyaWFibGUtbGVuZ3RoIGludGVnZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ8TG9uZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IGB0aGlzYCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuLlxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlVmFyaW50NjRaaWdaYWcgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRlVmFyaW50NjQoQnl0ZUJ1ZmZlci56aWdaYWdFbmNvZGU2NCh2YWx1ZSksIG9mZnNldCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVhZHMgYSA2NGJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci4gUmVxdWlyZXMgTG9uZy5qcy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgICAgICogIHJlYWQgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd8IXt2YWx1ZTogTG9uZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgdmFsdWUgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgdmFsdWUgcmVhZCBhbmRcclxuICAgICAgICAgKiAgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQncyBub3QgYSB2YWxpZCB2YXJpbnRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVmFyaW50NjQgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aXZlID0gdHlwZW9mIG9mZnNldCA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIisxK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVmOiBzcmMvZ29vZ2xlL3Byb3RvYnVmL2lvL2NvZGVkX3N0cmVhbS5jY1xyXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgICAgICAgICBwYXJ0MCA9IDAsXHJcbiAgICAgICAgICAgICAgICBwYXJ0MSA9IDAsXHJcbiAgICAgICAgICAgICAgICBwYXJ0MiA9IDAsXHJcbiAgICAgICAgICAgICAgICBiICA9IDA7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MCAgPSAoYiAmIDB4N0YpICAgICAgOyBpZiAoIGIgJiAweDgwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MCB8PSAoYiAmIDB4N0YpIDw8ICA3OyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MCB8PSAoYiAmIDB4N0YpIDw8IDE0OyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MCB8PSAoYiAmIDB4N0YpIDw8IDIxOyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MSAgPSAoYiAmIDB4N0YpICAgICAgOyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MSB8PSAoYiAmIDB4N0YpIDw8ICA3OyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MSB8PSAoYiAmIDB4N0YpIDw8IDE0OyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MSB8PSAoYiAmIDB4N0YpIDw8IDIxOyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MiAgPSAoYiAmIDB4N0YpICAgICAgOyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdOyBwYXJ0MiB8PSAoYiAmIDB4N0YpIDw8ICA3OyBpZiAoKGIgJiAweDgwKSB8fCAodGhpcy5ub0Fzc2VydCAmJiB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQnVmZmVyIG92ZXJydW5cIik7IH19fX19fX19fX1cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gTG9uZy5mcm9tQml0cyhwYXJ0MCB8IChwYXJ0MSA8PCAyOCksIChwYXJ0MSA+Pj4gNCkgfCAocGFydDIpIDw8IDI0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICd2YWx1ZSc6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICdsZW5ndGgnOiBvZmZzZXQtc3RhcnRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCA2NGJpdCBiYXNlIDEyOCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlci4gUmVxdWlyZXMgTG9uZy5qcy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgICAgICogIHJlYWQgaWYgb21pdHRlZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IUxvbmd8IXt2YWx1ZTogTG9uZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgdmFsdWUgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgdmFsdWUgcmVhZCBhbmRcclxuICAgICAgICAgKiAgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgaXQncyBub3QgYSB2YWxpZCB2YXJpbnRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVmFyaW50NjRaaWdaYWcgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IHRoaXMucmVhZFZhcmludDY0KG9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmICh2YWwgJiYgdmFsWyd2YWx1ZSddIGluc3RhbmNlb2YgTG9uZylcclxuICAgICAgICAgICAgICAgIHZhbFtcInZhbHVlXCJdID0gQnl0ZUJ1ZmZlci56aWdaYWdEZWNvZGU2NCh2YWxbXCJ2YWx1ZVwiXSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHZhbCA9IEJ5dGVCdWZmZXIuemlnWmFnRGVjb2RlNjQodmFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgIH0gLy8gTG9uZ1xyXG5cclxuXHJcbiAgICAvLyB0eXBlcy9zdHJpbmdzL2NzdHJpbmdcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIE5VTEwtdGVybWluYXRlZCBVVEY4IGVuY29kZWQgc3RyaW5nLiBGb3IgdGhpcyB0byB3b3JrIHRoZSBzcGVjaWZpZWQgc3RyaW5nIG11c3Qgbm90IGNvbnRhaW4gYW55IE5VTExcclxuICAgICAqICBjaGFyYWN0ZXJzIGl0c2VsZi5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gd3JpdGUgdG8uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICBjb250YWluZWQgaW4gYHN0cmAgKyAxIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ8bnVtYmVyfSB0aGlzIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZUNTdHJpbmcgPSBmdW5jdGlvbihzdHIsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgayA9IHN0ci5sZW5ndGg7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7XHJcbiAgICAgICAgICAgIGZvciAoaT0wOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkpID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHN0cjogQ29udGFpbnMgTlVMTC1jaGFyYWN0ZXJzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICAvLyBVVEY4IHN0cmluZ3MgZG8gbm90IGNvbnRhaW4gemVybyBieXRlcyBpbiBiZXR3ZWVuIGV4Y2VwdCBmb3IgdGhlIHplcm8gY2hhcmFjdGVyLCBzbzpcclxuICAgICAgICBrID0gdXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSlbMV07XHJcbiAgICAgICAgb2Zmc2V0ICs9IGsrMTtcbiAgICAgICAgdmFyIGNhcGFjaXR5MTIgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxMilcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTEyICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkxMiA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSBrKzE7XG4gICAgICAgIHV0ZnguZW5jb2RlVVRGMTZ0b1VURjgoc3RyaW5nU291cmNlKHN0ciksIGZ1bmN0aW9uKGIpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3W29mZnNldCsrXSA9IGI7XHJcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gMDtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIE5VTEwtdGVybWluYXRlZCBVVEY4IGVuY29kZWQgc3RyaW5nLiBGb3IgdGhpcyB0byB3b3JrIHRoZSBzdHJpbmcgcmVhZCBtdXN0IG5vdCBjb250YWluIGFueSBOVUxMIGNoYXJhY3RlcnNcclxuICAgICAqICBpdHNlbGYuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3whe3N0cmluZzogc3RyaW5nLCBsZW5ndGg6IG51bWJlcn19IFRoZSBzdHJpbmcgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgc3RyaW5nXHJcbiAgICAgKiAgcmVhZCBhbmQgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkQ1N0cmluZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDEgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIisxK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldDtcclxyXG4gICAgICAgIC8vIFVURjggc3RyaW5ncyBkbyBub3QgY29udGFpbiB6ZXJvIGJ5dGVzIGluIGJldHdlZW4gZXhjZXB0IGZvciB0aGUgemVybyBjaGFyYWN0ZXIgaXRzZWxmLCBzbzpcclxuICAgICAgICB2YXIgc2QsIGIgPSAtMTtcclxuICAgICAgICB1dGZ4LmRlY29kZVVURjh0b1VURjE2KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoYiA9PT0gMCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPj0gdGhpcy5saW1pdClcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIrb2Zmc2V0K1wiIDwgXCIrdGhpcy5saW1pdCk7XHJcbiAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbb2Zmc2V0KytdO1xyXG4gICAgICAgICAgICByZXR1cm4gYiA9PT0gMCA/IG51bGwgOiBiO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSwgc2QgPSBzdHJpbmdEZXN0aW5hdGlvbigpLCB0cnVlKTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBzZCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiOiBzZCgpLFxyXG4gICAgICAgICAgICAgICAgXCJsZW5ndGhcIjogb2Zmc2V0IC0gc3RhcnRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIHR5cGVzL3N0cmluZ3MvaXN0cmluZ1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgbGVuZ3RoIGFzIHVpbnQzMiBwcmVmaXhlZCBVVEY4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHdyaXR0ZW4gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IGB0aGlzYCBpZiBgb2Zmc2V0YCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciN3cml0ZVZhcmludDMyXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUud3JpdGVJU3RyaW5nID0gZnVuY3Rpb24oc3RyLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgICAgIGs7XHJcbiAgICAgICAgayA9IHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0ciksIHRoaXMubm9Bc3NlcnQpWzFdO1xyXG4gICAgICAgIG9mZnNldCArPSA0K2s7XG4gICAgICAgIHZhciBjYXBhY2l0eTEzID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MTMpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkxMyAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MTMgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gNCtrO1xuICAgICAgICBpZiAodGhpcy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAoayA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAoayA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAoayA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAgayAgICAgICAgICYgMHhGRjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQgIF0gPSAoayA+Pj4gMjQpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMV0gPSAoayA+Pj4gMTYpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrMl0gPSAoayA+Pj4gIDgpICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrM10gPSAgayAgICAgICAgICYgMHhGRjtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICB1dGZ4LmVuY29kZVVURjE2dG9VVEY4KHN0cmluZ1NvdXJjZShzdHIpLCBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrK10gPSBiO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gc3RhcnQgKyA0ICsgaylcclxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitvZmZzZXQrXCIgPT0gXCIrKG9mZnNldCs0K2spKTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSBsZW5ndGggYXMgdWludDMyIHByZWZpeGVkIFVURjggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3whe3N0cmluZzogc3RyaW5nLCBsZW5ndGg6IG51bWJlcn19IFRoZSBzdHJpbmcgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgc3RyaW5nXHJcbiAgICAgKiAgcmVhZCBhbmQgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNyZWFkVmFyaW50MzJcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkSVN0cmluZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIis0K1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldDtcclxuICAgICAgICB2YXIgbGVuID0gdGhpcy5yZWFkVWludDMyKG9mZnNldCk7XHJcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMucmVhZFVURjhTdHJpbmcobGVuLCBCeXRlQnVmZmVyLk1FVFJJQ1NfQllURVMsIG9mZnNldCArPSA0KTtcclxuICAgICAgICBvZmZzZXQgKz0gc3RyWydsZW5ndGgnXTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJbJ3N0cmluZyddO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAnc3RyaW5nJzogc3RyWydzdHJpbmcnXSxcclxuICAgICAgICAgICAgICAgICdsZW5ndGgnOiBvZmZzZXQgLSBzdGFydFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gdHlwZXMvc3RyaW5ncy91dGY4c3RyaW5nXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRyaWNzIHJlcHJlc2VudGluZyBudW1iZXIgb2YgVVRGOCBjaGFyYWN0ZXJzLiBFdmFsdWF0ZXMgdG8gYGNgLlxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLk1FVFJJQ1NfQ0hBUlMgPSAnYyc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRyaWNzIHJlcHJlc2VudGluZyBudW1iZXIgb2YgYnl0ZXMuIEV2YWx1YXRlcyB0byBgYmAuXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuTUVUUklDU19CWVRFUyA9ICdiJztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhbiBVVEY4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gd3JpdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byB3cml0ZSB0by4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcnxudW1iZXJ9IHRoaXMgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbi5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVURjhTdHJpbmcgPSBmdW5jdGlvbihzdHIsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBrO1xyXG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldDtcclxuICAgICAgICBrID0gdXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSlbMV07XHJcbiAgICAgICAgb2Zmc2V0ICs9IGs7XG4gICAgICAgIHZhciBjYXBhY2l0eTE0ID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgaWYgKG9mZnNldCA+IGNhcGFjaXR5MTQpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgoY2FwYWNpdHkxNCAqPSAyKSA+IG9mZnNldCA/IGNhcGFjaXR5MTQgOiBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgLT0gaztcbiAgICAgICAgdXRmeC5lbmNvZGVVVEYxNnRvVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdbb2Zmc2V0KytdID0gYjtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gVVRGOCBlbmNvZGVkIHN0cmluZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciN3cml0ZVVURjhTdHJpbmd9LlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gdGhpcyBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyB3cml0dGVuLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLndyaXRlU3RyaW5nID0gQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVVURjhTdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgVVRGOCBjaGFyYWN0ZXJzIG9mIGEgc3RyaW5nLiBKYXZhU2NyaXB0IGl0c2VsZiB1c2VzIFVURi0xNiwgc28gdGhhdCBhIHN0cmluZydzXHJcbiAgICAgKiAgYGxlbmd0aGAgcHJvcGVydHkgZG9lcyBub3QgcmVmbGVjdCBpdHMgYWN0dWFsIFVURjggc2l6ZSBpZiBpdCBjb250YWlucyBjb2RlIHBvaW50cyBsYXJnZXIgdGhhbiAweEZGRkYuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjYWxjdWxhdGVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBVVEY4IGNoYXJhY3RlcnNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVVVEY4Q2hhcnMgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICByZXR1cm4gdXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSlbMF07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIFVURjggYnl0ZXMgb2YgYSBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjYWxjdWxhdGVcclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBVVEY4IGJ5dGVzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVVRGOEJ5dGVzID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjgoc3RyaW5nU291cmNlKHN0cikpWzFdO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBVVEY4IGJ5dGVzIG9mIGEgc3RyaW5nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyLmNhbGN1bGF0ZVVURjhCeXRlc30uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNhbGN1bGF0ZVxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIFVURjggYnl0ZXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVTdHJpbmcgPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVVURjhCeXRlcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGFuIFVURjggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBjaGFyYWN0ZXJzIG9yIGJ5dGVzIHRvIHJlYWQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IG1ldHJpY3MgTWV0cmljcyBzcGVjaWZ5aW5nIHdoYXQgYGxlbmd0aGAgaXMgbWVhbnQgdG8gY291bnQuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuTUVUUklDU19DSEFSU30uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcmVhZCBmcm9tLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3whe3N0cmluZzogc3RyaW5nLCBsZW5ndGg6IG51bWJlcn19IFRoZSBzdHJpbmcgcmVhZCBpZiBvZmZzZXQgaXMgb21pdHRlZCwgZWxzZSB0aGUgc3RyaW5nXHJcbiAgICAgKiAgcmVhZCBhbmQgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5yZWFkVVRGOFN0cmluZyA9IGZ1bmN0aW9uKGxlbmd0aCwgbWV0cmljcywgb2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRyaWNzID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSBtZXRyaWNzO1xyXG4gICAgICAgICAgICBtZXRyaWNzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRyaWNzID09PSAndW5kZWZpbmVkJykgbWV0cmljcyA9IEJ5dGVCdWZmZXIuTUVUUklDU19DSEFSUztcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInIHx8IGxlbmd0aCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBsZW5ndGg6IFwiK2xlbmd0aCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgbGVuZ3RoIHw9IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICsgMCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiAwIDw9IFwiK29mZnNldCtcIiAoK1wiKzArXCIpIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICAgICAgc2Q7XHJcbiAgICAgICAgaWYgKG1ldHJpY3MgPT09IEJ5dGVCdWZmZXIuTUVUUklDU19DSEFSUykgeyAvLyBUaGUgc2FtZSBmb3Igbm9kZSBhbmQgdGhlIGJyb3dzZXJcclxuICAgICAgICAgICAgc2QgPSBzdHJpbmdEZXN0aW5hdGlvbigpO1xyXG4gICAgICAgICAgICB1dGZ4LmRlY29kZVVURjgoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA8IGxlbmd0aCAmJiBvZmZzZXQgPCB0aGlzLmxpbWl0ID8gdGhpcy52aWV3W29mZnNldCsrXSA6IG51bGw7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgZnVuY3Rpb24oY3ApIHtcclxuICAgICAgICAgICAgICAgICsraTsgdXRmeC5VVEY4dG9VVEYxNihjcCwgc2QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKGkgIT09IGxlbmd0aClcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiBUcnVuY2F0ZWQgZGF0YSwgXCIraStcIiA9PSBcIitsZW5ndGgpO1xyXG4gICAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNkKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCI6IHNkKCksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJsZW5ndGhcIjogb2Zmc2V0IC0gc3RhcnRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKG1ldHJpY3MgPT09IEJ5dGVCdWZmZXIuTUVUUklDU19CWVRFUykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogXCIrb2Zmc2V0K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyBsZW5ndGggPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrbGVuZ3RoK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGsgPSBvZmZzZXQgKyBsZW5ndGg7XHJcbiAgICAgICAgICAgIHV0ZnguZGVjb2RlVVRGOHRvVVRGMTYoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0IDwgayA/IHRoaXMudmlld1tvZmZzZXQrK10gOiBudWxsO1xyXG4gICAgICAgICAgICB9LmJpbmQodGhpcyksIHNkID0gc3RyaW5nRGVzdGluYXRpb24oKSwgdGhpcy5ub0Fzc2VydCk7XHJcbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGspXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK29mZnNldCtcIiA9PSBcIitrKTtcclxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZCgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAnc3RyaW5nJzogc2QoKSxcclxuICAgICAgICAgICAgICAgICAgICAnbGVuZ3RoJzogb2Zmc2V0IC0gc3RhcnRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgbWV0cmljczogXCIrbWV0cmljcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYW4gVVRGOCBlbmNvZGVkIHN0cmluZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgQnl0ZUJ1ZmZlciNyZWFkVVRGOFN0cmluZ30uXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGNoYXJhY3RlcnMgb3IgYnl0ZXMgdG8gcmVhZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBtZXRyaWNzIE1ldHJpY3Mgc3BlY2lmeWluZyB3aGF0IGBuYCBpcyBtZWFudCB0byBjb3VudC4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5NRVRSSUNTX0NIQVJTfS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byByZWFkIGZyb20uIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICByZWFkIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfCF7c3RyaW5nOiBzdHJpbmcsIGxlbmd0aDogbnVtYmVyfX0gVGhlIHN0cmluZyByZWFkIGlmIG9mZnNldCBpcyBvbWl0dGVkLCBlbHNlIHRoZSBzdHJpbmdcclxuICAgICAqICByZWFkIGFuZCB0aGUgYWN0dWFsIG51bWJlciBvZiBieXRlcyByZWFkLlxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRTdHJpbmcgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnJlYWRVVEY4U3RyaW5nO1xyXG5cclxuICAgIC8vIHR5cGVzL3N0cmluZ3MvdnN0cmluZ1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgbGVuZ3RoIGFzIHZhcmludDMyIHByZWZpeGVkIFVURjggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byB3cml0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHdyaXRlIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgd3JpdHRlbiBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfG51bWJlcn0gYHRoaXNgIGlmIGBvZmZzZXRgIGlzIG9taXR0ZWQsIGVsc2UgdGhlIGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI3dyaXRlVmFyaW50MzJcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS53cml0ZVZTdHJpbmcgPSBmdW5jdGlvbihzdHIsIG9mZnNldCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICAgICAgaywgbDtcclxuICAgICAgICBrID0gdXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgdGhpcy5ub0Fzc2VydClbMV07XHJcbiAgICAgICAgbCA9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoayk7XHJcbiAgICAgICAgb2Zmc2V0ICs9IGwraztcbiAgICAgICAgdmFyIGNhcGFjaXR5MTUgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAob2Zmc2V0ID4gY2FwYWNpdHkxNSlcbiAgICAgICAgICAgIHRoaXMucmVzaXplKChjYXBhY2l0eTE1ICo9IDIpID4gb2Zmc2V0ID8gY2FwYWNpdHkxNSA6IG9mZnNldCk7XG4gICAgICAgIG9mZnNldCAtPSBsK2s7XG4gICAgICAgIG9mZnNldCArPSB0aGlzLndyaXRlVmFyaW50MzIoaywgb2Zmc2V0KTtcclxuICAgICAgICB1dGZ4LmVuY29kZVVURjE2dG9VVEY4KHN0cmluZ1NvdXJjZShzdHIpLCBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld1tvZmZzZXQrK10gPSBiO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gc3RhcnQraytsKVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogVHJ1bmNhdGVkIGRhdGEsIFwiK29mZnNldCtcIiA9PSBcIisob2Zmc2V0K2srbCkpO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIGxlbmd0aCBhcyB2YXJpbnQzMiBwcmVmaXhlZCBVVEY4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHJlYWQgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHJlYWQgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8IXtzdHJpbmc6IHN0cmluZywgbGVuZ3RoOiBudW1iZXJ9fSBUaGUgc3RyaW5nIHJlYWQgaWYgb2Zmc2V0IGlzIG9taXR0ZWQsIGVsc2UgdGhlIHN0cmluZ1xyXG4gICAgICogIHJlYWQgYW5kIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjcmVhZFZhcmludDMyXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVhZFZTdHJpbmcgPSBmdW5jdGlvbihvZmZzZXQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJztcbiAgICAgICAgaWYgKHJlbGF0aXZlKSBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAxID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMStcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XHJcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMucmVhZFZhcmludDMyKG9mZnNldCk7XHJcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMucmVhZFVURjhTdHJpbmcobGVuWyd2YWx1ZSddLCBCeXRlQnVmZmVyLk1FVFJJQ1NfQllURVMsIG9mZnNldCArPSBsZW5bJ2xlbmd0aCddKTtcclxuICAgICAgICBvZmZzZXQgKz0gc3RyWydsZW5ndGgnXTtcclxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJbJ3N0cmluZyddO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAnc3RyaW5nJzogc3RyWydzdHJpbmcnXSxcclxuICAgICAgICAgICAgICAgICdsZW5ndGgnOiBvZmZzZXQgLSBzdGFydFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyBzb21lIGRhdGEgdG8gdGhpcyBCeXRlQnVmZmVyLiBUaGlzIHdpbGwgb3ZlcndyaXRlIGFueSBjb250ZW50cyBiZWhpbmQgdGhlIHNwZWNpZmllZCBvZmZzZXQgdXAgdG8gdGhlIGFwcGVuZGVkXHJcbiAgICAgKiAgZGF0YSdzIGxlbmd0aC5cclxuICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ8IUFycmF5QnVmZmVyfCFVaW50OEFycmF5fHN0cmluZ30gc291cmNlIERhdGEgdG8gYXBwZW5kLiBJZiBgc291cmNlYCBpcyBhIEJ5dGVCdWZmZXIsIGl0cyBvZmZzZXRzXHJcbiAgICAgKiAgd2lsbCBiZSBtb2RpZmllZCBhY2NvcmRpbmcgdG8gdGhlIHBlcmZvcm1lZCByZWFkIG9wZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xudW1iZXIpPX0gZW5jb2RpbmcgRW5jb2RpbmcgaWYgYGRhdGFgIGlzIGEgc3RyaW5nIChcImJhc2U2NFwiLCBcImhleFwiLCBcImJpbmFyeVwiLCBkZWZhdWx0cyB0byBcInV0ZjhcIilcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byBhcHBlbmQgYXQuIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBleGFtcGxlIEEgcmVsYXRpdmUgYDwwMSAwMj4wMy5hcHBlbmQoPDA0IDA1PilgIHdpbGwgcmVzdWx0IGluIGA8MDEgMDIgMDQgMDU+LCAwNCAwNXxgXHJcbiAgICAgKiBAZXhhbXBsZSBBbiBhYnNvbHV0ZSBgPDAxIDAyPjAzLmFwcGVuZCgwNCAwNT4sIDEpYCB3aWxsIHJlc3VsdCBpbiBgPDAxIDA0PjA1LCAwNCAwNXxgXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oc291cmNlLCBlbmNvZGluZywgb2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSBlbmNvZGluZztcclxuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIEJ5dGVCdWZmZXIpKVxyXG4gICAgICAgICAgICBzb3VyY2UgPSBCeXRlQnVmZmVyLndyYXAoc291cmNlLCBlbmNvZGluZyk7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHNvdXJjZS5saW1pdCAtIHNvdXJjZS5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA8PSAwKSByZXR1cm4gdGhpczsgLy8gTm90aGluZyB0byBhcHBlbmRcclxuICAgICAgICBvZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICB2YXIgY2FwYWNpdHkxNiA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChvZmZzZXQgPiBjYXBhY2l0eTE2KVxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKGNhcGFjaXR5MTYgKj0gMikgPiBvZmZzZXQgPyBjYXBhY2l0eTE2IDogb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0IC09IGxlbmd0aDtcbiAgICAgICAgdGhpcy52aWV3LnNldChzb3VyY2Uudmlldy5zdWJhcnJheShzb3VyY2Uub2Zmc2V0LCBzb3VyY2UubGltaXQpLCBvZmZzZXQpO1xyXG4gICAgICAgIHNvdXJjZS5vZmZzZXQgKz0gbGVuZ3RoO1xyXG4gICAgICAgIGlmIChyZWxhdGl2ZSkgdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIHRoaXMgQnl0ZUJ1ZmZlcidzIGNvbnRlbnRzIHRvIGFub3RoZXIgQnl0ZUJ1ZmZlci4gVGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgY29udGVudHMgYXQgYW5kIGFmdGVyIHRoZVxyXG4gICAgICAgIHNwZWNpZmllZCBvZmZzZXQgdXAgdG8gdGhlIGxlbmd0aCBvZiB0aGlzIEJ5dGVCdWZmZXIncyBkYXRhLlxyXG4gICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcn0gdGFyZ2V0IFRhcmdldCBCeXRlQnVmZmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gYXBwZW5kIHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2Uge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzXHJcbiAgICAgKiAgcmVhZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjYXBwZW5kXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuYXBwZW5kVG8gPSBmdW5jdGlvbih0YXJnZXQsIG9mZnNldCkge1xyXG4gICAgICAgIHRhcmdldC5hcHBlbmQodGhpcywgb2Zmc2V0KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGFzc2VydGlvbnMgb2YgYXJndW1lbnQgdHlwZXMgYW5kIG9mZnNldHMuIEFzc2VydGlvbnMgYXJlIGVuYWJsZWQgYnkgZGVmYXVsdCBidXQgeW91IGNhbiBvcHQgdG9cclxuICAgICAqICBkaXNhYmxlIHRoZW0gaWYgeW91ciBjb2RlIGFscmVhZHkgbWFrZXMgc3VyZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgdmFsaWQuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFzc2VydCBgdHJ1ZWAgdG8gZW5hYmxlIGFzc2VydGlvbnMsIG90aGVyd2lzZSBgZmFsc2VgXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5hc3NlcnQgPSBmdW5jdGlvbihhc3NlcnQpIHtcclxuICAgICAgICB0aGlzLm5vQXNzZXJ0ID0gIWFzc2VydDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjYXBhY2l0eSBvZiB0aGlzIEJ5dGVCdWZmZXIncyBiYWNraW5nIGJ1ZmZlci5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IENhcGFjaXR5IG9mIHRoZSBiYWNraW5nIGJ1ZmZlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmNhcGFjaXR5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhpcyBCeXRlQnVmZmVyJ3Mgb2Zmc2V0cyBieSBzZXR0aW5nIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gdG8gYDBgIGFuZCB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0gdG8gdGhlXHJcbiAgICAgKiAgYmFja2luZyBidWZmZXIncyBjYXBhY2l0eS4gRGlzY2FyZHMge0BsaW5rIEJ5dGVCdWZmZXIjbWFya2VkT2Zmc2V0fS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMubGltaXQgPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMubWFya2VkT2Zmc2V0ID0gLTE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNsb25lZCBpbnN0YW5jZSBvZiB0aGlzIEJ5dGVCdWZmZXIsIHByZXNldCB3aXRoIHRoaXMgQnl0ZUJ1ZmZlcidzIHZhbHVlcyBmb3Ige0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSxcclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNtYXJrZWRPZmZzZXR9IGFuZCB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBjb3B5IFdoZXRoZXIgdG8gY29weSB0aGUgYmFja2luZyBidWZmZXIgb3IgdG8gcmV0dXJuIGFub3RoZXIgdmlldyBvbiB0aGUgc2FtZSwgZGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBDbG9uZWQgaW5zdGFuY2VcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKGNvcHkpIHtcclxuICAgICAgICB2YXIgYmIgPSBuZXcgQnl0ZUJ1ZmZlcigwLCB0aGlzLmxpdHRsZUVuZGlhbiwgdGhpcy5ub0Fzc2VydCk7XHJcbiAgICAgICAgaWYgKGNvcHkpIHtcclxuICAgICAgICAgICAgYmIuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICBiYi52aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYmIuYnVmZmVyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBiYi5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcclxuICAgICAgICAgICAgYmIudmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB9XHJcbiAgICAgICAgYmIub2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgYmIubWFya2VkT2Zmc2V0ID0gdGhpcy5tYXJrZWRPZmZzZXQ7XHJcbiAgICAgICAgYmIubGltaXQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYWN0cyB0aGlzIEJ5dGVCdWZmZXIgdG8gYmUgYmFja2VkIGJ5IGEge0BsaW5rIEJ5dGVCdWZmZXIjYnVmZmVyfSBvZiBpdHMgY29udGVudHMnIGxlbmd0aC4gQ29udGVudHMgYXJlIHRoZSBieXRlc1xyXG4gICAgICogIGJldHdlZW4ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LiBXaWxsIHNldCBgb2Zmc2V0ID0gMGAgYW5kIGBsaW1pdCA9IGNhcGFjaXR5YCBhbmRcclxuICAgICAqICBhZGFwdCB7QGxpbmsgQnl0ZUJ1ZmZlciNtYXJrZWRPZmZzZXR9IHRvIHRoZSBzYW1lIHJlbGF0aXZlIHBvc2l0aW9uIGlmIHNldC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gT2Zmc2V0IHRvIHN0YXJ0IGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBPZmZzZXQgdG8gZW5kIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH1cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiZWdpbiA9PT0gMCAmJiBlbmQgPT09IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBBbHJlYWR5IGNvbXBhY3RlZFxyXG4gICAgICAgIHZhciBsZW4gPSBlbmQgLSBiZWdpbjtcclxuICAgICAgICBpZiAobGVuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gRU1QVFlfQlVGRkVSO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXJrZWRPZmZzZXQgPj0gMCkgdGhpcy5tYXJrZWRPZmZzZXQgLT0gYmVnaW47XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5saW1pdCA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGxlbik7XHJcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgICAgIHZpZXcuc2V0KHRoaXMudmlldy5zdWJhcnJheShiZWdpbiwgZW5kKSk7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgICAgICBpZiAodGhpcy5tYXJrZWRPZmZzZXQgPj0gMCkgdGhpcy5tYXJrZWRPZmZzZXQgLT0gYmVnaW47XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMubGltaXQgPSBsZW47XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMuIENvbnRlbnRzIGFyZSB0aGUgYnl0ZXMgYmV0d2VlbiB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGFuZFxyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gQmVnaW4gb2Zmc2V0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBlbmQgRW5kIG9mZnNldCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBDb3B5XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJykgYmVnaW4gPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVnaW4gIT09ICdudW1iZXInIHx8IGJlZ2luICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGJlZ2luID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCBlbmQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGVuZCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGJlZ2luID4gZW5kIHx8IGVuZCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYmVnaW4rXCIgPD0gXCIrZW5kK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJlZ2luID09PSBlbmQpXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZUJ1ZmZlcigwLCB0aGlzLmxpdHRsZUVuZGlhbiwgdGhpcy5ub0Fzc2VydCk7XHJcbiAgICAgICAgdmFyIGNhcGFjaXR5ID0gZW5kIC0gYmVnaW4sXHJcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoY2FwYWNpdHksIHRoaXMubGl0dGxlRW5kaWFuLCB0aGlzLm5vQXNzZXJ0KTtcclxuICAgICAgICBiYi5vZmZzZXQgPSAwO1xyXG4gICAgICAgIGJiLmxpbWl0ID0gY2FwYWNpdHk7XHJcbiAgICAgICAgaWYgKGJiLm1hcmtlZE9mZnNldCA+PSAwKSBiYi5tYXJrZWRPZmZzZXQgLT0gYmVnaW47XHJcbiAgICAgICAgdGhpcy5jb3B5VG8oYmIsIDAsIGJlZ2luLCBlbmQpO1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMgdG8gYW5vdGhlciBCeXRlQnVmZmVyLiBDb250ZW50cyBhcmUgdGhlIGJ5dGVzIGJldHdlZW4ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmRcclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfSB0YXJnZXQgVGFyZ2V0IEJ5dGVCdWZmZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gdGFyZ2V0T2Zmc2V0IE9mZnNldCB0byBjb3B5IHRvLiBXaWxsIHVzZSBhbmQgaW5jcmVhc2UgdGhlIHRhcmdldCdzIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH1cclxuICAgICAqICBieSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGNvcGllZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBzb3VyY2VPZmZzZXQgT2Zmc2V0IHRvIHN0YXJ0IGNvcHlpbmcgZnJvbS4gV2lsbCB1c2UgYW5kIGluY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlXHJcbiAgICAgKiAgbnVtYmVyIG9mIGJ5dGVzIGNvcGllZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBzb3VyY2VMaW1pdCBPZmZzZXQgdG8gZW5kIGNvcHlpbmcgZnJvbSwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9XHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5jb3B5VG8gPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldE9mZnNldCwgc291cmNlT2Zmc2V0LCBzb3VyY2VMaW1pdCkge1xyXG4gICAgICAgIHZhciByZWxhdGl2ZSxcclxuICAgICAgICAgICAgdGFyZ2V0UmVsYXRpdmU7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICghQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIodGFyZ2V0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgdGFyZ2V0OiBOb3QgYSBCeXRlQnVmZmVyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0YXJnZXRPZmZzZXQgPSAodGFyZ2V0UmVsYXRpdmUgPSB0eXBlb2YgdGFyZ2V0T2Zmc2V0ID09PSAndW5kZWZpbmVkJykgPyB0YXJnZXQub2Zmc2V0IDogdGFyZ2V0T2Zmc2V0IHwgMDtcclxuICAgICAgICBzb3VyY2VPZmZzZXQgPSAocmVsYXRpdmUgPSB0eXBlb2Ygc291cmNlT2Zmc2V0ID09PSAndW5kZWZpbmVkJykgPyB0aGlzLm9mZnNldCA6IHNvdXJjZU9mZnNldCB8IDA7XHJcbiAgICAgICAgc291cmNlTGltaXQgPSB0eXBlb2Ygc291cmNlTGltaXQgPT09ICd1bmRlZmluZWQnID8gdGhpcy5saW1pdCA6IHNvdXJjZUxpbWl0IHwgMDtcclxuXHJcbiAgICAgICAgaWYgKHRhcmdldE9mZnNldCA8IDAgfHwgdGFyZ2V0T2Zmc2V0ID4gdGFyZ2V0LmJ1ZmZlci5ieXRlTGVuZ3RoKVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCB0YXJnZXQgcmFuZ2U6IDAgPD0gXCIrdGFyZ2V0T2Zmc2V0K1wiIDw9IFwiK3RhcmdldC5idWZmZXIuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgaWYgKHNvdXJjZU9mZnNldCA8IDAgfHwgc291cmNlTGltaXQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxyXG4gICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBzb3VyY2UgcmFuZ2U6IDAgPD0gXCIrc291cmNlT2Zmc2V0K1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG5cclxuICAgICAgICB2YXIgbGVuID0gc291cmNlTGltaXQgLSBzb3VyY2VPZmZzZXQ7XHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDsgLy8gTm90aGluZyB0byBjb3B5XHJcblxyXG4gICAgICAgIHRhcmdldC5lbnN1cmVDYXBhY2l0eSh0YXJnZXRPZmZzZXQgKyBsZW4pO1xyXG5cclxuICAgICAgICB0YXJnZXQudmlldy5zZXQodGhpcy52aWV3LnN1YmFycmF5KHNvdXJjZU9mZnNldCwgc291cmNlTGltaXQpLCB0YXJnZXRPZmZzZXQpO1xyXG5cclxuICAgICAgICBpZiAocmVsYXRpdmUpIHRoaXMub2Zmc2V0ICs9IGxlbjtcclxuICAgICAgICBpZiAodGFyZ2V0UmVsYXRpdmUpIHRhcmdldC5vZmZzZXQgKz0gbGVuO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlcyBzdXJlIHRoYXQgdGhpcyBCeXRlQnVmZmVyIGlzIGJhY2tlZCBieSBhIHtAbGluayBCeXRlQnVmZmVyI2J1ZmZlcn0gb2YgYXQgbGVhc3QgdGhlIHNwZWNpZmllZCBjYXBhY2l0eS4gSWYgdGhlXHJcbiAgICAgKiAgY3VycmVudCBjYXBhY2l0eSBpcyBleGNlZWRlZCwgaXQgd2lsbCBiZSBkb3VibGVkLiBJZiBkb3VibGUgdGhlIGN1cnJlbnQgY2FwYWNpdHkgaXMgbGVzcyB0aGFuIHRoZSByZXF1aXJlZCBjYXBhY2l0eSxcclxuICAgICAqICB0aGUgcmVxdWlyZWQgY2FwYWNpdHkgd2lsbCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2FwYWNpdHkgUmVxdWlyZWQgY2FwYWNpdHlcclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLmVuc3VyZUNhcGFjaXR5ID0gZnVuY3Rpb24oY2FwYWNpdHkpIHtcclxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgaWYgKGN1cnJlbnQgPCBjYXBhY2l0eSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplKChjdXJyZW50ICo9IDIpID4gY2FwYWNpdHkgPyBjdXJyZW50IDogY2FwYWNpdHkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE92ZXJ3cml0ZXMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlLiBDb250ZW50cyBhcmUgdGhlIGJ5dGVzIGJldHdlZW5cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGFuZCB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlIEJ5dGUgdmFsdWUgdG8gZmlsbCB3aXRoLiBJZiBnaXZlbiBhcyBhIHN0cmluZywgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyB1c2VkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBCZWdpbiBvZmZzZXQuIFdpbGwgdXNlIGFuZCBpbmNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICB3cml0dGVuIGlmIG9taXR0ZWQuIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBFbmQgb2Zmc2V0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqIEBleGFtcGxlIGBzb21lQnl0ZUJ1ZmZlci5jbGVhcigpLmZpbGwoMClgIGZpbGxzIHRoZSBlbnRpcmUgYmFja2luZyBidWZmZXIgd2l0aCB6ZXJvZXNcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24odmFsdWUsIGJlZ2luLCBlbmQpIHtcclxuICAgICAgICB2YXIgcmVsYXRpdmUgPSB0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJykgYmVnaW4gPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHZhbHVlOiBcIit2YWx1ZStcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmVnaW4gIT09ICdudW1iZXInIHx8IGJlZ2luICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGJlZ2luOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGJlZ2luID4+Pj0gMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCBlbmQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgZW5kOiBOb3QgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgICAgIGVuZCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAoYmVnaW4gPCAwIHx8IGJlZ2luID4gZW5kIHx8IGVuZCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IDAgPD0gXCIrYmVnaW4rXCIgPD0gXCIrZW5kK1wiIDw9IFwiK3RoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJlZ2luID49IGVuZClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIE5vdGhpbmcgdG8gZmlsbFxyXG4gICAgICAgIHdoaWxlIChiZWdpbiA8IGVuZCkgdGhpcy52aWV3W2JlZ2luKytdID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlKSB0aGlzLm9mZnNldCA9IGJlZ2luO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIHRoaXMgQnl0ZUJ1ZmZlciByZWFkeSBmb3IgYSBuZXcgc2VxdWVuY2Ugb2Ygd3JpdGUgb3IgcmVsYXRpdmUgcmVhZCBvcGVyYXRpb25zLiBTZXRzIGBsaW1pdCA9IG9mZnNldGAgYW5kXHJcbiAgICAgKiAgYG9mZnNldCA9IDBgLiBNYWtlIHN1cmUgYWx3YXlzIHRvIGZsaXAgYSBCeXRlQnVmZmVyIHdoZW4gYWxsIHJlbGF0aXZlIHJlYWQgb3Igd3JpdGUgb3BlcmF0aW9ucyBhcmUgY29tcGxldGUuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5mbGlwID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5saW1pdCA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE1hcmtzIGFuIG9mZnNldCBvbiB0aGlzIEJ5dGVCdWZmZXIgdG8gYmUgdXNlZCBsYXRlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gb2Zmc2V0IE9mZnNldCB0byBtYXJrLiBEZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvZmZzZXRgIGlzIG5vdCBhIHZhbGlkIG51bWJlclxyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYG9mZnNldGAgaXMgb3V0IG9mIGJvdW5kc1xyXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI3Jlc2V0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUubWFyayA9IGZ1bmN0aW9uKG9mZnNldCkge1xyXG4gICAgICAgIG9mZnNldCA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnID8gdGhpcy5vZmZzZXQgOiBvZmZzZXQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJyB8fCBvZmZzZXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgb2Zmc2V0OiBcIitvZmZzZXQrXCIgKG5vdCBhbiBpbnRlZ2VyKVwiKTtcbiAgICAgICAgICAgIG9mZnNldCA+Pj49IDA7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgKyAwID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IDAgPD0gXCIrb2Zmc2V0K1wiICgrXCIrMCtcIikgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1hcmtlZE9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGJ5dGUgb3JkZXIuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxpdHRsZUVuZGlhbiBgdHJ1ZWAgZm9yIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlciwgYGZhbHNlYCBmb3IgYmlnIGVuZGlhblxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUub3JkZXIgPSBmdW5jdGlvbihsaXR0bGVFbmRpYW4pIHtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXR0bGVFbmRpYW4gIT09ICdib29sZWFuJylcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgbGl0dGxlRW5kaWFuOiBOb3QgYSBib29sZWFuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9ICEhbGl0dGxlRW5kaWFuO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN3aXRjaGVzICh0bykgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIERlZmF1bHRzIHRvIGB0cnVlYCwgb3RoZXJ3aXNlIHVzZXMgYmlnIGVuZGlhblxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuTEUgPSBmdW5jdGlvbihsaXR0bGVFbmRpYW4pIHtcclxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IHR5cGVvZiBsaXR0bGVFbmRpYW4gIT09ICd1bmRlZmluZWQnID8gISFsaXR0bGVFbmRpYW4gOiB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN3aXRjaGVzICh0bykgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gYmlnRW5kaWFuIERlZmF1bHRzIHRvIGB0cnVlYCwgb3RoZXJ3aXNlIHVzZXMgbGl0dGxlIGVuZGlhblxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuQkUgPSBmdW5jdGlvbihiaWdFbmRpYW4pIHtcclxuICAgICAgICB0aGlzLmxpdHRsZUVuZGlhbiA9IHR5cGVvZiBiaWdFbmRpYW4gIT09ICd1bmRlZmluZWQnID8gIWJpZ0VuZGlhbiA6IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUHJlcGVuZHMgc29tZSBkYXRhIHRvIHRoaXMgQnl0ZUJ1ZmZlci4gVGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgY29udGVudHMgYmVmb3JlIHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHVwIHRvIHRoZVxyXG4gICAgICogIHByZXBlbmRlZCBkYXRhJ3MgbGVuZ3RoLiBJZiB0aGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSBiZWZvcmUgdGhlIHNwZWNpZmllZCBgb2Zmc2V0YCwgdGhlIGJhY2tpbmcgYnVmZmVyXHJcbiAgICAgKiAgd2lsbCBiZSByZXNpemVkIGFuZCBpdHMgY29udGVudHMgbW92ZWQgYWNjb3JkaW5nbHkuXHJcbiAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfHN0cmluZ3whQXJyYXlCdWZmZXJ9IHNvdXJjZSBEYXRhIHRvIHByZXBlbmQuIElmIGBzb3VyY2VgIGlzIGEgQnl0ZUJ1ZmZlciwgaXRzIG9mZnNldCB3aWxsIGJlXHJcbiAgICAgKiAgbW9kaWZpZWQgYWNjb3JkaW5nIHRvIHRoZSBwZXJmb3JtZWQgcmVhZCBvcGVyYXRpb24uXHJcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKT19IGVuY29kaW5nIEVuY29kaW5nIGlmIGBkYXRhYCBpcyBhIHN0cmluZyAoXCJiYXNlNjRcIiwgXCJoZXhcIiwgXCJiaW5hcnlcIiwgZGVmYXVsdHMgdG8gXCJ1dGY4XCIpXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9mZnNldCBPZmZzZXQgdG8gcHJlcGVuZCBhdC4gV2lsbCB1c2UgYW5kIGRlY3JlYXNlIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYnkgdGhlIG51bWJlciBvZiBieXRlc1xyXG4gICAgICogIHByZXBlbmRlZCBpZiBvbWl0dGVkLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAZXhhbXBsZSBBIHJlbGF0aXZlIGAwMDwwMSAwMiAwMz4ucHJlcGVuZCg8MDQgMDU+KWAgcmVzdWx0cyBpbiBgPDA0IDA1IDAxIDAyIDAzPiwgMDQgMDV8YFxyXG4gICAgICogQGV4YW1wbGUgQW4gYWJzb2x1dGUgYDAwPDAxIDAyIDAzPi5wcmVwZW5kKDwwNCAwNT4sIDIpYCByZXN1bHRzIGluIGAwNDwwNSAwMiAwMz4sIDA0IDA1fGBcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24oc291cmNlLCBlbmNvZGluZywgb2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSBlbmNvZGluZztcclxuICAgICAgICAgICAgZW5jb2RpbmcgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZWxhdGl2ZSA9IHR5cGVvZiBvZmZzZXQgPT09ICd1bmRlZmluZWQnO1xuICAgICAgICBpZiAocmVsYXRpdmUpIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICdudW1iZXInIHx8IG9mZnNldCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBvZmZzZXQ6IFwiK29mZnNldCtcIiAobm90IGFuIGludGVnZXIpXCIpO1xuICAgICAgICAgICAgb2Zmc2V0ID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCArIDAgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogMCA8PSBcIitvZmZzZXQrXCIgKCtcIiswK1wiKSA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIEJ5dGVCdWZmZXIpKVxyXG4gICAgICAgICAgICBzb3VyY2UgPSBCeXRlQnVmZmVyLndyYXAoc291cmNlLCBlbmNvZGluZyk7XHJcbiAgICAgICAgdmFyIGxlbiA9IHNvdXJjZS5saW1pdCAtIHNvdXJjZS5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKGxlbiA8PSAwKSByZXR1cm4gdGhpczsgLy8gTm90aGluZyB0byBwcmVwZW5kXHJcbiAgICAgICAgdmFyIGRpZmYgPSBsZW4gLSBvZmZzZXQ7XHJcbiAgICAgICAgaWYgKGRpZmYgPiAwKSB7IC8vIE5vdCBlbm91Z2ggc3BhY2UgYmVmb3JlIG9mZnNldCwgc28gcmVzaXplICsgbW92ZVxyXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGggKyBkaWZmKTtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgICAgICAgICB2aWV3LnNldCh0aGlzLnZpZXcuc3ViYXJyYXkob2Zmc2V0LCB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSwgbGVuKTtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IGRpZmY7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcmtlZE9mZnNldCA+PSAwKSB0aGlzLm1hcmtlZE9mZnNldCArPSBkaWZmO1xyXG4gICAgICAgICAgICB0aGlzLmxpbWl0ICs9IGRpZmY7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSBkaWZmO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBhcnJheVZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmlldy5zZXQoc291cmNlLnZpZXcuc3ViYXJyYXkoc291cmNlLm9mZnNldCwgc291cmNlLmxpbWl0KSwgb2Zmc2V0IC0gbGVuKTtcclxuXHJcbiAgICAgICAgc291cmNlLm9mZnNldCA9IHNvdXJjZS5saW1pdDtcclxuICAgICAgICBpZiAocmVsYXRpdmUpXHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0IC09IGxlbjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwZW5kcyB0aGlzIEJ5dGVCdWZmZXIgdG8gYW5vdGhlciBCeXRlQnVmZmVyLiBUaGlzIHdpbGwgb3ZlcndyaXRlIGFueSBjb250ZW50cyBiZWZvcmUgdGhlIHNwZWNpZmllZCBvZmZzZXQgdXAgdG8gdGhlXHJcbiAgICAgKiAgcHJlcGVuZGVkIGRhdGEncyBsZW5ndGguIElmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGBvZmZzZXRgLCB0aGUgYmFja2luZyBidWZmZXJcclxuICAgICAqICB3aWxsIGJlIHJlc2l6ZWQgYW5kIGl0cyBjb250ZW50cyBtb3ZlZCBhY2NvcmRpbmdseS5cclxuICAgICAqIEBwYXJhbSB7IUJ5dGVCdWZmZXJ9IHRhcmdldCBUYXJnZXQgQnl0ZUJ1ZmZlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBvZmZzZXQgT2Zmc2V0IHRvIHByZXBlbmQgYXQuIFdpbGwgdXNlIGFuZCBkZWNyZWFzZSB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9IGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXNcclxuICAgICAqICBwcmVwZW5kZWQgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICogQHNlZSBCeXRlQnVmZmVyI3ByZXBlbmRcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS5wcmVwZW5kVG8gPSBmdW5jdGlvbih0YXJnZXQsIG9mZnNldCkge1xyXG4gICAgICAgIHRhcmdldC5wcmVwZW5kKHRoaXMsIG9mZnNldCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcmludHMgZGVidWcgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMuXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyk9fSBvdXQgT3V0cHV0IGZ1bmN0aW9uIHRvIGNhbGwsIGRlZmF1bHRzIHRvIGNvbnNvbGUubG9nXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucHJpbnREZWJ1ZyA9IGZ1bmN0aW9uKG91dCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb3V0ICE9PSAnZnVuY3Rpb24nKSBvdXQgPSBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xyXG4gICAgICAgIG91dChcclxuICAgICAgICAgICAgdGhpcy50b1N0cmluZygpK1wiXFxuXCIrXHJcbiAgICAgICAgICAgIFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiK1xyXG4gICAgICAgICAgICB0aGlzLnRvRGVidWcoLyogY29sdW1ucyAqLyB0cnVlKVxyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHJlbWFpbmluZyByZWFkYWJsZSBieXRlcy4gQ29udGVudHMgYXJlIHRoZSBieXRlcyBiZXR3ZWVuIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LCBzbyB0aGlzIHJldHVybnMgYGxpbWl0IC0gb2Zmc2V0YC5cclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJlbWFpbmluZyByZWFkYWJsZSBieXRlcy4gTWF5IGJlIG5lZ2F0aXZlIGlmIGBvZmZzZXQgPiBsaW1pdGAuXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVtYWluaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGltaXQgLSB0aGlzLm9mZnNldDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGlzIEJ5dGVCdWZmZXIncyB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9LiBJZiBhbiBvZmZzZXQgaGFzIGJlZW4gbWFya2VkIHRocm91Z2gge0BsaW5rIEJ5dGVCdWZmZXIjbWFya31cclxuICAgICAqICBiZWZvcmUsIGBvZmZzZXRgIHdpbGwgYmUgc2V0IHRvIHtAbGluayBCeXRlQnVmZmVyI21hcmtlZE9mZnNldH0sIHdoaWNoIHdpbGwgdGhlbiBiZSBkaXNjYXJkZWQuIElmIG5vIG9mZnNldCBoYXMgYmVlblxyXG4gICAgICogIG1hcmtlZCwgc2V0cyBgb2Zmc2V0ID0gMGAuXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEBzZWUgQnl0ZUJ1ZmZlciNtYXJrXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5tYXJrZWRPZmZzZXQgPj0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IHRoaXMubWFya2VkT2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLm1hcmtlZE9mZnNldCA9IC0xO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVzIHRoaXMgQnl0ZUJ1ZmZlciB0byBiZSBiYWNrZWQgYnkgYSBidWZmZXIgb2YgYXQgbGVhc3QgdGhlIGdpdmVuIGNhcGFjaXR5LiBXaWxsIGRvIG5vdGhpbmcgaWYgYWxyZWFkeSB0aGF0XHJcbiAgICAgKiAgbGFyZ2Ugb3IgbGFyZ2VyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNhcGFjaXR5IENhcGFjaXR5IHJlcXVpcmVkXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IHRoaXNcclxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYGNhcGFjaXR5YCBpcyBub3QgYSBudW1iZXJcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBjYXBhY2l0eSA8IDBgXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24oY2FwYWNpdHkpIHtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjYXBhY2l0eSAhPT0gJ251bWJlcicgfHwgY2FwYWNpdHkgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgY2FwYWNpdHk6IFwiK2NhcGFjaXR5K1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBjYXBhY2l0eSB8PSAwO1xuICAgICAgICAgICAgaWYgKGNhcGFjaXR5IDwgMClcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIGNhcGFjaXR5OiAwIDw9IFwiK2NhcGFjaXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGggPCBjYXBhY2l0eSkge1xyXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGNhcGFjaXR5KTtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgICAgICAgICB2aWV3LnNldCh0aGlzLnZpZXcpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICAgICAgdGhpcy52aWV3ID0gdmlldztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXZlcnNlcyB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gT2Zmc2V0IHRvIHN0YXJ0IGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBPZmZzZXQgdG8gZW5kIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH1cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gdGhpc1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiZWdpbiA9PT0gZW5kKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gTm90aGluZyB0byByZXZlcnNlXHJcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbCh0aGlzLnZpZXcuc3ViYXJyYXkoYmVnaW4sIGVuZCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2tpcHMgdGhlIG5leHQgYGxlbmd0aGAgYnl0ZXMuIFRoaXMgd2lsbCBqdXN0IGFkdmFuY2VcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAuIE1heSBhbHNvIGJlIG5lZ2F0aXZlIHRvIG1vdmUgdGhlIG9mZnNldCBiYWNrLlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSB0aGlzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicgfHwgbGVuZ3RoICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGxlbmd0aDogXCIrbGVuZ3RoK1wiIChub3QgYW4gaW50ZWdlcilcIik7XG4gICAgICAgICAgICBsZW5ndGggfD0gMDtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIGxlbmd0aDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIGxlbmd0aDogMCA8PSBcIit0aGlzLm9mZnNldCtcIiArIFwiK2xlbmd0aCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2xpY2VzIHRoaXMgQnl0ZUJ1ZmZlciBieSBjcmVhdGluZyBhIGNsb25lZCBpbnN0YW5jZSB3aXRoIGBvZmZzZXQgPSBiZWdpbmAgYW5kIGBsaW1pdCA9IGVuZGAuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIEJlZ2luIG9mZnNldCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIEVuZCBvZmZzZXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQ2xvbmUgb2YgdGhpcyBCeXRlQnVmZmVyIHdpdGggc2xpY2luZyBhcHBsaWVkLCBiYWNrZWQgYnkgdGhlIHNhbWUge0BsaW5rIEJ5dGVCdWZmZXIjYnVmZmVyfVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmVnaW4gPT09ICd1bmRlZmluZWQnKSBiZWdpbiA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykgZW5kID0gdGhpcy5saW1pdDtcclxuICAgICAgICBpZiAoIXRoaXMubm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiAhPT0gJ251bWJlcicgfHwgYmVnaW4gJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgYmVnaW46IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgYmVnaW4gPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IGVuZCAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBlbmQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgZW5kID4+Pj0gMDtcbiAgICAgICAgICAgIGlmIChiZWdpbiA8IDAgfHwgYmVnaW4gPiBlbmQgfHwgZW5kID4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBSYW5nZUVycm9yKFwiSWxsZWdhbCByYW5nZTogMCA8PSBcIitiZWdpbitcIiA8PSBcIitlbmQrXCIgPD0gXCIrdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmIgPSB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgYmIub2Zmc2V0ID0gYmVnaW47XHJcbiAgICAgICAgYmIubGltaXQgPSBlbmQ7XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGJhY2tpbmcgYnVmZmVyIHRoYXQgY29udGFpbnMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMuIENvbnRlbnRzIGFyZSB0aGUgYnl0ZXMgYmV0d2VlblxyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZvcmNlQ29weSBJZiBgdHJ1ZWAgcmV0dXJucyBhIGNvcHksIG90aGVyd2lzZSByZXR1cm5zIGEgdmlldyByZWZlcmVuY2luZyB0aGUgc2FtZSBtZW1vcnkgaWZcclxuICAgICAqICBwb3NzaWJsZS4gRGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICogQHJldHVybnMgeyFBcnJheUJ1ZmZlcn0gQ29udGVudHMgYXMgYW4gQXJyYXlCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKGZvcmNlQ29weSkge1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCxcclxuICAgICAgICAgICAgbGltaXQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ251bWJlcicgfHwgb2Zmc2V0ICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIG9mZnNldDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBvZmZzZXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaW1pdCAhPT0gJ251bWJlcicgfHwgbGltaXQgJSAxICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgbGltaXQ6IE5vdCBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgbGltaXQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gbGltaXQgfHwgbGltaXQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK29mZnNldCtcIiA8PSBcIitsaW1pdCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5PVEU6IEl0J3Mgbm90IHBvc3NpYmxlIHRvIGhhdmUgYW5vdGhlciBBcnJheUJ1ZmZlciByZWZlcmVuY2UgdGhlIHNhbWUgbWVtb3J5IGFzIHRoZSBiYWNraW5nIGJ1ZmZlci4gVGhpcyBpc1xyXG4gICAgICAgIC8vIHBvc3NpYmxlIHdpdGggVWludDhBcnJheSNzdWJhcnJheSBvbmx5LCBidXQgd2UgaGF2ZSB0byByZXR1cm4gYW4gQXJyYXlCdWZmZXIgYnkgY29udHJhY3QuIFNvOlxyXG4gICAgICAgIGlmICghZm9yY2VDb3B5ICYmIG9mZnNldCA9PT0gMCAmJiBsaW1pdCA9PT0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xyXG4gICAgICAgIGlmIChvZmZzZXQgPT09IGxpbWl0KVxyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xyXG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIobGltaXQgLSBvZmZzZXQpO1xyXG4gICAgICAgIG5ldyBVaW50OEFycmF5KGJ1ZmZlcikuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyKS5zdWJhcnJheShvZmZzZXQsIGxpbWl0KSwgMCk7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcmF3IGJ1ZmZlciBjb21wYWN0ZWQgdG8gY29udGFpbiB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cy4gQ29udGVudHMgYXJlIHRoZSBieXRlcyBiZXR3ZWVuXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fSBhbmQge0BsaW5rIEJ5dGVCdWZmZXIjbGltaXR9LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBCeXRlQnVmZmVyI3RvQnVmZmVyfS5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VDb3B5IElmIGB0cnVlYCByZXR1cm5zIGEgY29weSwgb3RoZXJ3aXNlIHJldHVybnMgYSB2aWV3IHJlZmVyZW5jaW5nIHRoZSBzYW1lIG1lbW9yeS5cclxuICAgICAqICBEZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgKiBAcmV0dXJucyB7IUFycmF5QnVmZmVyfSBDb250ZW50cyBhcyBhbiBBcnJheUJ1ZmZlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBCeXRlQnVmZmVyUHJvdG90eXBlLnRvQnVmZmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIEJ5dGVCdWZmZXIncyBjb250ZW50cyB0byBhIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gZW5jb2RpbmcgT3V0cHV0IGVuY29kaW5nLiBSZXR1cm5zIGFuIGluZm9ybWF0aXZlIHN0cmluZyByZXByZXNlbnRhdGlvbiBpZiBvbWl0dGVkIGJ1dCBhbHNvIGFsbG93c1xyXG4gICAgICogIGRpcmVjdCBjb252ZXJzaW9uIHRvIFwidXRmOFwiLCBcImhleFwiLCBcImJhc2U2NFwiIGFuZCBcImJpbmFyeVwiIGVuY29kaW5nLiBcImRlYnVnXCIgcmV0dXJucyBhIGhleCByZXByZXNlbnRhdGlvbiB3aXRoXHJcbiAgICAgKiAgaGlnaGxpZ2h0ZWQgb2Zmc2V0cy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gYmVnaW4gT2Zmc2V0IHRvIGJlZ2luIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNvZmZzZXR9XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBPZmZzZXQgdG8gZW5kIGF0LCBkZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH1cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvblxyXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIGBlbmNvZGluZ2AgaXMgaW52YWxpZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oZW5jb2RpbmcsIGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgcmV0dXJuIFwiQnl0ZUJ1ZmZlckFCKG9mZnNldD1cIit0aGlzLm9mZnNldCtcIixtYXJrZWRPZmZzZXQ9XCIrdGhpcy5tYXJrZWRPZmZzZXQrXCIsbGltaXQ9XCIrdGhpcy5saW1pdCtcIixjYXBhY2l0eT1cIit0aGlzLmNhcGFjaXR5KCkrXCIpXCI7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgIGVuY29kaW5nID0gXCJ1dGY4XCIsIGJlZ2luID0gZW5jb2RpbmcsIGVuZCA9IGJlZ2luO1xyXG4gICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcclxuICAgICAgICAgICAgY2FzZSBcInV0ZjhcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvVVRGOChiZWdpbiwgZW5kKTtcclxuICAgICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CYXNlNjQoYmVnaW4sIGVuZCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJoZXhcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSGV4KGJlZ2luLCBlbmQpO1xyXG4gICAgICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0JpbmFyeShiZWdpbiwgZW5kKTtcclxuICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RlYnVnKCk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJjb2x1bW5zXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0NvbHVtbnMoKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5zdXBwb3J0ZWQgZW5jb2Rpbmc6IFwiK2VuY29kaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGx4aXYtZW1iZWRkYWJsZVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogbHhpdi1lbWJlZGRhYmxlIChjKSAyMDE0IERhbmllbCBXaXJ0eiA8ZGNvZGVAZGNvZGUuaW8+XHJcbiAgICAgKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAgICAgKiBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL2x4aXYgZm9yIGRldGFpbHNcclxuICAgICAqL1xyXG4gICAgdmFyIGx4aXYgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogbHhpdiBuYW1lc3BhY2UuXHJcbiAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAgICAgKiBAZXhwb3J0cyBseGl2XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGx4aXYgPSB7fTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hhcmFjdGVyIGNvZGVzIGZvciBvdXRwdXQuXHJcbiAgICAgICAgICogQHR5cGUgeyFBcnJheS48bnVtYmVyPn1cclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgYW91dCA9IFtcclxuICAgICAgICAgICAgNjUsIDY2LCA2NywgNjgsIDY5LCA3MCwgNzEsIDcyLCA3MywgNzQsIDc1LCA3NiwgNzcsIDc4LCA3OSwgODAsXHJcbiAgICAgICAgICAgIDgxLCA4MiwgODMsIDg0LCA4NSwgODYsIDg3LCA4OCwgODksIDkwLCA5NywgOTgsIDk5LCAxMDAsIDEwMSwgMTAyLFxyXG4gICAgICAgICAgICAxMDMsIDEwNCwgMTA1LCAxMDYsIDEwNywgMTA4LCAxMDksIDExMCwgMTExLCAxMTIsIDExMywgMTE0LCAxMTUsIDExNiwgMTE3LCAxMTgsXHJcbiAgICAgICAgICAgIDExOSwgMTIwLCAxMjEsIDEyMiwgNDgsIDQ5LCA1MCwgNTEsIDUyLCA1MywgNTQsIDU1LCA1NiwgNTcsIDQzLCA0N1xyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoYXJhY3RlciBjb2RlcyBmb3IgaW5wdXQuXHJcbiAgICAgICAgICogQHR5cGUgeyFBcnJheS48bnVtYmVyPn1cclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgYWluID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaT0wLCBrPWFvdXQubGVuZ3RoOyBpPGs7ICsraSlcclxuICAgICAgICAgICAgYWluW2FvdXRbaV1dID0gaTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyBieXRlcyB0byBiYXNlNjQgY2hhciBjb2Rlcy5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbigpOm51bWJlcnxudWxsfSBzcmMgQnl0ZXMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGJ5dGUgcmVzcGVjdGl2ZWx5IGBudWxsYCBpZlxyXG4gICAgICAgICAqICB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBsZWZ0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBDaGFyYWN0ZXJzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIGVhY2ggZW5jb2RlZCBjaGFyXHJcbiAgICAgICAgICogIGNvZGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbHhpdi5lbmNvZGUgPSBmdW5jdGlvbihzcmMsIGRzdCkge1xyXG4gICAgICAgICAgICB2YXIgYiwgdDtcclxuICAgICAgICAgICAgd2hpbGUgKChiID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBkc3QoYW91dFsoYj4+MikmMHgzZl0pO1xyXG4gICAgICAgICAgICAgICAgdCA9IChiJjB4Myk8PDQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGIgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0IHw9IChiPj40KSYweGY7XHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KGFvdXRbKHR8KChiPj40KSYweGYpKSYweDNmXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IChiJjB4Zik8PDI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChiID0gc3JjKCkpICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkc3QoYW91dFsodHwoKGI+PjYpJjB4MykpJjB4M2ZdKSwgZHN0KGFvdXRbYiYweDNmXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkc3QoYW91dFt0JjB4M2ZdKSwgZHN0KDYxKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGRzdChhb3V0W3QmMHgzZl0pLCBkc3QoNjEpLCBkc3QoNjEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBiYXNlNjQgY2hhciBjb2RlcyB0byBieXRlcy5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbigpOm51bWJlcnxudWxsfSBzcmMgQ2hhcmFjdGVycyBzb3VyY2UgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgY2hhciBjb2RlIHJlc3BlY3RpdmVseVxyXG4gICAgICAgICAqICBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyBsZWZ0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBCeXRlcyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCB0aGUgbmV4dCBieXRlLlxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhIGNoYXJhY3RlciBjb2RlIGlzIGludmFsaWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBseGl2LmRlY29kZSA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XHJcbiAgICAgICAgICAgIHZhciBjLCB0MSwgdDI7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZhaWwoYykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGNoYXJhY3RlciBjb2RlOiBcIitjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAoKGMgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHQxID0gYWluW2NdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0MSA9PT0gJ3VuZGVmaW5lZCcpIGZhaWwoYyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGMgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0MiA9IGFpbltjXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHQyID09PSAndW5kZWZpbmVkJykgZmFpbChjKTtcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKHQxPDwyKT4+PjB8KHQyJjB4MzApPj40KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGMgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdDEgPSBhaW5bY107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdDEgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IDYxKSBicmVhazsgZWxzZSBmYWlsKGMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkc3QoKCh0MiYweGYpPDw0KT4+PjB8KHQxJjB4M2MpPj4yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MiA9IGFpbltjXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdDIgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjID09PSA2MSkgYnJlYWs7IGVsc2UgZmFpbChjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRzdCgoKHQxJjB4Myk8PDYpPj4+MHx0Mik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIHN0cmluZyBpcyB2YWxpZCBiYXNlNjQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gdGVzdFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdmFsaWQsIG90aGVyd2lzZSBgZmFsc2VgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbHhpdi50ZXN0ID0gZnVuY3Rpb24oc3RyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdChzdHIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBseGl2O1xyXG4gICAgfSgpO1xyXG5cclxuICAgIC8vIGVuY29kaW5ncy9iYXNlNjRcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIE9mZnNldCB0byBiZWdpbiBhdCwgZGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIE9mZnNldCB0byBlbmQgYXQsIGRlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYGJlZ2luYCBvciBgZW5kYCBpcyBvdXQgb2YgYm91bmRzXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXJQcm90b3R5cGUudG9CYXNlNjQgPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIGJlZ2luID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBlbmQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGJlZ2luID0gYmVnaW4gfCAwOyBlbmQgPSBlbmQgfCAwO1xyXG4gICAgICAgIGlmIChiZWdpbiA8IDAgfHwgZW5kID4gdGhpcy5jYXBhY2l0eSB8fCBiZWdpbiA+IGVuZClcclxuICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcImJlZ2luLCBlbmRcIik7XHJcbiAgICAgICAgdmFyIHNkOyBseGl2LmVuY29kZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJlZ2luIDwgZW5kID8gdGhpcy52aWV3W2JlZ2luKytdIDogbnVsbDtcclxuICAgICAgICB9LmJpbmQodGhpcyksIHNkID0gc3RyaW5nRGVzdGluYXRpb24oKSk7XHJcbiAgICAgICAgcmV0dXJuIHNkKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byBhIEJ5dGVCdWZmZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBkZWNvZGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRvIHVzZSBsaXR0bGUgb3IgYmlnIGVuZGlhbiBieXRlIG9yZGVyLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfRU5ESUFOfS5cclxuICAgICAqIEByZXR1cm5zIHshQnl0ZUJ1ZmZlcn0gQnl0ZUJ1ZmZlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmZyb21CYXNlNjQgPSBmdW5jdGlvbihzdHIsIGxpdHRsZUVuZGlhbikge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwic3RyXCIpO1xyXG4gICAgICAgIHZhciBiYiA9IG5ldyBCeXRlQnVmZmVyKHN0ci5sZW5ndGgvNCozLCBsaXR0bGVFbmRpYW4pLFxyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICBseGl2LmRlY29kZShzdHJpbmdTb3VyY2Uoc3RyKSwgZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICBiYi52aWV3W2krK10gPSBiO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGJiLmxpbWl0ID0gaTtcclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyBhIGJpbmFyeSBzdHJpbmcgdG8gYmFzZTY0IGxpa2UgYHdpbmRvdy5idG9hYCBkb2VzLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBCaW5hcnkgc3RyaW5nXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy5idG9hXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuYnRvYSA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21CaW5hcnkoc3RyKS50b0Jhc2U2NCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYmluYXJ5IGxpa2UgYHdpbmRvdy5hdG9iYCBkb2VzLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGI2NCBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEJpbmFyeSBzdHJpbmdcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy5hdG9iXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuYXRvYiA9IGZ1bmN0aW9uKGI2NCkge1xyXG4gICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmZyb21CYXNlNjQoYjY0KS50b0JpbmFyeSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBlbmNvZGluZ3MvYmluYXJ5XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIHRoaXMgQnl0ZUJ1ZmZlciB0byBhIGJpbmFyeSBlbmNvZGVkIHN0cmluZywgdGhhdCBpcyB1c2luZyBvbmx5IGNoYXJhY3RlcnMgMHgwMC0weEZGIGFzIGJ5dGVzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBiZWdpbiBPZmZzZXQgdG8gYmVnaW4gYXQuIERlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGVuZCBPZmZzZXQgdG8gZW5kIGF0LiBEZWZhdWx0cyB0byB7QGxpbmsgQnl0ZUJ1ZmZlciNsaW1pdH0uXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBCaW5hcnkgZW5jb2RlZCBzdHJpbmdcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXQgPiBsaW1pdGBcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b0JpbmFyeSA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgYmVnaW4gPSB0aGlzLm9mZnNldDtcclxuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgIGVuZCA9IHRoaXMubGltaXQ7XHJcbiAgICAgICAgYmVnaW4gfD0gMDsgZW5kIHw9IDA7XHJcbiAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBlbmQgPiB0aGlzLmNhcGFjaXR5KCkgfHwgYmVnaW4gPiBlbmQpXHJcbiAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJiZWdpbiwgZW5kXCIpO1xyXG4gICAgICAgIGlmIChiZWdpbiA9PT0gZW5kKVxyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB2YXIgY2hhcnMgPSBbXSxcclxuICAgICAgICAgICAgcGFydHMgPSBbXTtcclxuICAgICAgICB3aGlsZSAoYmVnaW4gPCBlbmQpIHtcclxuICAgICAgICAgICAgY2hhcnMucHVzaCh0aGlzLnZpZXdbYmVnaW4rK10pO1xyXG4gICAgICAgICAgICBpZiAoY2hhcnMubGVuZ3RoID49IDEwMjQpXHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaGFycykpLCBjaGFycyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbignJykgKyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2hhcnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYSBiaW5hcnkgZW5jb2RlZCBzdHJpbmcsIHRoYXQgaXMgdXNpbmcgb25seSBjaGFyYWN0ZXJzIDB4MDAtMHhGRiBhcyBieXRlcywgdG8gYSBCeXRlQnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IEJ5dGVCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5mcm9tQmluYXJ5ID0gZnVuY3Rpb24oc3RyLCBsaXR0bGVFbmRpYW4pIHtcclxuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcInN0clwiKTtcclxuICAgICAgICB2YXIgaSA9IDAsXHJcbiAgICAgICAgICAgIGsgPSBzdHIubGVuZ3RoLFxyXG4gICAgICAgICAgICBjaGFyQ29kZSxcclxuICAgICAgICAgICAgYmIgPSBuZXcgQnl0ZUJ1ZmZlcihrLCBsaXR0bGVFbmRpYW4pO1xyXG4gICAgICAgIHdoaWxlIChpPGspIHtcclxuICAgICAgICAgICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICAgICAgaWYgKGNoYXJDb2RlID4gMHhmZilcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJpbGxlZ2FsIGNoYXIgY29kZTogXCIrY2hhckNvZGUpO1xyXG4gICAgICAgICAgICBiYi52aWV3W2krK10gPSBjaGFyQ29kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmIubGltaXQgPSBrO1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLy8gZW5jb2RpbmdzL2RlYnVnXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIHRoaXMgQnl0ZUJ1ZmZlciB0byBhIGhleCBlbmNvZGVkIHN0cmluZyB3aXRoIG1hcmtlZCBvZmZzZXRzLiBPZmZzZXQgc3ltYm9scyBhcmU6XHJcbiAgICAgKiAqIGA8YCA6IG9mZnNldCxcclxuICAgICAqICogYCdgIDogbWFya2VkT2Zmc2V0LFxyXG4gICAgICogKiBgPmAgOiBsaW1pdCxcclxuICAgICAqICogYHxgIDogb2Zmc2V0IGFuZCBsaW1pdCxcclxuICAgICAqICogYFtgIDogb2Zmc2V0IGFuZCBtYXJrZWRPZmZzZXQsXHJcbiAgICAgKiAqIGBdYCA6IG1hcmtlZE9mZnNldCBhbmQgbGltaXQsXHJcbiAgICAgKiAqIGAhYCA6IG9mZnNldCwgbWFya2VkT2Zmc2V0IGFuZCBsaW1pdFxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gY29sdW1ucyBJZiBgdHJ1ZWAgcmV0dXJucyB0d28gY29sdW1ucyBoZXggKyBhc2NpaSwgZGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3whQXJyYXkuPHN0cmluZz59IERlYnVnIHN0cmluZyBvciBhcnJheSBvZiBsaW5lcyBpZiBgYXNBcnJheSA9IHRydWVgXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAZXhhbXBsZSBgPjAwJzAxIDAyPDAzYCBjb250YWlucyBmb3VyIGJ5dGVzIHdpdGggYGxpbWl0PTAsIG1hcmtlZE9mZnNldD0xLCBvZmZzZXQ9M2BcclxuICAgICAqIEBleGFtcGxlIGAwMFswMSAwMiAwMz5gIGNvbnRhaW5zIGZvdXIgYnl0ZXMgd2l0aCBgb2Zmc2V0PW1hcmtlZE9mZnNldD0xLCBsaW1pdD00YFxyXG4gICAgICogQGV4YW1wbGUgYDAwfDAxIDAyIDAzYCBjb250YWlucyBmb3VyIGJ5dGVzIHdpdGggYG9mZnNldD1saW1pdD0xLCBtYXJrZWRPZmZzZXQ9LTFgXHJcbiAgICAgKiBAZXhhbXBsZSBgfGAgY29udGFpbnMgemVybyBieXRlcyB3aXRoIGBvZmZzZXQ9bGltaXQ9MCwgbWFya2VkT2Zmc2V0PS0xYFxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvRGVidWcgPSBmdW5jdGlvbihjb2x1bW5zKSB7XHJcbiAgICAgICAgdmFyIGkgPSAtMSxcclxuICAgICAgICAgICAgayA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgsXHJcbiAgICAgICAgICAgIGIsXHJcbiAgICAgICAgICAgIGhleCA9IFwiXCIsXHJcbiAgICAgICAgICAgIGFzYyA9IFwiXCIsXHJcbiAgICAgICAgICAgIG91dCA9IFwiXCI7XHJcbiAgICAgICAgd2hpbGUgKGk8aykge1xyXG4gICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGIgPSB0aGlzLnZpZXdbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoYiA8IDB4MTApIGhleCArPSBcIjBcIitiLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBoZXggKz0gYi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5zKVxyXG4gICAgICAgICAgICAgICAgICAgIGFzYyArPSBiID4gMzIgJiYgYiA8IDEyNyA/IFN0cmluZy5mcm9tQ2hhckNvZGUoYikgOiAnLic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBpZiAoY29sdW1ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwICYmIGkgJSAxNiA9PT0gMCAmJiBpICE9PSBrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGhleC5sZW5ndGggPCAzKjE2KzMpIGhleCArPSBcIiBcIjtcclxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gaGV4K2FzYytcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGhleCA9IGFzYyA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGkgPT09IHRoaXMub2Zmc2V0ICYmIGkgPT09IHRoaXMubGltaXQpXHJcbiAgICAgICAgICAgICAgICBoZXggKz0gaSA9PT0gdGhpcy5tYXJrZWRPZmZzZXQgPyBcIiFcIiA6IFwifFwiO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpID09PSB0aGlzLm9mZnNldClcclxuICAgICAgICAgICAgICAgIGhleCArPSBpID09PSB0aGlzLm1hcmtlZE9mZnNldCA/IFwiW1wiIDogXCI8XCI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPT09IHRoaXMubGltaXQpXHJcbiAgICAgICAgICAgICAgICBoZXggKz0gaSA9PT0gdGhpcy5tYXJrZWRPZmZzZXQgPyBcIl1cIiA6IFwiPlwiO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBoZXggKz0gaSA9PT0gdGhpcy5tYXJrZWRPZmZzZXQgPyBcIidcIiA6IChjb2x1bW5zIHx8IChpICE9PSAwICYmIGkgIT09IGspID8gXCIgXCIgOiBcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbHVtbnMgJiYgaGV4ICE9PSBcIiBcIikge1xyXG4gICAgICAgICAgICB3aGlsZSAoaGV4Lmxlbmd0aCA8IDMqMTYrMylcclxuICAgICAgICAgICAgICAgIGhleCArPSBcIiBcIjtcclxuICAgICAgICAgICAgb3V0ICs9IGhleCArIGFzYyArIFwiXFxuXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2x1bW5zID8gb3V0IDogaGV4O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYSBoZXggZW5jb2RlZCBzdHJpbmcgd2l0aCBtYXJrZWQgb2Zmc2V0cyB0byBhIEJ5dGVCdWZmZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIERlYnVnIHN0cmluZyB0byBkZWNvZGUgKG5vdCBiZSBnZW5lcmF0ZWQgd2l0aCBgY29sdW1ucyA9IHRydWVgKVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBCeXRlQnVmZmVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKiBAc2VlIEJ5dGVCdWZmZXIjdG9EZWJ1Z1xyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyLmZyb21EZWJ1ZyA9IGZ1bmN0aW9uKHN0ciwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xyXG4gICAgICAgIHZhciBrID0gc3RyLmxlbmd0aCxcclxuICAgICAgICAgICAgYmIgPSBuZXcgQnl0ZUJ1ZmZlcigoKGsrMSkvMyl8MCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCk7XHJcbiAgICAgICAgdmFyIGkgPSAwLCBqID0gMCwgY2gsIGIsXHJcbiAgICAgICAgICAgIHJzID0gZmFsc2UsIC8vIFJlcXVpcmUgc3ltYm9sIG5leHRcclxuICAgICAgICAgICAgaG8gPSBmYWxzZSwgaG0gPSBmYWxzZSwgaGwgPSBmYWxzZSwgLy8gQWxyZWFkeSBoYXMgb2Zmc2V0IChobyksIG1hcmtlZE9mZnNldCAoaG0pLCBsaW1pdCAoaGwpP1xyXG4gICAgICAgICAgICBmYWlsID0gZmFsc2U7XHJcbiAgICAgICAgd2hpbGUgKGk8aykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGNoID0gc3RyLmNoYXJBdChpKyspKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICchJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChobyB8fCBobSB8fCBobCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBobyA9IGhtID0gaGwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi5vZmZzZXQgPSBiYi5tYXJrZWRPZmZzZXQgPSBiYi5saW1pdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3wnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvIHx8IGhsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvID0gaGwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi5vZmZzZXQgPSBiYi5saW1pdCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ1snOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvIHx8IGhtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvID0gaG0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi5vZmZzZXQgPSBiYi5tYXJrZWRPZmZzZXQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIHJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICc8JzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChobykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBobyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJiLm9mZnNldCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ10nOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhsIHx8IGhtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhsID0gaG0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYi5saW1pdCA9IGJiLm1hcmtlZE9mZnNldCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJz4nOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYmIubGltaXQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgIHJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiJ1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhtID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYmIubWFya2VkT2Zmc2V0ID0gajtcclxuICAgICAgICAgICAgICAgICAgICBycyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnICc6XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IHBhcnNlSW50KGNoK3N0ci5jaGFyQXQoaSsrKSwgMTYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGIpIHx8IGIgPCAwIHx8IGIgPiAyNTUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIHN0cjogTm90IGEgZGVidWcgZW5jb2RlZCBzdHJpbmdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJiLnZpZXdbaisrXSA9IGI7XHJcbiAgICAgICAgICAgICAgICAgICAgcnMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmYWlsKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IEludmFsaWQgc3ltYm9sIGF0IFwiK2kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgIGlmICghaG8gfHwgIWhsKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE1pc3Npbmcgb2Zmc2V0IG9yIGxpbWl0XCIpO1xyXG4gICAgICAgICAgICBpZiAoajxiYi5idWZmZXIuYnl0ZUxlbmd0aClcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBkZWJ1ZyBlbmNvZGVkIHN0cmluZyAoaXMgaXQgaGV4PykgXCIraitcIiA8IFwiK2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGVuY29kaW5ncy9oZXhcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgdGhpcyBCeXRlQnVmZmVyJ3MgY29udGVudHMgdG8gYSBoZXggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luIE9mZnNldCB0byBiZWdpbiBhdC4gRGVmYXVsdHMgdG8ge0BsaW5rIEJ5dGVCdWZmZXIjb2Zmc2V0fS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gZW5kIE9mZnNldCB0byBlbmQgYXQuIERlZmF1bHRzIHRvIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fS5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEhleCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBCeXRlQnVmZmVyUHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIGJlZ2luID0gdHlwZW9mIGJlZ2luID09PSAndW5kZWZpbmVkJyA/IHRoaXMub2Zmc2V0IDogYmVnaW47XHJcbiAgICAgICAgZW5kID0gdHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmxpbWl0IDogZW5kO1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXkoZW5kIC0gYmVnaW4pLFxyXG4gICAgICAgICAgICBiO1xyXG4gICAgICAgIHdoaWxlIChiZWdpbiA8IGVuZCkge1xyXG4gICAgICAgICAgICBiID0gdGhpcy52aWV3W2JlZ2luKytdO1xyXG4gICAgICAgICAgICBpZiAoYiA8IDB4MTApXHJcbiAgICAgICAgICAgICAgICBvdXQucHVzaChcIjBcIiwgYi50b1N0cmluZygxNikpO1xyXG4gICAgICAgICAgICBlbHNlIG91dC5wdXNoKGIudG9TdHJpbmcoMTYpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dC5qb2luKCcnKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIGEgaGV4IGVuY29kZWQgc3RyaW5nIHRvIGEgQnl0ZUJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdG8gdXNlIGxpdHRsZSBvciBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9FTkRJQU59LlxyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBza2lwIGFzc2VydGlvbnMgb2Ygb2Zmc2V0cyBhbmQgdmFsdWVzLiBEZWZhdWx0cyB0b1xyXG4gICAgICogIHtAbGluayBCeXRlQnVmZmVyLkRFRkFVTFRfTk9BU1NFUlR9LlxyXG4gICAgICogQHJldHVybnMgeyFCeXRlQnVmZmVyfSBCeXRlQnVmZmVyXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIEJ5dGVCdWZmZXIuZnJvbUhleCA9IGZ1bmN0aW9uKHN0ciwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xyXG4gICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IE5vdCBhIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggJSAyICE9PSAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IExlbmd0aCBub3QgYSBtdWx0aXBsZSBvZiAyXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgayA9IHN0ci5sZW5ndGgsXHJcbiAgICAgICAgICAgIGJiID0gbmV3IEJ5dGVCdWZmZXIoKGsgLyAyKSB8IDAsIGxpdHRsZUVuZGlhbiksXHJcbiAgICAgICAgICAgIGI7XHJcbiAgICAgICAgZm9yICh2YXIgaT0wLCBqPTA7IGk8azsgaSs9Mikge1xyXG4gICAgICAgICAgICBiID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpKzIpLCAxNik7XHJcbiAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpXHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGIpIHx8IGIgPCAwIHx8IGIgPiAyNTUpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBzdHI6IENvbnRhaW5zIG5vbi1oZXggY2hhcmFjdGVyc1wiKTtcclxuICAgICAgICAgICAgYmIudmlld1tqKytdID0gYjtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmIubGltaXQgPSBqO1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgLy8gdXRmeC1lbWJlZGRhYmxlXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB1dGZ4LWVtYmVkZGFibGUgKGMpIDIwMTQgRGFuaWVsIFdpcnR6IDxkY29kZUBkY29kZS5pbz5cclxuICAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcclxuICAgICAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vdXRmeCBmb3IgZGV0YWlsc1xyXG4gICAgICovXHJcbiAgICB2YXIgdXRmeCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiB1dGZ4IG5hbWVzcGFjZS5cclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciB1dGZ4ID0ge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1heGltdW0gdmFsaWQgY29kZSBwb2ludC5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBjb25zdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguTUFYX0NPREVQT0lOVCA9IDB4MTBGRkZGO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIFVURjggY29kZSBwb2ludHMgdG8gVVRGOCBieXRlcy5cclxuICAgICAgICAgKiBAcGFyYW0geyghZnVuY3Rpb24oKTpudW1iZXJ8bnVsbCkgfCBudW1iZXJ9IHNyYyBDb2RlIHBvaW50cyBzb3VyY2UsIGVpdGhlciBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBjb2RlIHBvaW50XHJcbiAgICAgICAgICogIHJlc3BlY3RpdmVseSBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY29kZSBwb2ludHMgbGVmdCBvciBhIHNpbmdsZSBudW1lcmljIGNvZGUgcG9pbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyKX0gZHN0IEJ5dGVzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIHRoZSBuZXh0IGJ5dGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LmVuY29kZVVURjggPSBmdW5jdGlvbihzcmMsIGRzdCkge1xyXG4gICAgICAgICAgICB2YXIgY3AgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICBjcCA9IHNyYywgc3JjID0gZnVuY3Rpb24oKSB7IHJldHVybiBudWxsOyB9O1xyXG4gICAgICAgICAgICB3aGlsZSAoY3AgIT09IG51bGwgfHwgKGNwID0gc3JjKCkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3AgPCAweDgwKVxyXG4gICAgICAgICAgICAgICAgICAgIGRzdChjcCYweDdGKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNwIDwgMHg4MDApXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KCgoY3A+PjYpJjB4MUYpfDB4QzApLCBkc3QoKGNwJjB4M0YpfDB4ODApO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3AgPCAweDEwMDAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGRzdCgoKGNwPj4xMikmMHgwRil8MHhFMCksIGRzdCgoKGNwPj42KSYweDNGKXwweDgwKSwgZHN0KChjcCYweDNGKXwweDgwKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBkc3QoKChjcD4+MTgpJjB4MDcpfDB4RjApLCBkc3QoKChjcD4+MTIpJjB4M0YpfDB4ODApLCBkc3QoKChjcD4+NikmMHgzRil8MHg4MCksIGRzdCgoY3AmMHgzRil8MHg4MCk7XHJcbiAgICAgICAgICAgICAgICBjcCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIFVURjggYnl0ZXMgdG8gVVRGOCBjb2RlIHBvaW50cy5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbigpOm51bWJlcnxudWxsfSBzcmMgQnl0ZXMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGJ5dGUgcmVzcGVjdGl2ZWx5IGBudWxsYCBpZiB0aGVyZVxyXG4gICAgICAgICAqICBhcmUgbm8gbW9yZSBieXRlcyBsZWZ0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBDb2RlIHBvaW50cyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCBlYWNoIGRlY29kZWQgY29kZSBwb2ludC5cclxuICAgICAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBhIHN0YXJ0aW5nIGJ5dGUgaXMgaW52YWxpZCBpbiBVVEY4XHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBsYXN0IHNlcXVlbmNlIGlzIHRydW5jYXRlZC4gSGFzIGFuIGFycmF5IHByb3BlcnR5IGBieXRlc2AgaG9sZGluZyB0aGVcclxuICAgICAgICAgKiAgcmVtYWluaW5nIGJ5dGVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguZGVjb2RlVVRGOCA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XHJcbiAgICAgICAgICAgIHZhciBhLCBiLCBjLCBkLCBmYWlsID0gZnVuY3Rpb24oYikge1xyXG4gICAgICAgICAgICAgICAgYiA9IGIuc2xpY2UoMCwgYi5pbmRleE9mKG51bGwpKTtcclxuICAgICAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihiLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgZXJyLm5hbWUgPSBcIlRydW5jYXRlZEVycm9yXCI7XHJcbiAgICAgICAgICAgICAgICBlcnJbJ2J5dGVzJ10gPSBiO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB3aGlsZSAoKGEgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmICgoYSYweDgwKSA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICBkc3QoYSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYSYweEUwKSA9PT0gMHhDMClcclxuICAgICAgICAgICAgICAgICAgICAoKGIgPSBzcmMoKSkgPT09IG51bGwpICYmIGZhaWwoW2EsIGJdKSwgZHN0KCgoYSYweDFGKTw8NikgfCAoYiYweDNGKSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoYSYweEYwKSA9PT0gMHhFMClcclxuICAgICAgICAgICAgICAgICAgICAoKGI9c3JjKCkpID09PSBudWxsIHx8IChjPXNyYygpKSA9PT0gbnVsbCkgJiYgZmFpbChbYSwgYiwgY10pLCBkc3QoKChhJjB4MEYpPDwxMikgfCAoKGImMHgzRik8PDYpIHwgKGMmMHgzRikpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKGEmMHhGOCkgPT09IDB4RjApXHJcbiAgICAgICAgICAgICAgICAgICAgKChiPXNyYygpKSA9PT0gbnVsbCB8fCAoYz1zcmMoKSkgPT09IG51bGwgfHwgKGQ9c3JjKCkpID09PSBudWxsKSAmJiBmYWlsKFthLCBiLCBjICxkXSksIGRzdCgoKGEmMHgwNyk8PDE4KSB8ICgoYiYweDNGKTw8MTIpIHwgKChjJjB4M0YpPDw2KSB8IChkJjB4M0YpKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgc3RhcnRpbmcgYnl0ZTogXCIrYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBVVEYxNiBjaGFyYWN0ZXJzIHRvIFVURjggY29kZSBwb2ludHMuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24oKTpudW1iZXJ8bnVsbH0gc3JjIENoYXJhY3RlcnMgc291cmNlIGFzIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBuZXh0IGNoYXIgY29kZSByZXNwZWN0aXZlbHlcclxuICAgICAgICAgKiAgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMgbGVmdC5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihudW1iZXIpfSBkc3QgQ29kZSBwb2ludHMgZGVzdGluYXRpb24gYXMgYSBmdW5jdGlvbiBzdWNjZXNzaXZlbHkgY2FsbGVkIHdpdGggZWFjaCBjb252ZXJ0ZWQgY29kZVxyXG4gICAgICAgICAqICBwb2ludC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB1dGZ4LlVURjE2dG9VVEY4ID0gZnVuY3Rpb24oc3JjLCBkc3QpIHtcclxuICAgICAgICAgICAgdmFyIGMxLCBjMiA9IG51bGw7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGMxID0gYzIgIT09IG51bGwgPyBjMiA6IHNyYygpKSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGlmIChjMSA+PSAweEQ4MDAgJiYgYzEgPD0gMHhERkZGKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjMiA9IHNyYygpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYzIgPj0gMHhEQzAwICYmIGMyIDw9IDB4REZGRikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHN0KChjMS0weEQ4MDApKjB4NDAwK2MyLTB4REMwMCsweDEwMDAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyID0gbnVsbDsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkc3QoYzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjMiAhPT0gbnVsbCkgZHN0KGMyKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBVVEY4IGNvZGUgcG9pbnRzIHRvIFVURjE2IGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICogQHBhcmFtIHsoIWZ1bmN0aW9uKCk6bnVtYmVyfG51bGwpIHwgbnVtYmVyfSBzcmMgQ29kZSBwb2ludHMgc291cmNlLCBlaXRoZXIgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgY29kZSBwb2ludFxyXG4gICAgICAgICAqICByZXNwZWN0aXZlbHkgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNvZGUgcG9pbnRzIGxlZnQgb3IgYSBzaW5nbGUgbnVtZXJpYyBjb2RlIHBvaW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBDaGFyYWN0ZXJzIGRlc3RpbmF0aW9uIGFzIGEgZnVuY3Rpb24gc3VjY2Vzc2l2ZWx5IGNhbGxlZCB3aXRoIGVhY2ggY29udmVydGVkIGNoYXIgY29kZS5cclxuICAgICAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBhIGNvZGUgcG9pbnQgaXMgb3V0IG9mIHJhbmdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5VVEY4dG9VVEYxNiA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XHJcbiAgICAgICAgICAgIHZhciBjcCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgIGNwID0gc3JjLCBzcmMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIG51bGw7IH07XHJcbiAgICAgICAgICAgIHdoaWxlIChjcCAhPT0gbnVsbCB8fCAoY3AgPSBzcmMoKSkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjcCA8PSAweEZGRkYpXHJcbiAgICAgICAgICAgICAgICAgICAgZHN0KGNwKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBjcCAtPSAweDEwMDAwLCBkc3QoKGNwPj4xMCkrMHhEODAwKSwgZHN0KChjcCUweDQwMCkrMHhEQzAwKTtcclxuICAgICAgICAgICAgICAgIGNwID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGFuZCBlbmNvZGVzIFVURjE2IGNoYXJhY3RlcnMgdG8gVVRGOCBieXRlcy5cclxuICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbigpOm51bWJlcnxudWxsfSBzcmMgQ2hhcmFjdGVycyBzb3VyY2UgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgY2hhciBjb2RlIHJlc3BlY3RpdmVseSBgbnVsbGBcclxuICAgICAgICAgKiAgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyBsZWZ0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKG51bWJlcil9IGRzdCBCeXRlcyBkZXN0aW5hdGlvbiBhcyBhIGZ1bmN0aW9uIHN1Y2Nlc3NpdmVseSBjYWxsZWQgd2l0aCB0aGUgbmV4dCBieXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguZW5jb2RlVVRGMTZ0b1VURjggPSBmdW5jdGlvbihzcmMsIGRzdCkge1xyXG4gICAgICAgICAgICB1dGZ4LlVURjE2dG9VVEY4KHNyYywgZnVuY3Rpb24oY3ApIHtcclxuICAgICAgICAgICAgICAgIHV0ZnguZW5jb2RlVVRGOChjcCwgZHN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhbmQgY29udmVydHMgVVRGOCBieXRlcyB0byBVVEYxNiBjaGFyYWN0ZXJzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCk6bnVtYmVyfG51bGx9IHNyYyBCeXRlcyBzb3VyY2UgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgYnl0ZSByZXNwZWN0aXZlbHkgYG51bGxgIGlmIHRoZXJlXHJcbiAgICAgICAgICogIGFyZSBubyBtb3JlIGJ5dGVzIGxlZnQuXHJcbiAgICAgICAgICogQHBhcmFtIHshZnVuY3Rpb24obnVtYmVyKX0gZHN0IENoYXJhY3RlcnMgZGVzdGluYXRpb24gYXMgYSBmdW5jdGlvbiBzdWNjZXNzaXZlbHkgY2FsbGVkIHdpdGggZWFjaCBjb252ZXJ0ZWQgY2hhciBjb2RlLlxyXG4gICAgICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGEgc3RhcnRpbmcgYnl0ZSBpcyBpbnZhbGlkIGluIFVURjhcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGxhc3Qgc2VxdWVuY2UgaXMgdHJ1bmNhdGVkLiBIYXMgYW4gYXJyYXkgcHJvcGVydHkgYGJ5dGVzYCBob2xkaW5nIHRoZSByZW1haW5pbmcgYnl0ZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5kZWNvZGVVVEY4dG9VVEYxNiA9IGZ1bmN0aW9uKHNyYywgZHN0KSB7XHJcbiAgICAgICAgICAgIHV0ZnguZGVjb2RlVVRGOChzcmMsIGZ1bmN0aW9uKGNwKSB7XHJcbiAgICAgICAgICAgICAgICB1dGZ4LlVURjh0b1VURjE2KGNwLCBkc3QpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBieXRlIGxlbmd0aCBvZiBhbiBVVEY4IGNvZGUgcG9pbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNwIFVURjggY29kZSBwb2ludFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5jYWxjdWxhdGVDb2RlUG9pbnQgPSBmdW5jdGlvbihjcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKGNwIDwgMHg4MCkgPyAxIDogKGNwIDwgMHg4MDApID8gMiA6IChjcCA8IDB4MTAwMDApID8gMyA6IDQ7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIFVURjggYnl0ZXMgcmVxdWlyZWQgdG8gc3RvcmUgVVRGOCBjb2RlIHBvaW50cy5cclxuICAgICAgICAgKiBAcGFyYW0geyghZnVuY3Rpb24oKTpudW1iZXJ8bnVsbCl9IHNyYyBDb2RlIHBvaW50cyBzb3VyY2UgYXMgYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG5leHQgY29kZSBwb2ludCByZXNwZWN0aXZlbHlcclxuICAgICAgICAgKiAgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBtb3JlIGNvZGUgcG9pbnRzIGxlZnQuXHJcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBVVEY4IGJ5dGVzIHJlcXVpcmVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdXRmeC5jYWxjdWxhdGVVVEY4ID0gZnVuY3Rpb24oc3JjKSB7XHJcbiAgICAgICAgICAgIHZhciBjcCwgbD0wO1xyXG4gICAgICAgICAgICB3aGlsZSAoKGNwID0gc3JjKCkpICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgbCArPSAoY3AgPCAweDgwKSA/IDEgOiAoY3AgPCAweDgwMCkgPyAyIDogKGNwIDwgMHgxMDAwMCkgPyAzIDogNDtcclxuICAgICAgICAgICAgcmV0dXJuIGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIFVURjggY29kZSBwb2ludHMgcmVzcGVjdGl2ZWx5IFVURjggYnl0ZXMgcmVxdWlyZWQgdG8gc3RvcmUgVVRGMTYgY2hhciBjb2Rlcy5cclxuICAgICAgICAgKiBAcGFyYW0geyghZnVuY3Rpb24oKTpudW1iZXJ8bnVsbCl9IHNyYyBDaGFyYWN0ZXJzIHNvdXJjZSBhcyBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbmV4dCBjaGFyIGNvZGUgcmVzcGVjdGl2ZWx5XHJcbiAgICAgICAgICogIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzIGxlZnQuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gVGhlIG51bWJlciBvZiBVVEY4IGNvZGUgcG9pbnRzIGF0IGluZGV4IDAgYW5kIHRoZSBudW1iZXIgb2YgVVRGOCBieXRlcyByZXF1aXJlZCBhdCBpbmRleCAxLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHV0ZnguY2FsY3VsYXRlVVRGMTZhc1VURjggPSBmdW5jdGlvbihzcmMpIHtcclxuICAgICAgICAgICAgdmFyIG49MCwgbD0wO1xyXG4gICAgICAgICAgICB1dGZ4LlVURjE2dG9VVEY4KHNyYywgZnVuY3Rpb24oY3ApIHtcclxuICAgICAgICAgICAgICAgICsrbjsgbCArPSAoY3AgPCAweDgwKSA/IDEgOiAoY3AgPCAweDgwMCkgPyAyIDogKGNwIDwgMHgxMDAwMCkgPyAzIDogNDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBbbixsXTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gdXRmeDtcclxuICAgIH0oKTtcclxuXHJcbiAgICAvLyBlbmNvZGluZ3MvdXRmOFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyB0aGlzIEJ5dGVCdWZmZXIncyBjb250ZW50cyBiZXR3ZWVuIHtAbGluayBCeXRlQnVmZmVyI29mZnNldH0gYW5kIHtAbGluayBCeXRlQnVmZmVyI2xpbWl0fSB0byBhbiBVVEY4IGVuY29kZWRcclxuICAgICAqICBzdHJpbmcuXHJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBIZXggZW5jb2RlZCBzdHJpbmdcclxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGBvZmZzZXQgPiBsaW1pdGBcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlclByb3RvdHlwZS50b1VURjggPSBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiZWdpbiA9PT0gJ3VuZGVmaW5lZCcpIGJlZ2luID0gdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxpbWl0O1xyXG4gICAgICAgIGlmICghdGhpcy5ub0Fzc2VydCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGJlZ2luICE9PSAnbnVtYmVyJyB8fCBiZWdpbiAlIDEgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiSWxsZWdhbCBiZWdpbjogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBiZWdpbiA+Pj49IDA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZCAhPT0gJ251bWJlcicgfHwgZW5kICUgMSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGVuZDogTm90IGFuIGludGVnZXJcIik7XG4gICAgICAgICAgICBlbmQgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKGJlZ2luIDwgMCB8fCBiZWdpbiA+IGVuZCB8fCBlbmQgPiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoXCJJbGxlZ2FsIHJhbmdlOiAwIDw9IFwiK2JlZ2luK1wiIDw9IFwiK2VuZCtcIiA8PSBcIit0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzZDsgdHJ5IHtcclxuICAgICAgICAgICAgdXRmeC5kZWNvZGVVVEY4dG9VVEYxNihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiZWdpbiA8IGVuZCA/IHRoaXMudmlld1tiZWdpbisrXSA6IG51bGw7XHJcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgc2QgPSBzdHJpbmdEZXN0aW5hdGlvbigpKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGlmIChiZWdpbiAhPT0gZW5kKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihcIklsbGVnYWwgcmFuZ2U6IFRydW5jYXRlZCBkYXRhLCBcIitiZWdpbitcIiAhPSBcIitlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2QoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIGFuIFVURjggZW5jb2RlZCBzdHJpbmcgdG8gYSBCeXRlQnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsaXR0bGVFbmRpYW4gV2hldGhlciB0byB1c2UgbGl0dGxlIG9yIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci4gRGVmYXVsdHMgdG9cclxuICAgICAqICB7QGxpbmsgQnl0ZUJ1ZmZlci5ERUZBVUxUX0VORElBTn0uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIHNraXAgYXNzZXJ0aW9ucyBvZiBvZmZzZXRzIGFuZCB2YWx1ZXMuIERlZmF1bHRzIHRvXHJcbiAgICAgKiAge0BsaW5rIEJ5dGVCdWZmZXIuREVGQVVMVF9OT0FTU0VSVH0uXHJcbiAgICAgKiBAcmV0dXJucyB7IUJ5dGVCdWZmZXJ9IEJ5dGVCdWZmZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgQnl0ZUJ1ZmZlci5mcm9tVVRGOCA9IGZ1bmN0aW9uKHN0ciwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xyXG4gICAgICAgIGlmICghbm9Bc3NlcnQpXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIklsbGVnYWwgc3RyOiBOb3QgYSBzdHJpbmdcIik7XHJcbiAgICAgICAgdmFyIGJiID0gbmV3IEJ5dGVCdWZmZXIodXRmeC5jYWxjdWxhdGVVVEYxNmFzVVRGOChzdHJpbmdTb3VyY2Uoc3RyKSwgdHJ1ZSlbMV0sIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpLFxyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB1dGZ4LmVuY29kZVVURjE2dG9VVEY4KHN0cmluZ1NvdXJjZShzdHIpLCBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgICAgIGJiLnZpZXdbaSsrXSA9IGI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYmIubGltaXQgPSBpO1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEJ5dGVCdWZmZXI7XHJcbn0pO1xufSk7XG5cbnZhciBlbXB0eSQxID0ge307XG5cblxudmFyIGVtcHR5JDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogZW1wdHkkMVxufSk7XG5cbnZhciByZXF1aXJlJCQyID0gKCBlbXB0eSQyICYmIGVtcHR5JDEgKSB8fCBlbXB0eSQyO1xuXG52YXIgcHJvdG9idWZMaWdodCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbi8qXHJcbiBDb3B5cmlnaHQgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG5cclxuIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAbGljZW5zZSBwcm90b2J1Zi5qcyAoYykgMjAxMyBEYW5pZWwgV2lydHogPGRjb2RlQGRjb2RlLmlvPlxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wXHJcbiAqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vcHJvdG9idWYuanMgZm9yIGRldGFpbHNcclxuICovXHJcbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcclxuXHJcbiAgICAvKiBBTUQgKi8gaWYgKHR5cGVvZiB1bmRlZmluZWQgPT09ICdmdW5jdGlvbicgJiYgdW5kZWZpbmVkW1wiYW1kXCJdKVxyXG4gICAgICAgIHVuZGVmaW5lZChbXCJieXRlYnVmZmVyXCJdLCBmYWN0b3J5KTtcclxuICAgIC8qIENvbW1vbkpTICovIGVsc2UgaWYgKHR5cGVvZiBjb21tb25qc1JlcXVpcmUgPT09IFwiZnVuY3Rpb25cIiAmJiAnb2JqZWN0JyA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUgJiYgbW9kdWxlW1wiZXhwb3J0c1wiXSlcclxuICAgICAgICBtb2R1bGVbXCJleHBvcnRzXCJdID0gZmFjdG9yeShieXRlYnVmZmVyLCB0cnVlKTtcclxuICAgIC8qIEdsb2JhbCAqLyBlbHNlXHJcbiAgICAgICAgKGdsb2JhbFtcImRjb2RlSU9cIl0gPSBnbG9iYWxbXCJkY29kZUlPXCJdIHx8IHt9KVtcIlByb3RvQnVmXCJdID0gZmFjdG9yeShnbG9iYWxbXCJkY29kZUlPXCJdW1wiQnl0ZUJ1ZmZlclwiXSk7XHJcblxyXG59KShjb21tb25qc0dsb2JhbCwgZnVuY3Rpb24oQnl0ZUJ1ZmZlciwgaXNDb21tb25KUykge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIFByb3RvQnVmIG5hbWVzcGFjZS5cclxuICAgICAqIEBleHBvcnRzIFByb3RvQnVmXHJcbiAgICAgKiBAbmFtZXNwYWNlXHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIHZhciBQcm90b0J1ZiA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgeyFmdW5jdGlvbihuZXc6IEJ5dGVCdWZmZXIsIC4uLlsqXSl9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLkJ5dGVCdWZmZXIgPSBCeXRlQnVmZmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUgez9mdW5jdGlvbihuZXc6IExvbmcsIC4uLlsqXSl9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLkxvbmcgPSBCeXRlQnVmZmVyLkxvbmcgfHwgbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3RvQnVmLmpzIHZlcnNpb24uXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLlZFUlNJT04gPSBcIjUuMC4zXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaXJlIHR5cGVzLlxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuV0lSRV9UWVBFUyA9IHt9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmFyaW50IHdpcmUgdHlwZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5UID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpeGVkIDY0IGJpdHMgd2lyZSB0eXBlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NCA9IDE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMZW5ndGggZGVsaW1pdGVkIHdpcmUgdHlwZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU0gPSAyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnQgZ3JvdXAgd2lyZSB0eXBlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLlNUQVJUR1JPVVAgPSAzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5kIGdyb3VwIHdpcmUgdHlwZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5FTkRHUk9VUCA9IDQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXhlZCAzMiBiaXRzIHdpcmUgdHlwZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzIgPSA1O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFja2FibGUgd2lyZSB0eXBlcy5cclxuICAgICAqIEB0eXBlIHshQXJyYXkuPG51bWJlcj59XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuUEFDS0FCTEVfV0lSRV9UWVBFUyA9IFtcclxuICAgICAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcclxuICAgICAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFM2NCxcclxuICAgICAgICBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFMzMlxyXG4gICAgXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFR5cGVzLlxyXG4gICAgICogQGRpY3RcclxuICAgICAqIEB0eXBlIHshT2JqZWN0LjxzdHJpbmcse25hbWU6IHN0cmluZywgd2lyZVR5cGU6IG51bWJlciwgZGVmYXVsdFZhbHVlOiAqfT59XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuVFlQRVMgPSB7XHJcbiAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBwcm90b2J1ZiBzcGVjLlxyXG4gICAgICAgIFwiaW50MzJcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcImludDMyXCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInVpbnQzMlwiOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwidWludDMyXCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInNpbnQzMlwiOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwic2ludDMyXCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVCxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiAwXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImludDY0XCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJpbnQ2NFwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogUHJvdG9CdWYuTG9uZyA/IFByb3RvQnVmLkxvbmcuWkVSTyA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJ1aW50NjRcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcInVpbnQ2NFwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogUHJvdG9CdWYuTG9uZyA/IFByb3RvQnVmLkxvbmcuVVpFUk8gOiB1bmRlZmluZWRcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwic2ludDY0XCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJzaW50NjRcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuVkFSSU5ULFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IFByb3RvQnVmLkxvbmcgPyBQcm90b0J1Zi5Mb25nLlpFUk8gOiB1bmRlZmluZWRcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiYm9vbFwiOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiYm9vbFwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZmFsc2VcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZG91YmxlXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJkb3VibGVcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0LFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwic3RyaW5nXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IFwiXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiYnl0ZXNcIjoge1xyXG4gICAgICAgICAgICBuYW1lOiBcImJ5dGVzXCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsIC8vIG92ZXJyaWRkZW4gaW4gdGhlIGNvZGUsIG11c3QgYmUgYSB1bmlxdWUgaW5zdGFuY2VcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZml4ZWQzMlwiOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiZml4ZWQzMlwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzIsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJzZml4ZWQzMlwiOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwic2ZpeGVkMzJcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZml4ZWQ2NFwiOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiZml4ZWQ2NFwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTNjQsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogIFByb3RvQnVmLkxvbmcgPyBQcm90b0J1Zi5Mb25nLlVaRVJPIDogdW5kZWZpbmVkXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcInNmaXhlZDY0XCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJzZml4ZWQ2NFwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTNjQsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogUHJvdG9CdWYuTG9uZyA/IFByb3RvQnVmLkxvbmcuWkVSTyA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJmbG9hdFwiOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiZmxvYXRcIixcclxuICAgICAgICAgICAgd2lyZVR5cGU6IFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzMyLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZW51bVwiOiB7XHJcbiAgICAgICAgICAgIG5hbWU6IFwiZW51bVwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQsXHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJtZXNzYWdlXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJtZXNzYWdlXCIsXHJcbiAgICAgICAgICAgIHdpcmVUeXBlOiBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSxcclxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImdyb3VwXCI6IHtcclxuICAgICAgICAgICAgbmFtZTogXCJncm91cFwiLFxyXG4gICAgICAgICAgICB3aXJlVHlwZTogUHJvdG9CdWYuV0lSRV9UWVBFUy5TVEFSVEdST1VQLFxyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IG51bGxcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmFsaWQgbWFwIGtleSB0eXBlcy5cclxuICAgICAqIEB0eXBlIHshQXJyYXkuPCFPYmplY3QuPHN0cmluZyx7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyLCBkZWZhdWx0VmFsdWU6ICp9Pj59XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuTUFQX0tFWV9UWVBFUyA9IFtcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcImludDMyXCJdLFxyXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1wic2ludDMyXCJdLFxyXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkMzJcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJ1aW50MzJcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdLFxyXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1wiaW50NjRcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJzaW50NjRcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJzZml4ZWQ2NFwiXSxcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXSxcclxuICAgICAgICBQcm90b0J1Zi5UWVBFU1tcImZpeGVkNjRcIl0sXHJcbiAgICAgICAgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdLFxyXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1wic3RyaW5nXCJdLFxyXG4gICAgICAgIFByb3RvQnVmLlRZUEVTW1wiYnl0ZXNcIl1cclxuICAgIF07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNaW5pbXVtIGZpZWxkIGlkLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5JRF9NSU4gPSAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWF4aW11bSBmaWVsZCBpZC5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKiBAY29uc3RcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuSURfTUFYID0gMHgxRkZGRkZGRjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHNldCB0byBgdHJ1ZWAsIGZpZWxkIG5hbWVzIHdpbGwgYmUgY29udmVydGVkIGZyb20gdW5kZXJzY29yZSBub3RhdGlvbiB0byBjYW1lbCBjYXNlLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxyXG4gICAgICogIE11c3QgYmUgc2V0IHByaW9yIHRvIHBhcnNpbmcuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYuY29udmVydEZpZWxkc1RvQ2FtZWxDYXNlID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCBtZXNzYWdlcyBhcmUgcG9wdWxhdGVkIHdpdGggKHNldFgsIHNldF94KSBhY2Nlc3NvcnMgZm9yIGVhY2ggZmllbGQuIFRoaXMgY2FuIGJlIGRpc2FibGVkIGJ5XHJcbiAgICAgKiAgc2V0dGluZyB0aGlzIHRvIGBmYWxzZWAgcHJpb3IgdG8gYnVpbGRpbmcgbWVzc2FnZXMuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYucG9wdWxhdGVBY2Nlc3NvcnMgPSB0cnVlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnkgZGVmYXVsdCwgbWVzc2FnZXMgYXJlIHBvcHVsYXRlZCB3aXRoIGRlZmF1bHQgdmFsdWVzIGlmIGEgZmllbGQgaXMgbm90IHByZXNlbnQgb24gdGhlIHdpcmUuIFRvIGRpc2FibGVcclxuICAgICAqICB0aGlzIGJlaGF2aW9yLCBzZXQgdGhpcyBzZXR0aW5nIHRvIGBmYWxzZWAuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYucG9wdWxhdGVEZWZhdWx0cyA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAYWxpYXMgUHJvdG9CdWYuVXRpbFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5VdGlsID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm90b0J1ZiB1dGlsaXRpZXMuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuVXRpbFxyXG4gICAgICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVXRpbCA9IHt9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGbGFnIGlmIHJ1bm5pbmcgaW4gbm9kZSBvciBub3QuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGNvbnN0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWwuSVNfTk9ERSA9ICEhKFxyXG4gICAgICAgICAgICB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2VzcysnJyA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nICYmICFwcm9jZXNzWydicm93c2VyJ11cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LlxyXG4gICAgICAgICAqIEByZXR1cm4ge1hNTEh0dHBSZXF1ZXN0fVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBYTUxIdHRwUmVxdWVzdCBpcyBub3Qgc3VwcG9ydGVkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWwuWEhSID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vIE5vIGRlcGVuZGVuY2llcyBwbGVhc2UsIHJlZjogaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy94bWxodHRwLmh0bWxcclxuICAgICAgICAgICAgdmFyIFhNTEh0dHBGYWN0b3JpZXMgPSBbXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpfSxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNc3htbDIuWE1MSFRUUFwiKX0sXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTXN4bWwzLlhNTEhUVFBcIil9LFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpfVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAvKiogQHR5cGUgez9YTUxIdHRwUmVxdWVzdH0gKi9cclxuICAgICAgICAgICAgdmFyIHhociA9IG51bGw7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDtpPFhNTEh0dHBGYWN0b3JpZXMubGVuZ3RoO2krKykge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHsgeGhyID0gWE1MSHR0cEZhY3Rvcmllc1tpXSgpOyB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF4aHIpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlhNTEh0dHBSZXF1ZXN0IGlzIG5vdCBzdXBwb3J0ZWRcIik7XHJcbiAgICAgICAgICAgIHJldHVybiB4aHI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmV0Y2hlcyBhIHJlc291cmNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFJlc291cmNlIHBhdGhcclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9zdHJpbmcpPX0gY2FsbGJhY2sgQ2FsbGJhY2sgcmVjZWl2aW5nIHRoZSByZXNvdXJjZSdzIGNvbnRlbnRzLiBJZiBvbWl0dGVkIHRoZSByZXNvdXJjZSB3aWxsXHJcbiAgICAgICAgICogICBiZSBmZXRjaGVkIHN5bmNocm9ub3VzbHkuIElmIHRoZSByZXF1ZXN0IGZhaWxlZCwgY29udGVudHMgd2lsbCBiZSBudWxsLlxyXG4gICAgICAgICAqIEByZXR1cm4gez9zdHJpbmd8dW5kZWZpbmVkfSBSZXNvdXJjZSBjb250ZW50cyBpZiBjYWxsYmFjayBpcyBvbWl0dGVkIChudWxsIGlmIHRoZSByZXF1ZXN0IGZhaWxlZCksIGVsc2UgdW5kZWZpbmVkLlxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlsLmZldGNoID0gZnVuY3Rpb24ocGF0aCwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKVxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoVXRpbC5JU19OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnMgPSByZXF1aXJlJCQyO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnMucmVhZEZpbGUocGF0aCwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soXCJcIitkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMocGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeGhyID0gVXRpbC5YSFIoKTtcclxuICAgICAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBwYXRoLCBjYWxsYmFjayA/IHRydWUgOiBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAvLyB4aHIuc2V0UmVxdWVzdEhlYWRlcignVXNlci1BZ2VudCcsICdYTUxIVFRQLzEuMCcpO1xyXG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICd0ZXh0L3BsYWluJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHhoci5vdmVycmlkZU1pbWVUeXBlID09PSAnZnVuY3Rpb24nKSB4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbicpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT0gNCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLyogcmVtb3RlICovIHhoci5zdGF0dXMgPT0gMjAwIHx8IC8qIGxvY2FsICovICh4aHIuc3RhdHVzID09IDAgJiYgdHlwZW9mIHhoci5yZXNwb25zZVRleHQgPT09ICdzdHJpbmcnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHhoci5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgvKiByZW1vdGUgKi8geGhyLnN0YXR1cyA9PSAyMDAgfHwgLyogbG9jYWwgKi8gKHhoci5zdGF0dXMgPT0gMCAmJiB0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCA9PT0gJ3N0cmluZycpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGNhbWVsIGNhc2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWwudG9DYW1lbENhc2UgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9fKFthLXpBLVpdKS9nLCBmdW5jdGlvbiAoJDAsICQxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJDEudG9VcHBlckNhc2UoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFV0aWw7XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGFuZ3VhZ2UgZXhwcmVzc2lvbnMuXHJcbiAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCFSZWdFeHA+fVxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5MYW5nID0ge1xyXG5cclxuICAgICAgICAvLyBDaGFyYWN0ZXJzIGFsd2F5cyBlbmRpbmcgYSBzdGF0ZW1lbnRcclxuICAgICAgICBERUxJTTogL1tcXHNcXHtcXH09OzpcXFtcXF0sJ1wiXFwoXFwpPD5dL2csXHJcblxyXG4gICAgICAgIC8vIEZpZWxkIHJ1bGVzXHJcbiAgICAgICAgUlVMRTogL14oPzpyZXF1aXJlZHxvcHRpb25hbHxyZXBlYXRlZHxtYXApJC8sXHJcblxyXG4gICAgICAgIC8vIEZpZWxkIHR5cGVzXHJcbiAgICAgICAgVFlQRTogL14oPzpkb3VibGV8ZmxvYXR8aW50MzJ8dWludDMyfHNpbnQzMnxpbnQ2NHx1aW50NjR8c2ludDY0fGZpeGVkMzJ8c2ZpeGVkMzJ8Zml4ZWQ2NHxzZml4ZWQ2NHxib29sfHN0cmluZ3xieXRlcykkLyxcclxuXHJcbiAgICAgICAgLy8gTmFtZXNcclxuICAgICAgICBOQU1FOiAvXlthLXpBLVpfXVthLXpBLVpfMC05XSokLyxcclxuXHJcbiAgICAgICAgLy8gVHlwZSBkZWZpbml0aW9uc1xyXG4gICAgICAgIFRZUEVERUY6IC9eW2EtekEtWl1bYS16QS1aXzAtOV0qJC8sXHJcblxyXG4gICAgICAgIC8vIFR5cGUgcmVmZXJlbmNlc1xyXG4gICAgICAgIFRZUEVSRUY6IC9eKD86XFwuP1thLXpBLVpfXVthLXpBLVpfMC05XSopKD86XFwuW2EtekEtWl9dW2EtekEtWl8wLTldKikqJC8sXHJcblxyXG4gICAgICAgIC8vIEZ1bGx5IHF1YWxpZmllZCB0eXBlIHJlZmVyZW5jZXNcclxuICAgICAgICBGUVRZUEVSRUY6IC9eKD86XFwuW2EtekEtWl9dW2EtekEtWl8wLTldKikrJC8sXHJcblxyXG4gICAgICAgIC8vIEFsbCBudW1iZXJzXHJcbiAgICAgICAgTlVNQkVSOiAvXi0/KD86WzEtOV1bMC05XSp8MHwwW3hYXVswLTlhLWZBLUZdK3wwWzAtN10rfChbMC05XSooXFwuWzAtOV0qKT8oW0VlXVsrLV0/WzAtOV0rKT8pfGluZnxuYW4pJC8sXHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgbnVtYmVyc1xyXG4gICAgICAgIE5VTUJFUl9ERUM6IC9eKD86WzEtOV1bMC05XSp8MCkkLyxcclxuXHJcbiAgICAgICAgLy8gSGV4YWRlY2ltYWwgbnVtYmVyc1xyXG4gICAgICAgIE5VTUJFUl9IRVg6IC9eMFt4WF1bMC05YS1mQS1GXSskLyxcclxuXHJcbiAgICAgICAgLy8gT2N0YWwgbnVtYmVyc1xyXG4gICAgICAgIE5VTUJFUl9PQ1Q6IC9eMFswLTddKyQvLFxyXG5cclxuICAgICAgICAvLyBGbG9hdGluZyBwb2ludCBudW1iZXJzXHJcbiAgICAgICAgTlVNQkVSX0ZMVDogL14oWzAtOV0qKFxcLlswLTldKik/KFtFZV1bKy1dP1swLTldKyk/fGluZnxuYW4pJC8sXHJcblxyXG4gICAgICAgIC8vIEJvb2xlYW5zXHJcbiAgICAgICAgQk9PTDogL14oPzp0cnVlfGZhbHNlKSQvaSxcclxuXHJcbiAgICAgICAgLy8gSWQgbnVtYmVyc1xyXG4gICAgICAgIElEOiAvXig/OlsxLTldWzAtOV0qfDB8MFt4WF1bMC05YS1mQS1GXSt8MFswLTddKykkLyxcclxuXHJcbiAgICAgICAgLy8gTmVnYXRpdmUgaWQgbnVtYmVycyAoZW51bSB2YWx1ZXMpXHJcbiAgICAgICAgTkVHSUQ6IC9eXFwtPyg/OlsxLTldWzAtOV0qfDB8MFt4WF1bMC05YS1mQS1GXSt8MFswLTddKykkLyxcclxuXHJcbiAgICAgICAgLy8gV2hpdGVzcGFjZXNcclxuICAgICAgICBXSElURVNQQUNFOiAvXFxzLyxcclxuXHJcbiAgICAgICAgLy8gQWxsIHN0cmluZ3NcclxuICAgICAgICBTVFJJTkc6IC8oPzpcIihbXlwiXFxcXF0qKD86XFxcXC5bXlwiXFxcXF0qKSopXCIpfCg/OicoW14nXFxcXF0qKD86XFxcXC5bXidcXFxcXSopKiknKS9nLFxyXG5cclxuICAgICAgICAvLyBEb3VibGUgcXVvdGVkIHN0cmluZ3NcclxuICAgICAgICBTVFJJTkdfRFE6IC8oPzpcIihbXlwiXFxcXF0qKD86XFxcXC5bXlwiXFxcXF0qKSopXCIpL2csXHJcblxyXG4gICAgICAgIC8vIFNpbmdsZSBxdW90ZWQgc3RyaW5nc1xyXG4gICAgICAgIFNUUklOR19TUTogLyg/OicoW14nXFxcXF0qKD86XFxcXC5bXidcXFxcXSopKiknKS9nXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0XHJcbiAgICAgKiBAZXhwb3NlXHJcbiAgICAgKi9cclxuICAgIFByb3RvQnVmLlJlZmxlY3QgPSAoZnVuY3Rpb24oUHJvdG9CdWYpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVmbGVjdGlvbiB0eXBlcy5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0XHJcbiAgICAgICAgICogQG5hbWVzcGFjZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBSZWZsZWN0ID0ge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBSZWZsZWN0IGJhc2UgY2xhc3MuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGFic3RyYWN0XHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7P1Byb3RvQnVmLlJlZmxlY3QuVH0gcGFyZW50IFBhcmVudCBvYmplY3RcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPYmplY3QgbmFtZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUID0gZnVuY3Rpb24oYnVpbGRlciwgcGFyZW50LCBuYW1lKSB7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQnVpbGRlciByZWZlcmVuY2UuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuQnVpbGRlcn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5idWlsZGVyID0gYnVpbGRlcjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7P1Byb3RvQnVmLlJlZmxlY3QuVH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT2JqZWN0IG5hbWUgaW4gbmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZ1bGx5IHF1YWxpZmllZCBjbGFzcyBuYW1lXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlQucHJvdG90eXBlXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFRQcm90b3R5cGUgPSBULnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgZnVsbHkgcXVhbGlmaWVkIG5hbWUgb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gRnVsbHkgcXVhbGlmaWVkIG5hbWUgYXMgb2YgXCIuUEFUSC5UTy5USElTXCJcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVFByb3RvdHlwZS5mcW4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBwdHIgPSB0aGlzO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKHB0ciA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IHB0ci5uYW1lK1wiLlwiK25hbWU7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgUmVmbGVjdCBvYmplY3QgKGl0cyBmdWxseSBxdWFsaWZpZWQgbmFtZSkuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5jbHVkZUNsYXNzIFNldCB0byB0cnVlIHRvIGluY2x1ZGUgdGhlIGNsYXNzIG5hbWUuIERlZmF1bHRzIHRvIGZhbHNlLlxyXG4gICAgICAgICAqIEByZXR1cm4gU3RyaW5nIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihpbmNsdWRlQ2xhc3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChpbmNsdWRlQ2xhc3MgPyB0aGlzLmNsYXNzTmFtZSArIFwiIFwiIDogXCJcIikgKyB0aGlzLmZxbigpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkcyB0aGlzIHR5cGUuXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoaXMgdHlwZSBjYW5ub3QgYmUgYnVpbHQgZGlyZWN0bHlcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVFByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcih0aGlzLnRvU3RyaW5nKHRydWUpK1wiIGNhbm5vdCBiZSBidWlsdCBkaXJlY3RseVwiKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuVCA9IFQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTmFtZXNwYWNlLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7P1Byb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlfSBwYXJlbnQgTmFtZXNwYWNlIHBhcmVudFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBuYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgTmFtZXNwYWNlIG9wdGlvbnNcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZz99IHN5bnRheCBUaGUgc3ludGF4IGxldmVsIG9mIHRoaXMgZGVmaW5pdGlvbiAoZS5nLiwgcHJvdG8zKVxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuVFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBOYW1lc3BhY2UgPSBmdW5jdGlvbihidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIHN5bnRheCkge1xyXG4gICAgICAgICAgICBULmNhbGwodGhpcywgYnVpbGRlciwgcGFyZW50LCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJOYW1lc3BhY2VcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGlsZHJlbiBpbnNpZGUgdGhlIG5hbWVzcGFjZS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48UHJvdG9CdWYuUmVmbGVjdC5UPn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPcHRpb25zLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCAqPn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3ludGF4IGxldmVsIChlLmcuLCBwcm90bzIgb3IgcHJvdG8zKS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFzdHJpbmd9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnN5bnRheCA9IHN5bnRheCB8fCBcInByb3RvMlwiO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgTmFtZXNwYWNlUHJvdG90eXBlID0gTmFtZXNwYWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBuYW1lc3BhY2UncyBjaGlsZHJlbi5cclxuICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLlJlZmxlY3QuVD19IHR5cGUgRmlsdGVyIHR5cGUgKHJldHVybnMgaW5zdGFuY2VzIG9mIHRoaXMgdHlwZSBvbmx5KS4gRGVmYXVsdHMgdG8gbnVsbCAoYWxsIGNoaWxkcmVuKS5cclxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48UHJvdG9CdWYuUmVmbGVjdC5UPn1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmFtZXNwYWNlUHJvdG90eXBlLmdldENoaWxkcmVuID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBudWxsO1xyXG4gICAgICAgICAgICBpZiAodHlwZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uc2xpY2UoKTtcclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz10aGlzLmNoaWxkcmVuLmxlbmd0aDsgaTxrOyArK2kpXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSBpbnN0YW5jZW9mIHR5cGUpXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBjaGlsZCB0byB0aGUgbmFtZXNwYWNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuUmVmbGVjdC5UfSBjaGlsZCBDaGlsZFxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgY2hpbGQgY2Fubm90IGJlIGFkZGVkIChkdXBsaWNhdGUpXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIHZhciBvdGhlcjtcclxuICAgICAgICAgICAgaWYgKG90aGVyID0gdGhpcy5nZXRDaGlsZChjaGlsZC5uYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHJldmVydCBjYW1lbGNhc2UgdHJhbnNmb3JtYXRpb24gb24gY29sbGlzaW9uXHJcbiAgICAgICAgICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBNZXNzYWdlLkZpZWxkICYmIG90aGVyLm5hbWUgIT09IG90aGVyLm9yaWdpbmFsTmFtZSAmJiB0aGlzLmdldENoaWxkKG90aGVyLm9yaWdpbmFsTmFtZSkgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIubmFtZSA9IG90aGVyLm9yaWdpbmFsTmFtZTsgLy8gUmV2ZXJ0IHByZXZpb3VzIGZpcnN0IChlZmZlY3RpdmVseSBrZWVwcyBib3RoIG9yaWdpbmFscylcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgTWVzc2FnZS5GaWVsZCAmJiBjaGlsZC5uYW1lICE9PSBjaGlsZC5vcmlnaW5hbE5hbWUgJiYgdGhpcy5nZXRDaGlsZChjaGlsZC5vcmlnaW5hbE5hbWUpID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLm5hbWUgPSBjaGlsZC5vcmlnaW5hbE5hbWU7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJEdXBsaWNhdGUgbmFtZSBpbiBuYW1lc3BhY2UgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrY2hpbGQubmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGEgY2hpbGQgYnkgaXRzIG5hbWUgb3IgaWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JJZCBDaGlsZCBuYW1lIG9yIGlkXHJcbiAgICAgICAgICogQHJldHVybiB7P1Byb3RvQnVmLlJlZmxlY3QuVH0gVGhlIGNoaWxkIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uKG5hbWVPcklkKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB0eXBlb2YgbmFtZU9ySWQgPT09ICdudW1iZXInID8gJ2lkJyA6ICduYW1lJztcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrPXRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpPGs7ICsraSlcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2tleV0gPT09IG5hbWVPcklkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNvbHZlcyBhIHJlZmxlY3Qgb2JqZWN0IGluc2lkZSBvZiB0aGlzIG5hbWVzcGFjZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3whQXJyYXkuPHN0cmluZz59IHFuIFF1YWxpZmllZCBuYW1lIHRvIHJlc29sdmVcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBleGNsdWRlTm9uTmFtZXNwYWNlIEV4Y2x1ZGVzIG5vbi1uYW1lc3BhY2UgdHlwZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgKiBAcmV0dXJuIHs/UHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2V9IFRoZSByZXNvbHZlZCB0eXBlIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocW4sIGV4Y2x1ZGVOb25OYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgdmFyIHBhcnQgPSB0eXBlb2YgcW4gPT09ICdzdHJpbmcnID8gcW4uc3BsaXQoXCIuXCIpIDogcW4sXHJcbiAgICAgICAgICAgICAgICBwdHIgPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgIGlmIChwYXJ0W2ldID09PSBcIlwiKSB7IC8vIEZ1bGx5IHF1YWxpZmllZCBuYW1lLCBlLmcuIFwiLk15Lk1lc3NhZ2UnXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocHRyLnBhcmVudCAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjaGlsZDtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHB0ciBpbnN0YW5jZW9mIFJlZmxlY3QuTmFtZXNwYWNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBwdHIuZ2V0Q2hpbGQocGFydFtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZCB8fCAhKGNoaWxkIGluc3RhbmNlb2YgUmVmbGVjdC5UKSB8fCAoZXhjbHVkZU5vbk5hbWVzcGFjZSAmJiAhKGNoaWxkIGluc3RhbmNlb2YgUmVmbGVjdC5OYW1lc3BhY2UpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gY2hpbGQ7IGkrKztcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGkgPCBwYXJ0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocHRyICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIEZvdW5kXHJcbiAgICAgICAgICAgICAgICAvLyBFbHNlIHNlYXJjaCB0aGUgcGFyZW50XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnJlc29sdmUocW4sIGV4Y2x1ZGVOb25OYW1lc3BhY2UpO1xyXG4gICAgICAgICAgICB9IHdoaWxlIChwdHIgIT0gbnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwdHI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgc2hvcnRlc3QgcXVhbGlmaWVkIG5hbWUgb2YgdGhlIHNwZWNpZmllZCB0eXBlLCBpZiBhbnksIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuVH0gdCBSZWZsZWN0aW9uIHR5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc2hvcnRlc3QgcXVhbGlmaWVkIG5hbWUgb3IsIGlmIHRoZXJlIGlzIG5vbmUsIHRoZSBmcW5cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmFtZXNwYWNlUHJvdG90eXBlLnFuID0gZnVuY3Rpb24odCkge1xyXG4gICAgICAgICAgICB2YXIgcGFydCA9IFtdLCBwdHIgPSB0O1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0LnVuc2hpZnQocHRyLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcclxuICAgICAgICAgICAgfSB3aGlsZSAocHRyICE9PSBudWxsKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgbGVuPTE7IGxlbiA8PSBwYXJ0Lmxlbmd0aDsgbGVuKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBxbiA9IHBhcnQuc2xpY2UocGFydC5sZW5ndGgtbGVuKTtcclxuICAgICAgICAgICAgICAgIGlmICh0ID09PSB0aGlzLnJlc29sdmUocW4sIHQgaW5zdGFuY2VvZiBSZWZsZWN0Lk5hbWVzcGFjZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHFuLmpvaW4oXCIuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0LmZxbigpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkcyB0aGUgbmFtZXNwYWNlIGFuZCByZXR1cm5zIHRoZSBydW50aW1lIGNvdW50ZXJwYXJ0LlxyXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLEZ1bmN0aW9ufE9iamVjdD59IFJ1bnRpbWUgbmFtZXNwYWNlXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvKiogQGRpY3QgKi9cclxuICAgICAgICAgICAgdmFyIG5zID0ge307XHJcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz1jaGlsZHJlbi5sZW5ndGgsIGNoaWxkOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIE5hbWVzcGFjZSlcclxuICAgICAgICAgICAgICAgICAgICBuc1tjaGlsZC5uYW1lXSA9IGNoaWxkLmJ1aWxkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSlcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgXCIkb3B0aW9uc1wiLCB7IFwidmFsdWVcIjogdGhpcy5idWlsZE9wdCgpIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbnM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVpbGRzIHRoZSBuYW1lc3BhY2UncyAnJG9wdGlvbnMnIHByb3BlcnR5LlxyXG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5idWlsZE9wdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgb3B0ID0ge30sXHJcbiAgICAgICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrPWtleXMubGVuZ3RoOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5vcHRpb25zW2tleXNbaV1dO1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogT3B0aW9ucyBhcmUgbm90IHJlc29sdmVkLCB5ZXQuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiAodmFsIGluc3RhbmNlb2YgTmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgb3B0W2tleV0gPSB2YWwuYnVpbGQoKTtcclxuICAgICAgICAgICAgICAgIC8vIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcHRba2V5XSA9IHZhbDtcclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3B0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHZhbHVlIGFzc2lnbmVkIHRvIHRoZSBvcHRpb24gd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIFJldHVybnMgdGhlIG9wdGlvbiB2YWx1ZSBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSBhbGwgb3B0aW9ucyBhcmUgcmV0dXJuZWQuXHJcbiAgICAgICAgICogQHJldHVybiB7KnxPYmplY3QuPHN0cmluZywqPn1udWxsfSBPcHRpb24gdmFsdWUgb3IgTlVMTCBpZiB0aGVyZSBpcyBubyBzdWNoIG9wdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hbWVzcGFjZVByb3RvdHlwZS5nZXRPcHRpb24gPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMub3B0aW9uc1tuYW1lXSAhPT0gJ3VuZGVmaW5lZCcgPyB0aGlzLm9wdGlvbnNbbmFtZV0gOiBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSZWZsZWN0Lk5hbWVzcGFjZSA9IE5hbWVzcGFjZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBFbGVtZW50IGltcGxlbWVudGF0aW9uIHRoYXQgY2hlY2tzIGFuZCBjb252ZXJ0cyB2YWx1ZXMgZm9yIGFcclxuICAgICAgICAgKiBwYXJ0aWN1bGFyIGZpZWxkIHR5cGUsIGFzIGFwcHJvcHJpYXRlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQW4gRWxlbWVudCByZXByZXNlbnRzIGEgc2luZ2xlIHZhbHVlOiBlaXRoZXIgdGhlIHZhbHVlIG9mIGEgc2luZ3VsYXIgZmllbGQsXHJcbiAgICAgICAgICogb3IgYSB2YWx1ZSBjb250YWluZWQgaW4gb25lIGVudHJ5IG9mIGEgcmVwZWF0ZWQgZmllbGQgb3IgbWFwIGZpZWxkLiBUaGlzXHJcbiAgICAgICAgICogY2xhc3MgZG9lcyBub3QgaW1wbGVtZW50IHRoZXNlIGhpZ2hlci1sZXZlbCBjb25jZXB0czsgaXQgb25seSBlbmNhcHN1bGF0ZXNcclxuICAgICAgICAgKiB0aGUgbG93LWxldmVsIHR5cGVjaGVja2luZyBhbmQgY29udmVyc2lvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuRWxlbWVudFxyXG4gICAgICAgICAqIEBwYXJhbSB7e25hbWU6IHN0cmluZywgd2lyZVR5cGU6IG51bWJlcn19IHR5cGUgUmVzb2x2ZWQgZGF0YSB0eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtQcm90b0J1Zi5SZWZsZWN0LlR8bnVsbH0gcmVzb2x2ZWRUeXBlIFJlc29sdmVkIHR5cGUsIGlmIHJlbGV2YW50XHJcbiAgICAgICAgICogKGUuZy4gc3VibWVzc2FnZSBmaWVsZCkuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc01hcEtleSBJcyB0aGlzIGVsZW1lbnQgYSBNYXAga2V5PyBUaGUgdmFsdWUgd2lsbCBiZVxyXG4gICAgICAgICAqIGNvbnZlcnRlZCB0byBzdHJpbmcgZm9ybSBpZiBzby5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ludGF4IFN5bnRheCBsZXZlbCBvZiBkZWZpbmluZyBtZXNzYWdlIHR5cGUsIGUuZy4sXHJcbiAgICAgICAgICogcHJvdG8yIG9yIHByb3RvMy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBmaWVsZCBjb250YWluaW5nIHRoaXMgZWxlbWVudCAoZm9yIGVycm9yXHJcbiAgICAgICAgICogbWVzc2FnZXMpXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEVsZW1lbnQgPSBmdW5jdGlvbih0eXBlLCByZXNvbHZlZFR5cGUsIGlzTWFwS2V5LCBzeW50YXgsIG5hbWUpIHtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbGVtZW50IHR5cGUsIGFzIGEgc3RyaW5nIChlLmcuLCBpbnQzMikuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHt7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyfX1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRWxlbWVudCB0eXBlIHJlZmVyZW5jZSB0byBzdWJtZXNzYWdlIG9yIGVudW0gZGVmaW5pdGlvbiwgaWYgbmVlZGVkLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5UfG51bGx9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkVHlwZSA9IHJlc29sdmVkVHlwZTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbGVtZW50IGlzIGEgbWFwIGtleS5cclxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmlzTWFwS2V5ID0gaXNNYXBLZXk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3ludGF4IGxldmVsIG9mIGRlZmluaW5nIG1lc3NhZ2UgdHlwZSwgZS5nLiwgcHJvdG8yIG9yIHByb3RvMy5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuc3ludGF4ID0gc3ludGF4O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5hbWUgb2YgdGhlIGZpZWxkIGNvbnRhaW5pbmcgdGhpcyBlbGVtZW50IChmb3IgZXJyb3IgbWVzc2FnZXMpXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG5cclxuICAgICAgICAgICAgaWYgKGlzTWFwS2V5ICYmIFByb3RvQnVmLk1BUF9LRVlfVFlQRVMuaW5kZXhPZih0eXBlKSA8IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgbWFwIGtleSB0eXBlOiBcIiArIHR5cGUubmFtZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIEVsZW1lbnRQcm90b3R5cGUgPSBFbGVtZW50LnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT2J0YWlucyBhIChuZXcpIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgdHlwZS5cclxuICAgICAgICAgKiBAcGFyYW0gdHlwZSB7c3RyaW5nfHtuYW1lOiBzdHJpbmcsIHdpcmVUeXBlOiBudW1iZXJ9fSBGaWVsZCB0eXBlXHJcbiAgICAgICAgICogQHJldHVybnMgeyp9IERlZmF1bHQgdmFsdWVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBta0RlZmF1bHQodHlwZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgdHlwZSA9IFByb3RvQnVmLlRZUEVTW3R5cGVdO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHR5cGUuZGVmYXVsdFZhbHVlID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZGVmYXVsdCB2YWx1ZSBmb3IgdHlwZSBcIit0eXBlLm5hbWUrXCIgaXMgbm90IHN1cHBvcnRlZFwiKTtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT0gUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZUJ1ZmZlcigwKTtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhpcyBmaWVsZCBpbiBwcm90bzMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHR5cGUge3N0cmluZ3x7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyfX0gdGhlIGZpZWxkIHR5cGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gRGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVsZW1lbnQuZGVmYXVsdEZpZWxkVmFsdWUgPSBta0RlZmF1bHQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1ha2VzIGEgTG9uZyBmcm9tIGEgdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHt7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fHN0cmluZ3xudW1iZXJ9IHZhbHVlIFZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHJldXNlIGl0IGZyb20gTG9uZy1saWtlIG9iamVjdHMgb3IgdG8gc2lnbmVkIGZvclxyXG4gICAgICAgICAqICBzdHJpbmdzIGFuZCBudW1iZXJzXHJcbiAgICAgICAgICogQHJldHVybnMgeyFMb25nfVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIExvbmdcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBta0xvbmcodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUubG93ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUuaGlnaCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnVuc2lnbmVkID09PSAnYm9vbGVhbidcclxuICAgICAgICAgICAgICAgICYmIHZhbHVlLmxvdyA9PT0gdmFsdWUubG93ICYmIHZhbHVlLmhpZ2ggPT09IHZhbHVlLmhpZ2gpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb3RvQnVmLkxvbmcodmFsdWUubG93LCB2YWx1ZS5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICd1bmRlZmluZWQnID8gdmFsdWUudW5zaWduZWQgOiB1bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb3RvQnVmLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSwgdW5zaWduZWQgfHwgZmFsc2UsIDEwKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvdG9CdWYuTG9uZy5mcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCB8fCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibm90IGNvbnZlcnRpYmxlIHRvIExvbmdcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBFbGVtZW50UHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5uYW1lIHx8ICcnKSArICh0aGlzLmlzTWFwS2V5ID8gJ21hcCcgOiAndmFsdWUnKSArICcgZWxlbWVudCc7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBjYW4gYmUgc2V0IGZvciBhbiBlbGVtZW50IG9mIHRoaXMgdHlwZSAoc2luZ3VsYXJcclxuICAgICAgICAgKiBmaWVsZCBvciBvbmUgZWxlbWVudCBvZiBhIHJlcGVhdGVkIGZpZWxkIG9yIG1hcCkuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBjaGVja1xyXG4gICAgICAgICAqIEByZXR1cm4geyp9IFZlcmlmaWVkLCBtYXliZSBhZGp1c3RlZCwgdmFsdWVcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSB2ZXJpZmllZCBmb3IgdGhpcyBlbGVtZW50IHNsb3RcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWxlbWVudFByb3RvdHlwZS52ZXJpZnlWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgICAgZnVuY3Rpb24gZmFpbCh2YWwsIG1zZykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlIGZvciBcIitzZWxmLnRvU3RyaW5nKHRydWUpK1wiIG9mIHR5cGUgXCIrc2VsZi50eXBlLm5hbWUrXCI6IFwiK3ZhbCtcIiAoXCIrbXNnK1wiKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2lnbmVkIDMyYml0XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFjY291bnQgZm9yICFOYU46IHZhbHVlID09PSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8ICh2YWx1ZSA9PT0gdmFsdWUgJiYgdmFsdWUgJSAxICE9PSAwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGFuIGludGVnZXJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gNDI5NDk2NzI5NSA/IHZhbHVlIHwgMCA6IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVuc2lnbmVkIDMyYml0XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1widWludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkMzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgKHZhbHVlID09PSB2YWx1ZSAmJiB2YWx1ZSAlIDEgIT09IDApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJub3QgYW4gaW50ZWdlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gdmFsdWUgPj4+IDAgOiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTaWduZWQgNjRiaXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkNjRcIl06IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUHJvdG9CdWYuTG9uZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBta0xvbmcodmFsdWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIGUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcInJlcXVpcmVzIExvbmcuanNcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVW5zaWduZWQgNjRiaXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJ1aW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZml4ZWQ2NFwiXToge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChQcm90b0J1Zi5Mb25nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1rTG9uZyh2YWx1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBlLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJyZXF1aXJlcyBMb25nLmpzXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEJvb2xcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwibm90IGEgYm9vbGVhblwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRmxvYXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmbG9hdFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJkb3VibGVcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vdCBhIG51bWJlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgISh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vdCBhIHN0cmluZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIit2YWx1ZTsgLy8gQ29udmVydCBTdHJpbmcgb2JqZWN0IHRvIHN0cmluZ1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIExlbmd0aC1kZWxpbWl0ZWQgYnl0ZXNcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXTpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIud3JhcCh2YWx1ZSwgXCJiYXNlNjRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29uc3RhbnQgZW51bSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl06IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5yZXNvbHZlZFR5cGUuZ2V0Q2hpbGRyZW4oUHJvdG9CdWYuUmVmbGVjdC5FbnVtLlZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNbaV0ubmFtZSA9PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbaV0uaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlc1tpXS5pZCA9PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbaV0uaWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN5bnRheCA9PT0gJ3Byb3RvMycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvdG8zOiBqdXN0IG1ha2Ugc3VyZSBpdCdzIGFuIGludGVnZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8ICh2YWx1ZSA9PT0gdmFsdWUgJiYgdmFsdWUgJSAxICE9PSAwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vdCBhbiBpbnRlZ2VyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiA0Mjk0OTY3Mjk1IHx8IHZhbHVlIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vdCBpbiByYW5nZSBmb3IgdWludDMyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvdG8yIHJlcXVpcmVzIGVudW0gdmFsdWVzIHRvIGJlIHZhbGlkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsKHZhbHVlLCBcIm5vdCBhIHZhbGlkIGVudW0gdmFsdWVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRW1iZWRkZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImdyb3VwXCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcIm1lc3NhZ2VcIl06IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm9iamVjdCBleHBlY3RlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiB0aGlzLnJlc29sdmVkVHlwZS5jbGF6eilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNaXNtYXRjaGVkIHR5cGU6IENvbnZlcnQgdG8gb2JqZWN0IChzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL1Byb3RvQnVmLmpzL2lzc3Vlcy8xODApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpbaV0gPSB2YWx1ZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmo7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2UgbGV0J3MgdHJ5IHRvIGNvbnN0cnVjdCBvbmUgZnJvbSBhIGtleS12YWx1ZSBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh0aGlzLnJlc29sdmVkVHlwZS5jbGF6eikodmFsdWUpOyAvLyBNYXkgdGhyb3cgZm9yIGEgaHVuZHJlZCBvZiByZWFzb25zXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBlbmQgaGVyZVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gSWxsZWdhbCB2YWx1ZSBmb3IgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdmFsdWUrXCIgKHVuZGVmaW5lZCB0eXBlIFwiK3RoaXMudHlwZStcIilcIik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgYW4gZWxlbWVudCBvbiB0aGUgd2lyZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgRmllbGQgbnVtYmVyXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBGaWVsZCB2YWx1ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgY2FsY3VsYXRlZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbGVtZW50UHJvdG90eXBlLmNhbGN1bGF0ZUxlbmd0aCA9IGZ1bmN0aW9uKGlkLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiAwOyAvLyBOb3RoaW5nIHRvIGVuY29kZVxyXG4gICAgICAgICAgICAvLyBUYWcgaGFzIGFscmVhZHkgYmVlbiB3cml0dGVuXHJcbiAgICAgICAgICAgIHZhciBuO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA8IDAgPyBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDY0KHZhbHVlKSA6IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKEJ5dGVCdWZmZXIuemlnWmFnRW5jb2RlMzIodmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZsb2F0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA0O1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQ2NCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDY0KEJ5dGVCdWZmZXIuemlnWmFnRW5jb2RlNjQodmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA4O1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJvb2xcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZW51bVwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZG91YmxlXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA4O1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInN0cmluZ1wiXTpcclxuICAgICAgICAgICAgICAgICAgICBuID0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVVVEY4Qnl0ZXModmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKG4pICsgbjtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJieXRlc1wiXTpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUucmVtYWluaW5nKCkgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlLnJlbWFpbmluZygpK1wiIGJ5dGVzIHJlbWFpbmluZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMih2YWx1ZS5yZW1haW5pbmcoKSkgKyB2YWx1ZS5yZW1haW5pbmcoKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIG4gPSB0aGlzLnJlc29sdmVkVHlwZS5jYWxjdWxhdGUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKG4pICsgbjtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJncm91cFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBuID0gdGhpcy5yZXNvbHZlZFR5cGUuY2FsY3VsYXRlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbiArIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKGlkIDw8IDMpIHwgUHJvdG9CdWYuV0lSRV9UWVBFUy5FTkRHUk9VUCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIG5ldmVyIGVuZCBoZXJlXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiW0lOVEVSTkFMXSBJbGxlZ2FsIHZhbHVlIHRvIGVuY29kZSBpbiBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZStcIiAodW5rbm93biB0eXBlKVwiKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIGEgdmFsdWUgdG8gdGhlIHNwZWNpZmllZCBidWZmZXIuIERvZXMgbm90IGVuY29kZSB0aGUga2V5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBGaWVsZCBudW1iZXJcclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEZpZWxkIHZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHtCeXRlQnVmZmVyfSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgKiBAcmV0dXJuIHtCeXRlQnVmZmVyfSBUaGUgQnl0ZUJ1ZmZlciBmb3IgY2hhaW5pbmdcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBlbmNvZGVkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVsZW1lbnRQcm90b3R5cGUuZW5jb2RlVmFsdWUgPSBmdW5jdGlvbihpZCwgdmFsdWUsIGJ1ZmZlcikge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiBidWZmZXI7IC8vIE5vdGhpbmcgdG8gZW5jb2RlXHJcbiAgICAgICAgICAgIC8vIFRhZyBoYXMgYWxyZWFkeSBiZWVuIHdyaXR0ZW5cclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAzMmJpdCBzaWduZWQgdmFyaW50XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gXCJJZiB5b3UgdXNlIGludDMyIG9yIGludDY0IGFzIHRoZSB0eXBlIGZvciBhIG5lZ2F0aXZlIG51bWJlciwgdGhlIHJlc3VsdGluZyB2YXJpbnQgaXMgYWx3YXlzIHRlbiBieXRlc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvbmcg4oCTIGl0IGlzLCBlZmZlY3RpdmVseSwgdHJlYXRlZCBsaWtlIGEgdmVyeSBsYXJnZSB1bnNpZ25lZCBpbnRlZ2VyLlwiIChzZWUgIzEyMilcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQ2NCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMzJiaXQgdW5zaWduZWQgdmFyaW50XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1widWludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAzMmJpdCB2YXJpbnQgemlnLXphZ1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMlppZ1phZyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRml4ZWQgdW5zaWduZWQgMzJiaXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVpbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRml4ZWQgc2lnbmVkIDMyYml0XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkMzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlSW50MzIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDY0Yml0IHZhcmludCBhcy1pc1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQ2NCh2YWx1ZSk7IC8vIHRocm93c1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDY0Yml0IHZhcmludCB6aWctemFnXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDY0WmlnWmFnKHZhbHVlKTsgLy8gdGhyb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRml4ZWQgdW5zaWduZWQgNjRiaXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVpbnQ2NCh2YWx1ZSk7IC8vIHRocm93c1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeGVkIHNpZ25lZCA2NGJpdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZUludDY0KHZhbHVlKTsgLy8gdGhyb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQm9vbFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJvb2xcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdmYWxzZScgPyAwIDogISF2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMih2YWx1ZSA/IDEgOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb25zdGFudCBlbnVtIHZhbHVlXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZW51bVwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMzJiaXQgZmxvYXRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmbG9hdFwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVGbG9hdDMyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyA2NGJpdCBmbG9hdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImRvdWJsZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVGbG9hdDY0KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMZW5ndGgtZGVsaW1pdGVkIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInN0cmluZ1wiXTpcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWU3RyaW5nKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMZW5ndGgtZGVsaW1pdGVkIGJ5dGVzXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiYnl0ZXNcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnJlbWFpbmluZygpIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZS5yZW1haW5pbmcoKStcIiBieXRlcyByZW1haW5pbmdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZPZmZzZXQgPSB2YWx1ZS5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIodmFsdWUucmVtYWluaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLm9mZnNldCA9IHByZXZPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRW1iZWRkZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcIm1lc3NhZ2VcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJiID0gbmV3IEJ5dGVCdWZmZXIoKS5MRSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRUeXBlLmVuY29kZSh2YWx1ZSwgYmIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKGJiLm9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmFwcGVuZChiYi5mbGlwKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBncm91cFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImdyb3VwXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRUeXBlLmVuY29kZSh2YWx1ZSwgYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMigoaWQgPDwgMykgfCBQcm90b0J1Zi5XSVJFX1RZUEVTLkVOREdST1VQKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBlbmQgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiW0lOVEVSTkFMXSBJbGxlZ2FsIHZhbHVlIHRvIGVuY29kZSBpbiBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZStcIiAodW5rbm93biB0eXBlKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZSBvbmUgZWxlbWVudCB2YWx1ZSBmcm9tIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Qnl0ZUJ1ZmZlcn0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lyZVR5cGUgVGhlIGZpZWxkIHdpcmUgdHlwZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBUaGUgZmllbGQgbnVtYmVyXHJcbiAgICAgICAgICogQHJldHVybiB7Kn0gRGVjb2RlZCB2YWx1ZVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZmllbGQgY2Fubm90IGJlIGRlY29kZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRWxlbWVudFByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihidWZmZXIsIHdpcmVUeXBlLCBpZCkge1xyXG4gICAgICAgICAgICBpZiAod2lyZVR5cGUgIT0gdGhpcy50eXBlLndpcmVUeXBlKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmV4cGVjdGVkIHdpcmUgdHlwZSBmb3IgZWxlbWVudFwiKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSwgbkJ5dGVzO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gMzJiaXQgc2lnbmVkIHZhcmludFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZFZhcmludDMyKCkgfCAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDMyYml0IHVuc2lnbmVkIHZhcmludFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWYXJpbnQzMigpID4+PiAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDMyYml0IHNpZ25lZCB2YXJpbnQgemlnLXphZ1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWYXJpbnQzMlppZ1phZygpIHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaXhlZCAzMmJpdCB1bnNpZ25lZFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkMzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVWludDMyKCkgPj4+IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXIucmVhZEludDMyKCkgfCAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDY0Yml0IHNpZ25lZCB2YXJpbnRcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWYXJpbnQ2NCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDY0Yml0IHVuc2lnbmVkIHZhcmludFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWYXJpbnQ2NCgpLnRvVW5zaWduZWQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyA2NGJpdCBzaWduZWQgdmFyaW50IHppZy16YWdcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVmFyaW50NjRaaWdaYWcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaXhlZCA2NGJpdCB1bnNpZ25lZFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkNjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkVWludDY0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRml4ZWQgNjRiaXQgc2lnbmVkXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkNjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkSW50NjQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBCb29sIHZhcmludFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJvb2xcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbnN0YW50IGVudW0gdmFsdWUgKHZhcmludClcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJlbnVtXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgQnVpbGRlci5NZXNzYWdlI3NldCB3aWxsIGFscmVhZHkgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDMyYml0IGZsb2F0XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZmxvYXRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5yZWFkRmxvYXQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyA2NGJpdCBmbG9hdFxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImRvdWJsZVwiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWREb3VibGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMZW5ndGgtZGVsaW1pdGVkIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInN0cmluZ1wiXTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyLnJlYWRWU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVuZ3RoLWRlbGltaXRlZCBieXRlc1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbkJ5dGVzID0gYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIucmVtYWluaW5nKCkgPCBuQnl0ZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBudW1iZXIgb2YgYnl0ZXMgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK25CeXRlcytcIiByZXF1aXJlZCBidXQgZ290IG9ubHkgXCIrYnVmZmVyLnJlbWFpbmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJ1ZmZlci5jbG9uZSgpOyAvLyBPZmZzZXQgYWxyZWFkeSBzZXRcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5saW1pdCA9IHZhbHVlLm9mZnNldCtuQnl0ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCArPSBuQnl0ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIExlbmd0aC1kZWxpbWl0ZWQgZW1iZWRkZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcIm1lc3NhZ2VcIl06IHtcclxuICAgICAgICAgICAgICAgICAgICBuQnl0ZXMgPSBidWZmZXIucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRUeXBlLmRlY29kZShidWZmZXIsIG5CeXRlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTGVnYWN5IGdyb3VwXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZ3JvdXBcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRUeXBlLmRlY29kZShidWZmZXIsIC0xLCBpZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBlbmQgaGVyZVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gSWxsZWdhbCBkZWNvZGUgdHlwZVwiKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyBhIHZhbHVlIGZyb20gYSBzdHJpbmcgdG8gdGhlIGNhbm9uaWNhbCBlbGVtZW50IHR5cGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBMZWdhbCBvbmx5IHdoZW4gaXNNYXBLZXkgaXMgdHJ1ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB2YWx1ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBFbGVtZW50UHJvdG90eXBlLnZhbHVlRnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNNYXBLZXkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwidmFsdWVGcm9tU3RyaW5nKCkgY2FsbGVkIG9uIG5vbi1tYXAta2V5IGVsZW1lbnRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInNmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInVpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJmaXhlZDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeVZhbHVlKHBhcnNlSW50KHN0cikpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkNjRcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1widWludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkNjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBMb25nLWJhc2VkIGZpZWxkcyBzdXBwb3J0IGNvbnZlcnNpb25zIGZyb20gc3RyaW5nIGFscmVhZHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlWYWx1ZShzdHIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0ciA9PT0gXCJ0cnVlXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcInN0cmluZ1wiXTpcclxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeVZhbHVlKHN0cik7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ5dGVCdWZmZXIuZnJvbUJpbmFyeShzdHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgYSB2YWx1ZSBmcm9tIHRoZSBjYW5vbmljYWwgZWxlbWVudCB0eXBlIHRvIGEgc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSXQgc2hvdWxkIGJlIHRoZSBjYXNlIHRoYXQgYHZhbHVlRnJvbVN0cmluZyh2YWx1ZVRvU3RyaW5nKHZhbCkpYCByZXR1cm5zXHJcbiAgICAgICAgICogYSB2YWx1ZSBlcXVpdmFsZW50IHRvIGB2ZXJpZnlWYWx1ZSh2YWwpYCBmb3IgZXZlcnkgbGVnYWwgdmFsdWUgb2YgYHZhbGBcclxuICAgICAgICAgKiBhY2NvcmRpbmcgdG8gdGhpcyBlbGVtZW50IHR5cGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIG1heSBiZSB1c2VkIHdoZW4gdGhlIGVsZW1lbnQgbXVzdCBiZSBzdG9yZWQgb3IgdXNlZCBhcyBhIHN0cmluZyxcclxuICAgICAgICAgKiBlLmcuLCBhcyBhIG1hcCBrZXkgb24gYW4gT2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTGVnYWwgb25seSB3aGVuIGlzTWFwS2V5IGlzIHRydWUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWVcclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc3RyaW5nIGZvcm0gb2YgdGhlIHZhbHVlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVsZW1lbnRQcm90b3R5cGUudmFsdWVUb1N0cmluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc01hcEtleSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJ2YWx1ZVRvU3RyaW5nKCkgY2FsbGVkIG9uIG5vbi1tYXAta2V5IGVsZW1lbnRcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFByb3RvQnVmLlRZUEVTW1wiYnl0ZXNcIl0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZyhcImJpbmFyeVwiKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuRWxlbWVudFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSZWZsZWN0LkVsZW1lbnQgPSBFbGVtZW50O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1lc3NhZ2UuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlfSBwYXJlbnQgUGFyZW50IG1lc3NhZ2Ugb3IgbmFtZXNwYWNlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWVzc2FnZSBuYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgTWVzc2FnZSBvcHRpb25zXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gaXNHcm91cCBgdHJ1ZWAgaWYgdGhpcyBpcyBhIGxlZ2FjeSBncm91cFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nP30gc3ludGF4IFRoZSBzeW50YXggbGV2ZWwgb2YgdGhpcyBkZWZpbml0aW9uIChlLmcuLCBwcm90bzMpXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgTWVzc2FnZSA9IGZ1bmN0aW9uKGJ1aWxkZXIsIHBhcmVudCwgbmFtZSwgb3B0aW9ucywgaXNHcm91cCwgc3ludGF4KSB7XHJcbiAgICAgICAgICAgIE5hbWVzcGFjZS5jYWxsKHRoaXMsIGJ1aWxkZXIsIHBhcmVudCwgbmFtZSwgb3B0aW9ucywgc3ludGF4KTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJNZXNzYWdlXCI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRXh0ZW5zaW9ucyByYW5nZS5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFBcnJheS48bnVtYmVyPnx1bmRlZmluZWR9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSdW50aW1lIG1lc3NhZ2UgY2xhc3MuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHs/ZnVuY3Rpb24obmV3OlByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSl9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhenogPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgdGhpcyBpcyBhIGxlZ2FjeSBncm91cCBvciBub3QuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmlzR3JvdXAgPSAhIWlzR3JvdXA7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNhY2hlZCBjb2xsZWN0aW9ucyBhcmUgdXNlZCB0byBlZmZpY2llbnRseSBpdGVyYXRlIG92ZXIgb3IgbG9vayB1cCBmaWVsZHMgd2hlbiBkZWNvZGluZy5cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWNoZWQgZmllbGRzLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7P0FycmF5LjwhUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkPn1cclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkcyA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FjaGVkIGZpZWxkcyBieSBpZC5cclxuICAgICAgICAgICAgICogQHR5cGUgez9PYmplY3QuPG51bWJlciwhUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkPn1cclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0J5SWQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhY2hlZCBmaWVsZHMgYnkgbmFtZS5cclxuICAgICAgICAgICAgICogQHR5cGUgez9PYmplY3QuPHN0cmluZywhUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkPn1cclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0J5TmFtZSA9IG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgTWVzc2FnZVByb3RvdHlwZSA9IE1lc3NhZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVpbGRzIHRoZSBtZXNzYWdlIGFuZCByZXR1cm5zIHRoZSBydW50aW1lIGNvdW50ZXJwYXJ0LCB3aGljaCBpcyBhIGZ1bGx5IGZ1bmN0aW9uYWwgY2xhc3MuXHJcbiAgICAgICAgICogQHNlZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2VcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWJ1aWxkIFdoZXRoZXIgdG8gcmVidWlsZCBvciBub3QsIGRlZmF1bHRzIHRvIGZhbHNlXHJcbiAgICAgICAgICogQHJldHVybiB7UHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfSBNZXNzYWdlIGNsYXNzXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBidWlsdFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24ocmVidWlsZCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jbGF6eiAmJiAhcmVidWlsZClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYXp6O1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBydW50aW1lIE1lc3NhZ2UgY2xhc3MgaW4gaXRzIG93biBzY29wZVxyXG4gICAgICAgICAgICB2YXIgY2xhenogPSAoZnVuY3Rpb24oUHJvdG9CdWYsIFQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRzID0gVC5nZXRDaGlsZHJlbihQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQpLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uZW9mcyA9IFQuZ2V0Q2hpbGRyZW4oUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLk9uZU9mKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgcnVudGltZSBNZXNzYWdlLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgKiBAY2xhc3MgQmFyZWJvbmUgb2YgYWxsIHJ1bnRpbWUgbWVzc2FnZXMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywqPnxzdHJpbmd9IHZhbHVlcyBQcmVzZXQgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gey4uLnN0cmluZ30gdmFyX2FyZ3NcclxuICAgICAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBjcmVhdGVkXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciBNZXNzYWdlID0gZnVuY3Rpb24odmFsdWVzLCB2YXJfYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdmlydHVhbCBvbmVvZiBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrPW9uZW9mcy5sZW5ndGg7IGk8azsgKytpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW29uZW9mc1tpXS5uYW1lXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGZpZWxkcyBhbmQgc2V0IGRlZmF1bHQgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpPTAsIGs9ZmllbGRzLmxlbmd0aDsgaTxrOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm5hbWVdID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLnJlcGVhdGVkID8gW10gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZpZWxkLm1hcCA/IG5ldyBQcm90b0J1Zi5NYXAoZmllbGQpIDogbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZmllbGQucmVxdWlyZWQgfHwgVC5zeW50YXggPT09ICdwcm90bzMnKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuZGVmYXVsdFZhbHVlICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tmaWVsZC5uYW1lXSA9IGZpZWxkLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBmaWVsZCB2YWx1ZXMgZnJvbSBhIHZhbHVlcyBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdmFsdWVzICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZXMgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBub3QgX2Fub3RoZXJfIE1lc3NhZ2UgKi8gKHR5cGVvZiB2YWx1ZXMuZW5jb2RlICE9PSAnZnVuY3Rpb24nIHx8IHZhbHVlcyBpbnN0YW5jZW9mIE1lc3NhZ2UpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBub3QgYSByZXBlYXRlZCBmaWVsZCAqLyAhQXJyYXkuaXNBcnJheSh2YWx1ZXMpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBub3QgYSBNYXAgKi8gISh2YWx1ZXMgaW5zdGFuY2VvZiBQcm90b0J1Zi5NYXApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBub3QgYSBCeXRlQnVmZmVyICovICFCeXRlQnVmZmVyLmlzQnl0ZUJ1ZmZlcih2YWx1ZXMpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBub3QgYW4gQXJyYXlCdWZmZXIgKi8gISh2YWx1ZXMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG5vdCBhIExvbmcgKi8gIShQcm90b0J1Zi5Mb25nICYmIHZhbHVlcyBpbnN0YW5jZW9mIFByb3RvQnVmLkxvbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXQodmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIC8vIFNldCBmaWVsZCB2YWx1ZXMgZnJvbSBhcmd1bWVudHMsIGluIGRlY2xhcmF0aW9uIG9yZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MCwgaz1hcmd1bWVudHMubGVuZ3RoOyBpPGs7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSA9IGFyZ3VtZW50c1tpXSkgIT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRzZXQoZmllbGRzW2ldLm5hbWUsIHZhbHVlKTsgLy8gTWF5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UucHJvdG90eXBlXHJcbiAgICAgICAgICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIE1lc3NhZ2VQcm90b3R5cGUgPSBNZXNzYWdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBZGRzIGEgdmFsdWUgdG8gYSByZXBlYXRlZCBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNhZGRcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBGaWVsZCBuYW1lXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGFkZFxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBhc3NlcnQgdGhlIHZhbHVlIG9yIG5vdCAoYXNzZXJ0cyBieSBkZWZhdWx0KVxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IHRoaXNcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIGFkZGVkXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBULl9maWVsZHNCeU5hbWVba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmllbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcih0aGlzK1wiI1wiK2tleStcIiBpcyB1bmRlZmluZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGZpZWxkIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIGZpZWxkOiBcIitmaWVsZC50b1N0cmluZyh0cnVlKSk7IC8vIE1heSB0aHJvdyBpZiBpdCdzIGFuIGVudW0gb3IgZW1iZWRkZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkLnJlcGVhdGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXkrXCIgaXMgbm90IGEgcmVwZWF0ZWQgZmllbGRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZmllbGQudmVyaWZ5VmFsdWUodmFsdWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1trZXldID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0ucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWRkcyBhIHZhbHVlIHRvIGEgcmVwZWF0ZWQgZmllbGQuIFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjYWRkfS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSMkYWRkXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgRmllbGQgbmFtZVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBhZGRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gYXNzZXJ0IHRoZSB2YWx1ZSBvciBub3QgKGFzc2VydHMgYnkgZGVmYXVsdClcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSB0aGlzXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBhZGRlZFxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLiRhZGQgPSBNZXNzYWdlUHJvdG90eXBlLmFkZDtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgYSBmaWVsZCdzIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3NldFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3whT2JqZWN0LjxzdHJpbmcsKj59IGtleU9yT2JqIFN0cmluZyBrZXkgb3IgcGxhaW4gb2JqZWN0IGhvbGRpbmcgbXVsdGlwbGUgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geygqfGJvb2xlYW4pPX0gdmFsdWUgVmFsdWUgdG8gc2V0IGlmIGtleSBpcyBhIHN0cmluZywgb3RoZXJ3aXNlIG9taXR0ZWRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gbm90IGFzc2VydCBmb3IgYW4gYWN0dWFsIGZpZWxkIC8gcHJvcGVyIHZhbHVlIHR5cGUsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSB0aGlzXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBzZXRcclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihrZXlPck9iaiwgdmFsdWUsIG5vQXNzZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleU9yT2JqICYmIHR5cGVvZiBrZXlPck9iaiA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9Bc3NlcnQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWtleSBpbiBrZXlPck9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdmlydHVhbCBvbmVvZiBmaWVsZCAtIGRvbid0IHNldCB0aGVzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleU9yT2JqLmhhc093blByb3BlcnR5KGlrZXkpICYmIHR5cGVvZiAodmFsdWUgPSBrZXlPck9ialtpa2V5XSkgIT09ICd1bmRlZmluZWQnICYmIFQuX29uZW9mc0J5TmFtZVtpa2V5XSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJHNldChpa2V5LCB2YWx1ZSwgbm9Bc3NlcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBULl9maWVsZHNCeU5hbWVba2V5T3JPYmpdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5T3JPYmorXCIgaXMgbm90IGEgZmllbGQ6IHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXlPck9iaitcIiBpcyBub3QgYSBmaWVsZDogXCIrZmllbGQudG9TdHJpbmcodHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm5hbWVdID0gKHZhbHVlID0gZmllbGQudmVyaWZ5VmFsdWUodmFsdWUpKTsgLy8gTWF5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5T3JPYmpdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLm9uZW9mKSB7IC8vIEZpZWxkIGlzIHBhcnQgb2YgYW4gT25lT2YgKG5vdCBhIHZpcnR1YWwgT25lT2YgZmllbGQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RmllbGQgPSB0aGlzW2ZpZWxkLm9uZW9mLm5hbWVdOyAvLyBWaXJ0dWFsIGZpZWxkIHJlZmVyZW5jZXMgY3VycmVudGx5IHNldCBmaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmllbGQgIT09IG51bGwgJiYgY3VycmVudEZpZWxkICE9PSBmaWVsZC5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbY3VycmVudEZpZWxkXSA9IG51bGw7IC8vIENsZWFyIGN1cnJlbnRseSBzZXQgZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbZmllbGQub25lb2YubmFtZV0gPSBmaWVsZC5uYW1lOyAvLyBQb2ludCB2aXJ0dWFsIGZpZWxkIGF0IHRoaXMgZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvKiB2YWx1ZSA9PT0gbnVsbCAmJiAqL2N1cnJlbnRGaWVsZCA9PT0ga2V5T3JPYmopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm9uZW9mLm5hbWVdID0gbnVsbDsgLy8gQ2xlYXIgdmlydHVhbCBmaWVsZCAoY3VycmVudCBmaWVsZCBleHBsaWNpdGx5IGNsZWFyZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgYSBmaWVsZCdzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIGZvciBbQGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI3NldH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJHNldFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3whT2JqZWN0LjxzdHJpbmcsKj59IGtleU9yT2JqIFN0cmluZyBrZXkgb3IgcGxhaW4gb2JqZWN0IGhvbGRpbmcgbXVsdGlwbGUgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geygqfGJvb2xlYW4pPX0gdmFsdWUgVmFsdWUgdG8gc2V0IGlmIGtleSBpcyBhIHN0cmluZywgb3RoZXJ3aXNlIG9taXR0ZWRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gbm90IGFzc2VydCB0aGUgdmFsdWUsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLiRzZXQgPSBNZXNzYWdlUHJvdG90eXBlLnNldDtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgYSBmaWVsZCdzIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2dldFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnQgV2hldGhlciB0byBub3QgYXNzZXJ0IGZvciBhbiBhY3R1YWwgZmllbGQsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFZhbHVlXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgbm8gc3VjaCBmaWVsZFxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSwgbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9Bc3NlcnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gVC5fZmllbGRzQnlOYW1lW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZCB8fCAhKGZpZWxkIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodGhpcytcIiNcIitrZXkrXCIgaXMgbm90IGEgZmllbGQ6IHVuZGVmaW5lZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShmaWVsZCBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRoaXMrXCIjXCIra2V5K1wiIGlzIG5vdCBhIGZpZWxkOiBcIitmaWVsZC50b1N0cmluZyh0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZmllbGQubmFtZV07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyBhIGZpZWxkJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgZm9yIHtAbGluayBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJGdldH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjJGdldFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IEtleVxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7Kn0gVmFsdWVcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBubyBzdWNoIGZpZWxkXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuJGdldCA9IE1lc3NhZ2VQcm90b3R5cGUuZ2V0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldHRlcnMgYW5kIHNldHRlcnNcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8ZmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vIHNldHRlcnMgZm9yIGV4dGVuc2lvbiBmaWVsZHMgYXMgdGhlc2UgYXJlIG5hbWVkIGJ5IHRoZWlyIGZxblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5FeHRlbnNpb25GaWVsZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChULmJ1aWxkZXIub3B0aW9uc1sncG9wdWxhdGVBY2Nlc3NvcnMnXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKGZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQvZ2V0W1NvbWVWYWx1ZV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBOYW1lID0gZmllbGQub3JpZ2luYWxOYW1lLnJlcGxhY2UoLyhfW2EtekEtWl0pL2csIGZ1bmN0aW9uKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgnXycsJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOYW1lID0gTmFtZS5zdWJzdHJpbmcoMCwxKS50b1VwcGVyQ2FzZSgpICsgTmFtZS5zdWJzdHJpbmcoMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0L2dldF9bc29tZV92YWx1ZV0gRklYTUU6IERvIHdlIHJlYWxseSBuZWVkIHRoZXNlP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBmaWVsZC5vcmlnaW5hbE5hbWUucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbihtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIl9cIittYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgZmllbGQncyB1bmJvdW5kIHNldHRlciBmdW5jdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9Bc3NlcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbih2YWx1ZSwgbm9Bc3NlcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkLm5hbWVdID0gbm9Bc3NlcnQgPyB2YWx1ZSA6IGZpZWxkLnZlcmlmeVZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGUgY3VycmVudCBmaWVsZCdzIHVuYm91bmQgZ2V0dGVyIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0dGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZmllbGQubmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChULmdldENoaWxkKFwic2V0XCIrTmFtZSkgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2Ujc2V0W1NvbWVGaWVsZF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vQXNzZXJ0IFdoZXRoZXIgdG8gbm90IGFzc2VydCB0aGUgdmFsdWUsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gdGhpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdmFsdWUgY2Fubm90IGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGVbXCJzZXRcIitOYW1lXSA9IHNldHRlcjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVC5nZXRDaGlsZChcInNldF9cIituYW1lKSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTZXRzIGEgdmFsdWUuIFRoaXMgbWV0aG9kIGlzIHByZXNlbnQgZm9yIGVhY2ggZmllbGQsIGJ1dCBvbmx5IGlmIHRoZXJlIGlzIG5vIG5hbWUgY29uZmxpY3Qgd2l0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICBhbm90aGVyIGZpZWxkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNzZXRfW3NvbWVfZmllbGRdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBub0Fzc2VydCBXaGV0aGVyIHRvIG5vdCBhc3NlcnQgdGhlIHZhbHVlLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlW1wic2V0X1wiK25hbWVdID0gc2V0dGVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChULmdldENoaWxkKFwiZ2V0XCIrTmFtZSkgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogR2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZ2V0W1NvbWVGaWVsZF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAYWJzdHJhY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlW1wiZ2V0XCIrTmFtZV0gPSBnZXR0ZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFQuZ2V0Q2hpbGQoXCJnZXRfXCIrbmFtZSkgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogR2V0cyBhIHZhbHVlLiBUaGlzIG1ldGhvZCBpcyBwcmVzZW50IGZvciBlYWNoIGZpZWxkLCBidXQgb25seSBpZiB0aGVyZSBpcyBubyBuYW1lIGNvbmZsaWN0IHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgYW5vdGhlciBmaWVsZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZ2V0X1tzb21lX2ZpZWxkXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGVbXCJnZXRfXCIrbmFtZV0gPSBnZXR0ZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KShmaWVsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRW4tL2RlY29kaW5nXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBtZXNzYWdlLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlIyRlbmNvZGVcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsoIUJ5dGVCdWZmZXJ8Ym9vbGVhbik9fSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBlbmNvZGUgdG8uIFdpbGwgY3JlYXRlIGEgbmV3IG9uZSBhbmQgZmxpcCBpdCBpZiBvbWl0dGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gbm9WZXJpZnkgV2hldGhlciB0byBub3QgdmVyaWZ5IGZpZWxkIHZhbHVlcywgZGVmYXVsdHMgdG8gYGZhbHNlYFxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7IUJ5dGVCdWZmZXJ9IEVuY29kZWQgbWVzc2FnZSBhcyBhIEJ5dGVCdWZmZXJcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgQnl0ZUJ1ZmZlciBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZTY0XHJcbiAgICAgICAgICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVIZXhcclxuICAgICAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUFCXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oYnVmZmVyLCBub1ZlcmlmeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnYm9vbGVhbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vVmVyaWZ5ID0gYnVmZmVyLCBidWZmZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzTmV3ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFidWZmZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBCeXRlQnVmZmVyKCksIGlzTmV3ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGUgPSBidWZmZXIubGl0dGxlRW5kaWFuO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFQuZW5jb2RlKHRoaXMsIGJ1ZmZlci5MRSgpLCBub1ZlcmlmeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaXNOZXcgPyBidWZmZXIuZmxpcCgpIDogYnVmZmVyKS5MRShsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuTEUobGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRW5jb2RlcyBhIG1lc3NhZ2UgdXNpbmcgdGhlIHNwZWNpZmllZCBkYXRhIHBheWxvYWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywqPn0gZGF0YSBEYXRhIHBheWxvYWRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KCFCeXRlQnVmZmVyfGJvb2xlYW4pPX0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgYW5kIGZsaXAgaXQgaWYgb21pdHRlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vVmVyaWZ5IFdoZXRoZXIgdG8gbm90IHZlcmlmeSBmaWVsZCB2YWx1ZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCeXRlQnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgYSBCeXRlQnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2UuZW5jb2RlID0gZnVuY3Rpb24oZGF0YSwgYnVmZmVyLCBub1ZlcmlmeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWVzc2FnZShkYXRhKS5lbmNvZGUoYnVmZmVyLCBub1ZlcmlmeSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgdGhlIG1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjY2FsY3VsYXRlXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGNhbGN1bGF0ZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBULmNhbGN1bGF0ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSB2YXJpbnQzMiBsZW5ndGgtZGVsaW1pdGVkIG1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjZW5jb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KCFCeXRlQnVmZmVyfGJvb2xlYW4pPX0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgYW5kIGZsaXAgaXQgaWYgb21pdHRlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vVmVyaWZ5IFdoZXRoZXIgdG8gbm90IHZlcmlmeSBmaWVsZCB2YWx1ZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCeXRlQnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgYSBCeXRlQnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBlbmNvZGVkIEJ5dGVCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24oYnVmZmVyLCBub1ZlcmlmeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc05ldyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYnVmZmVyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQnl0ZUJ1ZmZlcigpLCBpc05ldyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuYyA9IG5ldyBCeXRlQnVmZmVyKCkuTEUoKTtcclxuICAgICAgICAgICAgICAgICAgICBULmVuY29kZSh0aGlzLCBlbmMsIG5vVmVyaWZ5KS5mbGlwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoZW5jLnJlbWFpbmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKGVuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTmV3ID8gYnVmZmVyLmZsaXAoKSA6IGJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGFuIEFycmF5QnVmZmVyLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUFCXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBFbmNvZGVkIG1lc3NhZ2UgYXMgQXJyYXlCdWZmZXJcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgQXJyYXlCdWZmZXIgaW4gdGhlIGBlbmNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlQUIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUoKS50b0FycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtcImVuY29kZWRcIl0pIGVbXCJlbmNvZGVkXCJdID0gZVtcImVuY29kZWRcIl0udG9BcnJheUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhbiBBcnJheUJ1ZmZlci4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGVBQn0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjdG9BcnJheUJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gRW5jb2RlZCBtZXNzYWdlIGFzIEFycmF5QnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBlbmNvZGVkIEFycmF5QnVmZmVyIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBNZXNzYWdlUHJvdG90eXBlLmVuY29kZUFCO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGlyZWN0bHkgZW5jb2RlcyB0aGUgbWVzc2FnZSB0byBhIG5vZGUgQnVmZmVyLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZU5CXHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFCdWZmZXJ9XHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGVuY29kZWQsIG5vdCBydW5uaW5nIHVuZGVyIG5vZGUuanMgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZVxyXG4gICAgICAgICAgICAgICAgICogIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbCByZXR1cm5zIHRoZSBlbmNvZGVkIG5vZGUgQnVmZmVyIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmVuY29kZU5CID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKCkudG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlW1wiZW5jb2RlZFwiXSkgZVtcImVuY29kZWRcIl0gPSBlW1wiZW5jb2RlZFwiXS50b0J1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhIG5vZGUgQnVmZmVyLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZU5CfS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSN0b0J1ZmZlclxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshQnVmZmVyfVxyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZW5jb2RlZCBub2RlIEJ1ZmZlciBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b0J1ZmZlciA9IE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlTkI7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZTY0XHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHVuZGVybHlpbmcgYnVmZmVyIGNhbm5vdCBiZSBlbmNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyXHJcbiAgICAgICAgICAgICAgICAgKiAgc3RpbGwgcmV0dXJucyB0aGUgZW5jb2RlZCBiYXNlNjQgc3RyaW5nIGluIHRoZSBgZW5jb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmVuY29kZTY0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKCkudG9CYXNlNjQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlW1wiZW5jb2RlZFwiXSkgZVtcImVuY29kZWRcIl0gPSBlW1wiZW5jb2RlZFwiXS50b0Jhc2U2NCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgbWVzc2FnZSBhcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy4gVGhpcyBpcyBhbiBhbGlhcyBmb3Ige0BsaW5rIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSNlbmNvZGU2NH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjdG9CYXNlNjRcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgYmFzZTY0IHN0cmluZyBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b0Jhc2U2NCA9IE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlNjQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEaXJlY3RseSBlbmNvZGVzIHRoZSBtZXNzYWdlIHRvIGEgaGV4IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUhleFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEhleCBlbmNvZGVkIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlclxyXG4gICAgICAgICAgICAgICAgICogIHN0aWxsIHJldHVybnMgdGhlIGVuY29kZWQgaGV4IHN0cmluZyBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS5lbmNvZGVIZXggPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUoKS50b0hleCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVbXCJlbmNvZGVkXCJdKSBlW1wiZW5jb2RlZFwiXSA9IGVbXCJlbmNvZGVkXCJdLnRvSGV4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBtZXNzYWdlIGFzIGEgaGV4IGVuY29kZWQgc3RyaW5nLiBUaGlzIGlzIGFuIGFsaWFzIGZvciB7QGxpbmsgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlI2VuY29kZUhleH0uXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UjdG9IZXhcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBIZXggZW5jb2RlZCBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZW5jb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGVuY29kZWQgaGV4IHN0cmluZyBpbiB0aGUgYGVuY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b0hleCA9IE1lc3NhZ2VQcm90b3R5cGUuZW5jb2RlSGV4O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2xvbmVzIGEgbWVzc2FnZSBvYmplY3Qgb3IgZmllbGQgdmFsdWUgdG8gYSByYXcgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsqfSBvYmogT2JqZWN0IHRvIGNsb25lXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGJpbmFyeUFzQmFzZTY0IFdoZXRoZXIgdG8gaW5jbHVkZSBiaW5hcnkgZGF0YSBhcyBiYXNlNjQgc3RyaW5ncyBvciBhcyBhIGJ1ZmZlciBvdGhlcndpc2VcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9uZ3NBc1N0cmluZ3MgV2hldGhlciB0byBlbmNvZGUgbG9uZ3MgYXMgc3RyaW5nc1xyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5UPX0gcmVzb2x2ZWRUeXBlIFRoZSByZXNvbHZlZCBmaWVsZCB0eXBlIGlmIGEgZmllbGRcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfSBDbG9uZWQgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2xvbmVSYXcob2JqLCBiaW5hcnlBc0Jhc2U2NCwgbG9uZ3NBc1N0cmluZ3MsIHJlc29sdmVkVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBlbnVtIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIG5hbWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFR5cGUgJiYgcmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5FbnVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IFByb3RvQnVmLlJlZmxlY3QuRW51bS5nZXROYW1lKHJlc29sdmVkVHlwZS5vYmplY3QsIG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXNzLXRocm91Z2ggc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG51bGwuLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBCeXRlQnVmZmVycyB0byByYXcgYnVmZmVyIG9yIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIob2JqKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmFyeUFzQmFzZTY0ID8gb2JqLnRvQmFzZTY0KCkgOiBvYmoudG9CdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IExvbmdzIHRvIHByb3BlciBvYmplY3RzIG9yIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUHJvdG9CdWYuTG9uZy5pc0xvbmcob2JqKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvbmdzQXNTdHJpbmdzID8gb2JqLnRvU3RyaW5nKCkgOiBQcm90b0J1Zi5Mb25nLmZyb21WYWx1ZShvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG9uZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDbG9uZSBhcnJheXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uKHYsIGspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lW2tdID0gY2xvbmVSYXcodiwgYmluYXJ5QXNCYXNlNjQsIGxvbmdzQXNTdHJpbmdzLCByZXNvbHZlZFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgbWFwcyB0byBvYmplY3RzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvQnVmLk1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXQgPSBvYmouZW50cmllcygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gaXQubmV4dCgpOyAhZS5kb25lOyBlID0gaXQubmV4dCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVbb2JqLmtleUVsZW0udmFsdWVUb1N0cmluZyhlLnZhbHVlWzBdKV0gPSBjbG9uZVJhdyhlLnZhbHVlWzFdLCBiaW5hcnlBc0Jhc2U2NCwgbG9uZ3NBc1N0cmluZ3MsIG9iai52YWx1ZUVsZW0ucmVzb2x2ZWRUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBFdmVyeXRoaW5nIGVsc2UgaXMgYSBub24tbnVsbCBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IG9iai4kdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvYmopXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICYmIChmaWVsZCA9IHR5cGUuZ2V0Q2hpbGQoaSkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lW2ldID0gY2xvbmVSYXcob2JqW2ldLCBiaW5hcnlBc0Jhc2U2NCwgbG9uZ3NBc1N0cmluZ3MsIGZpZWxkLnJlc29sdmVkVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVbaV0gPSBjbG9uZVJhdyhvYmpbaV0sIGJpbmFyeUFzQmFzZTY0LCBsb25nc0FzU3RyaW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBtZXNzYWdlJ3MgcmF3IHBheWxvYWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBiaW5hcnlBc0Jhc2U2NCBXaGV0aGVyIHRvIGluY2x1ZGUgYmluYXJ5IGRhdGEgYXMgYmFzZTY0IHN0cmluZ3MgaW5zdGVhZCBvZiBCdWZmZXJzLCBkZWZhdWx0cyB0byBgZmFsc2VgXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvbmdzQXNTdHJpbmdzIFdoZXRoZXIgdG8gZW5jb2RlIGxvbmdzIGFzIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUmF3IHBheWxvYWRcclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS50b1JhdyA9IGZ1bmN0aW9uKGJpbmFyeUFzQmFzZTY0LCBsb25nc0FzU3RyaW5ncykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZVJhdyh0aGlzLCAhIWJpbmFyeUFzQmFzZTY0LCAhIWxvbmdzQXNTdHJpbmdzLCB0aGlzLiR0eXBlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBFbmNvZGVzIGEgbWVzc2FnZSB0byBKU09OLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gSlNPTiBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZVByb3RvdHlwZS5lbmNvZGVKU09OID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZVJhdyh0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGJpbmFyeS1hcy1iYXNlNjQgKi8gdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsb25ncy1hcy1zdHJpbmdzICovIHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgYnVmZmVyIG9yIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGVcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcnwhQXJyYXlCdWZmZXJ8IUJ1ZmZlcnxzdHJpbmd9IGJ1ZmZlciBCdWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KG51bWJlcnxzdHJpbmcpPX0gbGVuZ3RoIE1lc3NhZ2UgbGVuZ3RoLiBEZWZhdWx0cyB0byBkZWNvZGUgYWxsIHRoZSByZW1haW5pZyBkYXRhLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbmMgRW5jb2RpbmcgaWYgYnVmZmVyIGlzIGEgc3RyaW5nOiBoZXgsIHV0ZjggKG5vdCByZWNvbW1lbmRlZCksIGRlZmF1bHRzIHRvIGJhc2U2NFxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gRGVjb2RlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGRlY29kZWQgb3IgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nLiBUaGUgbGF0ZXIgc3RpbGxcclxuICAgICAgICAgICAgICAgICAqICByZXR1cm5zIHRoZSBkZWNvZGVkIG1lc3NhZ2Ugd2l0aCBtaXNzaW5nIGZpZWxkcyBpbiB0aGUgYGRlY29kZWRgIHByb3BlcnR5IG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZTY0XHJcbiAgICAgICAgICAgICAgICAgKiBAc2VlIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZS5kZWNvZGVIZXhcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTWVzc2FnZS5kZWNvZGUgPSBmdW5jdGlvbihidWZmZXIsIGxlbmd0aCwgZW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmMgPSBsZW5ndGgsIGxlbmd0aCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gQnl0ZUJ1ZmZlci53cmFwKGJ1ZmZlciwgZW5jID8gZW5jIDogXCJiYXNlNjRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIUJ5dGVCdWZmZXIuaXNCeXRlQnVmZmVyKGJ1ZmZlcikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IEJ5dGVCdWZmZXIud3JhcChidWZmZXIpOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGUgPSBidWZmZXIubGl0dGxlRW5kaWFuO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBULmRlY29kZShidWZmZXIuTEUoKSwgbGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLkxFKGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1zZztcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5MRShsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93KGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgdmFyaW50MzIgbGVuZ3RoLWRlbGltaXRlZCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCBidWZmZXIgb3Igc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZURlbGltaXRlZFxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyFCeXRlQnVmZmVyfCFBcnJheUJ1ZmZlcnwhQnVmZmVyfHN0cmluZ30gYnVmZmVyIEJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbmMgRW5jb2RpbmcgaWYgYnVmZmVyIGlzIGEgc3RyaW5nOiBoZXgsIHV0ZjggKG5vdCByZWNvbW1lbmRlZCksIGRlZmF1bHRzIHRvIGJhc2U2NFxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBEZWNvZGVkIG1lc3NhZ2Ugb3IgYG51bGxgIGlmIG5vdCBlbm91Z2ggYnl0ZXMgYXJlIGF2YWlsYWJsZSB5ZXRcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZGVjb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGRlY29kZWQgbWVzc2FnZSB3aXRoIG1pc3NpbmcgZmllbGRzIGluIHRoZSBgZGVjb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgZW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBCeXRlQnVmZmVyLndyYXAoYnVmZmVyLCBlbmMgPyBlbmMgOiBcImJhc2U2NFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghQnl0ZUJ1ZmZlci5pc0J5dGVCdWZmZXIoYnVmZmVyKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gQnl0ZUJ1ZmZlci53cmFwKGJ1ZmZlcik7IC8vIE1heSB0aHJvd1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIucmVtYWluaW5nKCkgPCAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2ZmID0gYnVmZmVyLm9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuID0gYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChidWZmZXIucmVtYWluaW5nKCkgPCBsZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCA9IG9mZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBULmRlY29kZShidWZmZXIuc2xpY2UoYnVmZmVyLm9mZnNldCwgYnVmZmVyLm9mZnNldCArIGxlbikuTEUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gbGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXNnO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ICs9IGxlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIHRoZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuZGVjb2RlNjRcclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IERlY29kZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZy4gVGhlIGxhdGVyIHN0aWxsXHJcbiAgICAgICAgICAgICAgICAgKiAgcmV0dXJucyB0aGUgZGVjb2RlZCBtZXNzYWdlIHdpdGggbWlzc2luZyBmaWVsZHMgaW4gdGhlIGBkZWNvZGVkYCBwcm9wZXJ0eSBvbiB0aGUgZXJyb3IuXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2UuZGVjb2RlNjQgPSBmdW5jdGlvbihzdHIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWVzc2FnZS5kZWNvZGUoc3RyLCBcImJhc2U2NFwiKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIHRoZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCBoZXggZW5jb2RlZCBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UuZGVjb2RlSGV4XHJcbiAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBEZWNvZGVkIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgZGVjb2RlZCBvciBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmcuIFRoZSBsYXRlciBzdGlsbFxyXG4gICAgICAgICAgICAgICAgICogIHJldHVybnMgdGhlIGRlY29kZWQgbWVzc2FnZSB3aXRoIG1pc3NpbmcgZmllbGRzIGluIHRoZSBgZGVjb2RlZGAgcHJvcGVydHkgb24gdGhlIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlLmRlY29kZUhleCA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNZXNzYWdlLmRlY29kZShzdHIsIFwiaGV4XCIpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIERlY29kZXMgdGhlIG1lc3NhZ2UgZnJvbSBhIEpTT04gc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQG5hbWUgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlLmRlY29kZUpTT05cclxuICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IERlY29kZWQgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkIG9yIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmVcclxuICAgICAgICAgICAgICAgICAqIG1pc3NpbmcuXHJcbiAgICAgICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIE1lc3NhZ2UuZGVjb2RlSlNPTiA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWVzc2FnZShKU09OLnBhcnNlKHN0cikpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVdGlsaXR5XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgTWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSN0b1N0cmluZ1xyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBhcyBvZiBcIi5GdWxseS5RdWFsaWZpZWQuTWVzc2FnZU5hbWVcIlxyXG4gICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBNZXNzYWdlUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSlcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZSwgJyRvcHRpb25zJywgeyBcInZhbHVlXCI6IFQuYnVpbGRPcHQoKSB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2VQcm90b3R5cGUsIFwiJG9wdGlvbnNcIiwgeyBcInZhbHVlXCI6IE1lc3NhZ2VbXCIkb3B0aW9uc1wiXSB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2UsIFwiJHR5cGVcIiwgeyBcInZhbHVlXCI6IFQgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlUHJvdG90eXBlLCBcIiR0eXBlXCIsIHsgXCJ2YWx1ZVwiOiBUIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBNZXNzYWdlO1xyXG5cclxuICAgICAgICAgICAgfSkoUHJvdG9CdWYsIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RhdGljIGVudW1zIGFuZCBwcm90b3R5cGVkIHN1Yi1tZXNzYWdlcyAvIGNhY2hlZCBjb2xsZWN0aW9uc1xyXG4gICAgICAgICAgICB0aGlzLl9maWVsZHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fZmllbGRzQnlJZCA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLl9maWVsZHNCeU5hbWUgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5fb25lb2ZzQnlOYW1lID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz10aGlzLmNoaWxkcmVuLmxlbmd0aCwgY2hpbGQ7IGk8azsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBFbnVtIHx8IGNoaWxkIGluc3RhbmNlb2YgTWVzc2FnZSB8fCBjaGlsZCBpbnN0YW5jZW9mIFNlcnZpY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhenouaGFzT3duUHJvcGVydHkoY2hpbGQubmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCByZWZsZWN0IGNoaWxkIG9mIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK2NoaWxkLnRvU3RyaW5nKHRydWUpK1wiIGNhbm5vdCBvdmVycmlkZSBzdGF0aWMgcHJvcGVydHkgJ1wiK2NoaWxkLm5hbWUrXCInXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXp6W2NoaWxkLm5hbWVdID0gY2hpbGQuYnVpbGQoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBNZXNzYWdlLkZpZWxkKVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmJ1aWxkKCksIHRoaXMuX2ZpZWxkcy5wdXNoKGNoaWxkKSwgdGhpcy5fZmllbGRzQnlJZFtjaGlsZC5pZF0gPSBjaGlsZCwgdGhpcy5fZmllbGRzQnlOYW1lW2NoaWxkLm5hbWVdID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIE1lc3NhZ2UuT25lT2YpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbmVvZnNCeU5hbWVbY2hpbGQubmFtZV0gPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBNZXNzYWdlLk9uZU9mKSAmJiAhKGNoaWxkIGluc3RhbmNlb2YgRXh0ZW5zaW9uKSkgLy8gTm90IGJ1aWx0XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHJlZmxlY3QgY2hpbGQgb2YgXCIrdGhpcy50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy5jaGlsZHJlbltpXS50b1N0cmluZyh0cnVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYXp6ID0gY2xheno7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyBhIHJ1bnRpbWUgbWVzc2FnZSdzIGNvbnRlbnRzIHRvIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gbWVzc2FnZSBSdW50aW1lIG1lc3NhZ2UgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHBhcmFtIHtCeXRlQnVmZmVyfSBidWZmZXIgQnl0ZUJ1ZmZlciB0byB3cml0ZSB0b1xyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG5vVmVyaWZ5IFdoZXRoZXIgdG8gbm90IHZlcmlmeSBmaWVsZCB2YWx1ZXMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgKiBAcmV0dXJuIHtCeXRlQnVmZmVyfSBUaGUgQnl0ZUJ1ZmZlciBmb3IgY2hhaW5pbmdcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nIG9yIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBlbmNvZGVkIGZvciBhbm90aGVyIHJlYXNvblxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBNZXNzYWdlUHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGJ1ZmZlciwgbm9WZXJpZnkpIHtcclxuICAgICAgICAgICAgdmFyIGZpZWxkTWlzc2luZyA9IG51bGwsXHJcbiAgICAgICAgICAgICAgICBmaWVsZDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrPXRoaXMuX2ZpZWxkcy5sZW5ndGgsIHZhbDsgaTxrOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGZpZWxkID0gdGhpcy5fZmllbGRzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFsID0gbWVzc2FnZVtmaWVsZC5uYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5yZXF1aXJlZCAmJiB2YWwgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRNaXNzaW5nID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZE1pc3NpbmcgPSBmaWVsZDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLmVuY29kZShub1ZlcmlmeSA/IHZhbCA6IGZpZWxkLnZlcmlmeVZhbHVlKHZhbCksIGJ1ZmZlciwgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZpZWxkTWlzc2luZyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFwiTWlzc2luZyBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgZmllbGQgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK2ZpZWxkTWlzc2luZyk7XHJcbiAgICAgICAgICAgICAgICBlcnJbXCJlbmNvZGVkXCJdID0gYnVmZmVyOyAvLyBTdGlsbCBleHBvc2Ugd2hhdCB3ZSBnb3RcclxuICAgICAgICAgICAgICAgIHRocm93KGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIGEgcnVudGltZSBtZXNzYWdlJ3MgYnl0ZSBsZW5ndGguXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBtZXNzYWdlIFJ1bnRpbWUgbWVzc2FnZSB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3Npbmcgb3IgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGNhbGN1bGF0ZWQgZm9yIGFub3RoZXIgcmVhc29uXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuY2FsY3VsYXRlID0gZnVuY3Rpb24obWVzc2FnZSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBuPTAsIGk9MCwgaz10aGlzLl9maWVsZHMubGVuZ3RoLCBmaWVsZCwgdmFsOyBpPGs7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgZmllbGQgPSB0aGlzLl9maWVsZHNbaV07XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBtZXNzYWdlW2ZpZWxkLm5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLnJlcXVpcmVkICYmIHZhbCA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiTWlzc2luZyBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgZmllbGQgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK2ZpZWxkKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBuICs9IGZpZWxkLmNhbGN1bGF0ZSh2YWwsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNraXBzIGFsbCBkYXRhIHVudGlsIHRoZSBlbmQgb2YgdGhlIHNwZWNpZmllZCBncm91cCBoYXMgYmVlbiByZWFjaGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleHBlY3RlZElkIEV4cGVjdGVkIEdST1VQRU5EIGlkXHJcbiAgICAgICAgICogQHBhcmFtIHshQnl0ZUJ1ZmZlcn0gYnVmIEJ5dGVCdWZmZXJcclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGEgdmFsdWUgYXMgYmVlbiBza2lwcGVkLCBgZmFsc2VgIGlmIHRoZSBlbmQgaGFzIGJlZW4gcmVhY2hlZFxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBpdCB3YXNuJ3QgcG9zc2libGUgdG8gZmluZCB0aGUgZW5kIG9mIHRoZSBncm91cCAoYnVmZmVyIG92ZXJydW4gb3IgZW5kIHRhZyBtaXNtYXRjaClcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBza2lwVGlsbEdyb3VwRW5kKGV4cGVjdGVkSWQsIGJ1Zikge1xyXG4gICAgICAgICAgICB2YXIgdGFnID0gYnVmLnJlYWRWYXJpbnQzMigpLCAvLyBUaHJvd3Mgb24gT09CXHJcbiAgICAgICAgICAgICAgICB3aXJlVHlwZSA9IHRhZyAmIDB4MDcsXHJcbiAgICAgICAgICAgICAgICBpZCA9IHRhZyA+Pj4gMztcclxuICAgICAgICAgICAgc3dpdGNoICh3aXJlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLlZBUklOVDpcclxuICAgICAgICAgICAgICAgICAgICBkbyB0YWcgPSBidWYucmVhZFVpbnQ4KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCh0YWcgJiAweDgwKSA9PT0gMHg4MCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0OlxyXG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5vZmZzZXQgKz0gODtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU06XHJcbiAgICAgICAgICAgICAgICAgICAgdGFnID0gYnVmLnJlYWRWYXJpbnQzMigpOyAvLyByZWFkcyB0aGUgdmFyaW50XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmLm9mZnNldCArPSB0YWc7ICAgICAgICAvLyBza2lwcyBuIGJ5dGVzXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuU1RBUlRHUk9VUDpcclxuICAgICAgICAgICAgICAgICAgICBza2lwVGlsbEdyb3VwRW5kKGlkLCBidWYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkVOREdST1VQOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZCA9PT0gZXhwZWN0ZWRJZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIEdST1VQRU5EIGFmdGVyIHVua25vd24gZ3JvdXA6IFwiK2lkK1wiIChcIitleHBlY3RlZElkK1wiIGV4cGVjdGVkKVwiKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5CSVRTMzI6XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmLm9mZnNldCArPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgd2lyZSB0eXBlIGluIHVua25vd24gZ3JvdXAgXCIrZXhwZWN0ZWRJZCtcIjogXCIrd2lyZVR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhbiBlbmNvZGVkIG1lc3NhZ2UgYW5kIHJldHVybnMgdGhlIGRlY29kZWQgbWVzc2FnZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0J5dGVCdWZmZXJ9IGJ1ZmZlciBCeXRlQnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBsZW5ndGggTWVzc2FnZSBsZW5ndGguIERlZmF1bHRzIHRvIGRlY29kZSBhbGwgcmVtYWluaW5nIGRhdGEuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBleHBlY3RlZEdyb3VwRW5kSWQgRXhwZWN0ZWQgR1JPVVBFTkQgaWQgaWYgdGhpcyBpcyBhIGxlZ2FjeSBncm91cFxyXG4gICAgICAgICAqIEByZXR1cm4ge1Byb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gRGVjb2RlZCBtZXNzYWdlXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtZXNzYWdlIGNhbm5vdCBiZSBkZWNvZGVkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1lc3NhZ2VQcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oYnVmZmVyLCBsZW5ndGgsIGV4cGVjdGVkR3JvdXBFbmRJZCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICBsZW5ndGggPSAtMTtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYnVmZmVyLm9mZnNldCxcclxuICAgICAgICAgICAgICAgIG1zZyA9IG5ldyAodGhpcy5jbGF6eikoKSxcclxuICAgICAgICAgICAgICAgIHRhZywgd2lyZVR5cGUsIGlkLCBmaWVsZDtcclxuICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlci5vZmZzZXQgPCBzdGFydCtsZW5ndGggfHwgKGxlbmd0aCA9PT0gLTEgJiYgYnVmZmVyLnJlbWFpbmluZygpID4gMCkpIHtcclxuICAgICAgICAgICAgICAgIHRhZyA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgIHdpcmVUeXBlID0gdGFnICYgMHgwNztcclxuICAgICAgICAgICAgICAgIGlkID0gdGFnID4+PiAzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09PSBQcm90b0J1Zi5XSVJFX1RZUEVTLkVOREdST1VQKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkICE9PSBleHBlY3RlZEdyb3VwRW5kSWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBncm91cCBlbmQgaW5kaWNhdG9yIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIitpZCtcIiAoXCIrKGV4cGVjdGVkR3JvdXBFbmRJZCA/IGV4cGVjdGVkR3JvdXBFbmRJZCtcIiBleHBlY3RlZFwiIDogXCJub3QgYSBncm91cFwiKStcIilcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIShmaWVsZCA9IHRoaXMuX2ZpZWxkc0J5SWRbaWRdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFwibWVzc2FnZXMgY3JlYXRlZCBieSB5b3VyIG5ldyBjb2RlIGNhbiBiZSBwYXJzZWQgYnkgeW91ciBvbGQgY29kZTogb2xkIGJpbmFyaWVzIHNpbXBseSBpZ25vcmUgdGhlIG5ldyBmaWVsZCB3aGVuIHBhcnNpbmcuXCJcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5WQVJJTlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLkJJVFMzMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5vZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLldJUkVfVFlQRVMuQklUUzY0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCArPSA4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gYnVmZmVyLnJlYWRWYXJpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLm9mZnNldCArPSBsZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5XSVJFX1RZUEVTLlNUQVJUR1JPVVA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc2tpcFRpbGxHcm91cEVuZChpZCwgYnVmZmVyKSkge31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHdpcmUgdHlwZSBmb3IgdW5rbm93biBmaWVsZCBcIitpZCtcIiBpbiBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiI2RlY29kZTogXCIrd2lyZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5yZXBlYXRlZCAmJiAhZmllbGQub3B0aW9uc1tcInBhY2tlZFwiXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1zZ1tmaWVsZC5uYW1lXS5wdXNoKGZpZWxkLmRlY29kZSh3aXJlVHlwZSwgYnVmZmVyKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLm1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXl2YWwgPSBmaWVsZC5kZWNvZGUod2lyZVR5cGUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnW2ZpZWxkLm5hbWVdLnNldChrZXl2YWxbMF0sIGtleXZhbFsxXSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1zZ1tmaWVsZC5uYW1lXSA9IGZpZWxkLmRlY29kZSh3aXJlVHlwZSwgYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQub25lb2YpIHsgLy8gRmllbGQgaXMgcGFydCBvZiBhbiBPbmVPZiAobm90IGEgdmlydHVhbCBPbmVPZiBmaWVsZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRGaWVsZCA9IG1zZ1tmaWVsZC5vbmVvZi5uYW1lXTsgLy8gVmlydHVhbCBmaWVsZCByZWZlcmVuY2VzIGN1cnJlbnRseSBzZXQgZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGaWVsZCAhPT0gbnVsbCAmJiBjdXJyZW50RmllbGQgIT09IGZpZWxkLm5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtc2dbY3VycmVudEZpZWxkXSA9IG51bGw7IC8vIENsZWFyIGN1cnJlbnRseSBzZXQgZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnW2ZpZWxkLm9uZW9mLm5hbWVdID0gZmllbGQubmFtZTsgLy8gUG9pbnQgdmlydHVhbCBmaWVsZCBhdCB0aGlzIGZpZWxkXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbGwgcmVxdWlyZWQgZmllbGRzIGFyZSBwcmVzZW50IGFuZCBzZXQgZGVmYXVsdCB2YWx1ZXMgZm9yIG9wdGlvbmFsIGZpZWxkcyB0aGF0IGFyZSBub3RcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBrPXRoaXMuX2ZpZWxkcy5sZW5ndGg7IGk8azsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBmaWVsZCA9IHRoaXMuX2ZpZWxkc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChtc2dbZmllbGQubmFtZV0gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zeW50YXggPT09IFwicHJvdG8zXCIpIHsgLy8gUHJvdG8zIHNldHMgZGVmYXVsdCB2YWx1ZXMgYnkgc3BlY2lmaWNhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2dbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXF1aXJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXCJNaXNzaW5nIGF0IGxlYXN0IG9uZSByZXF1aXJlZCBmaWVsZCBmb3IgXCIgKyB0aGlzLnRvU3RyaW5nKHRydWUpICsgXCI6IFwiICsgZmllbGQubmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycltcImRlY29kZWRcIl0gPSBtc2c7IC8vIFN0aWxsIGV4cG9zZSB3aGF0IHdlIGdvdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyhlcnIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoUHJvdG9CdWYucG9wdWxhdGVEZWZhdWx0cyAmJiBmaWVsZC5kZWZhdWx0VmFsdWUgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZ1tmaWVsZC5uYW1lXSA9IGZpZWxkLmRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbXNnO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2VcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5NZXNzYWdlID0gTWVzc2FnZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBNZXNzYWdlIEZpZWxkLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZFxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2V9IG1lc3NhZ2UgTWVzc2FnZSByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcnVsZSBSdWxlLCBvbmUgb2YgcmVxdXJpZWQsIG9wdGlvbmFsLCByZXBlYXRlZFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nP30ga2V5dHlwZSBLZXkgZGF0YSB0eXBlLCBpZiBhbnkuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRGF0YSB0eXBlLCBlLmcuIGludDMyXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBVbmlxdWUgZmllbGQgaWRcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLk9uZU9mPX0gb25lb2YgRW5jbG9zaW5nIE9uZU9mXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc/fSBzeW50YXggVGhlIHN5bnRheCBsZXZlbCBvZiB0aGlzIGRlZmluaXRpb24gKGUuZy4sIHByb3RvMylcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0LlRcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRmllbGQgPSBmdW5jdGlvbihidWlsZGVyLCBtZXNzYWdlLCBydWxlLCBrZXl0eXBlLCB0eXBlLCBuYW1lLCBpZCwgb3B0aW9ucywgb25lb2YsIHN5bnRheCkge1xyXG4gICAgICAgICAgICBULmNhbGwodGhpcywgYnVpbGRlciwgbWVzc2FnZSwgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiTWVzc2FnZS5GaWVsZFwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1lc3NhZ2UgZmllbGQgcmVxdWlyZWQgZmxhZy5cclxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZWQgPSBydWxlID09PSBcInJlcXVpcmVkXCI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWVzc2FnZSBmaWVsZCByZXBlYXRlZCBmbGFnLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yZXBlYXRlZCA9IHJ1bGUgPT09IFwicmVwZWF0ZWRcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNZXNzYWdlIGZpZWxkIG1hcCBmbGFnLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5tYXAgPSBydWxlID09PSBcIm1hcFwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1lc3NhZ2UgZmllbGQga2V5IHR5cGUuIFR5cGUgcmVmZXJlbmNlIHN0cmluZyBpZiB1bnJlc29sdmVkLCBwcm90b2J1ZlxyXG4gICAgICAgICAgICAgKiB0eXBlIGlmIHJlc29sdmVkLiBWYWxpZCBvbmx5IGlmIHRoaXMubWFwID09PSB0cnVlLCBudWxsIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ3x7bmFtZTogc3RyaW5nLCB3aXJlVHlwZTogbnVtYmVyfXxudWxsfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmtleVR5cGUgPSBrZXl0eXBlIHx8IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWVzc2FnZSBmaWVsZCB0eXBlLiBUeXBlIHJlZmVyZW5jZSBzdHJpbmcgaWYgdW5yZXNvbHZlZCwgcHJvdG9idWYgdHlwZSBpZlxyXG4gICAgICAgICAgICAgKiByZXNvbHZlZC4gSW4gYSBtYXAgZmllbGQsIHRoaXMgaXMgdGhlIHZhbHVlIHR5cGUuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd8e25hbWU6IHN0cmluZywgd2lyZVR5cGU6IG51bWJlcn19XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVzb2x2ZWQgdHlwZSByZWZlcmVuY2UgaW5zaWRlIHRoZSBnbG9iYWwgbmFtZXNwYWNlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5UfG51bGx9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRUeXBlID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBVbmlxdWUgbWVzc2FnZSBmaWVsZCBpZC5cclxuICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1lc3NhZ2UgZmllbGQgb3B0aW9ucy5cclxuICAgICAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAgICAgICAgICogQGRpY3RcclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZWZhdWx0IHZhbHVlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7Kn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEVuY2xvc2luZyBPbmVPZi5cclxuICAgICAgICAgICAgICogQHR5cGUgez9Qcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuT25lT2Z9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub25lb2YgPSBvbmVvZiB8fCBudWxsO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFN5bnRheCBsZXZlbCBvZiB0aGlzIGRlZmluaXRpb24gKGUuZy4sIHByb3RvMykuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuc3ludGF4ID0gc3ludGF4IHx8ICdwcm90bzInO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9yaWdpbmFsIGZpZWxkIG5hbWUuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxOYW1lID0gdGhpcy5uYW1lOyAvLyBVc2VkIHRvIHJldmVydCBjYW1lbGNhc2UgdHJhbnNmb3JtYXRpb24gb24gbmFtaW5nIGNvbGxpc2lvbnNcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbGVtZW50IGltcGxlbWVudGF0aW9uLiBDcmVhdGVkIGluIGJ1aWxkKCkgYWZ0ZXIgdHlwZXMgYXJlIHJlc29sdmVkLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuRWxlbWVudH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBLZXkgZWxlbWVudCBpbXBsZW1lbnRhdGlvbiwgZm9yIG1hcCBmaWVsZHMuIENyZWF0ZWQgaW4gYnVpbGQoKSBhZnRlclxyXG4gICAgICAgICAgICAgKiB0eXBlcyBhcmUgcmVzb2x2ZWQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtQcm90b0J1Zi5FbGVtZW50fVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmtleUVsZW1lbnQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCBmaWVsZCBuYW1lcyB0byBjYW1lbCBjYXNlIG5vdGF0aW9uIGlmIHRoZSBvdmVycmlkZSBpcyBzZXRcclxuICAgICAgICAgICAgaWYgKHRoaXMuYnVpbGRlci5vcHRpb25zWydjb252ZXJ0RmllbGRzVG9DYW1lbENhc2UnXSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBNZXNzYWdlLkV4dGVuc2lvbkZpZWxkKSlcclxuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IFByb3RvQnVmLlV0aWwudG9DYW1lbENhc2UodGhpcy5uYW1lKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkLnByb3RvdHlwZVxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBGaWVsZFByb3RvdHlwZSA9IEZpZWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCdWlsZHMgdGhlIGZpZWxkLlxyXG4gICAgICAgICAqIEBvdmVycmlkZVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWVsZFByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBuZXcgRWxlbWVudCh0aGlzLnR5cGUsIHRoaXMucmVzb2x2ZWRUeXBlLCBmYWxzZSwgdGhpcy5zeW50YXgsIHRoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcClcclxuICAgICAgICAgICAgICAgIHRoaXMua2V5RWxlbWVudCA9IG5ldyBFbGVtZW50KHRoaXMua2V5VHlwZSwgdW5kZWZpbmVkLCB0cnVlLCB0aGlzLnN5bnRheCwgdGhpcy5uYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEluIHByb3RvMywgZmllbGRzIGRvIG5vdCBoYXZlIGZpZWxkIHByZXNlbmNlLCBhbmQgZXZlcnkgZmllbGQgaXMgc2V0IHRvXHJcbiAgICAgICAgICAgIC8vIGl0cyB0eXBlJ3MgZGVmYXVsdCB2YWx1ZSAoXCJcIiwgMCwgMC4wLCBvciBmYWxzZSkuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN5bnRheCA9PT0gJ3Byb3RvMycgJiYgIXRoaXMucmVwZWF0ZWQgJiYgIXRoaXMubWFwKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBFbGVtZW50LmRlZmF1bHRGaWVsZFZhbHVlKHRoaXMudHlwZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGRlZmF1bHQgdmFsdWVzIGFyZSBwcmVzZW50IHdoZW4gZXhwbGljaXRseSBzcGVjaWZpZWRcclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMub3B0aW9uc1snZGVmYXVsdCddICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdGhpcy52ZXJpZnlWYWx1ZSh0aGlzLm9wdGlvbnNbJ2RlZmF1bHQnXSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBjYW4gYmUgc2V0IGZvciB0aGlzIGZpZWxkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gY2hlY2tcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBza2lwUmVwZWF0ZWQgV2hldGhlciB0byBza2lwIHRoZSByZXBlYXRlZCB2YWx1ZSBjaGVjayBvciBub3QuIERlZmF1bHRzIHRvIGZhbHNlLlxyXG4gICAgICAgICAqIEByZXR1cm4geyp9IFZlcmlmaWVkLCBtYXliZSBhZGp1c3RlZCwgdmFsdWVcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHZhbHVlIGNhbm5vdCBiZSBzZXQgZm9yIHRoaXMgZmllbGRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmllbGRQcm90b3R5cGUudmVyaWZ5VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgc2tpcFJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgIHNraXBSZXBlYXRlZCA9IHNraXBSZXBlYXRlZCB8fCBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmYWlsKHZhbCwgbXNnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3NlbGYudG9TdHJpbmcodHJ1ZSkrXCIgb2YgdHlwZSBcIitzZWxmLnR5cGUubmFtZStcIjogXCIrdmFsK1wiIChcIittc2crXCIpXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgeyAvLyBOVUxMIHZhbHVlcyBmb3Igb3B0aW9uYWwgZmllbGRzXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXF1aXJlZClcclxuICAgICAgICAgICAgICAgICAgICBmYWlsKHR5cGVvZiB2YWx1ZSwgXCJyZXF1aXJlZFwiKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN5bnRheCA9PT0gJ3Byb3RvMycgJiYgdGhpcy50eXBlICE9PSBQcm90b0J1Zi5UWVBFU1tcIm1lc3NhZ2VcIl0pXHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbCh0eXBlb2YgdmFsdWUsIFwicHJvdG8zIGZpZWxkIHdpdGhvdXQgZmllbGQgcHJlc2VuY2UgY2Fubm90IGJlIG51bGxcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0ZWQgJiYgIXNraXBSZXBlYXRlZCkgeyAvLyBSZXBlYXRlZCB2YWx1ZXMgYXMgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcclxuICAgICAgICAgICAgICAgIHZhciByZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPHZhbHVlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMuZWxlbWVudC52ZXJpZnlWYWx1ZSh2YWx1ZVtpXSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXAgJiYgIXNraXBSZXBlYXRlZCkgeyAvLyBNYXAgdmFsdWVzIGFzIG9iamVjdHNcclxuICAgICAgICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgUHJvdG9CdWYuTWFwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCBhbHJlYWR5IGEgTWFwLCBhdHRlbXB0IHRvIGNvbnZlcnQuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXhwZWN0ZWQgUHJvdG9CdWYuTWFwIG9yIHJhdyBvYmplY3QgZm9yIG1hcCBmaWVsZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm90b0J1Zi5NYXAodGhpcywgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQWxsIG5vbi1yZXBlYXRlZCBmaWVsZHMgZXhwZWN0IG5vIGFycmF5XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXBlYXRlZCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSlcclxuICAgICAgICAgICAgICAgIGZhaWwodHlwZW9mIHZhbHVlLCBcIm5vIGFycmF5IGV4cGVjdGVkXCIpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC52ZXJpZnlWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBmaWVsZCB3aWxsIGhhdmUgYSBwcmVzZW5jZSBvbiB0aGUgd2lyZSBnaXZlbiBpdHNcclxuICAgICAgICAgKiB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZlcmlmaWVkIGZpZWxkIHZhbHVlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBtZXNzYWdlIFJ1bnRpbWUgbWVzc2FnZVxyXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGZpZWxkIHdpbGwgYmUgcHJlc2VudCBvbiB0aGUgd2lyZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpZWxkUHJvdG90eXBlLmhhc1dpcmVQcmVzZW5jZSA9IGZ1bmN0aW9uKHZhbHVlLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN5bnRheCAhPT0gJ3Byb3RvMycpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHZhbHVlICE9PSBudWxsKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25lb2YgJiYgbWVzc2FnZVt0aGlzLm9uZW9mLm5hbWVdID09PSB0aGlzLm5hbWUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQzMlwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50MzJcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkMzJcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1widWludDMyXCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkMzJcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJpbnQ2NFwiXTpcclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzaW50NjRcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wic2ZpeGVkNjRcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1widWludDY0XCJdOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImZpeGVkNjRcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxvdyAhPT0gMCB8fCB2YWx1ZS5oaWdoICE9PSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJib29sXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZmxvYXRcIl06XHJcbiAgICAgICAgICAgICAgICBjYXNlIFByb3RvQnVmLlRZUEVTW1wiZG91YmxlXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gMC4wO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJzdHJpbmdcIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImJ5dGVzXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5yZW1haW5pbmcoKSA+IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBQcm90b0J1Zi5UWVBFU1tcImVudW1cIl06XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgUHJvdG9CdWYuVFlQRVNbXCJtZXNzYWdlXCJdOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgZmllbGQgdmFsdWUgdG8gdGhlIHNwZWNpZmllZCBidWZmZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWZXJpZmllZCBmaWVsZCB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7Qnl0ZUJ1ZmZlcn0gYnVmZmVyIEJ5dGVCdWZmZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSBtZXNzYWdlIFJ1bnRpbWUgbWVzc2FnZVxyXG4gICAgICAgICAqIEByZXR1cm4ge0J5dGVCdWZmZXJ9IFRoZSBCeXRlQnVmZmVyIGZvciBjaGFpbmluZ1xyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZmllbGQgY2Fubm90IGJlIGVuY29kZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmllbGRQcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24odmFsdWUsIGJ1ZmZlciwgbWVzc2FnZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBudWxsIHx8IHR5cGVvZiB0aGlzLnR5cGUgIT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJbSU5URVJOQUxdIFVucmVzb2x2ZWQgdHlwZSBpbiBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnR5cGUpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgKHRoaXMucmVwZWF0ZWQgJiYgdmFsdWUubGVuZ3RoID09IDApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjsgLy8gT3B0aW9uYWwgb21pdHRlZFxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBcIk9ubHkgcmVwZWF0ZWQgZmllbGRzIG9mIHByaW1pdGl2ZSBudW1lcmljIHR5cGVzICh0eXBlcyB3aGljaCB1c2UgdGhlIHZhcmludCwgMzItYml0LCBvciA2NC1iaXQgd2lyZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHR5cGVzKSBjYW4gYmUgZGVjbGFyZWQgJ3BhY2tlZCcuXCJcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zW1wicGFja2VkXCJdICYmIFByb3RvQnVmLlBBQ0tBQkxFX1dJUkVfVFlQRVMuaW5kZXhPZih0aGlzLnR5cGUud2lyZVR5cGUpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJBbGwgb2YgdGhlIGVsZW1lbnRzIG9mIHRoZSBmaWVsZCBhcmUgcGFja2VkIGludG8gYSBzaW5nbGUga2V5LXZhbHVlIHBhaXIgd2l0aCB3aXJlIHR5cGUgMlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAobGVuZ3RoLWRlbGltaXRlZCkuIEVhY2ggZWxlbWVudCBpcyBlbmNvZGVkIHRoZSBzYW1lIHdheSBpdCB3b3VsZCBiZSBub3JtYWxseSwgZXhjZXB0IHdpdGhvdXQgYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0YWcgcHJlY2VkaW5nIGl0LlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuZW5zdXJlQ2FwYWNpdHkoYnVmZmVyLm9mZnNldCArPSAxKTsgLy8gV2UgZG8gbm90IGtub3cgdGhlIGxlbmd0aCB5ZXQsIHNvIGxldCdzIGFzc3VtZSBhIHZhcmludCBvZiBsZW5ndGggMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBidWZmZXIub2Zmc2V0OyAvLyBSZW1lbWJlciB3aGVyZSB0aGUgY29udGVudHMgYmVnaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8dmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuZW5jb2RlVmFsdWUodGhpcy5pZCwgdmFsdWVbaV0sIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBidWZmZXIub2Zmc2V0LXN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaW50TGVuID0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihsZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFyaW50TGVuID4gMSkgeyAvLyBXZSBuZWVkIHRvIG1vdmUgdGhlIGNvbnRlbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudHMgPSBidWZmZXIuc2xpY2Uoc3RhcnQsIGJ1ZmZlci5vZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKz0gdmFyaW50TGVuLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ID0gc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKGNvbnRlbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMihsZW4sIHN0YXJ0LXZhcmludExlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJJZiB5b3VyIG1lc3NhZ2UgZGVmaW5pdGlvbiBoYXMgcmVwZWF0ZWQgZWxlbWVudHMgKHdpdGhvdXQgdGhlIFtwYWNrZWQ9dHJ1ZV0gb3B0aW9uKSwgdGhlIGVuY29kZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVzc2FnZSBoYXMgemVybyBvciBtb3JlIGtleS12YWx1ZSBwYWlycyB3aXRoIHRoZSBzYW1lIHRhZyBudW1iZXJcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGk9MDsgaTx2YWx1ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKSwgdGhpcy5lbGVtZW50LmVuY29kZVZhbHVlKHRoaXMuaWQsIHZhbHVlW2ldLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXcml0ZSBvdXQgZWFjaCBtYXAgZW50cnkgYXMgYSBzdWJtZXNzYWdlLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24odmFsLCBrZXksIG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBzdWJtZXNzYWdlIChrZXksIHZhbCkgcGFpci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKCgxIDw8IDMpIHwgdGhpcy5rZXlUeXBlLndpcmVUeXBlKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtleUVsZW1lbnQuY2FsY3VsYXRlTGVuZ3RoKDEsIGtleSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigoMiA8PCAzKSB8IHRoaXMudHlwZS53aXJlVHlwZSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmNhbGN1bGF0ZUxlbmd0aCgyLCB2YWwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VibWVzc2FnZSB3aXRoIHdpcmUgdHlwZSBvZiBsZW5ndGgtZGVsaW1pdGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIud3JpdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIobGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdyaXRlIG91dCB0aGUga2V5IGFuZCB2YWwuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKCgxIDw8IDMpIHwgdGhpcy5rZXlUeXBlLndpcmVUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZXlFbGVtZW50LmVuY29kZVZhbHVlKDEsIGtleSwgYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLndyaXRlVmFyaW50MzIoKDIgPDwgMykgfCB0aGlzLnR5cGUud2lyZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuZW5jb2RlVmFsdWUoMiwgdmFsLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNXaXJlUHJlc2VuY2UodmFsdWUsIG1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci53cml0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgdGhpcy50eXBlLndpcmVUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmVuY29kZVZhbHVlKHRoaXMuaWQsIHZhbHVlLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIHZhbHVlIGZvciBcIit0aGlzLnRvU3RyaW5nKHRydWUpK1wiOiBcIit2YWx1ZStcIiAoXCIrZStcIilcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgdGhpcyBmaWVsZCdzIHZhbHVlIG9uIHRoZSBuZXR3b3JrIGxldmVsLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgRmllbGQgdmFsdWVcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V9IG1lc3NhZ2UgUnVudGltZSBtZXNzYWdlXHJcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmllbGRQcm90b3R5cGUuY2FsY3VsYXRlID0gZnVuY3Rpb24odmFsdWUsIG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnZlcmlmeVZhbHVlKHZhbHVlKTsgLy8gTWF5IHRocm93XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IG51bGwgfHwgdHlwZW9mIHRoaXMudHlwZSAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIltJTlRFUk5BTF0gVW5yZXNvbHZlZCB0eXBlIGluIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3RoaXMudHlwZSk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCAodGhpcy5yZXBlYXRlZCAmJiB2YWx1ZS5sZW5ndGggPT0gMCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDsgLy8gT3B0aW9uYWwgb21pdHRlZFxyXG4gICAgICAgICAgICB2YXIgbiA9IDA7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpLCBuaTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zW1wicGFja2VkXCJdICYmIFByb3RvQnVmLlBBQ0tBQkxFX1dJUkVfVFlQRVMuaW5kZXhPZih0aGlzLnR5cGUud2lyZVR5cGUpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKCh0aGlzLmlkIDw8IDMpIHwgUHJvdG9CdWYuV0lSRV9UWVBFUy5MREVMSU0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaT0wOyBpPHZhbHVlLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmkgKz0gdGhpcy5lbGVtZW50LmNhbGN1bGF0ZUxlbmd0aCh0aGlzLmlkLCB2YWx1ZVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMihuaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gbmk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpPTA7IGk8dmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuICs9IEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKHRoaXMuaWQgPDwgMykgfCB0aGlzLnR5cGUud2lyZVR5cGUpLCBuICs9IHRoaXMuZWxlbWVudC5jYWxjdWxhdGVMZW5ndGgodGhpcy5pZCwgdmFsdWVbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIG1hcCBlbnRyeSBiZWNvbWVzIGEgc3VibWVzc2FnZS5cclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwga2V5LCBtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGxlbmd0aCBvZiB0aGUgc3VibWVzc2FnZSAoa2V5LCB2YWwpIHBhaXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigoMSA8PCAzKSB8IHRoaXMua2V5VHlwZS53aXJlVHlwZSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZXlFbGVtZW50LmNhbGN1bGF0ZUxlbmd0aCgxLCBrZXkpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ5dGVCdWZmZXIuY2FsY3VsYXRlVmFyaW50MzIoKDIgPDwgMykgfCB0aGlzLnR5cGUud2lyZVR5cGUpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jYWxjdWxhdGVMZW5ndGgoMiwgdmFsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IFByb3RvQnVmLldJUkVfVFlQRVMuTERFTElNKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbiArPSBCeXRlQnVmZmVyLmNhbGN1bGF0ZVZhcmludDMyKGxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gbGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNXaXJlUHJlc2VuY2UodmFsdWUsIG1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gQnl0ZUJ1ZmZlci5jYWxjdWxhdGVWYXJpbnQzMigodGhpcy5pZCA8PCAzKSB8IHRoaXMudHlwZS53aXJlVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gKz0gdGhpcy5lbGVtZW50LmNhbGN1bGF0ZUxlbmd0aCh0aGlzLmlkLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIklsbGVnYWwgdmFsdWUgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3ZhbHVlK1wiIChcIitlK1wiKVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGUgdGhlIGZpZWxkIHZhbHVlIGZyb20gdGhlIHNwZWNpZmllZCBidWZmZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIExlYWRpbmcgd2lyZSB0eXBlXHJcbiAgICAgICAgICogQHBhcmFtIHtCeXRlQnVmZmVyfSBidWZmZXIgQnl0ZUJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNraXBSZXBlYXRlZCBXaGV0aGVyIHRvIHNraXAgdGhlIHJlcGVhdGVkIGNoZWNrIG9yIG5vdC4gRGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICAgICAgICogQHJldHVybiB7Kn0gRGVjb2RlZCB2YWx1ZTogYXJyYXkgZm9yIHBhY2tlZCByZXBlYXRlZCBmaWVsZHMsIFtrZXksIHZhbHVlXSBmb3JcclxuICAgICAgICAgKiAgICAgICAgICAgICBtYXAgZmllbGRzLCBvciBhbiBpbmRpdmlkdWFsIHZhbHVlIG90aGVyd2lzZS5cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGZpZWxkIGNhbm5vdCBiZSBkZWNvZGVkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpZWxkUHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHdpcmVUeXBlLCBidWZmZXIsIHNraXBSZXBlYXRlZCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUsIG5CeXRlcztcclxuXHJcbiAgICAgICAgICAgIC8vIFdlIGV4cGVjdCB3aXJlVHlwZSB0byBtYXRjaCB0aGUgdW5kZXJseWluZyB0eXBlJ3Mgd2lyZVR5cGUgdW5sZXNzIHdlIHNlZVxyXG4gICAgICAgICAgICAvLyBhIHBhY2tlZCByZXBlYXRlZCBmaWVsZCwgb3IgdW5sZXNzIHRoaXMgaXMgYSBtYXAgZmllbGQuXHJcbiAgICAgICAgICAgIHZhciB3aXJlVHlwZU9LID1cclxuICAgICAgICAgICAgICAgICghdGhpcy5tYXAgJiYgd2lyZVR5cGUgPT0gdGhpcy50eXBlLndpcmVUeXBlKSB8fFxyXG4gICAgICAgICAgICAgICAgKCFza2lwUmVwZWF0ZWQgJiYgdGhpcy5yZXBlYXRlZCAmJiB0aGlzLm9wdGlvbnNbXCJwYWNrZWRcIl0gJiZcclxuICAgICAgICAgICAgICAgICB3aXJlVHlwZSA9PSBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSkgfHxcclxuICAgICAgICAgICAgICAgICh0aGlzLm1hcCAmJiB3aXJlVHlwZSA9PSBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSk7XHJcbiAgICAgICAgICAgIGlmICghd2lyZVR5cGVPSylcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB3aXJlIHR5cGUgZm9yIGZpZWxkIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK3dpcmVUeXBlK1wiIChcIit0aGlzLnR5cGUud2lyZVR5cGUrXCIgZXhwZWN0ZWQpXCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIHBhY2tlZCByZXBlYXRlZCBmaWVsZHMuXHJcbiAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PSBQcm90b0J1Zi5XSVJFX1RZUEVTLkxERUxJTSAmJiB0aGlzLnJlcGVhdGVkICYmIHRoaXMub3B0aW9uc1tcInBhY2tlZFwiXSAmJiBQcm90b0J1Zi5QQUNLQUJMRV9XSVJFX1RZUEVTLmluZGV4T2YodGhpcy50eXBlLndpcmVUeXBlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNraXBSZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5CeXRlcyA9IGJ1ZmZlci5yZWFkVmFyaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICBuQnl0ZXMgPSBidWZmZXIub2Zmc2V0ICsgbkJ5dGVzOyAvLyBMaW1pdFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYnVmZmVyLm9mZnNldCA8IG5CeXRlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5kZWNvZGUodGhpcy50eXBlLndpcmVUeXBlLCBidWZmZXIsIHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUmVhZCB0aGUgbmV4dCB2YWx1ZSBvdGhlcndpc2UuLi5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIG1hcHMuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcCkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVhZCBvbmUgKGtleSwgdmFsdWUpIHN1Ym1lc3NhZ2UsIGFuZCByZXR1cm4gW2tleSwgdmFsdWVdXHJcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gRWxlbWVudC5kZWZhdWx0RmllbGRWYWx1ZSh0aGlzLmtleVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBFbGVtZW50LmRlZmF1bHRGaWVsZFZhbHVlKHRoaXMudHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVhZCB0aGUgbGVuZ3RoXHJcbiAgICAgICAgICAgICAgICBuQnl0ZXMgPSBidWZmZXIucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnJlbWFpbmluZygpIDwgbkJ5dGVzKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCBudW1iZXIgb2YgYnl0ZXMgZm9yIFwiK3RoaXMudG9TdHJpbmcodHJ1ZSkrXCI6IFwiK25CeXRlcytcIiByZXF1aXJlZCBidXQgZ290IG9ubHkgXCIrYnVmZmVyLnJlbWFpbmluZygpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgYSBzdWItYnVmZmVyIG9mIHRoaXMga2V5L3ZhbHVlIHN1Ym1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIHZhciBtc2didWYgPSBidWZmZXIuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIG1zZ2J1Zi5saW1pdCA9IG1zZ2J1Zi5vZmZzZXQgKyBuQnl0ZXM7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ICs9IG5CeXRlcztcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobXNnYnVmLnJlbWFpbmluZygpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSBtc2didWYucmVhZFZhcmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lyZVR5cGUgPSB0YWcgJiAweDA3O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IHRhZyA+Pj4gMztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaWQgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5rZXlFbGVtZW50LmRlY29kZShtc2didWYsIHdpcmVUeXBlLCBpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpZCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZWxlbWVudC5kZWNvZGUobXNnYnVmLCB3aXJlVHlwZSwgaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5leHBlY3RlZCB0YWcgaW4gbWFwIGZpZWxkIGtleS92YWx1ZSBzdWJtZXNzYWdlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBIYW5kbGUgc2luZ3VsYXIgYW5kIG5vbi1wYWNrZWQgcmVwZWF0ZWQgZmllbGQgdmFsdWVzLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmRlY29kZShidWZmZXIsIHdpcmVUeXBlLCB0aGlzLmlkKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuTWVzc2FnZS5GaWVsZCA9IEZpZWxkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1lc3NhZ2UgRXh0ZW5zaW9uRmllbGQuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkV4dGVuc2lvbkZpZWxkXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX0gbWVzc2FnZSBNZXNzYWdlIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBydWxlIFJ1bGUsIG9uZSBvZiByZXF1cmllZCwgb3B0aW9uYWwsIHJlcGVhdGVkXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRGF0YSB0eXBlLCBlLmcuIGludDMyXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBVbmlxdWUgZmllbGQgaWRcclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgT3B0aW9uc1xyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBFeHRlbnNpb25GaWVsZCA9IGZ1bmN0aW9uKGJ1aWxkZXIsIG1lc3NhZ2UsIHJ1bGUsIHR5cGUsIG5hbWUsIGlkLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIEZpZWxkLmNhbGwodGhpcywgYnVpbGRlciwgbWVzc2FnZSwgcnVsZSwgLyoga2V5dHlwZSA9ICovIG51bGwsIHR5cGUsIG5hbWUsIGlkLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFeHRlbnNpb24gcmVmZXJlbmNlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuRXh0ZW5zaW9ufVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBFeHRlbmRzIEZpZWxkXHJcbiAgICAgICAgRXh0ZW5zaW9uRmllbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWVsZC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkV4dGVuc2lvbkZpZWxkXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuTWVzc2FnZS5FeHRlbnNpb25GaWVsZCA9IEV4dGVuc2lvbkZpZWxkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1lc3NhZ2UgT25lT2YuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLk9uZU9mXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZX0gbWVzc2FnZSBNZXNzYWdlIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9uZU9mIG5hbWVcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAZXh0ZW5kcyBQcm90b0J1Zi5SZWZsZWN0LlRcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgT25lT2YgPSBmdW5jdGlvbihidWlsZGVyLCBtZXNzYWdlLCBuYW1lKSB7XHJcbiAgICAgICAgICAgIFQuY2FsbCh0aGlzLCBidWlsZGVyLCBtZXNzYWdlLCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbmNsb3NlZCBmaWVsZHMuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshQXJyYXkuPCFQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuRmllbGQ+fVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmZpZWxkcyA9IFtdO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2UuT25lT2ZcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5NZXNzYWdlLk9uZU9mID0gT25lT2Y7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRW51bS5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LkVudW1cclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5UfSBwYXJlbnQgUGFyZW50IFJlZmxlY3Qgb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRW51bSBuYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IG9wdGlvbnMgRW51bSBvcHRpb25zXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc/fSBzeW50YXggVGhlIHN5bnRheCBsZXZlbCAoZS5nLiwgcHJvdG8zKVxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBleHRlbmRzIFByb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEVudW0gPSBmdW5jdGlvbihidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIHN5bnRheCkge1xyXG4gICAgICAgICAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCBidWlsZGVyLCBwYXJlbnQsIG5hbWUsIG9wdGlvbnMsIHN5bnRheCk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiRW51bVwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJ1bnRpbWUgZW51bSBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fG51bGx9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0ID0gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBzdHJpbmcgbmFtZSBvZiBhbiBlbnVtIHZhbHVlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXIuRW51bX0gZW5tIFJ1bnRpbWUgZW51bVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBFbnVtIHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMgez9zdHJpbmd9IE5hbWUgb3IgYG51bGxgIGlmIG5vdCBwcmVzZW50XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVudW0uZ2V0TmFtZSA9IGZ1bmN0aW9uKGVubSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhlbm0pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTAsIGtleTsgaTxrZXlzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICAgICAgaWYgKGVubVtrZXkgPSBrZXlzW2ldXSA9PT0gdmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuRW51bS5wcm90b3R5cGVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRW51bVByb3RvdHlwZSA9IEVudW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVpbGRzIHRoaXMgZW51bSBhbmQgcmV0dXJucyB0aGUgcnVudGltZSBjb3VudGVycGFydC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlYnVpbGQgV2hldGhlciB0byByZWJ1aWxkIG9yIG5vdCwgZGVmYXVsdHMgdG8gZmFsc2VcclxuICAgICAgICAgKiBAcmV0dXJucyB7IU9iamVjdC48c3RyaW5nLG51bWJlcj59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVudW1Qcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihyZWJ1aWxkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9iamVjdCAmJiAhcmVidWlsZClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdDtcclxuICAgICAgICAgICAgdmFyIGVubSA9IG5ldyBQcm90b0J1Zi5CdWlsZGVyLkVudW0oKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHRoaXMuZ2V0Q2hpbGRyZW4oRW51bS5WYWx1ZSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MCwgaz12YWx1ZXMubGVuZ3RoOyBpPGs7ICsraSlcclxuICAgICAgICAgICAgICAgIGVubVt2YWx1ZXNbaV1bJ25hbWUnXV0gPSB2YWx1ZXNbaV1bJ2lkJ107XHJcbiAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZW5tLCAnJG9wdGlvbnMnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiB0aGlzLmJ1aWxkT3B0KCksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJlbnVtZXJhYmxlXCI6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0ID0gZW5tO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LkVudW1cclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5FbnVtID0gRW51bTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBFbnVtIFZhbHVlLlxyXG4gICAgICAgICAqIEBleHBvcnRzIFByb3RvQnVmLlJlZmxlY3QuRW51bS5WYWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LkVudW19IGVubSBFbnVtIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGZpZWxkIGlkXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFZhbHVlID0gZnVuY3Rpb24oYnVpbGRlciwgZW5tLCBuYW1lLCBpZCkge1xyXG4gICAgICAgICAgICBULmNhbGwodGhpcywgYnVpbGRlciwgZW5tLCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJFbnVtLlZhbHVlXCI7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVW5pcXVlIGVudW0gdmFsdWUgaWQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBFeHRlbmRzIFRcclxuICAgICAgICBWYWx1ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuRW51bS5WYWx1ZVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSZWZsZWN0LkVudW0uVmFsdWUgPSBWYWx1ZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gZXh0ZW5zaW9uIChmaWVsZCkuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5FeHRlbnNpb25cclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5CdWlsZGVyfSBidWlsZGVyIEJ1aWxkZXIgcmVmZXJlbmNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5UfSBwYXJlbnQgUGFyZW50IG9iamVjdFxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9iamVjdCBuYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLkZpZWxkfSBmaWVsZCBFeHRlbnNpb24gZmllbGRcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRXh0ZW5zaW9uID0gZnVuY3Rpb24oYnVpbGRlciwgcGFyZW50LCBuYW1lLCBmaWVsZCkge1xyXG4gICAgICAgICAgICBULmNhbGwodGhpcywgYnVpbGRlciwgcGFyZW50LCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFeHRlbmRlZCBtZXNzYWdlIGZpZWxkLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZS5GaWVsZH1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEV4dGVuZHMgVFxyXG4gICAgICAgIEV4dGVuc2lvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuRXh0ZW5zaW9uXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuRXh0ZW5zaW9uID0gRXh0ZW5zaW9uO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFNlcnZpY2UuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuTmFtZXNwYWNlfSByb290IFJvb3RcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBTZXJ2aWNlIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5OYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgU2VydmljZSA9IGZ1bmN0aW9uKGJ1aWxkZXIsIHJvb3QsIG5hbWUsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgTmFtZXNwYWNlLmNhbGwodGhpcywgYnVpbGRlciwgcm9vdCwgbmFtZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiU2VydmljZVwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJ1aWx0IHJ1bnRpbWUgc2VydmljZSBjbGFzcy5cclxuICAgICAgICAgICAgICogQHR5cGUgez9mdW5jdGlvbihuZXc6UHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlKX1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhenogPSBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UucHJvdG90eXBlXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFNlcnZpY2VQcm90b3R5cGUgPSBTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkcyB0aGUgc2VydmljZSBhbmQgcmV0dXJucyB0aGUgcnVudGltZSBjb3VudGVycGFydCwgd2hpY2ggaXMgYSBmdWxseSBmdW5jdGlvbmFsIGNsYXNzLlxyXG4gICAgICAgICAqIEBzZWUgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gcmVidWlsZCBXaGV0aGVyIHRvIHJlYnVpbGQgb3Igbm90XHJcbiAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFNlcnZpY2UgY2xhc3NcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1lc3NhZ2UgY2Fubm90IGJlIGJ1aWx0XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNlcnZpY2VQcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihyZWJ1aWxkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNsYXp6ICYmICFyZWJ1aWxkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xheno7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHJ1bnRpbWUgU2VydmljZSBjbGFzcyBpbiBpdHMgb3duIHNjb3BlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYXp6ID0gKGZ1bmN0aW9uKFByb3RvQnVmLCBUKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHJ1bnRpbWUgU2VydmljZS5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSwgZnVuY3Rpb24oRXJyb3IsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZT0pKT19IHJwY0ltcGwgUlBDIGltcGxlbWVudGF0aW9uIHJlY2VpdmluZyB0aGUgbWV0aG9kIG5hbWUgYW5kIHRoZSBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgKiBAY2xhc3MgQmFyZWJvbmUgb2YgYWxsIHJ1bnRpbWUgc2VydmljZXMuXHJcbiAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2VydmljZSBjYW5ub3QgYmUgY3JlYXRlZFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgU2VydmljZSA9IGZ1bmN0aW9uKHJwY0ltcGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogU2VydmljZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSBQcm90b0J1Zi5CdWlsZGVyLlNlcnZpY2UjcnBjSW1wbFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEB0eXBlIHshZnVuY3Rpb24oc3RyaW5nLCBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2UsIGZ1bmN0aW9uKEVycm9yLCBQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2U9KSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnBjSW1wbCA9IHJwY0ltcGwgfHwgZnVuY3Rpb24obmFtZSwgbXNnLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHdoYXQgYSB1c2VyIGhhcyB0byBpbXBsZW1lbnQ6IEEgZnVuY3Rpb24gcmVjZWl2aW5nIHRoZSBtZXRob2QgbmFtZSwgdGhlIGFjdHVhbCBtZXNzYWdlIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbmQgKHR5cGUgY2hlY2tlZCkgYW5kIHRoZSBjYWxsYmFjayB0aGF0J3MgZWl0aGVyIHByb3ZpZGVkIHdpdGggdGhlIGVycm9yIGFzIGl0cyBmaXJzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmd1bWVudCBvciBudWxsIGFuZCB0aGUgYWN0dWFsIHJlc3BvbnNlIG1lc3NhZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2suYmluZCh0aGlzLCBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZCwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9Qcm90b0J1Zi5qcy93aWtpL1NlcnZpY2VzXCIpKSwgMCk7IC8vIE11c3QgYmUgYXN5bmMhXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlci5TZXJ2aWNlLnByb3RvdHlwZVxyXG4gICAgICAgICAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciBTZXJ2aWNlUHJvdG90eXBlID0gU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZS5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQXN5bmNocm9ub3VzbHkgcGVyZm9ybXMgYW4gUlBDIGNhbGwgdXNpbmcgdGhlIGdpdmVuIFJQQyBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZS5bTWV0aG9kXVxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyFmdW5jdGlvbihzdHJpbmcsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZSwgZnVuY3Rpb24oRXJyb3IsIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZT0pKX0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7UHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlfSByZXEgUmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgKFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZXxCeXRlQnVmZmVyfEJ1ZmZlcnxzdHJpbmcpPSl9IGNhbGxiYWNrIENhbGxiYWNrIHJlY2VpdmluZ1xyXG4gICAgICAgICAgICAgICAgICogIHRoZSBlcnJvciBpZiBhbnkgYW5kIHRoZSByZXNwb25zZSBlaXRoZXIgYXMgYSBwcmUtcGFyc2VkIG1lc3NhZ2Ugb3IgYXMgaXRzIHJhdyBieXRlc1xyXG4gICAgICAgICAgICAgICAgICogQGFic3RyYWN0XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFzeW5jaHJvbm91c2x5IHBlcmZvcm1zIGFuIFJQQyBjYWxsIHVzaW5nIHRoZSBpbnN0YW5jZSdzIFJQQyBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgICAgICAgICAqIEBuYW1lIFByb3RvQnVmLkJ1aWxkZXIuU2VydmljZSNbTWV0aG9kXVxyXG4gICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZX0gcmVxIFJlcXVlc3RcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIChQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V8Qnl0ZUJ1ZmZlcnxCdWZmZXJ8c3RyaW5nKT0pfSBjYWxsYmFjayBDYWxsYmFjayByZWNlaXZpbmdcclxuICAgICAgICAgICAgICAgICAqICB0aGUgZXJyb3IgaWYgYW55IGFuZCB0aGUgcmVzcG9uc2UgZWl0aGVyIGFzIGEgcHJlLXBhcnNlZCBtZXNzYWdlIG9yIGFzIGl0cyByYXcgYnl0ZXNcclxuICAgICAgICAgICAgICAgICAqIEBhYnN0cmFjdFxyXG4gICAgICAgICAgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHJwYyA9IFQuZ2V0Q2hpbGRyZW4oUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8cnBjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKG1ldGhvZCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VydmljZSNNZXRob2QobWVzc2FnZSwgY2FsbGJhY2spXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNlcnZpY2VQcm90b3R5cGVbbWV0aG9kLm5hbWVdID0gZnVuY3Rpb24ocmVxLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBnaXZlbiBhcyBhIGJ1ZmZlciwgZGVjb2RlIHRoZSByZXF1ZXN0LiBXaWxsIHRocm93IGEgVHlwZUVycm9yIGlmIG5vdCBhIHZhbGlkIGJ1ZmZlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gbWV0aG9kLnJlc29sdmVkUmVxdWVzdFR5cGUuY2xhenouZGVjb2RlKEJ5dGVCdWZmZXIud3JhcChyZXEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcSA9PT0gbnVsbCB8fCB0eXBlb2YgcmVxICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbGxlZ2FsIGFyZ3VtZW50c1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXEgaW5zdGFuY2VvZiBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZS5jbGF6eikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcSA9IG5ldyBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZS5jbGF6eihyZXEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnBjSW1wbChtZXRob2QuZnFuKCksIHJlcSwgZnVuY3Rpb24oZXJyLCByZXMpIHsgLy8gQXNzdW1lcyB0aGF0IHRoaXMgaXMgcHJvcGVybHkgYXN5bmNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb2FsZXNjZSB0byBlbXB0eSBzdHJpbmcgd2hlbiBzZXJ2aWNlIHJlc3BvbnNlIGhhcyBlbXB0eSBjb250ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHsgcmVzID0gbWV0aG9kLnJlc29sdmVkUmVzcG9uc2VUeXBlLmNsYXp6LmRlY29kZShyZXMpOyB9IGNhdGNoIChub3RBQnVmZmVyKSB7fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcyB8fCAhKHJlcyBpbnN0YW5jZW9mIG1ldGhvZC5yZXNvbHZlZFJlc3BvbnNlVHlwZS5jbGF6eikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKEVycm9yKFwiSWxsZWdhbCByZXNwb25zZSB0eXBlIHJlY2VpdmVkIGluIHNlcnZpY2UgbWV0aG9kIFwiKyBULm5hbWUrXCIjXCIrbWV0aG9kLm5hbWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjay5iaW5kKHRoaXMsIGVyciksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VydmljZS5NZXRob2QocnBjSW1wbCwgbWVzc2FnZSwgY2FsbGJhY2spXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNlcnZpY2VbbWV0aG9kLm5hbWVdID0gZnVuY3Rpb24ocnBjSW1wbCwgcmVxLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFNlcnZpY2UocnBjSW1wbClbbWV0aG9kLm5hbWVdKHJlcSwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlW21ldGhvZC5uYW1lXSwgXCIkb3B0aW9uc1wiLCB7IFwidmFsdWVcIjogbWV0aG9kLmJ1aWxkT3B0KCkgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlUHJvdG90eXBlW21ldGhvZC5uYW1lXSwgXCIkb3B0aW9uc1wiLCB7IFwidmFsdWVcIjogU2VydmljZVttZXRob2QubmFtZV1bXCIkb3B0aW9uc1wiXSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KShycGNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2UsIFwiJG9wdGlvbnNcIiwgeyBcInZhbHVlXCI6IFQuYnVpbGRPcHQoKSB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2VQcm90b3R5cGUsIFwiJG9wdGlvbnNcIiwgeyBcInZhbHVlXCI6IFNlcnZpY2VbXCIkb3B0aW9uc1wiXSB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2UsIFwiJHR5cGVcIiwgeyBcInZhbHVlXCI6IFQgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlUHJvdG90eXBlLCBcIiR0eXBlXCIsIHsgXCJ2YWx1ZVwiOiBUIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBTZXJ2aWNlO1xyXG5cclxuICAgICAgICAgICAgfSkoUHJvdG9CdWYsIHRoaXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2VcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmVmbGVjdC5TZXJ2aWNlID0gU2VydmljZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWJzdHJhY3Qgc2VydmljZSBtZXRob2QuXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLk1ldGhvZFxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLkJ1aWxkZXJ9IGJ1aWxkZXIgQnVpbGRlciByZWZlcmVuY2VcclxuICAgICAgICAgKiBAcGFyYW0geyFQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2V9IHN2YyBTZXJ2aWNlXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWV0aG9kIG5hbWVcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5UXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIE1ldGhvZCA9IGZ1bmN0aW9uKGJ1aWxkZXIsIHN2YywgbmFtZSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBULmNhbGwodGhpcywgYnVpbGRlciwgc3ZjLCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gXCJTZXJ2aWNlLk1ldGhvZFwiO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9wdGlvbnMuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgKj59XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5NZXRob2QucHJvdG90eXBlXHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIE1ldGhvZFByb3RvdHlwZSA9IE1ldGhvZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFQucHJvdG90eXBlKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVpbGRzIHRoZSBtZXRob2QncyAnJG9wdGlvbnMnIHByb3BlcnR5LlxyXG4gICAgICAgICAqIEBuYW1lIFByb3RvQnVmLlJlZmxlY3QuU2VydmljZS5NZXRob2QjYnVpbGRPcHRcclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBNZXRob2RQcm90b3R5cGUuYnVpbGRPcHQgPSBOYW1lc3BhY2VQcm90b3R5cGUuYnVpbGRPcHQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuTWV0aG9kXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJlZmxlY3QuU2VydmljZS5NZXRob2QgPSBNZXRob2Q7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJQQyBzZXJ2aWNlIG1ldGhvZC5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuUlBDTWV0aG9kXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuQnVpbGRlcn0gYnVpbGRlciBCdWlsZGVyIHJlZmVyZW5jZVxyXG4gICAgICAgICAqIEBwYXJhbSB7IVByb3RvQnVmLlJlZmxlY3QuU2VydmljZX0gc3ZjIFNlcnZpY2VcclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXRob2QgbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBuYW1lXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlIFJlc3BvbnNlIG1lc3NhZ2UgbmFtZVxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWVzdF9zdHJlYW0gV2hldGhlciByZXF1ZXN0cyBhcmUgc3RyZWFtZWRcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc3BvbnNlX3N0cmVhbSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgc3RyZWFtZWRcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBPcHRpb25zXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQGV4dGVuZHMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLk1ldGhvZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBSUENNZXRob2QgPSBmdW5jdGlvbihidWlsZGVyLCBzdmMsIG5hbWUsIHJlcXVlc3QsIHJlc3BvbnNlLCByZXF1ZXN0X3N0cmVhbSwgcmVzcG9uc2Vfc3RyZWFtLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIE1ldGhvZC5jYWxsKHRoaXMsIGJ1aWxkZXIsIHN2YywgbmFtZSwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQG92ZXJyaWRlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiU2VydmljZS5SUENNZXRob2RcIjtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXF1ZXN0IG1lc3NhZ2UgbmFtZS5cclxuICAgICAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0TmFtZSA9IHJlcXVlc3Q7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVzcG9uc2UgbWVzc2FnZSBuYW1lLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlTmFtZSA9IHJlc3BvbnNlO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgcmVxdWVzdHMgYXJlIHN0cmVhbWVkXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RTdHJlYW0gPSByZXF1ZXN0X3N0cmVhbTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgc3RyZWFtZWRcclxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2x9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2VTdHJlYW0gPSByZXNwb25zZV9zdHJlYW07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVzb2x2ZWQgcmVxdWVzdCBtZXNzYWdlIHR5cGUuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtQcm90b0J1Zi5SZWZsZWN0Lk1lc3NhZ2V9XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRSZXF1ZXN0VHlwZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVzb2x2ZWQgcmVzcG9uc2UgbWVzc2FnZSB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkUmVzcG9uc2VUeXBlID0gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBFeHRlbmRzIE1ldGhvZFxyXG4gICAgICAgIFJQQ01ldGhvZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1ldGhvZC5wcm90b3R5cGUpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSZWZsZWN0LlNlcnZpY2UuUlBDTWV0aG9kID0gUlBDTWV0aG9kO1xyXG5cclxuICAgICAgICByZXR1cm4gUmVmbGVjdDtcclxuXHJcbiAgICB9KShQcm90b0J1Zik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlclxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5CdWlsZGVyID0gKGZ1bmN0aW9uKFByb3RvQnVmLCBMYW5nLCBSZWZsZWN0KSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQnVpbGRlci5cclxuICAgICAgICAgKiBAZXhwb3J0cyBQcm90b0J1Zi5CdWlsZGVyXHJcbiAgICAgICAgICogQGNsYXNzIFByb3ZpZGVzIHRoZSBmdW5jdGlvbmFsaXR5IHRvIGJ1aWxkIHByb3RvY29sIG1lc3NhZ2VzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj49fSBvcHRpb25zIE9wdGlvbnNcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQnVpbGRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBOYW1lc3BhY2UuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtQcm90b0J1Zi5SZWZsZWN0Lk5hbWVzcGFjZX1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5ucyA9IG5ldyBSZWZsZWN0Lk5hbWVzcGFjZSh0aGlzLCBudWxsLCBcIlwiKTsgLy8gR2xvYmFsIG5hbWVzcGFjZVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5hbWVzcGFjZSBwb2ludGVyLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7UHJvdG9CdWYuUmVmbGVjdC5UfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnB0ciA9IHRoaXMubnM7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVzb2x2ZWQgZmxhZy5cclxuICAgICAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY3VycmVudCBidWlsZGluZyByZXN1bHQuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxQcm90b0J1Zi5CdWlsZGVyLk1lc3NhZ2V8T2JqZWN0PnxudWxsfVxyXG4gICAgICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW1wb3J0ZWQgZmlsZXMuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5maWxlcyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEltcG9ydCByb290IG92ZXJyaWRlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7P3N0cmluZ31cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5pbXBvcnRSb290ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPcHRpb25zLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IU9iamVjdC48c3RyaW5nLCAqPn1cclxuICAgICAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlci5wcm90b3R5cGVcclxuICAgICAgICAgKiBAaW5uZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQnVpbGRlclByb3RvdHlwZSA9IEJ1aWxkZXIucHJvdG90eXBlO1xyXG5cclxuICAgICAgICAvLyAtLS0tLSBEZWZpbml0aW9uIHRlc3RzIC0tLS0tXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIGlmIGEgZGVmaW5pdGlvbiBtb3N0IGxpa2VseSBkZXNjcmliZXMgYSBtZXNzYWdlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gZGVmXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXIuaXNNZXNzYWdlID0gZnVuY3Rpb24oZGVmKSB7XHJcbiAgICAgICAgICAgIC8vIE1lc3NhZ2VzIHJlcXVpcmUgYSBzdHJpbmcgbmFtZVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcIm5hbWVcIl0gIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBNZXNzYWdlcyBkbyBub3QgY29udGFpbiB2YWx1ZXMgKGVudW0pIG9yIHJwYyBtZXRob2RzIChzZXJ2aWNlKVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcInZhbHVlc1wiXSAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRlZltcInJwY1wiXSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlc3RzIGlmIGEgZGVmaW5pdGlvbiBtb3N0IGxpa2VseSBkZXNjcmliZXMgYSBtZXNzYWdlIGZpZWxkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gZGVmXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXIuaXNNZXNzYWdlRmllbGQgPSBmdW5jdGlvbihkZWYpIHtcclxuICAgICAgICAgICAgLy8gTWVzc2FnZSBmaWVsZHMgcmVxdWlyZSBhIHN0cmluZyBydWxlLCBuYW1lIGFuZCB0eXBlIGFuZCBhbiBpZFxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcInJ1bGVcIl0gIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkZWZbXCJuYW1lXCJdICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGVmW1widHlwZVwiXSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIGRlZltcImlkXCJdID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVzdHMgaWYgYSBkZWZpbml0aW9uIG1vc3QgbGlrZWx5IGRlc2NyaWJlcyBhbiBlbnVtLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gZGVmXHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXIuaXNFbnVtID0gZnVuY3Rpb24oZGVmKSB7XHJcbiAgICAgICAgICAgIC8vIEVudW1zIHJlcXVpcmUgYSBzdHJpbmcgbmFtZVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcIm5hbWVcIl0gIT09ICdzdHJpbmcnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBFbnVtcyByZXF1aXJlIGF0IGxlYXN0IG9uZSB2YWx1ZVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcInZhbHVlc1wiXSA9PT0gJ3VuZGVmaW5lZCcgfHwgIUFycmF5LmlzQXJyYXkoZGVmW1widmFsdWVzXCJdKSB8fCBkZWZbXCJ2YWx1ZXNcIl0ubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIGRlZmluaXRpb24gbW9zdCBsaWtlbHkgZGVzY3JpYmVzIGEgc2VydmljZS5cclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IGRlZlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyLmlzU2VydmljZSA9IGZ1bmN0aW9uKGRlZikge1xyXG4gICAgICAgICAgICAvLyBTZXJ2aWNlcyByZXF1aXJlIGEgc3RyaW5nIG5hbWUgYW5kIGFuIHJwYyBvYmplY3RcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZbXCJuYW1lXCJdICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGVmW1wicnBjXCJdICE9PSAnb2JqZWN0JyB8fCAhZGVmW1wicnBjXCJdKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXN0cyBpZiBhIGRlZmluaXRpb24gbW9zdCBsaWtlbHkgZGVzY3JpYmVzIGFuIGV4dGVuZGVkIG1lc3NhZ2VcclxuICAgICAgICAgKiBAcGFyYW0geyFPYmplY3R9IGRlZlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyLmlzRXh0ZW5kID0gZnVuY3Rpb24oZGVmKSB7XHJcbiAgICAgICAgICAgIC8vIEV4dGVuZHMgcnF1aXJlIGEgc3RyaW5nIHJlZlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlZltcInJlZlwiXSAhPT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIC0tLS0tIEJ1aWxkaW5nIC0tLS0tXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc2V0cyB0aGUgcG9pbnRlciB0byB0aGUgcm9vdCBuYW1lc3BhY2UuXHJcbiAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyfSB0aGlzXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXJQcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdGhpcy5wdHIgPSB0aGlzLm5zO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZpbmVzIGEgbmFtZXNwYWNlIG9uIHRvcCBvZiB0aGUgY3VycmVudCBwb2ludGVyIHBvc2l0aW9uIGFuZCBwbGFjZXMgdGhlIHBvaW50ZXIgb24gaXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZVxyXG4gICAgICAgICAqIEByZXR1cm4geyFQcm90b0J1Zi5CdWlsZGVyfSB0aGlzXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXJQcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24obmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlICE9PSAnc3RyaW5nJyB8fCAhTGFuZy5UWVBFUkVGLnRlc3QobmFtZXNwYWNlKSlcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBuYW1lc3BhY2U6IFwiK25hbWVzcGFjZSk7XHJcbiAgICAgICAgICAgIG5hbWVzcGFjZS5zcGxpdChcIi5cIikuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbnMgPSB0aGlzLnB0ci5nZXRDaGlsZChwYXJ0KTtcclxuICAgICAgICAgICAgICAgIGlmIChucyA9PT0gbnVsbCkgLy8gS2VlcCBleGlzdGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLmFkZENoaWxkKG5zID0gbmV3IFJlZmxlY3QuTmFtZXNwYWNlKHRoaXMsIHRoaXMucHRyLCBwYXJ0KSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB0ciA9IG5zO1xyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyB0aGUgc3BlY2lmaWVkIGRlZmluaXRpb25zIGF0IHRoZSBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHshQXJyYXkuPCFPYmplY3Q+fSBkZWZzIE1lc3NhZ2VzLCBlbnVtcyBvciBzZXJ2aWNlcyB0byBjcmVhdGVcclxuICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXJ9IHRoaXNcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYSBtZXNzYWdlIGRlZmluaXRpb24gaXMgaW52YWxpZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyUHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGRlZnMpIHtcclxuICAgICAgICAgICAgaWYgKCFkZWZzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIE5vdGhpbmcgdG8gY3JlYXRlXHJcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkZWZzKSlcclxuICAgICAgICAgICAgICAgIGRlZnMgPSBbZGVmc107XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZnMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgZGVmcyA9IGRlZnMuc2xpY2UoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSXQncyBxdWl0ZSBoYXJkIHRvIGtlZXAgdHJhY2sgb2Ygc2NvcGVzIGFuZCBtZW1vcnkgaGVyZSwgc28gbGV0J3MgZG8gdGhpcyBpdGVyYXRpdmVseS5cclxuICAgICAgICAgICAgdmFyIHN0YWNrID0gW2RlZnNdO1xyXG4gICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZGVmcyA9IHN0YWNrLnBvcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkZWZzKSkgLy8gU3RhY2sgYWx3YXlzIGNvbnRhaW5zIGVudGlyZSBuYW1lc3BhY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub3QgYSB2YWxpZCBuYW1lc3BhY2U6IFwiK0pTT04uc3RyaW5naWZ5KGRlZnMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoZGVmcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZiA9IGRlZnMuc2hpZnQoKTsgLy8gTmFtZXNwYWNlcyBhbHdheXMgY29udGFpbiBhbiBhcnJheSBvZiBtZXNzYWdlcywgZW51bXMgYW5kIHNlcnZpY2VzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChCdWlsZGVyLmlzTWVzc2FnZShkZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBuZXcgUmVmbGVjdC5NZXNzYWdlKHRoaXMsIHRoaXMucHRyLCBkZWZbXCJuYW1lXCJdLCBkZWZbXCJvcHRpb25zXCJdLCBkZWZbXCJpc0dyb3VwXCJdLCBkZWZbXCJzeW50YXhcIl0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIE9uZU9mc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25lb2ZzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbXCJvbmVvZnNcIl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkZWZbXCJvbmVvZnNcIl0pLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRDaGlsZChvbmVvZnNbbmFtZV0gPSBuZXcgUmVmbGVjdC5NZXNzYWdlLk9uZU9mKHRoaXMsIG9iaiwgbmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZmllbGRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbXCJmaWVsZHNcIl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZbXCJmaWVsZHNcIl0uZm9yRWFjaChmdW5jdGlvbihmbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmdldENoaWxkKGZsZFtcImlkXCJdfDApICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBvciBpbnZhbGlkIGZpZWxkIGlkIGluIFwiK29iai5uYW1lK1wiOiBcIitmbGRbJ2lkJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbGRbXCJvcHRpb25zXCJdICYmIHR5cGVvZiBmbGRbXCJvcHRpb25zXCJdICE9PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGZpZWxkIG9wdGlvbnMgaW4gXCIrb2JqLm5hbWUrXCIjXCIrZmxkW1wibmFtZVwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uZW9mID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZsZFtcIm9uZW9mXCJdID09PSAnc3RyaW5nJyAmJiAhKG9uZW9mID0gb25lb2ZzW2ZsZFtcIm9uZW9mXCJdXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBvbmVvZiBpbiBcIitvYmoubmFtZStcIiNcIitmbGRbXCJuYW1lXCJdK1wiOiBcIitmbGRbXCJvbmVvZlwiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxkID0gbmV3IFJlZmxlY3QuTWVzc2FnZS5GaWVsZCh0aGlzLCBvYmosIGZsZFtcInJ1bGVcIl0sIGZsZFtcImtleXR5cGVcIl0sIGZsZFtcInR5cGVcIl0sIGZsZFtcIm5hbWVcIl0sIGZsZFtcImlkXCJdLCBmbGRbXCJvcHRpb25zXCJdLCBvbmVvZiwgZGVmW1wic3ludGF4XCJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25lb2YpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZW9mLmZpZWxkcy5wdXNoKGZsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmFkZENoaWxkKGZsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1c2ggY2hpbGRyZW4gdG8gc3RhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1Yk9iaiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmW1wiZW51bXNcIl0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZbXCJlbnVtc1wiXS5mb3JFYWNoKGZ1bmN0aW9uKGVubSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk9iai5wdXNoKGVubSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZltcIm1lc3NhZ2VzXCJdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmW1wibWVzc2FnZXNcIl0uZm9yRWFjaChmdW5jdGlvbihtc2cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJPYmoucHVzaChtc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWZbXCJzZXJ2aWNlc1wiXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZltcInNlcnZpY2VzXCJdLmZvckVhY2goZnVuY3Rpb24oc3ZjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViT2JqLnB1c2goc3ZjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGV4dGVuc2lvbiByYW5nZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZltcImV4dGVuc2lvbnNcIl0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVmW1wiZXh0ZW5zaW9uc1wiXVswXSA9PT0gJ251bWJlcicpIC8vIHByZSA1LjAuMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5leHRlbnNpb25zID0gWyBkZWZbXCJleHRlbnNpb25zXCJdIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmV4dGVuc2lvbnMgPSBkZWZbXCJleHRlbnNpb25zXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgb24gdG9wIG9mIGN1cnJlbnQgbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLmFkZENoaWxkKG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJPYmoubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChkZWZzKTsgLy8gUHVzaCB0aGUgY3VycmVudCBsZXZlbCBiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZzID0gc3ViT2JqOyAvLyBDb250aW51ZSBwcm9jZXNzaW5nIHN1YiBsZXZlbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViT2JqID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyID0gb2JqOyAvLyBBbmQgbW92ZSB0aGUgcG9pbnRlciB0byB0aGlzIG5hbWVzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk9iaiA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQnVpbGRlci5pc0VudW0oZGVmKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gbmV3IFJlZmxlY3QuRW51bSh0aGlzLCB0aGlzLnB0ciwgZGVmW1wibmFtZVwiXSwgZGVmW1wib3B0aW9uc1wiXSwgZGVmW1wic3ludGF4XCJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmW1widmFsdWVzXCJdLmZvckVhY2goZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouYWRkQ2hpbGQobmV3IFJlZmxlY3QuRW51bS5WYWx1ZSh0aGlzLCBvYmosIHZhbFtcIm5hbWVcIl0sIHZhbFtcImlkXCJdKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5hZGRDaGlsZChvYmopO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEJ1aWxkZXIuaXNTZXJ2aWNlKGRlZikpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG5ldyBSZWZsZWN0LlNlcnZpY2UodGhpcywgdGhpcy5wdHIsIGRlZltcIm5hbWVcIl0sIGRlZltcIm9wdGlvbnNcIl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkZWZbXCJycGNcIl0pLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG10ZCA9IGRlZltcInJwY1wiXVtuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5hZGRDaGlsZChuZXcgUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZCh0aGlzLCBvYmosIG5hbWUsIG10ZFtcInJlcXVlc3RcIl0sIG10ZFtcInJlc3BvbnNlXCJdLCAhIW10ZFtcInJlcXVlc3Rfc3RyZWFtXCJdLCAhIW10ZFtcInJlc3BvbnNlX3N0cmVhbVwiXSwgbXRkW1wib3B0aW9uc1wiXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIuYWRkQ2hpbGQob2JqKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChCdWlsZGVyLmlzRXh0ZW5kKGRlZikpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IHRoaXMucHRyLnJlc29sdmUoZGVmW1wicmVmXCJdLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmW1wiZmllbGRzXCJdLmZvckVhY2goZnVuY3Rpb24oZmxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5nZXRDaGlsZChmbGRbJ2lkJ118MCkgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIGV4dGVuZGVkIGZpZWxkIGlkIGluIFwiK29iai5uYW1lK1wiOiBcIitmbGRbJ2lkJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGZpZWxkIGlkIGlzIGFsbG93ZWQgdG8gYmUgZXh0ZW5kZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmV4dGVuc2lvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5leHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24ocmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbGRbXCJpZFwiXSA+PSByYW5nZVswXSAmJiBmbGRbXCJpZFwiXSA8PSByYW5nZVsxXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGV4dGVuZGVkIGZpZWxkIGlkIGluIFwiK29iai5uYW1lK1wiOiBcIitmbGRbJ2lkJ10rXCIgKG5vdCB3aXRoaW4gdmFsaWQgcmFuZ2VzKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBleHRlbnNpb24gZmllbGQgbmFtZXMgdG8gY2FtZWwgY2FzZSBub3RhdGlvbiBpZiB0aGUgb3ZlcnJpZGUgaXMgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBmbGRbXCJuYW1lXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNbJ2NvbnZlcnRGaWVsZHNUb0NhbWVsQ2FzZSddKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gUHJvdG9CdWYuVXRpbC50b0NhbWVsQ2FzZShuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWUgIzE2MTogRXh0ZW5zaW9ucyB1c2UgdGhlaXIgZnVsbHkgcXVhbGlmaWVkIG5hbWUgYXMgdGhlaXIgcnVudGltZSBrZXkgYW5kLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gbmV3IFJlZmxlY3QuTWVzc2FnZS5FeHRlbnNpb25GaWVsZCh0aGlzLCBvYmosIGZsZFtcInJ1bGVcIl0sIGZsZFtcInR5cGVcIl0sIHRoaXMucHRyLmZxbigpKycuJytuYW1lLCBmbGRbXCJpZFwiXSwgZmxkW1wib3B0aW9uc1wiXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYXJlIGFkZGVkIG9uIHRvcCBvZiB0aGUgY3VycmVudCBuYW1lc3BhY2UgYXMgYW4gZXh0ZW5zaW9uIHdoaWNoIGlzIHVzZWQgZm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzb2x2aW5nIHRoZWlyIHR5cGUgbGF0ZXIgb24gKHRoZSBleHRlbnNpb24gYWx3YXlzIGtlZXBzIHRoZSBvcmlnaW5hbCBuYW1lIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudCBuYW1pbmcgY29sbGlzaW9ucylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ID0gbmV3IFJlZmxlY3QuRXh0ZW5zaW9uKHRoaXMsIHRoaXMucHRyLCBmbGRbXCJuYW1lXCJdLCBmaWVsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuZXh0ZW5zaW9uID0gZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLmFkZENoaWxkKGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmFkZENoaWxkKGZpZWxkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghL1xcLj9nb29nbGVcXC5wcm90b2J1ZlxcLi8udGVzdChkZWZbXCJyZWZcIl0pKSAvLyBTaWxlbnRseSBza2lwIGludGVybmFsIGV4dGVuc2lvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZXh0ZW5kZWQgbWVzc2FnZSBcIitkZWZbXCJyZWZcIl0rXCIgaXMgbm90IGRlZmluZWRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vdCBhIHZhbGlkIGRlZmluaXRpb246IFwiK0pTT04uc3RyaW5naWZ5KGRlZikpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkZWYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBCcmVhayBnb2VzIGhlcmVcclxuICAgICAgICAgICAgICAgIGRlZnMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdHIgPSB0aGlzLnB0ci5wYXJlbnQ7IC8vIE5hbWVzcGFjZSBkb25lLCBjb250aW51ZSBhdCBwYXJlbnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7IC8vIFJlcXVpcmUgcmUtcmVzb2x2ZVxyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9IG51bGw7IC8vIFJlcXVpcmUgcmUtYnVpbGRcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcGFnYXRlcyBzeW50YXggdG8gYWxsIGNoaWxkcmVuLlxyXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gcGFyZW50XHJcbiAgICAgICAgICogQGlubmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gcHJvcGFnYXRlU3ludGF4KHBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAocGFyZW50WydtZXNzYWdlcyddKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRbJ21lc3NhZ2VzJ10uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkW1wic3ludGF4XCJdID0gcGFyZW50W1wic3ludGF4XCJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZVN5bnRheChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGFyZW50WydlbnVtcyddKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRbJ2VudW1zJ10uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkW1wic3ludGF4XCJdID0gcGFyZW50W1wic3ludGF4XCJdO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEltcG9ydHMgYW5vdGhlciBkZWZpbml0aW9uIGludG8gdGhpcyBidWlsZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGpzb24gUGFyc2VkIGltcG9ydFxyXG4gICAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3x7cm9vdDogc3RyaW5nLCBmaWxlOiBzdHJpbmd9KT19IGZpbGVuYW1lIEltcG9ydGVkIGZpbGUgbmFtZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHshUHJvdG9CdWYuQnVpbGRlcn0gdGhpc1xyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgZGVmaW5pdGlvbiBvciBmaWxlIGNhbm5vdCBiZSBpbXBvcnRlZFxyXG4gICAgICAgICAqIEBleHBvc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyUHJvdG90eXBlW1wiaW1wb3J0XCJdID0gZnVuY3Rpb24oanNvbiwgZmlsZW5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGRlbGltID0gJy8nO1xyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRvIHNraXAgZHVwbGljYXRlIGltcG9ydHNcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsZW5hbWUgPT09ICdzdHJpbmcnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKFByb3RvQnVmLlV0aWwuSVNfTk9ERSlcclxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IHJlcXVpcmUkJDJbJ3Jlc29sdmUnXShmaWxlbmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maWxlc1tmaWxlbmFtZV0gPT09IHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsZXNbZmlsZW5hbWVdID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpbGVuYW1lID09PSAnb2JqZWN0JykgeyAvLyBPYmplY3Qgd2l0aCByb290LCBmaWxlLlxyXG5cclxuICAgICAgICAgICAgICAgIHZhciByb290ID0gZmlsZW5hbWUucm9vdDtcclxuICAgICAgICAgICAgICAgIGlmIChQcm90b0J1Zi5VdGlsLklTX05PREUpXHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IHJlcXVpcmUkJDJbJ3Jlc29sdmUnXShyb290KTtcclxuICAgICAgICAgICAgICAgIGlmIChyb290LmluZGV4T2YoXCJcXFxcXCIpID49IDAgfHwgZmlsZW5hbWUuZmlsZS5pbmRleE9mKFwiXFxcXFwiKSA+PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGltID0gJ1xcXFwnO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZuYW1lO1xyXG4gICAgICAgICAgICAgICAgaWYgKFByb3RvQnVmLlV0aWwuSVNfTk9ERSlcclxuICAgICAgICAgICAgICAgICAgICBmbmFtZSA9IHJlcXVpcmUkJDJbJ2pvaW4nXShyb290LCBmaWxlbmFtZS5maWxlKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBmbmFtZSA9IHJvb3QgKyBkZWxpbSArIGZpbGVuYW1lLmZpbGU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maWxlc1tmbmFtZV0gPT09IHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlsZXNbZm5hbWVdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW1wb3J0IGltcG9ydHNcclxuXHJcbiAgICAgICAgICAgIGlmIChqc29uWydpbXBvcnRzJ10gJiYganNvblsnaW1wb3J0cyddLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbXBvcnRSb290LFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0Um9vdCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsZW5hbWUgPT09ICdvYmplY3QnKSB7IC8vIElmIGFuIGltcG9ydCByb290IGlzIHNwZWNpZmllZCwgb3ZlcnJpZGVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRSb290ID0gZmlsZW5hbWVbXCJyb290XCJdOyByZXNldFJvb3QgPSB0cnVlOyAvLyAuLi4gYW5kIHJlc2V0IGFmdGVyd2FyZHNcclxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gdGhpcy5pbXBvcnRSb290O1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gZmlsZW5hbWVbXCJmaWxlXCJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbXBvcnRSb290LmluZGV4T2YoXCJcXFxcXCIpID49IDAgfHwgZmlsZW5hbWUuaW5kZXhPZihcIlxcXFxcIikgPj0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsaW0gPSAnXFxcXCc7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmlsZW5hbWUgPT09ICdzdHJpbmcnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmltcG9ydFJvb3QpIC8vIElmIGltcG9ydCByb290IGlzIG92ZXJyaWRkZW4sIHVzZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRSb290ID0gdGhpcy5pbXBvcnRSb290O1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBPdGhlcndpc2UgY29tcHV0ZSBmcm9tIGZpbGVuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlbmFtZS5pbmRleE9mKFwiL1wiKSA+PSAwKSB7IC8vIFVuaXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSBmaWxlbmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC8qIC9maWxlLnByb3RvICovIGltcG9ydFJvb3QgPT09IFwiXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IFwiL1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpbGVuYW1lLmluZGV4T2YoXCJcXFxcXCIpID49IDApIHsgLy8gV2luZG93c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IGZpbGVuYW1lLnJlcGxhY2UoL1xcXFxbXlxcXFxdKiQvLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGltID0gJ1xcXFwnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydFJvb3QgPSBcIi5cIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0Um9vdCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGpzb25bJ2ltcG9ydHMnXS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YganNvblsnaW1wb3J0cyddW2ldID09PSAnc3RyaW5nJykgeyAvLyBJbXBvcnQgZmlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWltcG9ydFJvb3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImNhbm5vdCBkZXRlcm1pbmUgaW1wb3J0IHJvb3RcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbXBvcnRGaWxlbmFtZSA9IGpzb25bJ2ltcG9ydHMnXVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltcG9ydEZpbGVuYW1lID09PSBcImdvb2dsZS9wcm90b2J1Zi9kZXNjcmlwdG9yLnByb3RvXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gTm90IG5lZWRlZCBhbmQgdGhlcmVmb3JlIG5vdCB1c2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChQcm90b0J1Zi5VdGlsLklTX05PREUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBvcnRGaWxlbmFtZSA9IHJlcXVpcmUkJDJbJ2pvaW4nXShpbXBvcnRSb290LCBpbXBvcnRGaWxlbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydEZpbGVuYW1lID0gaW1wb3J0Um9vdCArIGRlbGltICsgaW1wb3J0RmlsZW5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbGVzW2ltcG9ydEZpbGVuYW1lXSA9PT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBBbHJlYWR5IGltcG9ydGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXFwucHJvdG8kL2kudGVzdChpbXBvcnRGaWxlbmFtZSkgJiYgIVByb3RvQnVmLkRvdFByb3RvKSAgICAgICAvLyBJZiB0aGlzIGlzIGEgbGlnaHQgYnVpbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydEZpbGVuYW1lID0gaW1wb3J0RmlsZW5hbWUucmVwbGFjZSgvXFwucHJvdG8kLywgXCIuanNvblwiKTsgLy8gYWx3YXlzIGxvYWQgdGhlIEpTT04gZmlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudHMgPSBQcm90b0J1Zi5VdGlsLmZldGNoKGltcG9ydEZpbGVuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJmYWlsZWQgdG8gaW1wb3J0ICdcIitpbXBvcnRGaWxlbmFtZStcIicgaW4gJ1wiK2ZpbGVuYW1lK1wiJzogZmlsZSBub3QgZm91bmRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXFwuanNvbiQvaS50ZXN0KGltcG9ydEZpbGVuYW1lKSkgLy8gQWx3YXlzIHBvc3NpYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1wiaW1wb3J0XCJdKEpTT04ucGFyc2UoY29udGVudHMrXCJcIiksIGltcG9ydEZpbGVuYW1lKTsgLy8gTWF5IHRocm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbXCJpbXBvcnRcIl0oUHJvdG9CdWYuRG90UHJvdG8uUGFyc2VyLnBhcnNlKGNvbnRlbnRzKSwgaW1wb3J0RmlsZW5hbWUpOyAvLyBNYXkgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgLy8gSW1wb3J0IHN0cnVjdHVyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbGVuYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tcImltcG9ydFwiXShqc29uWydpbXBvcnRzJ11baV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXFwuKFxcdyspJC8udGVzdChmaWxlbmFtZSkpIC8vIFdpdGggZXh0ZW5zaW9uOiBBcHBlbmQgX2ltcG9ydE4gdG8gdGhlIG5hbWUgcG9ydGlvbiB0byBtYWtlIGl0IHVuaXF1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tcImltcG9ydFwiXShqc29uWydpbXBvcnRzJ11baV0sIGZpbGVuYW1lLnJlcGxhY2UoL14oLispXFwuKFxcdyspJC8sIGZ1bmN0aW9uKCQwLCAkMSwgJDIpIHsgcmV0dXJuICQxK1wiX2ltcG9ydFwiK2krXCIuXCIrJDI7IH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSAvLyBXaXRob3V0IGV4dGVuc2lvbjogQXBwZW5kIF9pbXBvcnROIHRvIG1ha2UgaXQgdW5pcXVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1wiaW1wb3J0XCJdKGpzb25bJ2ltcG9ydHMnXVtpXSwgZmlsZW5hbWUrXCJfaW1wb3J0XCIraSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzZXRSb290KSAvLyBSZXNldCBpbXBvcnQgcm9vdCBvdmVycmlkZSB3aGVuIGFsbCBpbXBvcnRzIGFyZSBkb25lXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRSb290ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW1wb3J0IHN0cnVjdHVyZXNcclxuXHJcbiAgICAgICAgICAgIGlmIChqc29uWydwYWNrYWdlJ10pXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmluZShqc29uWydwYWNrYWdlJ10pO1xyXG4gICAgICAgICAgICBpZiAoanNvblsnc3ludGF4J10pXHJcbiAgICAgICAgICAgICAgICBwcm9wYWdhdGVTeW50YXgoanNvbik7XHJcbiAgICAgICAgICAgIHZhciBiYXNlID0gdGhpcy5wdHI7XHJcbiAgICAgICAgICAgIGlmIChqc29uWydvcHRpb25zJ10pXHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhqc29uWydvcHRpb25zJ10pLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZS5vcHRpb25zW2tleV0gPSBqc29uWydvcHRpb25zJ11ba2V5XTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoanNvblsnbWVzc2FnZXMnXSlcclxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlKGpzb25bJ21lc3NhZ2VzJ10pLCB0aGlzLnB0ciA9IGJhc2U7XHJcbiAgICAgICAgICAgIGlmIChqc29uWydlbnVtcyddKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoanNvblsnZW51bXMnXSksIHRoaXMucHRyID0gYmFzZTtcclxuICAgICAgICAgICAgaWYgKGpzb25bJ3NlcnZpY2VzJ10pXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZShqc29uWydzZXJ2aWNlcyddKSwgdGhpcy5wdHIgPSBiYXNlO1xyXG4gICAgICAgICAgICBpZiAoanNvblsnZXh0ZW5kcyddKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGUoanNvblsnZXh0ZW5kcyddKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzb2x2ZXMgYWxsIG5hbWVzcGFjZSBvYmplY3RzLlxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhIHR5cGUgY2Fubm90IGJlIHJlc29sdmVkXHJcbiAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5CdWlsZGVyfSB0aGlzXHJcbiAgICAgICAgICogQGV4cG9zZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXJQcm90b3R5cGUucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAvLyBSZXNvbHZlIGFsbCByZWZsZWN0ZWQgb2JqZWN0c1xyXG4gICAgICAgICAgICB2YXIgcmVzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wdHIgPT0gbnVsbCB8fCB0eXBlb2YgdGhpcy5wdHIudHlwZSA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRG9uZSAoYWxyZWFkeSByZXNvbHZlZClcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnB0ciBpbnN0YW5jZW9mIFJlZmxlY3QuTmFtZXNwYWNlKSB7IC8vIFJlc29sdmUgY2hpbGRyZW5cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnB0ci5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIgPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVBbGwoKTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnB0ciBpbnN0YW5jZW9mIFJlZmxlY3QuTWVzc2FnZS5GaWVsZCkgeyAvLyBSZXNvbHZlIHR5cGVcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRS50ZXN0KHRoaXMucHRyLnR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFMYW5nLlRZUEVSRUYudGVzdCh0aGlzLnB0ci50eXBlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIHR5cGUgcmVmZXJlbmNlIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpK1wiOiBcIit0aGlzLnB0ci50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSAodGhpcy5wdHIgaW5zdGFuY2VvZiBSZWZsZWN0Lk1lc3NhZ2UuRXh0ZW5zaW9uRmllbGQgPyB0aGlzLnB0ci5leHRlbnNpb24ucGFyZW50IDogdGhpcy5wdHIucGFyZW50KS5yZXNvbHZlKHRoaXMucHRyLnR5cGUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInVucmVzb2x2YWJsZSB0eXBlIHJlZmVyZW5jZSBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy5wdHIudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIucmVzb2x2ZWRUeXBlID0gcmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBSZWZsZWN0LkVudW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIudHlwZSA9IFByb3RvQnVmLlRZUEVTW1wiZW51bVwiXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHRyLnN5bnRheCA9PT0gJ3Byb3RvMycgJiYgcmVzLnN5bnRheCAhPT0gJ3Byb3RvMycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInByb3RvMyBtZXNzYWdlIGNhbm5vdCByZWZlcmVuY2UgcHJvdG8yIGVudW1cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcyBpbnN0YW5jZW9mIFJlZmxlY3QuTWVzc2FnZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIudHlwZSA9IHJlcy5pc0dyb3VwID8gUHJvdG9CdWYuVFlQRVNbXCJncm91cFwiXSA6IFByb3RvQnVmLlRZUEVTW1wibWVzc2FnZVwiXTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCB0eXBlIHJlZmVyZW5jZSBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy5wdHIudHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci50eXBlID0gUHJvdG9CdWYuVFlQRVNbdGhpcy5wdHIudHlwZV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyBhIG1hcCBmaWVsZCwgYWxzbyByZXNvbHZlIHRoZSBrZXkgdHlwZS4gVGhlIGtleSB0eXBlIGNhbiBiZSBvbmx5IGEgbnVtZXJpYywgc3RyaW5nLCBvciBib29sIHR5cGVcclxuICAgICAgICAgICAgICAgIC8vIChpLmUuLCBubyBlbnVtcyBvciBtZXNzYWdlcyksIHNvIHdlIGRvbid0IG5lZWQgdG8gcmVzb2x2ZSBhZ2FpbnN0IHRoZSBjdXJyZW50IG5hbWVzcGFjZS5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnB0ci5tYXApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUxhbmcuVFlQRS50ZXN0KHRoaXMucHRyLmtleVR5cGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwga2V5IHR5cGUgZm9yIG1hcCBmaWVsZCBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy5wdHIua2V5VHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdHIua2V5VHlwZSA9IFByb3RvQnVmLlRZUEVTW3RoaXMucHRyLmtleVR5cGVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYSByZXBlYXRlZCBhbmQgcGFja2FibGUgZmllbGQgdGhlbiBwcm90bzMgbWFuZGF0ZXMgaXQgc2hvdWxkIGJlIHBhY2tlZCBieVxyXG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICB0aGlzLnB0ci5zeW50YXggPT09ICdwcm90bzMnICYmXHJcbiAgICAgICAgICAgICAgICAgIHRoaXMucHRyLnJlcGVhdGVkICYmIHRoaXMucHRyLm9wdGlvbnMucGFja2VkID09PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgICAgUHJvdG9CdWYuUEFDS0FCTEVfV0lSRV9UWVBFUy5pbmRleE9mKHRoaXMucHRyLnR5cGUud2lyZVR5cGUpICE9PSAtMVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRoaXMucHRyLm9wdGlvbnMucGFja2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wdHIgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0LlNlcnZpY2UuTWV0aG9kKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHRyIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5TZXJ2aWNlLlJQQ01ldGhvZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMucHRyLnBhcmVudC5yZXNvbHZlKHRoaXMucHRyLnJlcXVlc3ROYW1lLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcyB8fCAhKHJlcyBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB0eXBlIHJlZmVyZW5jZSBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy5wdHIucmVxdWVzdE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHRyLnJlc29sdmVkUmVxdWVzdFR5cGUgPSByZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wdHIucGFyZW50LnJlc29sdmUodGhpcy5wdHIucmVzcG9uc2VOYW1lLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcyB8fCAhKHJlcyBpbnN0YW5jZW9mIFByb3RvQnVmLlJlZmxlY3QuTWVzc2FnZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWxsZWdhbCB0eXBlIHJlZmVyZW5jZSBpbiBcIit0aGlzLnB0ci50b1N0cmluZyh0cnVlKStcIjogXCIrdGhpcy5wdHIucmVzcG9uc2VOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB0ci5yZXNvbHZlZFJlc3BvbnNlVHlwZSA9IHJlcztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSAvLyBTaG91bGQgbm90IGhhcHBlbiBhcyBub3RoaW5nIGVsc2UgaXMgaW1wbGVtZW50ZWRcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgc2VydmljZSB0eXBlIGluIFwiK3RoaXMucHRyLnRvU3RyaW5nKHRydWUpKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICAhKHRoaXMucHRyIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5NZXNzYWdlLk9uZU9mKSAmJiAvLyBOb3QgYnVpbHRcclxuICAgICAgICAgICAgICAgICEodGhpcy5wdHIgaW5zdGFuY2VvZiBQcm90b0J1Zi5SZWZsZWN0LkV4dGVuc2lvbikgJiYgLy8gTm90IGJ1aWx0XHJcbiAgICAgICAgICAgICAgICAhKHRoaXMucHRyIGluc3RhbmNlb2YgUHJvdG9CdWYuUmVmbGVjdC5FbnVtLlZhbHVlKSAvLyBCdWlsdCBpbiBlbnVtXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBvYmplY3QgaW4gbmFtZXNwYWNlOiBcIit0eXBlb2YodGhpcy5wdHIpK1wiOiBcIit0aGlzLnB0cik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1aWxkcyB0aGUgcHJvdG9jb2wuIFRoaXMgd2lsbCBmaXJzdCB0cnkgdG8gcmVzb2x2ZSBhbGwgZGVmaW5pdGlvbnMgYW5kLCBpZiB0aGlzIGhhcyBiZWVuIHN1Y2Nlc3NmdWwsXHJcbiAgICAgICAgICogcmV0dXJuIHRoZSBidWlsdCBwYWNrYWdlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3xBcnJheS48c3RyaW5nPik9fSBwYXRoIFNwZWNpZmllcyB3aGF0IHRvIHJldHVybi4gSWYgb21pdHRlZCwgdGhlIGVudGlyZSBuYW1lc3BhY2Ugd2lsbCBiZSByZXR1cm5lZC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IVByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZXwhT2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIGEgdHlwZSBjb3VsZCBub3QgYmUgcmVzb2x2ZWRcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlclByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKHBhdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVzb2x2ZWQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVBbGwoKSwgdGhpcy5yZXNvbHZlZCA9IHRydWUsIHRoaXMucmVzdWx0ID0gbnVsbDsgLy8gUmVxdWlyZSByZS1idWlsZFxyXG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bHQgPT09IG51bGwpIC8vIChSZS0pQnVpbGRcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5ucy5idWlsZCgpO1xyXG4gICAgICAgICAgICBpZiAoIXBhdGgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnID8gcGF0aC5zcGxpdChcIi5cIikgOiBwYXRoLFxyXG4gICAgICAgICAgICAgICAgcHRyID0gdGhpcy5yZXN1bHQ7IC8vIEJ1aWxkIG5hbWVzcGFjZSBwb2ludGVyIChubyBoYXNDaGlsZCBldGMuKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8cGFydC5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIGlmIChwdHJbcGFydFtpXV0pXHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gcHRyW3BhcnRbaV1dO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHRyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHB0cjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaW1pbGFyIHRvIHtAbGluayBQcm90b0J1Zi5CdWlsZGVyI2J1aWxkfSwgYnV0IGxvb2tzIHVwIHRoZSBpbnRlcm5hbCByZWZsZWN0aW9uIGRlc2NyaXB0b3IuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBwYXRoIFNwZWNpZmllcyB3aGF0IHRvIHJldHVybi4gSWYgb21pdHRlZCwgdGhlIGVudGlyZSBuYW1lc3BhY2Ugd2lpbCBiZSByZXR1cm5lZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBleGNsdWRlTm9uTmFtZXNwYWNlIEV4Y2x1ZGVzIG5vbi1uYW1lc3BhY2UgdHlwZXMgbGlrZSBmaWVsZHMsIGRlZmF1bHRzIHRvIGBmYWxzZWBcclxuICAgICAgICAgKiBAcmV0dXJucyB7P1Byb3RvQnVmLlJlZmxlY3QuVH0gUmVmbGVjdGlvbiBkZXNjcmlwdG9yIG9yIGBudWxsYCBpZiBub3QgZm91bmRcclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyUHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKHBhdGgsIGV4Y2x1ZGVOb25OYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhdGggPyB0aGlzLm5zLnJlc29sdmUocGF0aCwgZXhjbHVkZU5vbk5hbWVzcGFjZSkgOiB0aGlzLm5zO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gYXMgb2YgXCJCdWlsZGVyXCJcclxuICAgICAgICAgKiBAZXhwb3NlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlclByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJCdWlsZGVyXCI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gLS0tLS0gQmFzZSBjbGFzc2VzIC0tLS0tXHJcbiAgICAgICAgLy8gRXhpc3QgZm9yIHRoZSBzb2xlIHB1cnBvc2Ugb2YgYmVpbmcgYWJsZSB0byBcIi4uLiBpbnN0YW5jZW9mIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZVwiIGV0Yy5cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGFsaWFzIFByb3RvQnVmLkJ1aWxkZXIuTWVzc2FnZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1aWxkZXIuTWVzc2FnZSA9IGZ1bmN0aW9uKCkge307XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBhbGlhcyBQcm90b0J1Zi5CdWlsZGVyLkVudW1cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdWlsZGVyLkVudW0gPSBmdW5jdGlvbigpIHt9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAYWxpYXMgUHJvdG9CdWYuQnVpbGRlci5NZXNzYWdlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnVpbGRlci5TZXJ2aWNlID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcbiAgICAgICAgcmV0dXJuIEJ1aWxkZXI7XHJcblxyXG4gICAgfSkoUHJvdG9CdWYsIFByb3RvQnVmLkxhbmcsIFByb3RvQnVmLlJlZmxlY3QpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGFsaWFzIFByb3RvQnVmLk1hcFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5NYXAgPSAoZnVuY3Rpb24oUHJvdG9CdWYsIFJlZmxlY3QpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBNYXAuIEEgTWFwIGlzIGEgY29udGFpbmVyIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgbWFwXHJcbiAgICAgICAgICogZmllbGRzIG9uIG1lc3NhZ2Ugb2JqZWN0cy4gSXQgY2xvc2VseSBmb2xsb3dzIHRoZSBFUzYgTWFwIEFQSTsgaG93ZXZlcixcclxuICAgICAgICAgKiBpdCBpcyBkaXN0aW5jdCBiZWNhdXNlIHdlIGRvIG5vdCB3YW50IHRvIGRlcGVuZCBvbiBleHRlcm5hbCBwb2x5ZmlsbHMgb3JcclxuICAgICAgICAgKiBvbiBFUzYgaXRzZWxmLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4cG9ydHMgUHJvdG9CdWYuTWFwXHJcbiAgICAgICAgICogQHBhcmFtIHshUHJvdG9CdWYuUmVmbGVjdC5GaWVsZH0gZmllbGQgTWFwIGZpZWxkXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPj19IGNvbnRlbnRzIEluaXRpYWwgY29udGVudHNcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgTWFwID0gZnVuY3Rpb24oZmllbGQsIGNvbnRlbnRzKSB7XHJcbiAgICAgICAgICAgIGlmICghZmllbGQubWFwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJmaWVsZCBpcyBub3QgYSBtYXBcIik7XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGZpZWxkIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBtYXAuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuUmVmbGVjdC5GaWVsZH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFbGVtZW50IGluc3RhbmNlIGNvcnJlc3BvbmRpbmcgdG8ga2V5IHR5cGUuXHJcbiAgICAgICAgICAgICAqIEB0eXBlIHshUHJvdG9CdWYuUmVmbGVjdC5FbGVtZW50fVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5rZXlFbGVtID0gbmV3IFJlZmxlY3QuRWxlbWVudChmaWVsZC5rZXlUeXBlLCBudWxsLCB0cnVlLCBmaWVsZC5zeW50YXgpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEVsZW1lbnQgaW5zdGFuY2UgY29ycmVzcG9uZGluZyB0byB2YWx1ZSB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IVByb3RvQnVmLlJlZmxlY3QuRWxlbWVudH1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVFbGVtID0gbmV3IFJlZmxlY3QuRWxlbWVudChmaWVsZC50eXBlLCBmaWVsZC5yZXNvbHZlZFR5cGUsIGZhbHNlLCBmaWVsZC5zeW50YXgpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEludGVybmFsIG1hcDogc3RvcmVzIG1hcHBpbmcgb2YgKHN0cmluZyBmb3JtIG9mIGtleSkgLT4gKGtleSwgdmFsdWUpXHJcbiAgICAgICAgICAgICAqIHBhaXIuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIFdlIHByb3ZpZGUgbWFwIHNlbWFudGljcyBmb3IgYXJiaXRyYXJ5IGtleSB0eXBlcywgYnV0IHdlIGJ1aWxkIG9uIHRvcFxyXG4gICAgICAgICAgICAgKiBvZiBhbiBPYmplY3QsIHdoaWNoIGhhcyBvbmx5IHN0cmluZyBrZXlzLiBJbiBvcmRlciB0byBhdm9pZCB0aGUgbmVlZFxyXG4gICAgICAgICAgICAgKiB0byBjb252ZXJ0IGEgc3RyaW5nIGtleSBiYWNrIHRvIGl0cyBuYXRpdmUgdHlwZSBpbiBtYW55IHNpdHVhdGlvbnMsXHJcbiAgICAgICAgICAgICAqIHdlIHN0b3JlIHRoZSBuYXRpdmUga2V5IHZhbHVlIGFsb25nc2lkZSB0aGUgdmFsdWUuIFRodXMsIHdlIG9ubHkgbmVlZFxyXG4gICAgICAgICAgICAgKiBhIG9uZS13YXkgbWFwcGluZyBmcm9tIGEga2V5IHR5cGUgdG8gaXRzIHN0cmluZyBmb3JtIHRoYXQgZ3VhcmFudGVlc1xyXG4gICAgICAgICAgICAgKiB1bmlxdWVuZXNzIGFuZCBlcXVhbGl0eSAoaS5lLiwgc3RyKEsxKSA9PT0gc3RyKEsyKSBpZiBhbmQgb25seSBpZiBLMVxyXG4gICAgICAgICAgICAgKiA9PT0gSzIpLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIHtrZXk6ICosIHZhbHVlOiAqfT59XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLm1hcCA9IHt9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgbWFwLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gT2JqZWN0LmtleXModGhpcy5tYXApLmxlbmd0aDsgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpbGwgaW5pdGlhbCBjb250ZW50cyBmcm9tIGEgcmF3IG9iamVjdC5cclxuICAgICAgICAgICAgaWYgKGNvbnRlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbnRlbnRzKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLmtleUVsZW0udmFsdWVGcm9tU3RyaW5nKGtleXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSB0aGlzLnZhbHVlRWxlbS52ZXJpZnlWYWx1ZShjb250ZW50c1trZXlzW2ldXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBbdGhpcy5rZXlFbGVtLnZhbHVlVG9TdHJpbmcoa2V5KV0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGtleToga2V5LCB2YWx1ZTogdmFsIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgTWFwUHJvdG90eXBlID0gTWFwLnByb3RvdHlwZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGVscGVyOiByZXR1cm4gYW4gaXRlcmF0b3Igb3ZlciBhbiBhcnJheS5cclxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyIHRoZSBhcnJheVxyXG4gICAgICAgICAqIEByZXR1cm5zIHshT2JqZWN0fSBhbiBpdGVyYXRvclxyXG4gICAgICAgICAqIEBpbm5lclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGFycmF5SXRlcmF0b3IoYXJyKSB7XHJcbiAgICAgICAgICAgIHZhciBpZHggPSAwO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IGFyci5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogYXJyW2lkeCsrXSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYXJzIHRoZSBtYXAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTWFwUHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFwID0ge307XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsZXRlcyBhIHBhcnRpY3VsYXIga2V5IGZyb20gdGhlIG1hcC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBhbnkgZW50cnkgd2l0aCB0aGlzIGtleSB3YXMgZGVsZXRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBNYXBQcm90b3R5cGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGtleVZhbHVlID0gdGhpcy5rZXlFbGVtLnZhbHVlVG9TdHJpbmcodGhpcy5rZXlFbGVtLnZlcmlmeVZhbHVlKGtleSkpO1xyXG4gICAgICAgICAgICB2YXIgaGFkS2V5ID0ga2V5VmFsdWUgaW4gdGhpcy5tYXA7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1hcFtrZXlWYWx1ZV07XHJcbiAgICAgICAgICAgIHJldHVybiBoYWRLZXk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIFtrZXksIHZhbHVlXSBwYWlycyBpbiB0aGUgbWFwLlxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBpdGVyYXRvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1hcFByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBzdHJLZXlzID0gT2JqZWN0LmtleXModGhpcy5tYXApO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZW50cnk7IGkgPCBzdHJLZXlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgZW50cmllcy5wdXNoKFsoZW50cnk9dGhpcy5tYXBbc3RyS2V5c1tpXV0pLmtleSwgZW50cnkudmFsdWVdKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5SXRlcmF0b3IoZW50cmllcyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIGtleXMgaW4gdGhlIG1hcC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgaXRlcmF0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICBNYXBQcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgc3RyS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubWFwKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJLZXlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKHRoaXMubWFwW3N0cktleXNbaV1dLmtleSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheUl0ZXJhdG9yKGtleXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciB2YWx1ZXMgaW4gdGhlIG1hcC5cclxuICAgICAgICAgKiBAcmV0dXJucyB7IU9iamVjdH0gVGhlIGl0ZXJhdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTWFwUHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICAgICAgICAgIHZhciBzdHJLZXlzID0gT2JqZWN0LmtleXModGhpcy5tYXApO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cktleXMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLm1hcFtzdHJLZXlzW2ldXS52YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheUl0ZXJhdG9yKHZhbHVlcyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSXRlcmF0ZXMgb3ZlciBlbnRyaWVzIGluIHRoZSBtYXAsIGNhbGxpbmcgYSBmdW5jdGlvbiBvbiBlYWNoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczoqLCAqLCAqLCAqKX0gY2IgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIHZhbHVlLCBrZXksIGFuZCBtYXAgYXJndW1lbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gdGhpc0FyZyBUaGUgYHRoaXNgIHZhbHVlIGZvciB0aGUgY2FsbGJhY2tcclxuICAgICAgICAgKi9cclxuICAgICAgICBNYXBQcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNiLCB0aGlzQXJnKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHJLZXlzID0gT2JqZWN0LmtleXModGhpcy5tYXApO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZW50cnk7IGkgPCBzdHJLZXlzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgY2IuY2FsbCh0aGlzQXJnLCAoZW50cnk9dGhpcy5tYXBbc3RyS2V5c1tpXV0pLnZhbHVlLCBlbnRyeS5rZXksIHRoaXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgYSBrZXkgaW4gdGhlIG1hcCB0byB0aGUgZ2l2ZW4gdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleVxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMgeyFQcm90b0J1Zi5NYXB9IFRoZSBtYXAgaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBNYXBQcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIga2V5VmFsdWUgPSB0aGlzLmtleUVsZW0udmVyaWZ5VmFsdWUoa2V5KTtcclxuICAgICAgICAgICAgdmFyIHZhbFZhbHVlID0gdGhpcy52YWx1ZUVsZW0udmVyaWZ5VmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcFt0aGlzLmtleUVsZW0udmFsdWVUb1N0cmluZyhrZXlWYWx1ZSldID1cclxuICAgICAgICAgICAgICAgIHsga2V5OiBrZXlWYWx1ZSwgdmFsdWU6IHZhbFZhbHVlIH07XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gYSBrZXkgaW4gdGhlIG1hcC5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5XHJcbiAgICAgICAgICogQHJldHVybnMgeyp8dW5kZWZpbmVkfSBUaGUgdmFsdWUsIG9yIGB1bmRlZmluZWRgIGlmIGtleSBub3QgcHJlc2VudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1hcFByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGtleVZhbHVlID0gdGhpcy5rZXlFbGVtLnZhbHVlVG9TdHJpbmcodGhpcy5rZXlFbGVtLnZlcmlmeVZhbHVlKGtleSkpO1xyXG4gICAgICAgICAgICBpZiAoIShrZXlWYWx1ZSBpbiB0aGlzLm1hcCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBba2V5VmFsdWVdLnZhbHVlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4ga2V5IGlzIHByZXNlbnQgaW4gdGhlIG1hcC5cclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5XHJcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUga2V5IGlzIHByZXNlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICBNYXBQcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IHRoaXMua2V5RWxlbS52YWx1ZVRvU3RyaW5nKHRoaXMua2V5RWxlbS52ZXJpZnlWYWx1ZShrZXkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIChrZXlWYWx1ZSBpbiB0aGlzLm1hcCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hcDtcclxuICAgIH0pKFByb3RvQnVmLCBQcm90b0J1Zi5SZWZsZWN0KTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGVtcHR5IEJ1aWxkZXIuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+PX0gb3B0aW9ucyBCdWlsZGVyIG9wdGlvbnMsIGRlZmF1bHRzIHRvIGdsb2JhbCBvcHRpb25zIHNldCBvbiBQcm90b0J1ZlxyXG4gICAgICogQHJldHVybiB7IVByb3RvQnVmLkJ1aWxkZXJ9IEJ1aWxkZXJcclxuICAgICAqIEBleHBvc2VcclxuICAgICAqL1xyXG4gICAgUHJvdG9CdWYubmV3QnVpbGRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnNbJ2NvbnZlcnRGaWVsZHNUb0NhbWVsQ2FzZSddID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgb3B0aW9uc1snY29udmVydEZpZWxkc1RvQ2FtZWxDYXNlJ10gPSBQcm90b0J1Zi5jb252ZXJ0RmllbGRzVG9DYW1lbENhc2U7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zWydwb3B1bGF0ZUFjY2Vzc29ycyddID09PSAndW5kZWZpbmVkJylcclxuICAgICAgICAgICAgb3B0aW9uc1sncG9wdWxhdGVBY2Nlc3NvcnMnXSA9IFByb3RvQnVmLnBvcHVsYXRlQWNjZXNzb3JzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvdG9CdWYuQnVpbGRlcihvcHRpb25zKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhIC5qc29uIGRlZmluaXRpb24gYW5kIHJldHVybnMgdGhlIEJ1aWxkZXIuXHJcbiAgICAgKiBAcGFyYW0geyEqfHN0cmluZ30ganNvbiBKU09OIGRlZmluaXRpb25cclxuICAgICAqIEBwYXJhbSB7KFByb3RvQnVmLkJ1aWxkZXJ8c3RyaW5nfHtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ30pPX0gYnVpbGRlciBCdWlsZGVyIHRvIGFwcGVuZCB0by4gV2lsbCBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXHJcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8e3Jvb3Q6IHN0cmluZywgZmlsZTogc3RyaW5nfSk9fSBmaWxlbmFtZSBUaGUgY29ycmVzcG9uZGluZyBmaWxlIG5hbWUgaWYga25vd24uIE11c3QgYmUgc3BlY2lmaWVkIGZvciBpbXBvcnRzLlxyXG4gICAgICogQHJldHVybiB7UHJvdG9CdWYuQnVpbGRlcn0gQnVpbGRlciB0byBjcmVhdGUgbmV3IG1lc3NhZ2VzXHJcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRlZmluaXRpb24gY2Fubm90IGJlIHBhcnNlZCBvciBidWlsdFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5sb2FkSnNvbiA9IGZ1bmN0aW9uKGpzb24sIGJ1aWxkZXIsIGZpbGVuYW1lKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBidWlsZGVyID09PSAnc3RyaW5nJyB8fCAoYnVpbGRlciAmJiB0eXBlb2YgYnVpbGRlcltcImZpbGVcIl0gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBidWlsZGVyW1wicm9vdFwiXSA9PT0gJ3N0cmluZycpKVxyXG4gICAgICAgICAgICBmaWxlbmFtZSA9IGJ1aWxkZXIsIGJ1aWxkZXIgPSBudWxsO1xyXG4gICAgICAgIGlmICghYnVpbGRlciB8fCB0eXBlb2YgYnVpbGRlciAhPT0gJ29iamVjdCcpXHJcbiAgICAgICAgICAgIGJ1aWxkZXIgPSBQcm90b0J1Zi5uZXdCdWlsZGVyKCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uID09PSAnc3RyaW5nJylcclxuICAgICAgICAgICAganNvbiA9IEpTT04ucGFyc2UoanNvbik7XHJcbiAgICAgICAgYnVpbGRlcltcImltcG9ydFwiXShqc29uLCBmaWxlbmFtZSk7XHJcbiAgICAgICAgYnVpbGRlci5yZXNvbHZlQWxsKCk7XHJcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSAuanNvbiBmaWxlIGFuZCByZXR1cm5zIHRoZSBCdWlsZGVyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8IXtyb290OiBzdHJpbmcsIGZpbGU6IHN0cmluZ319IGZpbGVuYW1lIFBhdGggdG8ganNvbiBmaWxlIG9yIGFuIG9iamVjdCBzcGVjaWZ5aW5nICdmaWxlJyB3aXRoXHJcbiAgICAgKiAgYW4gb3ZlcnJpZGRlbiAncm9vdCcgcGF0aCBmb3IgYWxsIGltcG9ydGVkIGZpbGVzLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IsICFQcm90b0J1Zi5CdWlsZGVyPSk9fSBjYWxsYmFjayBDYWxsYmFjayB0aGF0IHdpbGwgcmVjZWl2ZSBgbnVsbGAgYXMgdGhlIGZpcnN0IGFuZFxyXG4gICAgICogIHRoZSBCdWlsZGVyIGFzIGl0cyBzZWNvbmQgYXJndW1lbnQgb24gc3VjY2Vzcywgb3RoZXJ3aXNlIHRoZSBlcnJvciBhcyBpdHMgZmlyc3QgYXJndW1lbnQuIElmIG9taXR0ZWQsIHRoZVxyXG4gICAgICogIGZpbGUgd2lsbCBiZSByZWFkIHN5bmNocm9ub3VzbHkgYW5kIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIEJ1aWxkZXIuXHJcbiAgICAgKiBAcGFyYW0ge1Byb3RvQnVmLkJ1aWxkZXI9fSBidWlsZGVyIEJ1aWxkZXIgdG8gYXBwZW5kIHRvLiBXaWxsIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cclxuICAgICAqIEByZXR1cm4gez9Qcm90b0J1Zi5CdWlsZGVyfHVuZGVmaW5lZH0gVGhlIEJ1aWxkZXIgaWYgc3luY2hyb25vdXMgKG5vIGNhbGxiYWNrIHNwZWNpZmllZCwgd2lsbCBiZSBOVUxMIGlmIHRoZVxyXG4gICAgICogICByZXF1ZXN0IGhhcyBmYWlsZWQpLCBlbHNlIHVuZGVmaW5lZFxyXG4gICAgICogQGV4cG9zZVxyXG4gICAgICovXHJcbiAgICBQcm90b0J1Zi5sb2FkSnNvbkZpbGUgPSBmdW5jdGlvbihmaWxlbmFtZSwgY2FsbGJhY2ssIGJ1aWxkZXIpIHtcclxuICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrID09PSAnb2JqZWN0JylcclxuICAgICAgICAgICAgYnVpbGRlciA9IGNhbGxiYWNrLCBjYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgZWxzZSBpZiAoIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgIGlmIChjYWxsYmFjaylcclxuICAgICAgICAgICAgcmV0dXJuIFByb3RvQnVmLlV0aWwuZmV0Y2godHlwZW9mIGZpbGVuYW1lID09PSAnc3RyaW5nJyA/IGZpbGVuYW1lIDogZmlsZW5hbWVbXCJyb290XCJdK1wiL1wiK2ZpbGVuYW1lW1wiZmlsZVwiXSwgZnVuY3Rpb24oY29udGVudHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50cyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIGZpbGVcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgUHJvdG9CdWYubG9hZEpzb24oSlNPTi5wYXJzZShjb250ZW50cyksIGJ1aWxkZXIsIGZpbGVuYW1lKSk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBjb250ZW50cyA9IFByb3RvQnVmLlV0aWwuZmV0Y2godHlwZW9mIGZpbGVuYW1lID09PSAnb2JqZWN0JyA/IGZpbGVuYW1lW1wicm9vdFwiXStcIi9cIitmaWxlbmFtZVtcImZpbGVcIl0gOiBmaWxlbmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRlbnRzID09PSBudWxsID8gbnVsbCA6IFByb3RvQnVmLmxvYWRKc29uKEpTT04ucGFyc2UoY29udGVudHMpLCBidWlsZGVyLCBmaWxlbmFtZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBQcm90b0J1ZjtcclxufSk7XG59KTtcblxudmFyIG1lc3NhZ2VDb21waWxlZCA9IHByb3RvYnVmTGlnaHQubmV3QnVpbGRlcih7fSlbJ2ltcG9ydCddKHtcbiAgICBcInBhY2thZ2VcIjogXCJwdXNoX3NlcnZlci5tZXNzYWdlczJcIixcbiAgICBcInN5bnRheFwiOiBcInByb3RvMlwiLFxuICAgIFwib3B0aW9uc1wiOiB7XG4gICAgICAgIFwib2JqY19jbGFzc19wcmVmaXhcIjogXCJBVklNXCJcbiAgICB9LFxuICAgIFwibWVzc2FnZXNcIjogW3tcbiAgICAgICAgXCJuYW1lXCI6IFwiSnNvbk9iamVjdE1lc3NhZ2VcIixcbiAgICAgICAgXCJzeW50YXhcIjogXCJwcm90bzJcIixcbiAgICAgICAgXCJmaWVsZHNcIjogW3tcbiAgICAgICAgICAgIFwicnVsZVwiOiBcInJlcXVpcmVkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImRhdGFcIixcbiAgICAgICAgICAgIFwiaWRcIjogMVxuICAgICAgICB9XVxuICAgIH0sIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiVW5yZWFkVHVwbGVcIixcbiAgICAgICAgXCJzeW50YXhcIjogXCJwcm90bzJcIixcbiAgICAgICAgXCJmaWVsZHNcIjogW3tcbiAgICAgICAgICAgIFwicnVsZVwiOiBcInJlcXVpcmVkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImNpZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcInJlcXVpcmVkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQzMlwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwidW5yZWFkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWlkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDNcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDY0XCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ0aW1lc3RhbXBcIixcbiAgICAgICAgICAgIFwiaWRcIjogNFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJmcm9tXCIsXG4gICAgICAgICAgICBcImlkXCI6IDVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGF0YVwiLFxuICAgICAgICAgICAgXCJpZFwiOiA2XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwicGF0Y2hUaW1lc3RhbXBcIixcbiAgICAgICAgICAgIFwiaWRcIjogN1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWVudGlvbmVkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDhcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJiaW5hcnlNc2dcIixcbiAgICAgICAgICAgIFwiaWRcIjogOVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50MzJcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImNvbnZUeXBlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEwXG4gICAgICAgIH1dXG4gICAgfSwge1xuICAgICAgICBcIm5hbWVcIjogXCJMb2dJdGVtXCIsXG4gICAgICAgIFwic3ludGF4XCI6IFwicHJvdG8yXCIsXG4gICAgICAgIFwiZmllbGRzXCI6IFt7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJmcm9tXCIsXG4gICAgICAgICAgICBcImlkXCI6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGF0YVwiLFxuICAgICAgICAgICAgXCJpZFwiOiAyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwidGltZXN0YW1wXCIsXG4gICAgICAgICAgICBcImlkXCI6IDNcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibXNnSWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogNFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50NjRcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImFja0F0XCIsXG4gICAgICAgICAgICBcImlkXCI6IDVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDY0XCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJyZWFkQXRcIixcbiAgICAgICAgICAgIFwiaWRcIjogNlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50NjRcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInBhdGNoVGltZXN0YW1wXCIsXG4gICAgICAgICAgICBcImlkXCI6IDdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm1lbnRpb25BbGxcIixcbiAgICAgICAgICAgIFwiaWRcIjogOFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJyZXBlYXRlZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJtZW50aW9uUGlkc1wiLFxuICAgICAgICAgICAgXCJpZFwiOiA5XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJiaW5cIixcbiAgICAgICAgICAgIFwiaWRcIjogMTBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDMyXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjb252VHlwZVwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxMVxuICAgICAgICB9XVxuICAgIH0sIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiQ29udk1lbWJlckluZm9cIixcbiAgICAgICAgXCJzeW50YXhcIjogXCJwcm90bzJcIixcbiAgICAgICAgXCJmaWVsZHNcIjogW3tcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInBpZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInJvbGVcIixcbiAgICAgICAgICAgIFwiaWRcIjogMlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJpbmZvSWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogM1xuICAgICAgICB9XVxuICAgIH0sIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiRGF0YUNvbW1hbmRcIixcbiAgICAgICAgXCJzeW50YXhcIjogXCJwcm90bzJcIixcbiAgICAgICAgXCJmaWVsZHNcIjogW3tcbiAgICAgICAgICAgIFwicnVsZVwiOiBcInJlcGVhdGVkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImlkc1wiLFxuICAgICAgICAgICAgXCJpZFwiOiAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcInJlcGVhdGVkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJKc29uT2JqZWN0TWVzc2FnZVwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibXNnXCIsXG4gICAgICAgICAgICBcImlkXCI6IDJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm9mZmxpbmVcIixcbiAgICAgICAgICAgIFwiaWRcIjogM1xuICAgICAgICB9XVxuICAgIH0sIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiU2Vzc2lvbkNvbW1hbmRcIixcbiAgICAgICAgXCJzeW50YXhcIjogXCJwcm90bzJcIixcbiAgICAgICAgXCJmaWVsZHNcIjogW3tcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwidFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm5cIixcbiAgICAgICAgICAgIFwiaWRcIjogMlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJzXCIsXG4gICAgICAgICAgICBcImlkXCI6IDNcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwidWFcIixcbiAgICAgICAgICAgIFwiaWRcIjogNFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiclwiLFxuICAgICAgICAgICAgXCJpZFwiOiA1XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInRhZ1wiLFxuICAgICAgICAgICAgXCJpZFwiOiA2XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImRldmljZUlkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwic2Vzc2lvblBlZXJJZHNcIixcbiAgICAgICAgICAgIFwiaWRcIjogOFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJyZXBlYXRlZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJvbmxpbmVTZXNzaW9uUGVlcklkc1wiLFxuICAgICAgICAgICAgXCJpZFwiOiA5XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInN0XCIsXG4gICAgICAgICAgICBcImlkXCI6IDEwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQzMlwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwic3RUdGxcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDMyXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjb2RlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInJlYXNvblwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxM1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJkZXZpY2VUb2tlblwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxNFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwic3BcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGV0YWlsXCIsXG4gICAgICAgICAgICBcImlkXCI6IDE2XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibGFzdFVucmVhZE5vdGlmVGltZVwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxN1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50NjRcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImxhc3RQYXRjaFRpbWVcIixcbiAgICAgICAgICAgIFwiaWRcIjogMThcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDY0XCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjb25maWdCaXRtYXBcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTlcbiAgICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAgIFwibmFtZVwiOiBcIkVycm9yQ29tbWFuZFwiLFxuICAgICAgICBcInN5bnRheFwiOiBcInByb3RvMlwiLFxuICAgICAgICBcImZpZWxkc1wiOiBbe1xuICAgICAgICAgICAgXCJydWxlXCI6IFwicmVxdWlyZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDMyXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjb2RlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwicmVxdWlyZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwicmVhc29uXCIsXG4gICAgICAgICAgICBcImlkXCI6IDJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDMyXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJhcHBDb2RlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDNcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGV0YWlsXCIsXG4gICAgICAgICAgICBcImlkXCI6IDRcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwicGlkc1wiLFxuICAgICAgICAgICAgXCJpZFwiOiA1XG4gICAgICAgIH1dXG4gICAgfSwge1xuICAgICAgICBcIm5hbWVcIjogXCJEaXJlY3RDb21tYW5kXCIsXG4gICAgICAgIFwic3ludGF4XCI6IFwicHJvdG8yXCIsXG4gICAgICAgIFwiZmllbGRzXCI6IFt7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJtc2dcIixcbiAgICAgICAgICAgIFwiaWRcIjogMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ1aWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJmcm9tUGVlcklkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDNcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDY0XCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ0aW1lc3RhbXBcIixcbiAgICAgICAgICAgIFwiaWRcIjogNFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwib2ZmbGluZVwiLFxuICAgICAgICAgICAgXCJpZFwiOiA1XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJoYXNNb3JlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDZcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwidG9QZWVySWRzXCIsXG4gICAgICAgICAgICBcImlkXCI6IDdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInJcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2lkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDExXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImlkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ0cmFuc2llbnRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTNcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiZHRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTRcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwicm9vbUlkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDE1XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInB1c2hEYXRhXCIsXG4gICAgICAgICAgICBcImlkXCI6IDE2XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ3aWxsXCIsXG4gICAgICAgICAgICBcImlkXCI6IDE3XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwicGF0Y2hUaW1lc3RhbXBcIixcbiAgICAgICAgICAgIFwiaWRcIjogMThcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJ5dGVzXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJiaW5hcnlNc2dcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTlcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWVudGlvblBpZHNcIixcbiAgICAgICAgICAgIFwiaWRcIjogMjBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm1lbnRpb25BbGxcIixcbiAgICAgICAgICAgIFwiaWRcIjogMjFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDMyXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjb252VHlwZVwiLFxuICAgICAgICAgICAgXCJpZFwiOiAyMlxuICAgICAgICB9XVxuICAgIH0sIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiQWNrQ29tbWFuZFwiLFxuICAgICAgICBcInN5bnRheFwiOiBcInByb3RvMlwiLFxuICAgICAgICBcImZpZWxkc1wiOiBbe1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDMyXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjb2RlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwicmVhc29uXCIsXG4gICAgICAgICAgICBcImlkXCI6IDJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWlkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDNcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2lkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDRcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDY0XCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ0XCIsXG4gICAgICAgICAgICBcImlkXCI6IDVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwidWlkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDZcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDY0XCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJmcm9tdHNcIixcbiAgICAgICAgICAgIFwiaWRcIjogN1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50NjRcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInRvdHNcIixcbiAgICAgICAgICAgIFwiaWRcIjogOFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ0eXBlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDlcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiaWRzXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQzMlwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiYXBwQ29kZVwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxMVxuICAgICAgICB9XVxuICAgIH0sIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiVW5yZWFkQ29tbWFuZFwiLFxuICAgICAgICBcInN5bnRheFwiOiBcInByb3RvMlwiLFxuICAgICAgICBcImZpZWxkc1wiOiBbe1xuICAgICAgICAgICAgXCJydWxlXCI6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIlVucmVhZFR1cGxlXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjb252c1wiLFxuICAgICAgICAgICAgXCJpZFwiOiAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibm90aWZUaW1lXCIsXG4gICAgICAgICAgICBcImlkXCI6IDJcbiAgICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAgIFwibmFtZVwiOiBcIkNvbnZDb21tYW5kXCIsXG4gICAgICAgIFwic3ludGF4XCI6IFwicHJvdG8yXCIsXG4gICAgICAgIFwiZmllbGRzXCI6IFt7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJyZXBlYXRlZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJtXCIsXG4gICAgICAgICAgICBcImlkXCI6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInRyYW5zaWVudFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ1bmlxdWVcIixcbiAgICAgICAgICAgIFwiaWRcIjogM1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjaWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogNFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjZGF0ZVwiLFxuICAgICAgICAgICAgXCJpZFwiOiA1XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImluaXRCeVwiLFxuICAgICAgICAgICAgXCJpZFwiOiA2XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInNvcnRcIixcbiAgICAgICAgICAgIFwiaWRcIjogN1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50MzJcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImxpbWl0XCIsXG4gICAgICAgICAgICBcImlkXCI6IDhcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDMyXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJza2lwXCIsXG4gICAgICAgICAgICBcImlkXCI6IDlcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDMyXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJmbGFnXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQzMlwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY291bnRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwidWRhdGVcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDY0XCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ0XCIsXG4gICAgICAgICAgICBcImlkXCI6IDEzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm5cIixcbiAgICAgICAgICAgIFwiaWRcIjogMTRcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwic1wiLFxuICAgICAgICAgICAgXCJpZFwiOiAxNVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwic3RhdHVzU3ViXCIsXG4gICAgICAgICAgICBcImlkXCI6IDE2XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJzdGF0dXNQdWJcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDMyXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJzdGF0dXNUVExcIixcbiAgICAgICAgICAgIFwiaWRcIjogMThcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwidW5pcXVlSWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTlcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwidGFyZ2V0Q2xpZW50SWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMjBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDY0XCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJtYXhSZWFkVGltZXN0YW1wXCIsXG4gICAgICAgICAgICBcImlkXCI6IDIxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWF4QWNrVGltZXN0YW1wXCIsXG4gICAgICAgICAgICBcImlkXCI6IDIyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJxdWVyeUFsbE1lbWJlcnNcIixcbiAgICAgICAgICAgIFwiaWRcIjogMjNcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIk1heFJlYWRUdXBsZVwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWF4UmVhZFR1cGxlc1wiLFxuICAgICAgICAgICAgXCJpZFwiOiAyNFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJyZXBlYXRlZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjaWRzXCIsXG4gICAgICAgICAgICBcImlkXCI6IDI1XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJDb252TWVtYmVySW5mb1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiaW5mb1wiLFxuICAgICAgICAgICAgXCJpZFwiOiAyNlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwidGVtcENvbnZcIixcbiAgICAgICAgICAgIFwiaWRcIjogMjdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDMyXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ0ZW1wQ29udlRUTFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAyOFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJyZXBlYXRlZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ0ZW1wQ29udklkc1wiLFxuICAgICAgICAgICAgXCJpZFwiOiAyOVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJyZXBlYXRlZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJhbGxvd2VkUGlkc1wiLFxuICAgICAgICAgICAgXCJpZFwiOiAzMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJyZXBlYXRlZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiRXJyb3JDb21tYW5kXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJmYWlsZWRQaWRzXCIsXG4gICAgICAgICAgICBcImlkXCI6IDMxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm5leHRcIixcbiAgICAgICAgICAgIFwiaWRcIjogNDBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIkpzb25PYmplY3RNZXNzYWdlXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJyZXN1bHRzXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEwMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiSnNvbk9iamVjdE1lc3NhZ2VcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIndoZXJlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEwMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiSnNvbk9iamVjdE1lc3NhZ2VcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImF0dHJcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTAzXG4gICAgICAgIH1dXG4gICAgfSwge1xuICAgICAgICBcIm5hbWVcIjogXCJSb29tQ29tbWFuZFwiLFxuICAgICAgICBcInN5bnRheFwiOiBcInByb3RvMlwiLFxuICAgICAgICBcImZpZWxkc1wiOiBbe1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwicm9vbUlkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwic1wiLFxuICAgICAgICAgICAgXCJpZFwiOiAyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwidFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm5cIixcbiAgICAgICAgICAgIFwiaWRcIjogNFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwidHJhbnNpZW50XCIsXG4gICAgICAgICAgICBcImlkXCI6IDVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwicm9vbVBlZXJJZHNcIixcbiAgICAgICAgICAgIFwiaWRcIjogNlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJieVBlZXJJZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiA3XG4gICAgICAgIH1dXG4gICAgfSwge1xuICAgICAgICBcIm5hbWVcIjogXCJMb2dzQ29tbWFuZFwiLFxuICAgICAgICBcInN5bnRheFwiOiBcInByb3RvMlwiLFxuICAgICAgICBcImZpZWxkc1wiOiBbe1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2lkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDMyXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJsXCIsXG4gICAgICAgICAgICBcImlkXCI6IDJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDMyXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJsaW1pdFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwidFwiLFxuICAgICAgICAgICAgXCJpZFwiOiA0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwidHRcIixcbiAgICAgICAgICAgIFwiaWRcIjogNVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ0bWlkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDZcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWlkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2hlY2tzdW1cIixcbiAgICAgICAgICAgIFwiaWRcIjogOFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwic3RvcmVkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDlcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIlF1ZXJ5RGlyZWN0aW9uXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJkaXJlY3Rpb25cIixcbiAgICAgICAgICAgIFwiaWRcIjogMTAsXG4gICAgICAgICAgICBcIm9wdGlvbnNcIjoge1xuICAgICAgICAgICAgICAgIFwiZGVmYXVsdFwiOiBcIk9MRFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ0SW5jbHVkZWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInR0SW5jbHVkZWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDMyXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJsY3R5cGVcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTNcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIkxvZ0l0ZW1cIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImxvZ3NcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTA1XG4gICAgICAgIH1dLFxuICAgICAgICBcImVudW1zXCI6IFt7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJRdWVyeURpcmVjdGlvblwiLFxuICAgICAgICAgICAgXCJzeW50YXhcIjogXCJwcm90bzJcIixcbiAgICAgICAgICAgIFwidmFsdWVzXCI6IFt7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiT0xEXCIsXG4gICAgICAgICAgICAgICAgXCJpZFwiOiAxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiTkVXXCIsXG4gICAgICAgICAgICAgICAgXCJpZFwiOiAyXG4gICAgICAgICAgICB9XVxuICAgICAgICB9XVxuICAgIH0sIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiUmNwQ29tbWFuZFwiLFxuICAgICAgICBcInN5bnRheFwiOiBcInByb3RvMlwiLFxuICAgICAgICBcImZpZWxkc1wiOiBbe1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiaWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjaWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50NjRcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInRcIixcbiAgICAgICAgICAgIFwiaWRcIjogM1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwicmVhZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiA0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImZyb21cIixcbiAgICAgICAgICAgIFwiaWRcIjogNVxuICAgICAgICB9XVxuICAgIH0sIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiUmVhZFR1cGxlXCIsXG4gICAgICAgIFwic3ludGF4XCI6IFwicHJvdG8yXCIsXG4gICAgICAgIFwiZmllbGRzXCI6IFt7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJyZXF1aXJlZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjaWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50NjRcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInRpbWVzdGFtcFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm1pZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAzXG4gICAgICAgIH1dXG4gICAgfSwge1xuICAgICAgICBcIm5hbWVcIjogXCJNYXhSZWFkVHVwbGVcIixcbiAgICAgICAgXCJzeW50YXhcIjogXCJwcm90bzJcIixcbiAgICAgICAgXCJmaWVsZHNcIjogW3tcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInBpZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWF4QWNrVGltZXN0YW1wXCIsXG4gICAgICAgICAgICBcImlkXCI6IDJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDY0XCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJtYXhSZWFkVGltZXN0YW1wXCIsXG4gICAgICAgICAgICBcImlkXCI6IDNcbiAgICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAgIFwibmFtZVwiOiBcIlJlYWRDb21tYW5kXCIsXG4gICAgICAgIFwic3ludGF4XCI6IFwicHJvdG8yXCIsXG4gICAgICAgIFwiZmllbGRzXCI6IFt7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjaWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJyZXBlYXRlZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjaWRzXCIsXG4gICAgICAgICAgICBcImlkXCI6IDJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIlJlYWRUdXBsZVwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY29udnNcIixcbiAgICAgICAgICAgIFwiaWRcIjogM1xuICAgICAgICB9XVxuICAgIH0sIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiUHJlc2VuY2VDb21tYW5kXCIsXG4gICAgICAgIFwic3ludGF4XCI6IFwicHJvdG8yXCIsXG4gICAgICAgIFwiZmllbGRzXCI6IFt7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiU3RhdHVzVHlwZVwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwic3RhdHVzXCIsXG4gICAgICAgICAgICBcImlkXCI6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwic2Vzc2lvblBlZXJJZHNcIixcbiAgICAgICAgICAgIFwiaWRcIjogMlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjaWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogM1xuICAgICAgICB9XVxuICAgIH0sIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiUmVwb3J0Q29tbWFuZFwiLFxuICAgICAgICBcInN5bnRheFwiOiBcInByb3RvMlwiLFxuICAgICAgICBcImZpZWxkc1wiOiBbe1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImluaXRpYXRpdmVcIixcbiAgICAgICAgICAgIFwiaWRcIjogMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ0eXBlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGF0YVwiLFxuICAgICAgICAgICAgXCJpZFwiOiAzXG4gICAgICAgIH1dXG4gICAgfSwge1xuICAgICAgICBcIm5hbWVcIjogXCJQYXRjaEl0ZW1cIixcbiAgICAgICAgXCJzeW50YXhcIjogXCJwcm90bzJcIixcbiAgICAgICAgXCJmaWVsZHNcIjogW3tcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImNpZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm1pZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwidGltZXN0YW1wXCIsXG4gICAgICAgICAgICBcImlkXCI6IDNcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInJlY2FsbFwiLFxuICAgICAgICAgICAgXCJpZFwiOiA0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImRhdGFcIixcbiAgICAgICAgICAgIFwiaWRcIjogNVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiaW50NjRcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInBhdGNoVGltZXN0YW1wXCIsXG4gICAgICAgICAgICBcImlkXCI6IDZcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiZnJvbVwiLFxuICAgICAgICAgICAgXCJpZFwiOiA3XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJieXRlc1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiYmluYXJ5TXNnXCIsXG4gICAgICAgICAgICBcImlkXCI6IDhcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm1lbnRpb25BbGxcIixcbiAgICAgICAgICAgIFwiaWRcIjogOVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJyZXBlYXRlZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJtZW50aW9uUGlkc1wiLFxuICAgICAgICAgICAgXCJpZFwiOiAxMFxuICAgICAgICB9XVxuICAgIH0sIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiUGF0Y2hDb21tYW5kXCIsXG4gICAgICAgIFwic3ludGF4XCI6IFwicHJvdG8yXCIsXG4gICAgICAgIFwiZmllbGRzXCI6IFt7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJyZXBlYXRlZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiUGF0Y2hJdGVtXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJwYXRjaGVzXCIsXG4gICAgICAgICAgICBcImlkXCI6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDY0XCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJsYXN0UGF0Y2hUaW1lXCIsXG4gICAgICAgICAgICBcImlkXCI6IDJcbiAgICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAgIFwibmFtZVwiOiBcIlB1YnN1YkNvbW1hbmRcIixcbiAgICAgICAgXCJzeW50YXhcIjogXCJwcm90bzJcIixcbiAgICAgICAgXCJmaWVsZHNcIjogW3tcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImNpZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcInJlcGVhdGVkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImNpZHNcIixcbiAgICAgICAgICAgIFwiaWRcIjogMlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ0b3BpY1wiLFxuICAgICAgICAgICAgXCJpZFwiOiAzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInN1YnRvcGljXCIsXG4gICAgICAgICAgICBcImlkXCI6IDRcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwidG9waWNzXCIsXG4gICAgICAgICAgICBcImlkXCI6IDVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwic3VidG9waWNzXCIsXG4gICAgICAgICAgICBcImlkXCI6IDZcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIkpzb25PYmplY3RNZXNzYWdlXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJyZXN1bHRzXCIsXG4gICAgICAgICAgICBcImlkXCI6IDdcbiAgICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAgIFwibmFtZVwiOiBcIkJsYWNrbGlzdENvbW1hbmRcIixcbiAgICAgICAgXCJzeW50YXhcIjogXCJwcm90bzJcIixcbiAgICAgICAgXCJmaWVsZHNcIjogW3tcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInNyY0NpZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcInJlcGVhdGVkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInRvUGlkc1wiLFxuICAgICAgICAgICAgXCJpZFwiOiAyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInNyY1BpZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcInJlcGVhdGVkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInRvQ2lkc1wiLFxuICAgICAgICAgICAgXCJpZFwiOiA0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQzMlwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwibGltaXRcIixcbiAgICAgICAgICAgIFwiaWRcIjogNVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJuZXh0XCIsXG4gICAgICAgICAgICBcImlkXCI6IDZcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiYmxvY2tlZFBpZHNcIixcbiAgICAgICAgICAgIFwiaWRcIjogOFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJyZXBlYXRlZFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJibG9ja2VkQ2lkc1wiLFxuICAgICAgICAgICAgXCJpZFwiOiA5XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcInJlcGVhdGVkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImFsbG93ZWRQaWRzXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcInJlcGVhdGVkXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJFcnJvckNvbW1hbmRcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImZhaWxlZFBpZHNcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDY0XCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ0XCIsXG4gICAgICAgICAgICBcImlkXCI6IDEyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm5cIixcbiAgICAgICAgICAgIFwiaWRcIjogMTNcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwic1wiLFxuICAgICAgICAgICAgXCJpZFwiOiAxNFxuICAgICAgICB9XVxuICAgIH0sIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiR2VuZXJpY0NvbW1hbmRcIixcbiAgICAgICAgXCJzeW50YXhcIjogXCJwcm90bzJcIixcbiAgICAgICAgXCJmaWVsZHNcIjogW3tcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJDb21tYW5kVHlwZVwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY21kXCIsXG4gICAgICAgICAgICBcImlkXCI6IDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIk9wVHlwZVwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwib3BcIixcbiAgICAgICAgICAgIFwiaWRcIjogMlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJhcHBJZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInBlZXJJZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiA0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQzMlwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiaVwiLFxuICAgICAgICAgICAgXCJpZFwiOiA1XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImluc3RhbGxhdGlvbklkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDZcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludDMyXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJwcmlvcml0eVwiLFxuICAgICAgICAgICAgXCJpZFwiOiA3XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQzMlwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwic2VydmljZVwiLFxuICAgICAgICAgICAgXCJpZFwiOiA4XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwic2VydmVyVHNcIixcbiAgICAgICAgICAgIFwiaWRcIjogOVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiRGF0YUNvbW1hbmRcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImRhdGFNZXNzYWdlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEwMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiU2Vzc2lvbkNvbW1hbmRcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInNlc3Npb25NZXNzYWdlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEwMlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiRXJyb3JDb21tYW5kXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJlcnJvck1lc3NhZ2VcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTAzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJEaXJlY3RDb21tYW5kXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJkaXJlY3RNZXNzYWdlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEwNFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiQWNrQ29tbWFuZFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiYWNrTWVzc2FnZVwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxMDVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJydWxlXCI6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIlVucmVhZENvbW1hbmRcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInVucmVhZE1lc3NhZ2VcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTA2XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJSZWFkQ29tbWFuZFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwicmVhZE1lc3NhZ2VcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTA3XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJSY3BDb21tYW5kXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJyY3BNZXNzYWdlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEwOFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiTG9nc0NvbW1hbmRcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImxvZ3NNZXNzYWdlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEwOVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiQ29udkNvbW1hbmRcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImNvbnZNZXNzYWdlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDExMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiUm9vbUNvbW1hbmRcIixcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInJvb21NZXNzYWdlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDExMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiUHJlc2VuY2VDb21tYW5kXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJwcmVzZW5jZU1lc3NhZ2VcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTEyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJSZXBvcnRDb21tYW5kXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJyZXBvcnRNZXNzYWdlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDExM1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiUGF0Y2hDb21tYW5kXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJwYXRjaE1lc3NhZ2VcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTE0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwicnVsZVwiOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBcInR5cGVcIjogXCJQdWJzdWJDb21tYW5kXCIsXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJwdWJzdWJNZXNzYWdlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDExNVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcInJ1bGVcIjogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiQmxhY2tsaXN0Q29tbWFuZFwiLFxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiYmxhY2tsaXN0TWVzc2FnZVwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxMTZcbiAgICAgICAgfV1cbiAgICB9XSxcbiAgICBcImVudW1zXCI6IFt7XG4gICAgICAgIFwibmFtZVwiOiBcIkNvbW1hbmRUeXBlXCIsXG4gICAgICAgIFwic3ludGF4XCI6IFwicHJvdG8yXCIsXG4gICAgICAgIFwidmFsdWVzXCI6IFt7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJzZXNzaW9uXCIsXG4gICAgICAgICAgICBcImlkXCI6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY29udlwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImRpcmVjdFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImFja1wiLFxuICAgICAgICAgICAgXCJpZFwiOiAzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInJjcFwiLFxuICAgICAgICAgICAgXCJpZFwiOiA0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInVucmVhZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiA1XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImxvZ3NcIixcbiAgICAgICAgICAgIFwiaWRcIjogNlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJlcnJvclwiLFxuICAgICAgICAgICAgXCJpZFwiOiA3XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImxvZ2luXCIsXG4gICAgICAgICAgICBcImlkXCI6IDhcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiZGF0YVwiLFxuICAgICAgICAgICAgXCJpZFwiOiA5XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInJvb21cIixcbiAgICAgICAgICAgIFwiaWRcIjogMTBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwicmVhZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJwcmVzZW5jZVwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxMlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJyZXBvcnRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTNcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiZWNob1wiLFxuICAgICAgICAgICAgXCJpZFwiOiAxNFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJsb2dnZWRpblwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxNVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJsb2dvdXRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTZcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibG9nZ2Vkb3V0XCIsXG4gICAgICAgICAgICBcImlkXCI6IDE3XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInBhdGNoXCIsXG4gICAgICAgICAgICBcImlkXCI6IDE4XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInB1YnN1YlwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxOVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJibGFja2xpc3RcIixcbiAgICAgICAgICAgIFwiaWRcIjogMjBcbiAgICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAgIFwibmFtZVwiOiBcIk9wVHlwZVwiLFxuICAgICAgICBcInN5bnRheFwiOiBcInByb3RvMlwiLFxuICAgICAgICBcInZhbHVlc1wiOiBbe1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwib3BlblwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImFkZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInJlbW92ZVwiLFxuICAgICAgICAgICAgXCJpZFwiOiAzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImNsb3NlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDRcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwib3BlbmVkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiY2xvc2VkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDZcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwicXVlcnlcIixcbiAgICAgICAgICAgIFwiaWRcIjogN1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJxdWVyeV9yZXN1bHRcIixcbiAgICAgICAgICAgIFwiaWRcIjogOFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjb25mbGljdFwiLFxuICAgICAgICAgICAgXCJpZFwiOiA5XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcImFkZGVkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInJlbW92ZWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwicmVmcmVzaFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxMlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJyZWZyZXNoZWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTNcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwic3RhcnRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMzBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwic3RhcnRlZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAzMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJqb2luZWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMzJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWVtYmVyc19qb2luZWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMzNcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibGVmdFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAzOVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJtZW1iZXJzX2xlZnRcIixcbiAgICAgICAgICAgIFwiaWRcIjogNDBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwicmVzdWx0c1wiLFxuICAgICAgICAgICAgXCJpZFwiOiA0MlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJjb3VudFwiLFxuICAgICAgICAgICAgXCJpZFwiOiA0M1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJyZXN1bHRcIixcbiAgICAgICAgICAgIFwiaWRcIjogNDRcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwidXBkYXRlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDQ1XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInVwZGF0ZWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogNDZcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibXV0ZVwiLFxuICAgICAgICAgICAgXCJpZFwiOiA0N1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ1bm11dGVcIixcbiAgICAgICAgICAgIFwiaWRcIjogNDhcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwic3RhdHVzXCIsXG4gICAgICAgICAgICBcImlkXCI6IDQ5XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm1lbWJlcnNcIixcbiAgICAgICAgICAgIFwiaWRcIjogNTBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibWF4X3JlYWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogNTFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiaXNfbWVtYmVyXCIsXG4gICAgICAgICAgICBcImlkXCI6IDUyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm1lbWJlcl9pbmZvX3VwZGF0ZVwiLFxuICAgICAgICAgICAgXCJpZFwiOiA1M1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJtZW1iZXJfaW5mb191cGRhdGVkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDU0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm1lbWJlcl9pbmZvX2NoYW5nZWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogNTVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiam9pblwiLFxuICAgICAgICAgICAgXCJpZFwiOiA4MFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJpbnZpdGVcIixcbiAgICAgICAgICAgIFwiaWRcIjogODFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwibGVhdmVcIixcbiAgICAgICAgICAgIFwiaWRcIjogODJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwia2lja1wiLFxuICAgICAgICAgICAgXCJpZFwiOiA4M1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJyZWplY3RcIixcbiAgICAgICAgICAgIFwiaWRcIjogODRcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiaW52aXRlZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiA4NVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJraWNrZWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogODZcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwidXBsb2FkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEwMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ1cGxvYWRlZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxMDFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwic3Vic2NyaWJlXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEyMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJzdWJzY3JpYmVkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEyMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ1bnN1YnNjcmliZVwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxMjJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwidW5zdWJzY3JpYmVkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEyM1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJpc19zdWJzY3JpYmVkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDEyNFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJtb2RpZnlcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTUwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm1vZGlmaWVkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDE1MVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJibG9ja1wiLFxuICAgICAgICAgICAgXCJpZFwiOiAxNzBcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwidW5ibG9ja1wiLFxuICAgICAgICAgICAgXCJpZFwiOiAxNzFcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwiYmxvY2tlZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxNzJcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwidW5ibG9ja2VkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDE3M1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJtZW1iZXJzX2Jsb2NrZWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTc0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm1lbWJlcnNfdW5ibG9ja2VkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDE3NVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJhZGRfc2h1dHVwXCIsXG4gICAgICAgICAgICBcImlkXCI6IDE4MFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJyZW1vdmVfc2h1dHVwXCIsXG4gICAgICAgICAgICBcImlkXCI6IDE4MVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJxdWVyeV9zaHV0dXBcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTgyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInNodXR1cF9hZGRlZFwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxODNcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgXCJuYW1lXCI6IFwic2h1dHVwX3JlbW92ZWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTg0XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInNodXR1cF9yZXN1bHRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTg1XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcInNodXR1cGVkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDE4NlxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJ1bnNodXR1cGVkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDE4N1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJtZW1iZXJzX3NodXR1cGVkXCIsXG4gICAgICAgICAgICBcImlkXCI6IDE4OFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJtZW1iZXJzX3Vuc2h1dHVwZWRcIixcbiAgICAgICAgICAgIFwiaWRcIjogMTg5XG4gICAgICAgIH1dXG4gICAgfSwge1xuICAgICAgICBcIm5hbWVcIjogXCJTdGF0dXNUeXBlXCIsXG4gICAgICAgIFwic3ludGF4XCI6IFwicHJvdG8yXCIsXG4gICAgICAgIFwidmFsdWVzXCI6IFt7XG4gICAgICAgICAgICBcIm5hbWVcIjogXCJvblwiLFxuICAgICAgICAgICAgXCJpZFwiOiAxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm9mZlwiLFxuICAgICAgICAgICAgXCJpZFwiOiAyXG4gICAgICAgIH1dXG4gICAgfV0sXG4gICAgXCJpc05hbWVzcGFjZVwiOiB0cnVlXG59KS5idWlsZCgpO1xuXG52YXIgX21lc3NhZ2VzJHB1c2hfc2VydmVyID0gbWVzc2FnZUNvbXBpbGVkLnB1c2hfc2VydmVyLm1lc3NhZ2VzMixcbiAgICBKc29uT2JqZWN0TWVzc2FnZSA9IF9tZXNzYWdlcyRwdXNoX3NlcnZlci5Kc29uT2JqZWN0TWVzc2FnZSxcbiAgICBVbnJlYWRUdXBsZSA9IF9tZXNzYWdlcyRwdXNoX3NlcnZlci5VbnJlYWRUdXBsZSxcbiAgICBMb2dJdGVtID0gX21lc3NhZ2VzJHB1c2hfc2VydmVyLkxvZ0l0ZW0sXG4gICAgRGF0YUNvbW1hbmQgPSBfbWVzc2FnZXMkcHVzaF9zZXJ2ZXIuRGF0YUNvbW1hbmQsXG4gICAgU2Vzc2lvbkNvbW1hbmQgPSBfbWVzc2FnZXMkcHVzaF9zZXJ2ZXIuU2Vzc2lvbkNvbW1hbmQsXG4gICAgRXJyb3JDb21tYW5kID0gX21lc3NhZ2VzJHB1c2hfc2VydmVyLkVycm9yQ29tbWFuZCxcbiAgICBEaXJlY3RDb21tYW5kID0gX21lc3NhZ2VzJHB1c2hfc2VydmVyLkRpcmVjdENvbW1hbmQsXG4gICAgQWNrQ29tbWFuZCA9IF9tZXNzYWdlcyRwdXNoX3NlcnZlci5BY2tDb21tYW5kLFxuICAgIFVucmVhZENvbW1hbmQgPSBfbWVzc2FnZXMkcHVzaF9zZXJ2ZXIuVW5yZWFkQ29tbWFuZCxcbiAgICBDb252Q29tbWFuZCA9IF9tZXNzYWdlcyRwdXNoX3NlcnZlci5Db252Q29tbWFuZCxcbiAgICBSb29tQ29tbWFuZCA9IF9tZXNzYWdlcyRwdXNoX3NlcnZlci5Sb29tQ29tbWFuZCxcbiAgICBMb2dzQ29tbWFuZCA9IF9tZXNzYWdlcyRwdXNoX3NlcnZlci5Mb2dzQ29tbWFuZCxcbiAgICBSY3BDb21tYW5kID0gX21lc3NhZ2VzJHB1c2hfc2VydmVyLlJjcENvbW1hbmQsXG4gICAgUmVhZFR1cGxlID0gX21lc3NhZ2VzJHB1c2hfc2VydmVyLlJlYWRUdXBsZSxcbiAgICBNYXhSZWFkVHVwbGUgPSBfbWVzc2FnZXMkcHVzaF9zZXJ2ZXIuTWF4UmVhZFR1cGxlLFxuICAgIFJlYWRDb21tYW5kID0gX21lc3NhZ2VzJHB1c2hfc2VydmVyLlJlYWRDb21tYW5kLFxuICAgIFByZXNlbmNlQ29tbWFuZCA9IF9tZXNzYWdlcyRwdXNoX3NlcnZlci5QcmVzZW5jZUNvbW1hbmQsXG4gICAgUmVwb3J0Q29tbWFuZCA9IF9tZXNzYWdlcyRwdXNoX3NlcnZlci5SZXBvcnRDb21tYW5kLFxuICAgIEdlbmVyaWNDb21tYW5kID0gX21lc3NhZ2VzJHB1c2hfc2VydmVyLkdlbmVyaWNDb21tYW5kLFxuICAgIEJsYWNrbGlzdENvbW1hbmQgPSBfbWVzc2FnZXMkcHVzaF9zZXJ2ZXIuQmxhY2tsaXN0Q29tbWFuZCxcbiAgICBQYXRjaENvbW1hbmQgPSBfbWVzc2FnZXMkcHVzaF9zZXJ2ZXIuUGF0Y2hDb21tYW5kLFxuICAgIFBhdGNoSXRlbSA9IF9tZXNzYWdlcyRwdXNoX3NlcnZlci5QYXRjaEl0ZW0sXG4gICAgQ29udk1lbWJlckluZm8gPSBfbWVzc2FnZXMkcHVzaF9zZXJ2ZXIuQ29udk1lbWJlckluZm8sXG4gICAgQ29tbWFuZFR5cGUgPSBfbWVzc2FnZXMkcHVzaF9zZXJ2ZXIuQ29tbWFuZFR5cGUsXG4gICAgT3BUeXBlID0gX21lc3NhZ2VzJHB1c2hfc2VydmVyLk9wVHlwZSxcbiAgICBTdGF0dXNUeXBlID0gX21lc3NhZ2VzJHB1c2hfc2VydmVyLlN0YXR1c1R5cGU7XG5cblxudmFyIG1lc3NhZ2UgPSBPYmplY3QuZnJlZXplKHtcblx0SnNvbk9iamVjdE1lc3NhZ2U6IEpzb25PYmplY3RNZXNzYWdlLFxuXHRVbnJlYWRUdXBsZTogVW5yZWFkVHVwbGUsXG5cdExvZ0l0ZW06IExvZ0l0ZW0sXG5cdERhdGFDb21tYW5kOiBEYXRhQ29tbWFuZCxcblx0U2Vzc2lvbkNvbW1hbmQ6IFNlc3Npb25Db21tYW5kLFxuXHRFcnJvckNvbW1hbmQ6IEVycm9yQ29tbWFuZCxcblx0RGlyZWN0Q29tbWFuZDogRGlyZWN0Q29tbWFuZCxcblx0QWNrQ29tbWFuZDogQWNrQ29tbWFuZCxcblx0VW5yZWFkQ29tbWFuZDogVW5yZWFkQ29tbWFuZCxcblx0Q29udkNvbW1hbmQ6IENvbnZDb21tYW5kLFxuXHRSb29tQ29tbWFuZDogUm9vbUNvbW1hbmQsXG5cdExvZ3NDb21tYW5kOiBMb2dzQ29tbWFuZCxcblx0UmNwQ29tbWFuZDogUmNwQ29tbWFuZCxcblx0UmVhZFR1cGxlOiBSZWFkVHVwbGUsXG5cdE1heFJlYWRUdXBsZTogTWF4UmVhZFR1cGxlLFxuXHRSZWFkQ29tbWFuZDogUmVhZENvbW1hbmQsXG5cdFByZXNlbmNlQ29tbWFuZDogUHJlc2VuY2VDb21tYW5kLFxuXHRSZXBvcnRDb21tYW5kOiBSZXBvcnRDb21tYW5kLFxuXHRHZW5lcmljQ29tbWFuZDogR2VuZXJpY0NvbW1hbmQsXG5cdEJsYWNrbGlzdENvbW1hbmQ6IEJsYWNrbGlzdENvbW1hbmQsXG5cdFBhdGNoQ29tbWFuZDogUGF0Y2hDb21tYW5kLFxuXHRQYXRjaEl0ZW06IFBhdGNoSXRlbSxcblx0Q29udk1lbWJlckluZm86IENvbnZNZW1iZXJJbmZvLFxuXHRDb21tYW5kVHlwZTogQ29tbWFuZFR5cGUsXG5cdE9wVHlwZTogT3BUeXBlLFxuXHRTdGF0dXNUeXBlOiBTdGF0dXNUeXBlXG59KTtcblxudmFyIGV2ZW50ZW1pdHRlcjMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG57XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxufSk7XG5cbnZhciBydW50aW1lID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgdmFyIGluTW9kdWxlID0gJ29iamVjdCcgPT09IFwib2JqZWN0XCI7XG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcbiAgaWYgKHJ1bnRpbWUpIHtcbiAgICBpZiAoaW5Nb2R1bGUpIHtcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XG4gICAgfVxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgcnVudGltZS53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xufSkoXG4gIC8vIEluIHNsb3BweSBtb2RlLCB1bmJvdW5kIGB0aGlzYCByZWZlcnMgdG8gdGhlIGdsb2JhbCBvYmplY3QsIGZhbGxiYWNrIHRvXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cbiAgLy8gb2YgaW5kaXJlY3QgZXZhbCB3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cbiAgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKVxuKTtcbn0pO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXG52YXIgZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbnZhciBydW50aW1lTW9kdWxlID0gcnVudGltZTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG5cbnZhciByZWdlbmVyYXRvciA9IHJ1bnRpbWVNb2R1bGU7XG5cbnZhciBhc3luY1RvR2VuZXJhdG9yID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cblxudmFyIF9wcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocHJvbWlzZSQxKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdlbiA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIG5ldyBfcHJvbWlzZTIuZGVmYXVsdChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIF9wcm9taXNlMi5kZWZhdWx0LnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBzdGVwKFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgc3RlcChcInRocm93XCIsIGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ZXAoXCJuZXh0XCIpO1xuICAgIH0pO1xuICB9O1xufTtcbn0pO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IgPSB1bndyYXBFeHBvcnRzKGFzeW5jVG9HZW5lcmF0b3IpO1xuXG52YXIgX2NyZWF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gIGlmIChpbmRleCBpbiBvYmplY3QpIF9vYmplY3REcC5mKG9iamVjdCwgaW5kZXgsIF9wcm9wZXJ0eURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59O1xuXG5fZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiAqICFfaXRlckRldGVjdChmdW5jdGlvbiAoaXRlcikgeyB9KSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjIuMSBBcnJheS5mcm9tKGFycmF5TGlrZSwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gIGZyb206IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgICB2YXIgTyA9IF90b09iamVjdChhcnJheUxpa2UpO1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGl0ZXJGbiA9IGNvcmVfZ2V0SXRlcmF0b3JNZXRob2QoTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBfY3R4KG1hcGZuLCBhTGVuID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gICAgLy8gaWYgb2JqZWN0IGlzbid0IGl0ZXJhYmxlIG9yIGl0J3MgYXJyYXkgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIHNpbXBsZSBjYXNlXG4gICAgaWYgKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIF9pc0FycmF5SXRlcihpdGVyRm4pKSkge1xuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQygpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgICAgX2NyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBfaXRlckNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSBfdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBfY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxudmFyIGZyb20gPSBfY29yZS5BcnJheS5mcm9tO1xuXG52YXIgZnJvbSQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBmcm9tLCBfX2VzTW9kdWxlOiB0cnVlIH07XG59KTtcblxudmFyIF9BcnJheSRmcm9tID0gdW53cmFwRXhwb3J0cyhmcm9tJDEpO1xuXG52YXIgdG9Db25zdW1hYmxlQXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblxuXG52YXIgX2Zyb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChmcm9tJDEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnIyW2ldID0gYXJyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBhcnIyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoMCwgX2Zyb20yLmRlZmF1bHQpKGFycik7XG4gIH1cbn07XG59KTtcblxudmFyIF90b0NvbnN1bWFibGVBcnJheSA9IHVud3JhcEV4cG9ydHModG9Db25zdW1hYmxlQXJyYXkpO1xuXG52YXIgX21ldGEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG52YXIgTUVUQSA9IF91aWQoJ21ldGEnKTtcblxuXG52YXIgc2V0RGVzYyA9IF9vYmplY3REcC5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFfZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFfaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIV9oYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIV9oYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIV9oYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcbn0pO1xudmFyIF9tZXRhXzEgPSBfbWV0YS5LRVk7XG52YXIgX21ldGFfMiA9IF9tZXRhLk5FRUQ7XG52YXIgX21ldGFfMyA9IF9tZXRhLmZhc3RLZXk7XG52YXIgX21ldGFfNCA9IF9tZXRhLmdldFdlYWs7XG52YXIgX21ldGFfNSA9IF9tZXRhLm9uRnJlZXplO1xuXG52YXIgX3ZhbGlkYXRlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIChpdCwgVFlQRSkge1xuICBpZiAoIV9pc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cbnZhciBkUCQxID0gX29iamVjdERwLmY7XG5cblxuXG5cblxuXG5cblxuXG52YXIgZmFzdEtleSA9IF9tZXRhLmZhc3RLZXk7XG5cbnZhciBTSVpFID0gX2Rlc2NyaXB0b3JzID8gJ19zJyA6ICdzaXplJztcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICB2YXIgZW50cnk7XG4gIGlmIChpbmRleCAhPT0gJ0YnKSByZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IgKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgIGlmIChlbnRyeS5rID09IGtleSkgcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG52YXIgX2NvbGxlY3Rpb25TdHJvbmcgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIF9hbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gX29iamVjdENyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAvLyBzaXplXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBfZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIF9yZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgZm9yICh2YXIgdGhhdCA9IF92YWxpZGF0ZUNvbGxlY3Rpb24odGhpcywgTkFNRSksIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucCkgZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IF92YWxpZGF0ZUNvbGxlY3Rpb24odGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkubjtcbiAgICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKHByZXYpIHByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYgKG5leHQpIG5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYgKHRoYXQuX2YgPT0gZW50cnkpIHRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmICh0aGF0Ll9sID09IGVudHJ5KSB0aGF0Ll9sID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICAgICAgX3ZhbGlkYXRlQ29sbGVjdGlvbih0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGYgPSBfY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKSB7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkoX3ZhbGlkYXRlQ29sbGVjdGlvbih0aGlzLCBOQU1FKSwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoX2Rlc2NyaXB0b3JzKSBkUCQxKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3ZhbGlkYXRlQ29sbGVjdGlvbih0aGlzLCBOQU1FKVtTSVpFXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgdmFyIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYgKCF0aGF0Ll9mKSB0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZiAocHJldikgcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSB0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgTkFNRSwgSVNfTUFQKSB7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgIF9pdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgdGhpcy5fdCA9IF92YWxpZGF0ZUNvbGxlY3Rpb24oaXRlcmF0ZWQsIE5BTUUpOyAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7ICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGtpbmQgPSB0aGF0Ll9rO1xuICAgICAgdmFyIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZiAoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSkge1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gX2l0ZXJTdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gX2l0ZXJTdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBfaXRlclN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gX2l0ZXJTdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBfc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTtcblxuLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcblxudmFyIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gX2NvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG52YXIgU1BFQ0lFUyQyID0gX3drcygnc3BlY2llcycpO1xuXG52YXIgX2FycmF5U3BlY2llc0NvbnN0cnVjdG9yID0gZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIHZhciBDO1xuICBpZiAoX2lzQXJyYXkob3JpZ2luYWwpKSB7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IF9pc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKF9pc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFUyQyXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcblxuLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxuXG5cbnZhciBfYXJyYXlTcGVjaWVzQ3JlYXRlID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoX2FycmF5U3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG5cbi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcblxuXG5cblxuXG52YXIgX2FycmF5TWV0aG9kcyA9IGZ1bmN0aW9uIChUWVBFLCAkY3JlYXRlKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09IDE7XG4gIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09IDQ7XG4gIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgdmFyIGNyZWF0ZSA9ICRjcmVhdGUgfHwgX2FycmF5U3BlY2llc0NyZWF0ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCkge1xuICAgIHZhciBPID0gX3RvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IF9pb2JqZWN0KE8pO1xuICAgIHZhciBmID0gX2N0eChjYWxsYmFja2ZuLCB0aGF0LCAzKTtcbiAgICB2YXIgbGVuZ3RoID0gX3RvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWwsIHJlcztcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHJlc3VsdFtpbmRleF0gPSByZXM7ICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlcykgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmIChJU19FVkVSWSkgcmV0dXJuIGZhbHNlOyAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcblxudmFyIGRQJDIgPSBfb2JqZWN0RHAuZjtcbnZhciBlYWNoID0gX2FycmF5TWV0aG9kcygwKTtcblxuXG52YXIgX2NvbGxlY3Rpb24gPSBmdW5jdGlvbiAoTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspIHtcbiAgdmFyIEJhc2UgPSBfZ2xvYmFsW05BTUVdO1xuICB2YXIgQyA9IEJhc2U7XG4gIHZhciBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCc7XG4gIHZhciBwcm90byA9IEMgJiYgQy5wcm90b3R5cGU7XG4gIHZhciBPID0ge307XG4gIGlmICghX2Rlc2NyaXB0b3JzIHx8IHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIV9mYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgX3JlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBfbWV0YS5ORUVEID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBDID0gd3JhcHBlcihmdW5jdGlvbiAodGFyZ2V0LCBpdGVyYWJsZSkge1xuICAgICAgX2FuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FLCAnX2MnKTtcbiAgICAgIHRhcmdldC5fYyA9IG5ldyBCYXNlKCk7XG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBfZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGFyZ2V0W0FEREVSXSwgdGFyZ2V0KTtcbiAgICB9KTtcbiAgICBlYWNoKCdhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcyx0b0pTT04nLnNwbGl0KCcsJyksIGZ1bmN0aW9uIChLRVkpIHtcbiAgICAgIHZhciBJU19BRERFUiA9IEtFWSA9PSAnYWRkJyB8fCBLRVkgPT0gJ3NldCc7XG4gICAgICBpZiAoS0VZIGluIHByb3RvICYmICEoSVNfV0VBSyAmJiBLRVkgPT0gJ2NsZWFyJykpIF9oaWRlKEMucHJvdG90eXBlLCBLRVksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIF9hbkluc3RhbmNlKHRoaXMsIEMsIEtFWSk7XG4gICAgICAgIGlmICghSVNfQURERVIgJiYgSVNfV0VBSyAmJiAhX2lzT2JqZWN0KGEpKSByZXR1cm4gS0VZID09ICdnZXQnID8gdW5kZWZpbmVkIDogZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIElTX1dFQUsgfHwgZFAkMihDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Muc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9zZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgX2V4cG9ydChfZXhwb3J0LkcgKyBfZXhwb3J0LlcgKyBfZXhwb3J0LkYsIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcblxudmFyIFNFVCA9ICdTZXQnO1xuXG4vLyAyMy4yIFNldCBPYmplY3RzXG52YXIgZXM2X3NldCA9IF9jb2xsZWN0aW9uKFNFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9jb2xsZWN0aW9uU3Ryb25nLmRlZihfdmFsaWRhdGVDb2xsZWN0aW9uKHRoaXMsIFNFVCksIHZhbHVlID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWUsIHZhbHVlKTtcbiAgfVxufSwgX2NvbGxlY3Rpb25TdHJvbmcpO1xuXG52YXIgX2FycmF5RnJvbUl0ZXJhYmxlID0gZnVuY3Rpb24gKGl0ZXIsIElURVJBVE9SKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgX2Zvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG5cblxudmFyIF9jb2xsZWN0aW9uVG9Kc29uID0gZnVuY3Rpb24gKE5BTUUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICBpZiAoX2NsYXNzb2YodGhpcykgIT0gTkFNRSkgdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gX2FycmF5RnJvbUl0ZXJhYmxlKHRoaXMpO1xuICB9O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxuXG5cbl9leHBvcnQoX2V4cG9ydC5QICsgX2V4cG9ydC5SLCAnU2V0JywgeyB0b0pTT046IF9jb2xsZWN0aW9uVG9Kc29uKCdTZXQnKSB9KTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xuXG5cbnZhciBfc2V0Q29sbGVjdGlvbk9mID0gZnVuY3Rpb24gKENPTExFQ1RJT04pIHtcbiAgX2V4cG9ydChfZXhwb3J0LlMsIENPTExFQ1RJT04sIHsgb2Y6IGZ1bmN0aW9uIG9mKCkge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBBID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSBBW2xlbmd0aF0gPSBhcmd1bWVudHNbbGVuZ3RoXTtcbiAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gIH0gfSk7XG59O1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQub2Zcbl9zZXRDb2xsZWN0aW9uT2YoJ1NldCcpO1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG5cblxuXG5cblxudmFyIF9zZXRDb2xsZWN0aW9uRnJvbSA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gIF9leHBvcnQoX2V4cG9ydC5TLCBDT0xMRUNUSU9OLCB7IGZyb206IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwRm4sIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgbWFwRm4gPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1hcHBpbmcsIEEsIG4sIGNiO1xuICAgIF9hRnVuY3Rpb24odGhpcyk7XG4gICAgbWFwcGluZyA9IG1hcEZuICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG1hcHBpbmcpIF9hRnVuY3Rpb24obWFwRm4pO1xuICAgIGlmIChzb3VyY2UgPT0gdW5kZWZpbmVkKSByZXR1cm4gbmV3IHRoaXMoKTtcbiAgICBBID0gW107XG4gICAgaWYgKG1hcHBpbmcpIHtcbiAgICAgIG4gPSAwO1xuICAgICAgY2IgPSBfY3R4KG1hcEZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgICAgX2Zvck9mKHNvdXJjZSwgZmFsc2UsIGZ1bmN0aW9uIChuZXh0SXRlbSkge1xuICAgICAgICBBLnB1c2goY2IobmV4dEl0ZW0sIG4rKykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9mb3JPZihzb3VyY2UsIGZhbHNlLCBBLnB1c2gsIEEpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gIH0gfSk7XG59O1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQuZnJvbVxuX3NldENvbGxlY3Rpb25Gcm9tKCdTZXQnKTtcblxudmFyIHNldCA9IF9jb3JlLlNldDtcblxudmFyIHNldCQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBzZXQsIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0pO1xuXG52YXIgX1NldCA9IHVud3JhcEV4cG9ydHMoc2V0JDEpO1xuXG52YXIgb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcbn0pO1xuXG52YXIgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gdW53cmFwRXhwb3J0cyhvYmplY3RXaXRob3V0UHJvcGVydGllcyk7XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG59KTtcblxudmFyIF9jbGFzc0NhbGxDaGVjayA9IHVud3JhcEV4cG9ydHMoY2xhc3NDYWxsQ2hlY2spO1xuXG52YXIgZiQ0ID0gX3drcztcblxudmFyIF93a3NFeHQgPSB7XG5cdGY6IGYkNFxufTtcblxudmFyIGl0ZXJhdG9yID0gX3drc0V4dC5mKCdpdGVyYXRvcicpO1xuXG52YXIgaXRlcmF0b3IkMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogaXRlcmF0b3IsIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0pO1xuXG51bndyYXBFeHBvcnRzKGl0ZXJhdG9yJDEpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBfb2JqZWN0RHAuZjtcbnZhciBfd2tzRGVmaW5lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBfY29yZS5TeW1ib2wgfHwgKF9jb3JlLlN5bWJvbCA9IF9saWJyYXJ5ID8ge30gOiBfZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiBfd2tzRXh0LmYobmFtZSkgfSk7XG59O1xuXG4vLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xuXG5cblxudmFyIF9lbnVtS2V5cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gX29iamVjdEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IF9vYmplY3RHb3BzLmY7XG4gIGlmIChnZXRTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KTtcbiAgICB2YXIgaXNFbnVtID0gX29iamVjdFBpZS5mO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChzeW1ib2xzLmxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuXG52YXIgaGlkZGVuS2V5cyA9IF9lbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxudmFyIGYkNSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gX29iamVjdEtleXNJbnRlcm5hbChPLCBoaWRkZW5LZXlzKTtcbn07XG5cbnZhciBfb2JqZWN0R29wbiA9IHtcblx0ZjogZiQ1XG59O1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG5cbnZhciBnT1BOID0gX29iamVjdEdvcG4uZjtcbnZhciB0b1N0cmluZyQxID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxudmFyIGYkNiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nJDEuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKF90b0lvYmplY3QoaXQpKTtcbn07XG5cbnZhciBfb2JqZWN0R29wbkV4dCA9IHtcblx0ZjogZiQ2XG59O1xuXG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbnZhciBmJDcgPSBfZGVzY3JpcHRvcnMgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IF90b0lvYmplY3QoTyk7XG4gIFAgPSBfdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChfaWU4RG9tRGVmaW5lKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKF9oYXMoTywgUCkpIHJldHVybiBfcHJvcGVydHlEZXNjKCFfb2JqZWN0UGllLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG52YXIgX29iamVjdEdvcGQgPSB7XG5cdGY6IGYkN1xufTtcblxuLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbVxuXG5cblxuXG5cbnZhciBNRVRBID0gX21ldGEuS0VZO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgZ09QRCQxID0gX29iamVjdEdvcGQuZjtcbnZhciBkUCQzID0gX29iamVjdERwLmY7XG52YXIgZ09QTiQxID0gX29iamVjdEdvcG5FeHQuZjtcbnZhciAkU3ltYm9sID0gX2dsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBfZ2xvYmFsLkpTT047XG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcbnZhciBQUk9UT1RZUEUkMiA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiA9IF93a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgPSBfd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gX3NoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IF9zaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPUFN5bWJvbHMgPSBfc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8kMSA9IE9iamVjdFtQUk9UT1RZUEUkMl07XG52YXIgVVNFX05BVElWRSQxID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcbnZhciBRT2JqZWN0ID0gX2dsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFJDJdIHx8ICFRT2JqZWN0W1BST1RPVFlQRSQyXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBfZGVzY3JpcHRvcnMgJiYgX2ZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIF9vYmplY3RDcmVhdGUoZFAkMyh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCQzKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEJDEoT2JqZWN0UHJvdG8kMSwga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvJDFba2V5XTtcbiAgZFAkMyhpdCwga2V5LCBEKTtcbiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8kMSkgZFAkMyhPYmplY3RQcm90byQxLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFAkMztcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfb2JqZWN0Q3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFJDJdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSQxICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkge1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvJDEpICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIF9hbk9iamVjdChpdCk7XG4gIGtleSA9IF90b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBfYW5PYmplY3QoRCk7XG4gIGlmIChfaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUQuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFfaGFzKGl0LCBISURERU4pKSBkUCQzKGl0LCBISURERU4sIF9wcm9wZXJ0eURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChfaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX29iamVjdENyZWF0ZShELCB7IGVudW1lcmFibGU6IF9wcm9wZXJ0eURlc2MoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQJDMoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkge1xuICBfYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IF9lbnVtS2V5cyhQID0gX3RvSW9iamVjdChQKSk7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7XG4gIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfb2JqZWN0Q3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9vYmplY3RDcmVhdGUoaXQpLCBQKTtcbn07XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gX3RvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8kMSAmJiBfaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIV9oYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFfaGFzKHRoaXMsIGtleSkgfHwgIV9oYXMoQWxsU3ltYm9scywga2V5KSB8fCBfaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gX3RvSW9iamVjdChpdCk7XG4gIGtleSA9IF90b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvJDEgJiYgX2hhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFfaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQkMShpdCwga2V5KTtcbiAgaWYgKEQgJiYgX2hhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoX2hhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHZhciBuYW1lcyA9IGdPUE4kMShfdG9Jb2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmICghX2hhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvJDE7XG4gIHZhciBuYW1lcyA9IGdPUE4kMShJU19PUCA/IE9QU3ltYm9scyA6IF90b0lvYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKF9oYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gX2hhcyhPYmplY3RQcm90byQxLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYgKCFVU0VfTkFUSVZFJDEpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSBfdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvJDEpICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChfaGFzKHRoaXMsIEhJRERFTikgJiYgX2hhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgX3Byb3BlcnR5RGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKF9kZXNjcmlwdG9ycyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8kMSwgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIF9yZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRSQyXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gIF9vYmplY3RHb3BkLmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICBfb2JqZWN0RHAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgX29iamVjdEdvcG4uZiA9IF9vYmplY3RHb3BuRXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgX29iamVjdFBpZS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICBfb2JqZWN0R29wcy5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoX2Rlc2NyaXB0b3JzICYmICFfbGlicmFyeSkge1xuICAgIF9yZWRlZmluZShPYmplY3RQcm90byQxLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgX3drc0V4dC5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcChfd2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuX2V4cG9ydChfZXhwb3J0LkcgKyBfZXhwb3J0LlcgKyBfZXhwb3J0LkYgKiAhVVNFX05BVElWRSQxLCB7IFN5bWJvbDogJFN5bWJvbCB9KTtcblxuZm9yICh2YXIgZXM2U3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBqID0gMDsgZXM2U3ltYm9scy5sZW5ndGggPiBqOylfd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSBfb2JqZWN0S2V5cyhfd2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIF93a3NEZWZpbmUod2VsbEtub3duU3ltYm9sc1trKytdKTtcblxuX2V4cG9ydChfZXhwb3J0LlMgKyBfZXhwb3J0LkYgKiAhVVNFX05BVElWRSQxLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gX2hhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gU3ltYm9sUmVnaXN0cnkpIGlmIChTeW1ib2xSZWdpc3RyeVtrZXldID09PSBzeW0pIHJldHVybiBrZXk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG5fZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiAqICFVU0VfTkFUSVZFJDEsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmIF9leHBvcnQoX2V4cG9ydC5TICsgX2V4cG9ydC5GICogKCFVU0VfTkFUSVZFJDEgfHwgX2ZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIV9pc09iamVjdChyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIGlmICghX2lzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRSQyXVtUT19QUklNSVRJVkVdIHx8IF9oaWRlKCRTeW1ib2xbUFJPVE9UWVBFJDJdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFJDJdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuX3NldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbl9zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbl9zZXRUb1N0cmluZ1RhZyhfZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cbl93a3NEZWZpbmUoJ2FzeW5jSXRlcmF0b3InKTtcblxuX3drc0RlZmluZSgnb2JzZXJ2YWJsZScpO1xuXG52YXIgc3ltYm9sID0gX2NvcmUuU3ltYm9sO1xuXG52YXIgc3ltYm9sJDEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5tb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHN5bWJvbCwgX19lc01vZHVsZTogdHJ1ZSB9O1xufSk7XG5cbnZhciBfU3ltYm9sID0gdW53cmFwRXhwb3J0cyhzeW1ib2wkMSk7XG5cbnZhciBfdHlwZW9mXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblxuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoaXRlcmF0b3IkMSk7XG5cblxuXG52YXIgX3N5bWJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHN5bWJvbCQxKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07XG59KTtcblxudmFyIF90eXBlb2YgPSB1bndyYXBFeHBvcnRzKF90eXBlb2ZfMSk7XG5cbnZhciBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mXzEpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAoKHR5cGVvZiBjYWxsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShjYWxsKSkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG59KTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuID0gdW53cmFwRXhwb3J0cyhwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKTtcblxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBfYW5PYmplY3QoTyk7XG4gIGlmICghX2lzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCkgdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbnZhciBfc2V0UHJvdG8gPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gX2N0eChGdW5jdGlvbi5jYWxsLCBfb2JqZWN0R29wZC5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxuLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcblxuX2V4cG9ydChfZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiBfc2V0UHJvdG8uc2V0IH0pO1xuXG52YXIgc2V0UHJvdG90eXBlT2YgPSBfY29yZS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzZXRQcm90b3R5cGVPZiQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBzZXRQcm90b3R5cGVPZiwgX19lc01vZHVsZTogdHJ1ZSB9O1xufSk7XG5cbnVud3JhcEV4cG9ydHMoc2V0UHJvdG90eXBlT2YkMSk7XG5cbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuX2V4cG9ydChfZXhwb3J0LlMsICdPYmplY3QnLCB7IGNyZWF0ZTogX29iamVjdENyZWF0ZSB9KTtcblxudmFyICRPYmplY3QgPSBfY29yZS5PYmplY3Q7XG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpIHtcbiAgcmV0dXJuICRPYmplY3QuY3JlYXRlKFAsIEQpO1xufTtcblxudmFyIGNyZWF0ZSQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBjcmVhdGUsIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0pO1xuXG51bndyYXBFeHBvcnRzKGNyZWF0ZSQxKTtcblxudmFyIGluaGVyaXRzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cblxudmFyIF9zZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHNldFByb3RvdHlwZU9mJDEpO1xuXG5cblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChjcmVhdGUkMSk7XG5cblxuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2ZfMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyAodHlwZW9mIHN1cGVyQ2xhc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKHN1cGVyQ2xhc3MpKSk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSAoMCwgX2NyZWF0ZTIuZGVmYXVsdCkoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCA/ICgwLCBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59O1xufSk7XG5cbnZhciBfaW5oZXJpdHMgPSB1bndyYXBFeHBvcnRzKGluaGVyaXRzKTtcblxuLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxudmFyIG1zID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JykgfHxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcbiAgICBwbHVyYWwobXMsIG0sICdtaW51dGUnKSB8fFxuICAgIHBsdXJhbChtcywgcywgJ3NlY29uZCcpIHx8XG4gICAgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobXMgPCBuICogMS41KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIH1cbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cblxudmFyIGRlYnVnID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSBtcztcblxuLyoqXG4gKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydHMuaW5zdGFuY2VzID0gW107XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgdmFyIGhhc2ggPSAwLCBpO1xuXG4gIGZvciAoaSBpbiBuYW1lc3BhY2UpIHtcbiAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG4gIHZhciBwcmV2VGltZTtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zJCQxID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcyQkMTtcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgZXhwb3J0cy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95ICgpIHtcbiAgdmFyIGluZGV4ID0gZXhwb3J0cy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIGV4cG9ydHMuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIGk7XG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBleHBvcnRzLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnN0YW5jZSA9IGV4cG9ydHMuaW5zdGFuY2VzW2ldO1xuICAgIGluc3RhbmNlLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG59KTtcbnZhciBkZWJ1Z18xID0gZGVidWcuY29lcmNlO1xudmFyIGRlYnVnXzIgPSBkZWJ1Zy5kaXNhYmxlO1xudmFyIGRlYnVnXzMgPSBkZWJ1Zy5lbmFibGU7XG52YXIgZGVidWdfNCA9IGRlYnVnLmVuYWJsZWQ7XG52YXIgZGVidWdfNSA9IGRlYnVnLmh1bWFuaXplO1xudmFyIGRlYnVnXzYgPSBkZWJ1Zy5pbnN0YW5jZXM7XG52YXIgZGVidWdfNyA9IGRlYnVnLm5hbWVzO1xudmFyIGRlYnVnXzggPSBkZWJ1Zy5za2lwcztcbnZhciBkZWJ1Z185ID0gZGVidWcuZm9ybWF0dGVycztcblxudmFyIGJyb3dzZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLFxuICAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsXG4gICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJyxcbiAgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLFxuICAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsXG4gICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJyxcbiAgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLFxuICAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsXG4gICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJyxcbiAgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLFxuICAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxufSk7XG52YXIgYnJvd3Nlcl8xID0gYnJvd3Nlci5sb2c7XG52YXIgYnJvd3Nlcl8yID0gYnJvd3Nlci5mb3JtYXRBcmdzO1xudmFyIGJyb3dzZXJfMyA9IGJyb3dzZXIuc2F2ZTtcbnZhciBicm93c2VyXzQgPSBicm93c2VyLmxvYWQ7XG52YXIgYnJvd3Nlcl81ID0gYnJvd3Nlci51c2VDb2xvcnM7XG52YXIgYnJvd3Nlcl82ID0gYnJvd3Nlci5zdG9yYWdlO1xudmFyIGJyb3dzZXJfNyA9IGJyb3dzZXIuY29sb3JzO1xuXG52YXIgYmluZCA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuXG4vKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbnZhciBpc0J1ZmZlcl8xID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufTtcblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cbi8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmckMiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZyQyLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nJDIuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB2YWwgJiYgdmFsLmJ1ZmZlciAmJiB2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nJDIuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGaWxlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmckMi5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZyQyLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nJDIuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG4gIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG59XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKS5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICgodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkgIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoKSAvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi97XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAoX3R5cGVvZihyZXN1bHRba2V5XSkgPT09ICdvYmplY3QnICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxudmFyIHV0aWxzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXJfMSxcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW1cbn07XG5cbnZhciAkSlNPTiQxID0gX2NvcmUuSlNPTiB8fCAoX2NvcmUuSlNPTiA9IHsgc3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeSB9KTtcbnZhciBzdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04kMS5zdHJpbmdpZnkuYXBwbHkoJEpTT04kMSwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBzdHJpbmdpZnkkMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogc3RyaW5naWZ5LCBfX2VzTW9kdWxlOiB0cnVlIH07XG59KTtcblxudmFyIF9KU09OJHN0cmluZ2lmeSA9IHVud3JhcEV4cG9ydHMoc3RyaW5naWZ5JDEpO1xuXG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cblxudmFyIGVuaGFuY2VFcnJvciA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIHJldHVybiBlcnJvcjtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG52YXIgY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICovXG52YXIgc2V0dGxlID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICAvLyBOb3RlOiBzdGF0dXMgaXMgbm90IGV4cG9zZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UuY29uZmlnLCBudWxsLCByZXNwb25zZS5yZXF1ZXN0LCByZXNwb25zZSkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5yZXBsYWNlKC8lNDAvZ2ksICdAJykucmVwbGFjZSgvJTNBL2dpLCAnOicpLnJlcGxhY2UoLyUyNC9nLCAnJCcpLnJlcGxhY2UoLyUyQy9naSwgJywnKS5yZXBsYWNlKC8lMjAvZywgJysnKS5yZXBsYWNlKC8lNUIvZ2ksICdbJykucmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbnZhciBidWlsZFVSTCA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gX0pTT04kc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcblxuLy8gSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbnZhciBpZ25vcmVEdXBsaWNhdGVPZiA9IFsnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLCAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJywgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCddO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG52YXIgcGFyc2VIZWFkZXJzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuICB2YXIgaTtcblxuICBpZiAoIWhlYWRlcnMpIHtcbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcblxudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4vLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3Rcbi8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgdmFyIG9yaWdpblVSTDtcblxuICAvKipcbiAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAqL1xuICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgIHZhciBocmVmID0gdXJsO1xuXG4gICAgaWYgKG1zaWUpIHtcbiAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgfVxuXG4gICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgcmV0dXJuIHtcbiAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgcGF0aG5hbWU6IHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nID8gdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOiAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgIH07XG4gIH1cblxuICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAvKipcbiAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAqL1xuICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICB2YXIgcGFyc2VkID0gdXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICByZXR1cm4gcGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiYgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0O1xuICB9O1xufSgpIDpcblxuLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbmZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn0oKTtcblxuLy8gYnRvYSBwb2x5ZmlsbCBmb3IgSUU8MTAgY291cnRlc3kgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkY2hhbWJlcnMvQmFzZTY0LmpzXG5cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbmZ1bmN0aW9uIEUoKSB7XG4gIHRoaXMubWVzc2FnZSA9ICdTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXInO1xufVxuRS5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbkUucHJvdG90eXBlLmNvZGUgPSA1O1xuRS5wcm90b3R5cGUubmFtZSA9ICdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InO1xuXG5mdW5jdGlvbiBidG9hKGlucHV0KSB7XG4gIHZhciBzdHIgPSBTdHJpbmcoaW5wdXQpO1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIGZvciAoXG4gIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyXG4gIHZhciBibG9jaywgY2hhckNvZGUsIGlkeCA9IDAsIG1hcCA9IGNoYXJzO1xuICAvLyBpZiB0aGUgbmV4dCBzdHIgaW5kZXggZG9lcyBub3QgZXhpc3Q6XG4gIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gIC8vICAgY2hlY2sgaWYgZCBoYXMgbm8gZnJhY3Rpb25hbCBkaWdpdHNcbiAgc3RyLmNoYXJBdChpZHggfCAwKSB8fCAobWFwID0gJz0nLCBpZHggJSAxKTtcbiAgLy8gXCI4IC0gaWR4ICUgMSAqIDhcIiBnZW5lcmF0ZXMgdGhlIHNlcXVlbmNlIDIsIDQsIDYsIDhcbiAgb3V0cHV0ICs9IG1hcC5jaGFyQXQoNjMgJiBibG9jayA+PiA4IC0gaWR4ICUgMSAqIDgpKSB7XG4gICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpZHggKz0gMyAvIDQpO1xuICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgIHRocm93IG5ldyBFKCk7XG4gICAgfVxuICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbnZhciBidG9hXzEgPSBidG9hO1xuXG52YXIgY29va2llcyA9IHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4vLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbmZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgcmV0dXJuIHtcbiAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICB2YXIgY29va2llID0gW107XG4gICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgfVxuXG4gICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICB9LFxuXG4gICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgcmV0dXJuIG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGw7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgfVxuICB9O1xufSgpIDpcblxuLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICByZXR1cm4ge1xuICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgfTtcbn0oKTtcblxudmFyIGJ0b2EkMSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5idG9hICYmIHdpbmRvdy5idG9hLmJpbmQod2luZG93KSB8fCBidG9hXzE7XG5cbnZhciB4aHIgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgdmFyIGxvYWRFdmVudCA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xuICAgIHZhciB4RG9tYWluID0gZmFsc2U7XG5cbiAgICAvLyBGb3IgSUUgOC85IENPUlMgc3VwcG9ydFxuICAgIC8vIE9ubHkgc3VwcG9ydHMgUE9TVCBhbmQgR0VUIGNhbGxzIGFuZCBkb2Vzbid0IHJldHVybnMgdGhlIHJlc3BvbnNlIGhlYWRlcnMuXG4gICAgLy8gRE9OJ1QgZG8gdGhpcyBmb3IgdGVzdGluZyBiL2MgWE1MSHR0cFJlcXVlc3QgaXMgbW9ja2VkLCBub3QgWERvbWFpblJlcXVlc3QuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlhEb21haW5SZXF1ZXN0ICYmICEoJ3dpdGhDcmVkZW50aWFscycgaW4gcmVxdWVzdCkgJiYgIWlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkge1xuICAgICAgcmVxdWVzdCA9IG5ldyB3aW5kb3cuWERvbWFpblJlcXVlc3QoKTtcbiAgICAgIGxvYWRFdmVudCA9ICdvbmxvYWQnO1xuICAgICAgeERvbWFpbiA9IHRydWU7XG4gICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiBoYW5kbGVQcm9ncmVzcygpIHt9O1xuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge307XG4gICAgfVxuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCB8fCAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EkMSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0W2xvYWRFdmVudF0gPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCAmJiAheERvbWFpbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAvLyBJRSBzZW5kcyAxMjIzIGluc3RlYWQgb2YgMjA0IChodHRwczovL2dpdGh1Yi5jb20vYXhpb3MvYXhpb3MvaXNzdWVzLzIwMSlcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1cyA9PT0gMTIyMyA/ICdObyBDb250ZW50JyA6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgdmFyIGNvb2tpZXMkJDEgPSBjb29raWVzO1xuXG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oY29uZmlnLnVybCkpICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSA/IGNvb2tpZXMkJDEucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIERPTUV4Y2VwdGlvbiB0aHJvd24gYnkgYnJvd3NlcnMgbm90IGNvbXBhdGlibGUgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cbiAgICAgICAgLy8gQnV0LCB0aGlzIGNhbiBiZSBzdXBwcmVzc2VkIGZvciAnanNvbicgdHlwZSBhcyBpdCBjYW4gYmUgcGFyc2VkIGJ5IGRlZmF1bHQgJ3RyYW5zZm9ybVJlc3BvbnNlJyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdERhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHhocjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHhocjtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fCB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8IHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8IHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8IHV0aWxzLmlzRmlsZShkYXRhKSB8fCB1dGlscy5pc0Jsb2IoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gX0pTT04kc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7LyogSWdub3JlICovfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfVxufTtcblxuZGVmYXVsdHMuaGVhZGVycyA9IHtcbiAgY29tbW9uOiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbnZhciBkZWZhdWx0c18xID0gZGVmYXVsdHM7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyXzEgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xudmFyIHRyYW5zZm9ybURhdGEgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbihkYXRhLCBoZWFkZXJzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuXG52YXIgaXNDYW5jZWwgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cblxudmFyIGlzQWJzb2x1dGVVUkwgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuICgvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKVxuICApO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5cbnZhciBjb21iaW5lVVJMcyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTCA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKSA6IGJhc2VVUkw7XG59O1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gU3VwcG9ydCBiYXNlVVJMIGNvbmZpZ1xuICBpZiAoY29uZmlnLmJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwoY29uZmlnLnVybCkpIHtcbiAgICBjb25maWcudXJsID0gY29tYmluZVVSTHMoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICB9XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YShjb25maWcuZGF0YSwgY29uZmlnLmhlYWRlcnMsIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0KTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LCBjb25maWcuaGVhZGVycyB8fCB7fSk7XG5cbiAgdXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSwgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gIH0pO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHNfMS5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShyZXNwb25zZS5kYXRhLCByZXNwb25zZS5oZWFkZXJzLCBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UpO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEocmVhc29uLnJlc3BvbnNlLmRhdGEsIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLCBjb25maWcudHJhbnNmb3JtUmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXJfMSgpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyXzEoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IHV0aWxzLm1lcmdlKHtcbiAgICAgIHVybDogYXJndW1lbnRzWzBdXG4gICAgfSwgYXJndW1lbnRzWzFdKTtcbiAgfVxuXG4gIGNvbmZpZyA9IHV0aWxzLm1lcmdlKGRlZmF1bHRzXzEsIHsgbWV0aG9kOiAnZ2V0JyB9LCB0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIEhvb2sgdXAgaW50ZXJjZXB0b3JzIG1pZGRsZXdhcmVcbiAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcbiAgdmFyIHByb21pc2UgPSBfUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAodXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybFxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG52YXIgQXhpb3NfMSA9IEF4aW9zO1xuXG4vKipcbiAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG52YXIgQ2FuY2VsXzEgPSBDYW5jZWw7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcbiAgdGhpcy5wcm9taXNlID0gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWxfMShtZXNzYWdlKTtcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gKi9cbkNhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICBjYW5jZWwgPSBjO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogdG9rZW4sXG4gICAgY2FuY2VsOiBjYW5jZWxcbiAgfTtcbn07XG5cbnZhciBDYW5jZWxUb2tlbl8xID0gQ2FuY2VsVG9rZW47XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5cbnZhciBzcHJlYWQgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvc18xKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zXzEucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3NfMS5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0c18xKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zXzE7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UodXRpbHMubWVyZ2UoZGVmYXVsdHNfMSwgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gQ2FuY2VsXzE7XG5heGlvcy5DYW5jZWxUb2tlbiA9IENhbmNlbFRva2VuXzE7XG5heGlvcy5pc0NhbmNlbCA9IGlzQ2FuY2VsO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBfUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHNwcmVhZDtcblxudmFyIGF4aW9zXzEgPSBheGlvcztcblxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG52YXIgZGVmYXVsdF8xID0gYXhpb3M7XG5heGlvc18xLmRlZmF1bHQgPSBkZWZhdWx0XzE7XG5cbnZhciBheGlvcyQxID0gYXhpb3NfMTtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbnZhciBfY29weUFycmF5ID0gY29weUFycmF5O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciByZXR1cm5pbmdcbiAqIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBUaGUgbG93ZXIgYm91bmQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbn1cblxudmFyIF9iYXNlUmFuZG9tID0gYmFzZVJhbmRvbTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgd2hpY2ggbXV0YXRlcyBhbmQgc2V0cyB0aGUgc2l6ZSBvZiBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT1hcnJheS5sZW5ndGhdIFRoZSBzaXplIG9mIGBhcnJheWAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gc2h1ZmZsZVNlbGYoYXJyYXksIHNpemUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gIHNpemUgPSBzaXplID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBzaXplO1xuICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHtcbiAgICB2YXIgcmFuZCA9IF9iYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuXG4gICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gIH1cbiAgYXJyYXkubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG52YXIgX3NodWZmbGVTZWxmID0gc2h1ZmZsZVNlbGY7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIGZvciBhcnJheXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICByZXR1cm4gX3NodWZmbGVTZWxmKF9jb3B5QXJyYXkoYXJyYXkpKTtcbn1cblxudmFyIF9hcnJheVNodWZmbGUgPSBhcnJheVNodWZmbGU7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfYXJyYXlNYXAgPSBhcnJheU1hcDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gX2FycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG52YXIgX2Jhc2VWYWx1ZXMgPSBiYXNlVmFsdWVzO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VUaW1lcyA9IGJhc2VUaW1lcztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGNvbW1vbmpzR2xvYmFsO1xuXG52YXIgX2ZyZWVHbG9iYWwgPSBmcmVlR2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBfZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgX3Jvb3QgPSByb290O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wkMSA9IF9yb290LlN5bWJvbDtcblxudmFyIF9TeW1ib2wkMSA9IFN5bWJvbCQxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQxID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IF9TeW1ib2wkMSA/IF9TeW1ib2wkMS50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkkMS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2dldFJhd1RhZyA9IGdldFJhd1RhZztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDEgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmckMSA9IG9iamVjdFByb3RvJDEudG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmckMS5jYWxsKHZhbHVlKTtcbn1cblxudmFyIF9vYmplY3RUb1N0cmluZyA9IG9iamVjdFRvU3RyaW5nO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWckMSA9IF9TeW1ib2wkMSA/IF9TeW1ib2wkMS50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyQxICYmIHN5bVRvU3RyaW5nVGFnJDEgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IF9nZXRSYXdUYWcodmFsdWUpXG4gICAgOiBfb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG52YXIgX2Jhc2VHZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxudmFyIGlzT2JqZWN0TGlrZV8xID0gaXNPYmplY3RMaWtlO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlXzEodmFsdWUpICYmIF9iYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG52YXIgX2Jhc2VJc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDIgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gb2JqZWN0UHJvdG8kMi5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90byQyLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBfYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gX2Jhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2VfMSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkkMi5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxudmFyIGlzQXJndW1lbnRzXzEgPSBpc0FyZ3VtZW50cztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxudmFyIGlzQXJyYXlfMSA9IGlzQXJyYXkkMTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgc3R1YkZhbHNlXzEgPSBzdHViRmFsc2U7XG5cbnZhciBpc0J1ZmZlcl8xJDEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gJ29iamVjdCcgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmICdvYmplY3QnID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gX3Jvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZV8xO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xufSk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxudmFyIF9pc0luZGV4ID0gaXNJbmRleDtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiQxID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVIkMTtcbn1cblxudmFyIGlzTGVuZ3RoXzEgPSBpc0xlbmd0aDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWckMSA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZyQxXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2VfMSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aF8xKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tfYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG52YXIgX2Jhc2VJc1R5cGVkQXJyYXkgPSBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbnZhciBfYmFzZVVuYXJ5ID0gYmFzZVVuYXJ5O1xuXG52YXIgX25vZGVVdGlsID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9ICdvYmplY3QnID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiAnb2JqZWN0JyA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIF9mcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xufSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IF9ub2RlVXRpbCAmJiBfbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IF9iYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBfYmFzZUlzVHlwZWRBcnJheTtcblxudmFyIGlzVHlwZWRBcnJheV8xID0gaXNUeXBlZEFycmF5O1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kMyA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDMgPSBvYmplY3RQcm90byQzLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheV8xKHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzXzEodmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcl8xJDEodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheV8xKHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gX2Jhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkkMy5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIF9pc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9hcnJheUxpa2VLZXlzID0gYXJyYXlMaWtlS2V5cztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDQgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvJDQ7XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxudmFyIF9pc1Byb3RvdHlwZSA9IGlzUHJvdG90eXBlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxudmFyIF9vdmVyQXJnID0gb3ZlckFyZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBfb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxudmFyIF9uYXRpdmVLZXlzID0gbmF0aXZlS2V5cztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDUgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ0ID0gb2JqZWN0UHJvdG8kNS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIV9pc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIF9uYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkkNC5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9iYXNlS2V5cyA9IGJhc2VLZXlzO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCQxKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG52YXIgaXNPYmplY3RfMSA9IGlzT2JqZWN0JDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnJDEgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbiQxKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RfMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gX2Jhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWckMSB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbnZhciBpc0Z1bmN0aW9uXzEgPSBpc0Z1bmN0aW9uJDE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoXzEodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbl8xKHZhbHVlKTtcbn1cblxudmFyIGlzQXJyYXlMaWtlXzEgPSBpc0FycmF5TGlrZTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2VfMShvYmplY3QpID8gX2FycmF5TGlrZUtleXMob2JqZWN0KSA6IF9iYXNlS2V5cyhvYmplY3QpO1xufVxuXG52YXIga2V5c18xID0ga2V5cztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogX2Jhc2VWYWx1ZXMob2JqZWN0LCBrZXlzXzEob2JqZWN0KSk7XG59XG5cbnZhciB2YWx1ZXNfMSA9IHZhbHVlcztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBfc2h1ZmZsZVNlbGYodmFsdWVzXzEoY29sbGVjdGlvbikpO1xufVxuXG52YXIgX2Jhc2VTaHVmZmxlID0gYmFzZVNodWZmbGU7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGVcbiAqIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICB2YXIgZnVuYyA9IGlzQXJyYXlfMShjb2xsZWN0aW9uKSA/IF9hcnJheVNodWZmbGUgOiBfYmFzZVNodWZmbGU7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xufVxuXG52YXIgc2h1ZmZsZV8xID0gc2h1ZmZsZTtcblxuLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG5cblxuXG52YXIgX29iamVjdFNhcCA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKF9jb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICBfZXhwb3J0KF9leHBvcnQuUyArIF9leHBvcnQuRiAqIF9mYWlscyhmdW5jdGlvbiAoKSB7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuXG4vLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG5cbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBfb2JqZWN0R29wZC5mO1xuXG5fb2JqZWN0U2FwKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoX3RvSW9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTtcblxudmFyICRPYmplY3QkMSA9IF9jb3JlLk9iamVjdDtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICByZXR1cm4gJE9iamVjdCQxLmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KTtcbn07XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCBfX2VzTW9kdWxlOiB0cnVlIH07XG59KTtcblxudmFyIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gdW53cmFwRXhwb3J0cyhnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSk7XG5cbnZhciB0b0FycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cblxudmFyIF9mcm9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZnJvbSQxKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpID8gYXJyIDogKDAsIF9mcm9tMi5kZWZhdWx0KShhcnIpO1xufTtcbn0pO1xuXG52YXIgX3RvQXJyYXkgPSB1bndyYXBFeHBvcnRzKHRvQXJyYXkpO1xuXG52YXIgc3RhdGVNYWNoaW5lID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuLypcblxuICBKYXZhc2NyaXB0IFN0YXRlIE1hY2hpbmUgTGlicmFyeSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9qYWtlc2dvcmRvbi9qYXZhc2NyaXB0LXN0YXRlLW1hY2hpbmVcblxuICBDb3B5cmlnaHQgKGMpIDIwMTIsIDIwMTMsIDIwMTQsIDIwMTUsIEpha2UgR29yZG9uIGFuZCBjb250cmlidXRvcnNcbiAgUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIC0gaHR0cHM6Ly9naXRodWIuY29tL2pha2VzZ29yZG9uL2phdmFzY3JpcHQtc3RhdGUtbWFjaGluZS9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbiovXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIFN0YXRlTWFjaGluZSA9IHtcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBWRVJTSU9OOiBcIjIuNC4wXCIsXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgUmVzdWx0OiB7XG4gICAgICBTVUNDRUVERUQ6ICAgIDEsIC8vIHRoZSBldmVudCB0cmFuc2l0aW9uZWQgc3VjY2Vzc2Z1bGx5IGZyb20gb25lIHN0YXRlIHRvIGFub3RoZXJcbiAgICAgIE5PVFJBTlNJVElPTjogMiwgLy8gdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbCBidXQgbm8gc3RhdGUgdHJhbnNpdGlvbiB3YXMgbmVjZXNzYXJ5XG4gICAgICBDQU5DRUxMRUQ6ICAgIDMsIC8vIHRoZSBldmVudCB3YXMgY2FuY2VsbGVkIGJ5IHRoZSBjYWxsZXIgaW4gYSBiZWZvcmVFdmVudCBjYWxsYmFja1xuICAgICAgUEVORElORzogICAgICA0ICAvLyB0aGUgZXZlbnQgaXMgYXN5bmNocm9ub3VzIGFuZCB0aGUgY2FsbGVyIGlzIGluIGNvbnRyb2wgb2Ygd2hlbiB0aGUgdHJhbnNpdGlvbiBvY2N1cnNcbiAgICB9LFxuXG4gICAgRXJyb3I6IHtcbiAgICAgIElOVkFMSURfVFJBTlNJVElPTjogMTAwLCAvLyBjYWxsZXIgdHJpZWQgdG8gZmlyZSBhbiBldmVudCB0aGF0IHdhcyBpbm5hcHJvcHJpYXRlIGluIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICBQRU5ESU5HX1RSQU5TSVRJT046IDIwMCwgLy8gY2FsbGVyIHRyaWVkIHRvIGZpcmUgYW4gZXZlbnQgd2hpbGUgYW4gYXN5bmMgdHJhbnNpdGlvbiB3YXMgc3RpbGwgcGVuZGluZ1xuICAgICAgSU5WQUxJRF9DQUxMQkFDSzogICAzMDAgLy8gY2FsbGVyIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIHRocmV3IGFuIGV4Y2VwdGlvblxuICAgIH0sXG5cbiAgICBXSUxEQ0FSRDogJyonLFxuICAgIEFTWU5DOiAnYXN5bmMnLFxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNyZWF0ZTogZnVuY3Rpb24oY2ZnLCB0YXJnZXQpIHtcblxuICAgICAgdmFyIGluaXRpYWwgICAgICA9ICh0eXBlb2YgY2ZnLmluaXRpYWwgPT0gJ3N0cmluZycpID8geyBzdGF0ZTogY2ZnLmluaXRpYWwgfSA6IGNmZy5pbml0aWFsOyAvLyBhbGxvdyBmb3IgYSBzaW1wbGUgc3RyaW5nLCBvciBhbiBvYmplY3Qgd2l0aCB7IHN0YXRlOiAnZm9vJywgZXZlbnQ6ICdzZXR1cCcsIGRlZmVyOiB0cnVlfGZhbHNlIH1cbiAgICAgIHZhciB0ZXJtaW5hbCAgICAgPSBjZmcudGVybWluYWwgfHwgY2ZnWydmaW5hbCddO1xuICAgICAgdmFyIGZzbSAgICAgICAgICA9IHRhcmdldCB8fCBjZmcudGFyZ2V0ICB8fCB7fTtcbiAgICAgIHZhciBldmVudHMgICAgICAgPSBjZmcuZXZlbnRzIHx8IFtdO1xuICAgICAgdmFyIGNhbGxiYWNrcyAgICA9IGNmZy5jYWxsYmFja3MgfHwge307XG4gICAgICB2YXIgbWFwICAgICAgICAgID0ge307IC8vIHRyYWNrIHN0YXRlIHRyYW5zaXRpb25zIGFsbG93ZWQgZm9yIGFuIGV2ZW50IHsgZXZlbnQ6IHsgZnJvbTogWyB0byBdIH0gfVxuICAgICAgdmFyIHRyYW5zaXRpb25zICA9IHt9OyAvLyB0cmFjayBldmVudHMgYWxsb3dlZCBmcm9tIGEgc3RhdGUgICAgICAgICAgICB7IHN0YXRlOiBbIGV2ZW50IF0gfVxuXG4gICAgICB2YXIgYWRkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZnJvbSA9IEFycmF5LmlzQXJyYXkoZS5mcm9tKSA/IGUuZnJvbSA6IChlLmZyb20gPyBbZS5mcm9tXSA6IFtTdGF0ZU1hY2hpbmUuV0lMRENBUkRdKTsgLy8gYWxsb3cgJ3dpbGRjYXJkJyB0cmFuc2l0aW9uIGlmICdmcm9tJyBpcyBub3Qgc3BlY2lmaWVkXG4gICAgICAgIG1hcFtlLm5hbWVdID0gbWFwW2UubmFtZV0gfHwge307XG4gICAgICAgIGZvciAodmFyIG4gPSAwIDsgbiA8IGZyb20ubGVuZ3RoIDsgbisrKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbnNbZnJvbVtuXV0gPSB0cmFuc2l0aW9uc1tmcm9tW25dXSB8fCBbXTtcbiAgICAgICAgICB0cmFuc2l0aW9uc1tmcm9tW25dXS5wdXNoKGUubmFtZSk7XG5cbiAgICAgICAgICBtYXBbZS5uYW1lXVtmcm9tW25dXSA9IGUudG8gfHwgZnJvbVtuXTsgLy8gYWxsb3cgbm8tb3AgdHJhbnNpdGlvbiBpZiAndG8nIGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50bylcbiAgICAgICAgICB0cmFuc2l0aW9uc1tlLnRvXSA9IHRyYW5zaXRpb25zW2UudG9dIHx8IFtdO1xuICAgICAgfTtcblxuICAgICAgaWYgKGluaXRpYWwpIHtcbiAgICAgICAgaW5pdGlhbC5ldmVudCA9IGluaXRpYWwuZXZlbnQgfHwgJ3N0YXJ0dXAnO1xuICAgICAgICBhZGQoeyBuYW1lOiBpbml0aWFsLmV2ZW50LCBmcm9tOiAnbm9uZScsIHRvOiBpbml0aWFsLnN0YXRlIH0pO1xuICAgICAgfVxuXG4gICAgICBmb3IodmFyIG4gPSAwIDsgbiA8IGV2ZW50cy5sZW5ndGggOyBuKyspXG4gICAgICAgIGFkZChldmVudHNbbl0pO1xuXG4gICAgICBmb3IodmFyIG5hbWUgaW4gbWFwKSB7XG4gICAgICAgIGlmIChtYXAuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgICAgICAgZnNtW25hbWVdID0gU3RhdGVNYWNoaW5lLmJ1aWxkRXZlbnQobmFtZSwgbWFwW25hbWVdKTtcbiAgICAgIH1cblxuICAgICAgZm9yKHZhciBuYW1lIGluIGNhbGxiYWNrcykge1xuICAgICAgICBpZiAoY2FsbGJhY2tzLmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgICAgIGZzbVtuYW1lXSA9IGNhbGxiYWNrc1tuYW1lXTtcbiAgICAgIH1cblxuICAgICAgZnNtLmN1cnJlbnQgICAgID0gJ25vbmUnO1xuICAgICAgZnNtLmlzICAgICAgICAgID0gZnVuY3Rpb24oc3RhdGUpIHsgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3RhdGUpID8gKHN0YXRlLmluZGV4T2YodGhpcy5jdXJyZW50KSA+PSAwKSA6ICh0aGlzLmN1cnJlbnQgPT09IHN0YXRlKTsgfTtcbiAgICAgIGZzbS5jYW4gICAgICAgICA9IGZ1bmN0aW9uKGV2ZW50KSB7IHJldHVybiAhdGhpcy50cmFuc2l0aW9uICYmIChtYXBbZXZlbnRdICE9PSB1bmRlZmluZWQpICYmIChtYXBbZXZlbnRdLmhhc093blByb3BlcnR5KHRoaXMuY3VycmVudCkgfHwgbWFwW2V2ZW50XS5oYXNPd25Qcm9wZXJ0eShTdGF0ZU1hY2hpbmUuV0lMRENBUkQpKTsgfTtcbiAgICAgIGZzbS5jYW5ub3QgICAgICA9IGZ1bmN0aW9uKGV2ZW50KSB7IHJldHVybiAhdGhpcy5jYW4oZXZlbnQpOyB9O1xuICAgICAgZnNtLnRyYW5zaXRpb25zID0gZnVuY3Rpb24oKSAgICAgIHsgcmV0dXJuICh0cmFuc2l0aW9uc1t0aGlzLmN1cnJlbnRdIHx8IFtdKS5jb25jYXQodHJhbnNpdGlvbnNbU3RhdGVNYWNoaW5lLldJTERDQVJEXSB8fCBbXSk7IH07XG4gICAgICBmc20uaXNGaW5pc2hlZCAgPSBmdW5jdGlvbigpICAgICAgeyByZXR1cm4gdGhpcy5pcyh0ZXJtaW5hbCk7IH07XG4gICAgICBmc20uZXJyb3IgICAgICAgPSBjZmcuZXJyb3IgfHwgZnVuY3Rpb24obmFtZSwgZnJvbSwgdG8sIGFyZ3MsIGVycm9yLCBtc2csIGUpIHsgdGhyb3cgZSB8fCBtc2c7IH07IC8vIGRlZmF1bHQgYmVoYXZpb3Igd2hlbiBzb21ldGhpbmcgdW5leHBlY3RlZCBoYXBwZW5zIGlzIHRvIHRocm93IGFuIGV4Y2VwdGlvbiwgYnV0IGNhbGxlciBjYW4gb3ZlcnJpZGUgdGhpcyBiZWhhdmlvciBpZiBkZXNpcmVkIChzZWUgZ2l0aHViIGlzc3VlICMzIGFuZCAjMTcpXG4gICAgICBmc20uc3RhdGVzICAgICAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHRyYW5zaXRpb25zKS5zb3J0KCkgfTtcblxuICAgICAgaWYgKGluaXRpYWwgJiYgIWluaXRpYWwuZGVmZXIpXG4gICAgICAgIGZzbVtpbml0aWFsLmV2ZW50XSgpO1xuXG4gICAgICByZXR1cm4gZnNtO1xuXG4gICAgfSxcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBkb0NhbGxiYWNrOiBmdW5jdGlvbihmc20sIGZ1bmMsIG5hbWUsIGZyb20sIHRvLCBhcmdzKSB7XG4gICAgICBpZiAoZnVuYykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGZzbSwgW25hbWUsIGZyb20sIHRvXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGUpIHtcbiAgICAgICAgICByZXR1cm4gZnNtLmVycm9yKG5hbWUsIGZyb20sIHRvLCBhcmdzLCBTdGF0ZU1hY2hpbmUuRXJyb3IuSU5WQUxJRF9DQUxMQkFDSywgXCJhbiBleGNlcHRpb24gb2NjdXJyZWQgaW4gYSBjYWxsZXItcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb25cIiwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYmVmb3JlQW55RXZlbnQ6ICBmdW5jdGlvbihmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKSB7IHJldHVybiBTdGF0ZU1hY2hpbmUuZG9DYWxsYmFjayhmc20sIGZzbVsnb25iZWZvcmVldmVudCddLCAgICAgICAgICAgICAgICAgICAgICAgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpOyB9LFxuICAgIGFmdGVyQW55RXZlbnQ6ICAgZnVuY3Rpb24oZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncykgeyByZXR1cm4gU3RhdGVNYWNoaW5lLmRvQ2FsbGJhY2soZnNtLCBmc21bJ29uYWZ0ZXJldmVudCddIHx8IGZzbVsnb25ldmVudCddLCAgICAgIG5hbWUsIGZyb20sIHRvLCBhcmdzKTsgfSxcbiAgICBsZWF2ZUFueVN0YXRlOiAgIGZ1bmN0aW9uKGZzbSwgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpIHsgcmV0dXJuIFN0YXRlTWFjaGluZS5kb0NhbGxiYWNrKGZzbSwgZnNtWydvbmxlYXZlc3RhdGUnXSwgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLCBmcm9tLCB0bywgYXJncyk7IH0sXG4gICAgZW50ZXJBbnlTdGF0ZTogICBmdW5jdGlvbihmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKSB7IHJldHVybiBTdGF0ZU1hY2hpbmUuZG9DYWxsYmFjayhmc20sIGZzbVsnb25lbnRlcnN0YXRlJ10gfHwgZnNtWydvbnN0YXRlJ10sICAgICAgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpOyB9LFxuICAgIGNoYW5nZVN0YXRlOiAgICAgZnVuY3Rpb24oZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncykgeyByZXR1cm4gU3RhdGVNYWNoaW5lLmRvQ2FsbGJhY2soZnNtLCBmc21bJ29uY2hhbmdlc3RhdGUnXSwgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsIGZyb20sIHRvLCBhcmdzKTsgfSxcblxuICAgIGJlZm9yZVRoaXNFdmVudDogZnVuY3Rpb24oZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncykgeyByZXR1cm4gU3RhdGVNYWNoaW5lLmRvQ2FsbGJhY2soZnNtLCBmc21bJ29uYmVmb3JlJyArIG5hbWVdLCAgICAgICAgICAgICAgICAgICAgIG5hbWUsIGZyb20sIHRvLCBhcmdzKTsgfSxcbiAgICBhZnRlclRoaXNFdmVudDogIGZ1bmN0aW9uKGZzbSwgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpIHsgcmV0dXJuIFN0YXRlTWFjaGluZS5kb0NhbGxiYWNrKGZzbSwgZnNtWydvbmFmdGVyJyAgKyBuYW1lXSB8fCBmc21bJ29uJyArIG5hbWVdLCBuYW1lLCBmcm9tLCB0bywgYXJncyk7IH0sXG4gICAgbGVhdmVUaGlzU3RhdGU6ICBmdW5jdGlvbihmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKSB7IHJldHVybiBTdGF0ZU1hY2hpbmUuZG9DYWxsYmFjayhmc20sIGZzbVsnb25sZWF2ZScgICsgZnJvbV0sICAgICAgICAgICAgICAgICAgICAgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpOyB9LFxuICAgIGVudGVyVGhpc1N0YXRlOiAgZnVuY3Rpb24oZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncykgeyByZXR1cm4gU3RhdGVNYWNoaW5lLmRvQ2FsbGJhY2soZnNtLCBmc21bJ29uZW50ZXInICArIHRvXSAgIHx8IGZzbVsnb24nICsgdG9dLCAgIG5hbWUsIGZyb20sIHRvLCBhcmdzKTsgfSxcblxuICAgIGJlZm9yZUV2ZW50OiBmdW5jdGlvbihmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKSB7XG4gICAgICBpZiAoKGZhbHNlID09PSBTdGF0ZU1hY2hpbmUuYmVmb3JlVGhpc0V2ZW50KGZzbSwgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpKSB8fFxuICAgICAgICAgIChmYWxzZSA9PT0gU3RhdGVNYWNoaW5lLmJlZm9yZUFueUV2ZW50KCBmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgYWZ0ZXJFdmVudDogZnVuY3Rpb24oZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncykge1xuICAgICAgU3RhdGVNYWNoaW5lLmFmdGVyVGhpc0V2ZW50KGZzbSwgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpO1xuICAgICAgU3RhdGVNYWNoaW5lLmFmdGVyQW55RXZlbnQoIGZzbSwgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpO1xuICAgIH0sXG5cbiAgICBsZWF2ZVN0YXRlOiBmdW5jdGlvbihmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKSB7XG4gICAgICB2YXIgc3BlY2lmaWMgPSBTdGF0ZU1hY2hpbmUubGVhdmVUaGlzU3RhdGUoZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncyksXG4gICAgICAgICAgZ2VuZXJhbCAgPSBTdGF0ZU1hY2hpbmUubGVhdmVBbnlTdGF0ZSggZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncyk7XG4gICAgICBpZiAoKGZhbHNlID09PSBzcGVjaWZpYykgfHwgKGZhbHNlID09PSBnZW5lcmFsKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgZWxzZSBpZiAoKFN0YXRlTWFjaGluZS5BU1lOQyA9PT0gc3BlY2lmaWMpIHx8IChTdGF0ZU1hY2hpbmUuQVNZTkMgPT09IGdlbmVyYWwpKVxuICAgICAgICByZXR1cm4gU3RhdGVNYWNoaW5lLkFTWU5DO1xuICAgIH0sXG5cbiAgICBlbnRlclN0YXRlOiBmdW5jdGlvbihmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKSB7XG4gICAgICBTdGF0ZU1hY2hpbmUuZW50ZXJUaGlzU3RhdGUoZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncyk7XG4gICAgICBTdGF0ZU1hY2hpbmUuZW50ZXJBbnlTdGF0ZSggZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncyk7XG4gICAgfSxcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBidWlsZEV2ZW50OiBmdW5jdGlvbihuYW1lLCBtYXApIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgZnJvbSAgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIHZhciB0byAgICA9IG1hcFtmcm9tXSB8fCAobWFwW1N0YXRlTWFjaGluZS5XSUxEQ0FSRF0gIT0gU3RhdGVNYWNoaW5lLldJTERDQVJEID8gbWFwW1N0YXRlTWFjaGluZS5XSUxEQ0FSRF0gOiBmcm9tKSB8fCBmcm9tO1xuICAgICAgICB2YXIgYXJncyAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpOyAvLyB0dXJuIGFyZ3VtZW50cyBpbnRvIHB1cmUgYXJyYXlcblxuICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uKVxuICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKG5hbWUsIGZyb20sIHRvLCBhcmdzLCBTdGF0ZU1hY2hpbmUuRXJyb3IuUEVORElOR19UUkFOU0lUSU9OLCBcImV2ZW50IFwiICsgbmFtZSArIFwiIGluYXBwcm9wcmlhdGUgYmVjYXVzZSBwcmV2aW91cyB0cmFuc2l0aW9uIGRpZCBub3QgY29tcGxldGVcIik7XG5cbiAgICAgICAgaWYgKHRoaXMuY2Fubm90KG5hbWUpKVxuICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKG5hbWUsIGZyb20sIHRvLCBhcmdzLCBTdGF0ZU1hY2hpbmUuRXJyb3IuSU5WQUxJRF9UUkFOU0lUSU9OLCBcImV2ZW50IFwiICsgbmFtZSArIFwiIGluYXBwcm9wcmlhdGUgaW4gY3VycmVudCBzdGF0ZSBcIiArIHRoaXMuY3VycmVudCk7XG5cbiAgICAgICAgaWYgKGZhbHNlID09PSBTdGF0ZU1hY2hpbmUuYmVmb3JlRXZlbnQodGhpcywgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpKVxuICAgICAgICAgIHJldHVybiBTdGF0ZU1hY2hpbmUuUmVzdWx0LkNBTkNFTExFRDtcblxuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICBTdGF0ZU1hY2hpbmUuYWZ0ZXJFdmVudCh0aGlzLCBuYW1lLCBmcm9tLCB0bywgYXJncyk7XG4gICAgICAgICAgcmV0dXJuIFN0YXRlTWFjaGluZS5SZXN1bHQuTk9UUkFOU0lUSU9OO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJlcGFyZSBhIHRyYW5zaXRpb24gbWV0aG9kIGZvciB1c2UgRUlUSEVSIGxvd2VyIGRvd24sIG9yIGJ5IGNhbGxlciBpZiB0aGV5IHdhbnQgYW4gYXN5bmMgdHJhbnNpdGlvbiAoaW5kaWNhdGVkIGJ5IGFuIEFTWU5DIHJldHVybiB2YWx1ZSBmcm9tIGxlYXZlU3RhdGUpXG4gICAgICAgIHZhciBmc20gPSB0aGlzO1xuICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmc20udHJhbnNpdGlvbiA9IG51bGw7IC8vIHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGV2ZXIgYmUgY2FsbGVkIG9uY2VcbiAgICAgICAgICBmc20uY3VycmVudCA9IHRvO1xuICAgICAgICAgIFN0YXRlTWFjaGluZS5lbnRlclN0YXRlKCBmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKTtcbiAgICAgICAgICBTdGF0ZU1hY2hpbmUuY2hhbmdlU3RhdGUoZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncyk7XG4gICAgICAgICAgU3RhdGVNYWNoaW5lLmFmdGVyRXZlbnQoIGZzbSwgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpO1xuICAgICAgICAgIHJldHVybiBTdGF0ZU1hY2hpbmUuUmVzdWx0LlNVQ0NFRURFRDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uLmNhbmNlbCA9IGZ1bmN0aW9uKCkgeyAvLyBwcm92aWRlIGEgd2F5IGZvciBjYWxsZXIgdG8gY2FuY2VsIGFzeW5jIHRyYW5zaXRpb24gaWYgZGVzaXJlZCAoaXNzdWUgIzIyKVxuICAgICAgICAgIGZzbS50cmFuc2l0aW9uID0gbnVsbDtcbiAgICAgICAgICBTdGF0ZU1hY2hpbmUuYWZ0ZXJFdmVudChmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbGVhdmUgPSBTdGF0ZU1hY2hpbmUubGVhdmVTdGF0ZSh0aGlzLCBuYW1lLCBmcm9tLCB0bywgYXJncyk7XG4gICAgICAgIGlmIChmYWxzZSA9PT0gbGVhdmUpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSBudWxsO1xuICAgICAgICAgIHJldHVybiBTdGF0ZU1hY2hpbmUuUmVzdWx0LkNBTkNFTExFRDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChTdGF0ZU1hY2hpbmUuQVNZTkMgPT09IGxlYXZlKSB7XG4gICAgICAgICAgcmV0dXJuIFN0YXRlTWFjaGluZS5SZXN1bHQuUEVORElORztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uKSAvLyBuZWVkIHRvIGNoZWNrIGluIGNhc2UgdXNlciBtYW51YWxseSBjYWxsZWQgdHJhbnNpdGlvbigpIGJ1dCBmb3Jnb3QgdG8gcmV0dXJuIFN0YXRlTWFjaGluZS5BU1lOQ1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgIH07XG4gICAgfVxuXG4gIH07IC8vIFN0YXRlTWFjaGluZVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLy89PT09PT1cbiAgLy8gTk9ERVxuICAvLz09PT09PVxuICB7XG4gICAgaWYgKCdvYmplY3QnICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU3RhdGVNYWNoaW5lO1xuICAgIH1cbiAgICBleHBvcnRzLlN0YXRlTWFjaGluZSA9IFN0YXRlTWFjaGluZTtcbiAgfVxuXG59KCkpO1xufSk7XG52YXIgc3RhdGVNYWNoaW5lXzEgPSBzdGF0ZU1hY2hpbmUuU3RhdGVNYWNoaW5lO1xuXG52YXIgZ2V0V2VhayA9IF9tZXRhLmdldFdlYWs7XG5cblxuXG5cblxuXG5cbnZhciBhcnJheUZpbmQgPSBfYXJyYXlNZXRob2RzKDUpO1xudmFyIGFycmF5RmluZEluZGV4ID0gX2FycmF5TWV0aG9kcyg2KTtcbnZhciBpZCQxID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYSA9IFtdO1xufTtcbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYgKH5pbmRleCkgdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG52YXIgX2NvbGxlY3Rpb25XZWFrID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBfYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGlkJDErKzsgICAgICAvLyBjb2xsZWN0aW9uIGlkXG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAvLyBsZWFrIHN0b3JlIGZvciB1bmNhdWdodCBmcm96ZW4gb2JqZWN0c1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgX2Zvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICBfcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIV9pc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoX3ZhbGlkYXRlQ29sbGVjdGlvbih0aGlzLCBOQU1FKSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmIF9oYXMoZGF0YSwgdGhpcy5faSkgJiYgZGVsZXRlIGRhdGFbdGhpcy5faV07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICBpZiAoIV9pc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoX3ZhbGlkYXRlQ29sbGVjdGlvbih0aGlzLCBOQU1FKSkuaGFzKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmIF9oYXMoZGF0YSwgdGhpcy5faSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IGdldFdlYWsoX2FuT2JqZWN0KGtleSksIHRydWUpO1xuICAgIGlmIChkYXRhID09PSB0cnVlKSB1bmNhdWdodEZyb3plblN0b3JlKHRoYXQpLnNldChrZXksIHZhbHVlKTtcbiAgICBlbHNlIGRhdGFbdGhhdC5faV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhhdDtcbiAgfSxcbiAgdWZzdG9yZTogdW5jYXVnaHRGcm96ZW5TdG9yZVxufTtcblxudmFyIGVzNl93ZWFrTWFwID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xudmFyIGVhY2ggPSBfYXJyYXlNZXRob2RzKDApO1xuXG5cblxuXG5cblxuXG52YXIgV0VBS19NQVAgPSAnV2Vha01hcCc7XG52YXIgZ2V0V2VhayA9IF9tZXRhLmdldFdlYWs7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gX2NvbGxlY3Rpb25XZWFrLnVmc3RvcmU7XG52YXIgdG1wID0ge307XG52YXIgSW50ZXJuYWxNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07XG5cbnZhciBtZXRob2RzID0ge1xuICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAoX2lzT2JqZWN0KGtleSkpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKF92YWxpZGF0ZUNvbGxlY3Rpb24odGhpcywgV0VBS19NQVApKS5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gZGF0YVt0aGlzLl9pXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIF9jb2xsZWN0aW9uV2Vhay5kZWYoX3ZhbGlkYXRlQ29sbGVjdGlvbih0aGlzLCBXRUFLX01BUCksIGtleSwgdmFsdWUpO1xuICB9XG59O1xuXG4vLyAyMy4zIFdlYWtNYXAgT2JqZWN0c1xudmFyICRXZWFrTWFwID0gbW9kdWxlLmV4cG9ydHMgPSBfY29sbGVjdGlvbihXRUFLX01BUCwgd3JhcHBlciwgbWV0aG9kcywgX2NvbGxlY3Rpb25XZWFrLCB0cnVlLCB0cnVlKTtcblxuLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuaWYgKF9mYWlscyhmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgJFdlYWtNYXAoKS5zZXQoKE9iamVjdC5mcmVlemUgfHwgT2JqZWN0KSh0bXApLCA3KS5nZXQodG1wKSAhPSA3OyB9KSkge1xuICBJbnRlcm5hbE1hcCA9IF9jb2xsZWN0aW9uV2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBXRUFLX01BUCk7XG4gIF9vYmplY3RBc3NpZ24oSW50ZXJuYWxNYXAucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgX21ldGEuTkVFRCA9IHRydWU7XG4gIGVhY2goWydkZWxldGUnLCAnaGFzJywgJ2dldCcsICdzZXQnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBwcm90byA9ICRXZWFrTWFwLnByb3RvdHlwZTtcbiAgICB2YXIgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICBfcmVkZWZpbmUocHJvdG8sIGtleSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYgKF9pc09iamVjdChhKSAmJiAhaXNFeHRlbnNpYmxlKGEpKSB7XG4gICAgICAgIGlmICghdGhpcy5fZikgdGhpcy5fZiA9IG5ldyBJbnRlcm5hbE1hcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZltrZXldKGEsIGIpO1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzZXQnID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxuICAgICAgfSByZXR1cm4gbWV0aG9kLmNhbGwodGhpcywgYSwgYik7XG4gICAgfSk7XG4gIH0pO1xufVxufSk7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAub2Zcbl9zZXRDb2xsZWN0aW9uT2YoJ1dlYWtNYXAnKTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5mcm9tXG5fc2V0Q29sbGVjdGlvbkZyb20oJ1dlYWtNYXAnKTtcblxudmFyIHdlYWtNYXAgPSBfY29yZS5XZWFrTWFwO1xuXG52YXIgd2Vha01hcCQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiB3ZWFrTWFwLCBfX2VzTW9kdWxlOiB0cnVlIH07XG59KTtcblxudmFyIF9XZWFrTWFwID0gdW53cmFwRXhwb3J0cyh3ZWFrTWFwJDEpO1xuXG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuX2V4cG9ydChfZXhwb3J0LlMgKyBfZXhwb3J0LkYgKiAhX2Rlc2NyaXB0b3JzLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogX29iamVjdERwLmYgfSk7XG5cbnZhciAkT2JqZWN0JDIgPSBfY29yZS5PYmplY3Q7XG52YXIgZGVmaW5lUHJvcGVydHkkMSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpIHtcbiAgcmV0dXJuICRPYmplY3QkMi5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBkZWZpbmVQcm9wZXJ0eSQxLCBfX2VzTW9kdWxlOiB0cnVlIH07XG59KTtcblxudmFyIF9PYmplY3QkZGVmaW5lUHJvcGVydHkgPSB1bndyYXBFeHBvcnRzKGRlZmluZVByb3BlcnR5JDIpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkkMyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChkZWZpbmVQcm9wZXJ0eSQyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG59KTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHVud3JhcEV4cG9ydHMoZGVmaW5lUHJvcGVydHkkMyk7XG5cbi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxuXG5cblxuX29iamVjdFNhcCgna2V5cycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gX29iamVjdEtleXMoX3RvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxudmFyIGtleXMkMSA9IF9jb3JlLk9iamVjdC5rZXlzO1xuXG52YXIga2V5cyQyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBrZXlzJDEsIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0pO1xuXG52YXIgX09iamVjdCRrZXlzID0gdW53cmFwRXhwb3J0cyhrZXlzJDIpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBfb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbnZhciBfZ2V0UHJvdG90eXBlID0gZ2V0UHJvdG90eXBlO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnJDEgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byQ2ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkNSA9IG9iamVjdFByb3RvJDYuaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZV8xKHZhbHVlKSB8fCBfYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnJDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gX2dldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkkNS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG52YXIgaXNQbGFpbk9iamVjdF8xID0gaXNQbGFpbk9iamVjdDtcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBnbG9iYWwkMSA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fTtcblxudmFyIGNyZWF0ZUNsYXNzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGRlZmluZVByb3BlcnR5JDIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gdW53cmFwRXhwb3J0cyhjcmVhdGVDbGFzcyk7XG5cbnZhciBFWFBJUkVEID0gX1N5bWJvbCgnZXhwaXJlZCcpO1xudmFyIGRlYnVnJDEgPSBicm93c2VyKCdMQzpFeHBpcmFibGUnKTtcblxudmFyIEV4cGlyYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXhwaXJhYmxlKHZhbHVlLCB0dGwpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXhwaXJhYmxlKTtcblxuICAgIHRoaXMub3JpZ2luYWxWYWx1ZSA9IHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdHRsID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5leHBpcmVkQXQgPSBEYXRlLm5vdygpICsgdHRsO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFeHBpcmFibGUsIFt7XG4gICAga2V5OiAndmFsdWUnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGV4cGlyZWQgPSB0aGlzLmV4cGlyZWRBdCAmJiB0aGlzLmV4cGlyZWRBdCA8PSBEYXRlLm5vdygpO1xuICAgICAgaWYgKGV4cGlyZWQpIGRlYnVnJDEoJ2V4cGlyZWQ6ICcgKyB0aGlzLm9yaWdpbmFsVmFsdWUpO1xuICAgICAgcmV0dXJuIGV4cGlyZWQgPyBFWFBJUkVEIDogdGhpcy5vcmlnaW5hbFZhbHVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFeHBpcmFibGU7XG59KCk7XG5cbkV4cGlyYWJsZS5FWFBJUkVEID0gRVhQSVJFRDtcblxudmFyIGRlYnVnJDIgPSBicm93c2VyKCdMQzpDYWNoZScpO1xuXG52YXIgQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENhY2hlKCkge1xuICAgIHZhciBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnYW5vbnltb3VzJztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYWNoZSk7XG5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuX21hcCA9IHt9O1xuICB9XG5cbiAgQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLl9tYXBba2V5XTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGNhY2hlLnZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUgIT09IEV4cGlyYWJsZS5FWFBJUkVEKSB7XG4gICAgICAgIGRlYnVnJDIoJ1slc10gaGl0OiAlcycsIHRoaXMubmFtZSwga2V5KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuX21hcFtrZXldO1xuICAgIH1cbiAgICBkZWJ1ZyQyKCdbJyArIHRoaXMubmFtZSArICddIG1pc3NlZDogJyArIGtleSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgQ2FjaGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlLCB0dGwpIHtcbiAgICBkZWJ1ZyQyKCdbJXNdIHNldDogJXMgJW8gJWQnLCB0aGlzLm5hbWUsIGtleSwgdmFsdWUsIHR0bCk7XG4gICAgdGhpcy5fbWFwW2tleV0gPSBuZXcgRXhwaXJhYmxlKHZhbHVlLCB0dGwpO1xuICB9O1xuXG4gIHJldHVybiBDYWNoZTtcbn0oKTtcblxudmFyIHRyeUFsbCA9IGZ1bmN0aW9uIHRyeUFsbChwcm9taXNlQ29uc3RydWN0b3JzKSB7XG4gIHZhciBwcm9taXNlID0gbmV3IF9Qcm9taXNlKHByb21pc2VDb25zdHJ1Y3RvcnNbMF0pO1xuICBpZiAocHJvbWlzZUNvbnN0cnVjdG9ycy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICByZXR1cm4gcHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRyeUFsbChwcm9taXNlQ29uc3RydWN0b3JzLnNsaWNlKDEpKTtcbiAgfSk7XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG52YXIgdGFwID0gZnVuY3Rpb24gdGFwKGludGVyY2VwdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJjZXB0b3IodmFsdWUpLCB2YWx1ZTtcbiAgfTtcbn07XG5cbnZhciBmaW5hbGl6ZSA9IGZ1bmN0aW9uIGZpbmFsaXplKGNhbGxiYWNrKSB7XG4gIHJldHVybiBbXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZXF1ZW5jZXNcbiAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCksIHZhbHVlO1xuICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIHRocm93IGVycm9yO1xuICB9XTtcbn07XG5cbi8qKlxuICog5bCG5a+56LGh6L2s5o2i5Li6IERhdGXvvIzmlK/mjIEgc3RyaW5n44CBbnVtYmVy44CBUHJvdG9CdWYgTG9uZyDku6Xlj4ogTGVhbkNsb3VkIOeahCBEYXRlIOexu+Wei++8jFxuICog5YW25LuW5oOF5Ya15LiL77yI5YyF5ous5a+56LGh5Li6IGZhbHN577yJ6L+U5Zue5Y6f5YC844CCXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZGVjb2RlRGF0ZSA9IGZ1bmN0aW9uIGRlY29kZURhdGUoZGF0ZSkge1xuICBpZiAoIWRhdGUpIHJldHVybiBkYXRlO1xuICBpZiAodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkYXRlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKTtcbiAgfVxuICBpZiAoZGF0ZS5fX3R5cGUgPT09ICdEYXRlJyAmJiBkYXRlLmlzbykge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmlzbyk7XG4gIH1cbiAgLy8gTG9uZ1xuICBpZiAodHlwZW9mIGRhdGUudG9OdW1iZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZS50b051bWJlcigpKTtcbiAgfVxuICByZXR1cm4gZGF0ZTtcbn07XG4vKipcbiAqIOiOt+WPliBEYXRlIOeahOavq+enkuaVsO+8jOWmguaenOS4jeaYr+S4gOS4qiBEYXRlIOi/lOWbniB1bmRlZmluZWTjgIJcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBnZXRUaW1lID0gZnVuY3Rpb24gZ2V0VGltZShkYXRlKSB7XG4gIHJldHVybiBkYXRlICYmIGRhdGUuZ2V0VGltZSA/IGRhdGUuZ2V0VGltZSgpIDogdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiDop6PnoIHlr7nosaHkuK3nmoQgTGVhbkNsb3VkIOaVsOaNrue7k+aehOOAglxuICog55uu5YmN5LuF5Lya5aSE55CGIERhdGUg57G75Z6L44CCXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHJldHVybiB2YWx1ZTtcbiAgaWYgKHZhbHVlLl9fdHlwZSA9PT0gJ0RhdGUnICYmIHZhbHVlLmlzbykge1xuICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZS5pc28pO1xuICB9XG4gIGlmIChpc1BsYWluT2JqZWN0XzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIF9PYmplY3Qka2V5cyh2YWx1ZSkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGtleSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzJDEoe30sIHJlc3VsdCwgX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIGRlY29kZSh2YWx1ZVtrZXldKSkpO1xuICAgIH0sIHt9KTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuLyoqXG4gKiDlsIblr7nosaHkuK3nmoTnibnmrornsbvlnovnvJbnoIHkuLogTGVhbkNsb3VkIOaVsOaNrue7k+aehOOAglxuICog55uu5YmN5LuF5Lya5aSE55CGIERhdGUg57G75Z6L44CCXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZW5jb2RlJDEgPSBmdW5jdGlvbiBlbmNvZGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHsgX190eXBlOiAnRGF0ZScsIGlzbzogdmFsdWUudG9KU09OKCkgfTtcbiAgaWYgKGlzUGxhaW5PYmplY3RfMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gX09iamVjdCRrZXlzKHZhbHVlKS5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwga2V5KSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMkMSh7fSwgcmVzdWx0LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgZW5jb2RlKHZhbHVlW2tleV0pKSk7XG4gICAgfSwge30pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBrZXlSZW1hcCA9IGZ1bmN0aW9uIGtleVJlbWFwKGtleW1hcCwgb2JqKSB7XG4gIHJldHVybiBfT2JqZWN0JGtleXMob2JqKS5yZWR1Y2UoZnVuY3Rpb24gKG5ld09iaiwga2V5KSB7XG4gICAgdmFyIG5ld0tleSA9IGtleW1hcFtrZXldIHx8IGtleTtcbiAgICByZXR1cm4gX09iamVjdCRhc3NpZ24obmV3T2JqLCBfZGVmaW5lUHJvcGVydHkoe30sIG5ld0tleSwgb2JqW2tleV0pKTtcbiAgfSwge30pO1xufTtcblxudmFyIGlzSUUxMCA9IGdsb2JhbCQxLm5hdmlnYXRvciAmJiBnbG9iYWwkMS5uYXZpZ2F0b3IudXNlckFnZW50ICYmIGdsb2JhbCQxLm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTVNJRSAxMC4nKSAhPT0gLTE7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgZ2V0U3RhdGljUHJvcGVydHkgPSBmdW5jdGlvbiBnZXRTdGF0aWNQcm9wZXJ0eShrbGFzcywgcHJvcGVydHkpIHtcbiAgcmV0dXJuIGtsYXNzW3Byb3BlcnR5XSB8fCAoa2xhc3MuX19wcm90b19fID8gZ2V0U3RhdGljUHJvcGVydHkoa2xhc3MuX19wcm90b19fLCBwcm9wZXJ0eSkgOiB1bmRlZmluZWQpO1xufTtcbi8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cblxudmFyIHVuaW9uID0gZnVuY3Rpb24gdW5pb24oYSwgYikge1xuICByZXR1cm4gX0FycmF5JGZyb20obmV3IF9TZXQoW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhKSwgX3RvQ29uc3VtYWJsZUFycmF5KGIpKSkpO1xufTtcbnZhciBkaWZmZXJlbmNlID0gZnVuY3Rpb24gZGlmZmVyZW5jZShhLCBiKSB7XG4gIHJldHVybiBfQXJyYXkkZnJvbShmdW5jdGlvbiAoYlNldCkge1xuICAgIHJldHVybiBuZXcgX1NldChhLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuICFiU2V0Lmhhcyh4KTtcbiAgICB9KSk7XG4gIH0obmV3IF9TZXQoYikpKTtcbn07XG5cbnZhciBtYXAgPSBuZXcgX1dlYWtNYXAoKTtcblxuLy8gcHJvdGVjdGVkIHByb3BlcnR5IGhlbHBlclxudmFyIGludGVybmFsID0gZnVuY3Rpb24gaW50ZXJuYWwob2JqZWN0KSB7XG4gIGlmICghbWFwLmhhcyhvYmplY3QpKSB7XG4gICAgbWFwLnNldChvYmplY3QsIHt9KTtcbiAgfVxuICByZXR1cm4gbWFwLmdldChvYmplY3QpO1xufTtcblxudmFyIGNvbXBhY3QgPSBmdW5jdGlvbiBjb21wYWN0KG9iaiwgZmlsdGVyKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdF8xKG9iaikpIHJldHVybiBvYmo7XG4gIHZhciBvYmplY3QgPSBfT2JqZWN0JGFzc2lnbih7fSwgb2JqKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gIGZvciAodmFyIHByb3AgaW4gb2JqZWN0KSB7XG4gICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wKSkge1xuICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W3Byb3BdO1xuICAgICAgaWYgKHZhbHVlID09PSBmaWx0ZXIpIHtcbiAgICAgICAgZGVsZXRlIG9iamVjdFtwcm9wXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdFtwcm9wXSA9IGNvbXBhY3QodmFsdWUsIGZpbHRlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG4vLyBkZWJ1ZyB1dGlsaXR5XG52YXIgcmVtb3ZlTnVsbCA9IGZ1bmN0aW9uIHJlbW92ZU51bGwob2JqKSB7XG4gIHJldHVybiBjb21wYWN0KG9iaiwgbnVsbCk7XG59O1xudmFyIHRyaW0kMSA9IGZ1bmN0aW9uIHRyaW0obWVzc2FnZSkge1xuICByZXR1cm4gcmVtb3ZlTnVsbChKU09OLnBhcnNlKF9KU09OJHN0cmluZ2lmeShtZXNzYWdlKSkpO1xufTtcblxudmFyIGVuc3VyZUFycmF5ID0gZnVuY3Rpb24gZW5zdXJlQXJyYXkodGFyZ2V0KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIFt0YXJnZXRdO1xufTtcblxudmFyIHNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gIC8vICcuJyBpcyBub3QgYWxsb3dlZCBpbiBDbGFzcyBrZXlzLCBlc2NhcGluZyBpcyBub3QgaW4gY29uY2VybiBub3cuXG4gIHZhciBzZWdzID0ga2V5LnNwbGl0KCcuJyk7XG4gIHZhciBsYXN0U2VnID0gc2Vncy5wb3AoKTtcbiAgdmFyIGN1cnJlbnRUYXJnZXQgPSB0YXJnZXQ7XG4gIHNlZ3MuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XG4gICAgaWYgKGN1cnJlbnRUYXJnZXRbc2VnXSA9PT0gdW5kZWZpbmVkKSBjdXJyZW50VGFyZ2V0W3NlZ10gPSB7fTtcbiAgICBjdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldFtzZWddO1xuICB9KTtcbiAgY3VycmVudFRhcmdldFtsYXN0U2VnXSA9IHZhbHVlO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGlzV2VhcHAgPVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4odHlwZW9mIHd4ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih3eCkpID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygd3guY29ubmVjdFNvY2tldCA9PT0gJ2Z1bmN0aW9uJztcblxuLy8gdGhyb3R0bGUgZGVjb3JhdG9yXG52YXIgdGhyb3R0bGUgPSBmdW5jdGlvbiB0aHJvdHRsZSh3YWl0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzY3JpcHRvcikge1xuICAgIHZhciBjYWxsYmFjayA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgLy8gdmVyeSBuYWl2ZSwgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICBpZiAoY2FsbGJhY2subGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rocm90dGxlZCBmdW5jdGlvbiBzaG91bGQgbm90IGFjY2VwdCBhbnkgYXJndW1lbnRzJyk7XG4gICAgfVxuICAgIHJldHVybiBfZXh0ZW5kcyQxKHt9LCBkZXNjcmlwdG9yLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIF9pbnRlcm5hbCA9IGludGVybmFsKHRoaXMpLFxuICAgICAgICAgICAgdGhyb3R0bGVNZXRhID0gX2ludGVybmFsLnRocm90dGxlTWV0YTtcblxuICAgICAgICBpZiAoIXRocm90dGxlTWV0YSkge1xuICAgICAgICAgIHRocm90dGxlTWV0YSA9IHt9O1xuICAgICAgICAgIGludGVybmFsKHRoaXMpLnRocm90dGxlTWV0YSA9IHRocm90dGxlTWV0YTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3Rocm90dGxlTWV0YSA9IHRocm90dGxlTWV0YSxcbiAgICAgICAgICAgIHByb3BlcnR5TWV0YSA9IF90aHJvdHRsZU1ldGFbcHJvcGVydHldO1xuXG4gICAgICAgIGlmICghcHJvcGVydHlNZXRhKSB7XG4gICAgICAgICAgcHJvcGVydHlNZXRhID0ge307XG4gICAgICAgICAgdGhyb3R0bGVNZXRhW3Byb3BlcnR5XSA9IHByb3BlcnR5TWV0YTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3Byb3BlcnR5TWV0YSA9IHByb3BlcnR5TWV0YSxcbiAgICAgICAgICAgIF9wcm9wZXJ0eU1ldGEkcHJldmlvdSA9IF9wcm9wZXJ0eU1ldGEucHJldmlvdXNlVGltZXN0YW1wLFxuICAgICAgICAgICAgcHJldmlvdXNlVGltZXN0YW1wID0gX3Byb3BlcnR5TWV0YSRwcmV2aW91ID09PSB1bmRlZmluZWQgPyAwIDogX3Byb3BlcnR5TWV0YSRwcmV2aW91LFxuICAgICAgICAgICAgdGltZW91dCA9IF9wcm9wZXJ0eU1ldGEudGltZW91dDtcblxuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIHJlbWFpbmluZ1RpbWUgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzZVRpbWVzdGFtcCk7XG4gICAgICAgIGlmIChyZW1haW5pbmdUaW1lIDw9IDApIHtcbiAgICAgICAgICB0aHJvdHRsZU1ldGFbcHJvcGVydHldLnByZXZpb3VzZVRpbWVzdGFtcCA9IG5vdztcbiAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGltZW91dCkge1xuICAgICAgICAgIHByb3BlcnR5TWV0YS50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eU1ldGEucHJldmlvdXNlVGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9wZXJ0eU1ldGEudGltZW91dDtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KF90aGlzKTtcbiAgICAgICAgICB9LCByZW1haW5pbmdUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufTtcblxudmFyIFdlYlNvY2tldCA9IGdsb2JhbCQxLldlYlNvY2tldCB8fCBnbG9iYWwkMS5Nb3pXZWJTb2NrZXQ7XG5cbnZhciBfY2xhc3M7XG5cbmZ1bmN0aW9uIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVjb3JhdG9ycywgZGVzY3JpcHRvciwgY29udGV4dCkge1xuICB2YXIgZGVzYyA9IHt9O1xuICBPYmplY3RbJ2tlJyArICd5cyddKGRlc2NyaXB0b3IpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGRlc2Nba2V5XSA9IGRlc2NyaXB0b3Jba2V5XTtcbiAgfSk7XG4gIGRlc2MuZW51bWVyYWJsZSA9ICEhZGVzYy5lbnVtZXJhYmxlO1xuICBkZXNjLmNvbmZpZ3VyYWJsZSA9ICEhZGVzYy5jb25maWd1cmFibGU7XG5cbiAgaWYgKCd2YWx1ZScgaW4gZGVzYyB8fCBkZXNjLmluaXRpYWxpemVyKSB7XG4gICAgZGVzYy53cml0YWJsZSA9IHRydWU7XG4gIH1cblxuICBkZXNjID0gZGVjb3JhdG9ycy5zbGljZSgpLnJldmVyc2UoKS5yZWR1Y2UoZnVuY3Rpb24gKGRlc2MsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eSwgZGVzYykgfHwgZGVzYztcbiAgfSwgZGVzYyk7XG5cbiAgaWYgKGNvbnRleHQgJiYgZGVzYy5pbml0aWFsaXplciAhPT0gdm9pZCAwKSB7XG4gICAgZGVzYy52YWx1ZSA9IGRlc2MuaW5pdGlhbGl6ZXIgPyBkZXNjLmluaXRpYWxpemVyLmNhbGwoY29udGV4dCkgOiB2b2lkIDA7XG4gICAgZGVzYy5pbml0aWFsaXplciA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChkZXNjLmluaXRpYWxpemVyID09PSB2b2lkIDApIHtcbiAgICBPYmplY3RbJ2RlZmluZScgKyAnUHJvcGVydHknXSh0YXJnZXQsIHByb3BlcnR5LCBkZXNjKTtcbiAgICBkZXNjID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBkZXNjO1xufVxuXG52YXIgZGVidWckMyA9IGJyb3dzZXIoJ0xDOldlYlNvY2tldFBsdXMnKTtcblxudmFyIE9QRU4gPSAnb3Blbic7XG52YXIgRElTQ09OTkVDVCA9ICdkaXNjb25uZWN0JztcbnZhciBSRUNPTk5FQ1QgPSAncmVjb25uZWN0JztcbnZhciBSRVRSWSA9ICdyZXRyeSc7XG52YXIgU0NIRURVTEUgPSAnc2NoZWR1bGUnO1xudmFyIE9GRkxJTkUgPSAnb2ZmbGluZSc7XG52YXIgT05MSU5FID0gJ29ubGluZSc7XG52YXIgRVJST1IgPSAnZXJyb3InO1xudmFyIE1FU1NBR0UgPSAnbWVzc2FnZSc7XG5cbnZhciBIRUFSVEJFQVRfVElNRSA9IDE4MDAwMDtcbnZhciBUSU1FT1VUX1RJTUUgPSAzODAwMDA7XG5cbnZhciBERUZBVUxUX1JFVFJZX1NUUkFURUdZID0gZnVuY3Rpb24gREVGQVVMVF9SRVRSWV9TVFJBVEVHWShhdHRlbXB0KSB7XG4gIHJldHVybiBNYXRoLm1pbigxMDAwICogTWF0aC5wb3coMiwgYXR0ZW1wdCksIDMwMDAwMCk7XG59O1xuXG52YXIgcmVxdWlyZUNvbm5lY3RlZCA9IGZ1bmN0aW9uIHJlcXVpcmVDb25uZWN0ZWQodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gIHJldHVybiBfT2JqZWN0JGFzc2lnbih7fSwgZGVzY3JpcHRvciwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiByZXF1aXJlQ29ubmVjdGVkV3JhcHBlcigpIHtcbiAgICAgIHZhciBfZGVzY3JpcHRvciR2YWx1ZTtcblxuICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpb25BdmFpbGFiaWxpdHkobmFtZSk7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoX2Rlc2NyaXB0b3IkdmFsdWUgPSBkZXNjcmlwdG9yLnZhbHVlKS5jYWxsLmFwcGx5KF9kZXNjcmlwdG9yJHZhbHVlLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIFdlYlNvY2tldFBsdXMgPSAoX2NsYXNzID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKFdlYlNvY2tldFBsdXMsIF9FdmVudEVtaXR0ZXIpO1xuXG4gIGZ1bmN0aW9uIFdlYlNvY2tldFBsdXMoZ2V0VXJscywgcHJvdG9jb2wpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViU29ja2V0UGx1cyk7XG5cbiAgICBpZiAodHlwZW9mIFdlYlNvY2tldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIHVuZGVmaW5lZC4gUG9seWZpbGwgaXMgcmVxdWlyZWQgaW4gdGhpcyBydW50aW1lLicpO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSk7XG5cbiAgICBfdGhpcy5pbml0KCk7XG4gICAgX3RoaXMuX3Byb3RvY29sID0gcHJvdG9jb2w7XG4gICAgX1Byb21pc2UucmVzb2x2ZSh0eXBlb2YgZ2V0VXJscyA9PT0gJ2Z1bmN0aW9uJyA/IGdldFVybHMoKSA6IGdldFVybHMpLnRoZW4oZW5zdXJlQXJyYXkpLnRoZW4oZnVuY3Rpb24gKHVybHMpIHtcbiAgICAgIF90aGlzLl91cmxzID0gdXJscztcbiAgICAgIHJldHVybiBfdGhpcy5fb3BlbigpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX19wb3N0cG9uZVRpbWVvdXRUaW1lciA9IF90aGlzLl9wb3N0cG9uZVRpbWVvdXRUaW1lci5iaW5kKF90aGlzKTtcbiAgICAgIGlmIChnbG9iYWwkMS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIF90aGlzLl9fcGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnBhdXNlKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9fcmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZ2xvYmFsJDEuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIF90aGlzLl9fcGF1c2UpO1xuICAgICAgICBnbG9iYWwkMS5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCBfdGhpcy5fX3Jlc3VtZSk7XG4gICAgICB9XG4gICAgICBfdGhpcy5vcGVuKCk7XG4gICAgfSkuY2F0Y2goX3RoaXMudGhyb3cuYmluZChfdGhpcykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFdlYlNvY2tldFBsdXMucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24gX29wZW4oKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlV3ModGhpcy5fdXJscywgdGhpcy5fcHJvdG9jb2wpLnRoZW4oZnVuY3Rpb24gKHdzKSB7XG4gICAgICB2YXIgX3VybHMgPSBfdG9BcnJheShfdGhpczIuX3VybHMpLFxuICAgICAgICAgIGZpcnN0ID0gX3VybHNbMF0sXG4gICAgICAgICAgcmVzZXQgPSBfdXJscy5zbGljZSgxKTtcblxuICAgICAgX3RoaXMyLl91cmxzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXNldCksIFtmaXJzdF0pO1xuICAgICAgcmV0dXJuIHdzO1xuICAgIH0pO1xuICB9O1xuXG4gIFdlYlNvY2tldFBsdXMucHJvdG90eXBlLl9jcmVhdGVXcyA9IGZ1bmN0aW9uIF9jcmVhdGVXcyh1cmxzLCBwcm90b2NvbCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRyeUFsbCh1cmxzLm1hcChmdW5jdGlvbiAodXJsKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBkZWJ1ZyQzKCdjb25uZWN0IFsnICsgdXJsICsgJ10gJyArIHByb3RvY29sKTtcbiAgICAgICAgdmFyIHdzID0gcHJvdG9jb2wgPyBuZXcgV2ViU29ja2V0KHVybCwgcHJvdG9jb2wpIDogbmV3IFdlYlNvY2tldCh1cmwpO1xuICAgICAgICB3cy5iaW5hcnlUeXBlID0gX3RoaXMzLmJpbmFyeVR5cGUgfHwgJ2FycmF5YnVmZmVyJztcbiAgICAgICAgd3Mub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKHdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgd3Mub25jbG9zZSA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaW4gYnJvd3NlciwgZXJyb3IgZXZlbnQgaXMgdXNlbGVzc1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gY29ubmVjdCBbJyArIHVybCArICddJykpO1xuICAgICAgICB9O1xuICAgICAgICB3cy5vbmVycm9yID0gd3Mub25jbG9zZTtcbiAgICAgIH07XG4gICAgfSkpLnRoZW4oZnVuY3Rpb24gKHdzKSB7XG4gICAgICBfdGhpczMuX3dzID0gd3M7XG4gICAgICBfdGhpczMuX3dzLm9uY2xvc2UgPSBfdGhpczMuX2hhbmRsZUNsb3NlLmJpbmQoX3RoaXMzKTtcbiAgICAgIF90aGlzMy5fd3Mub25tZXNzYWdlID0gX3RoaXMzLl9oYW5kbGVNZXNzYWdlLmJpbmQoX3RoaXMzKTtcbiAgICAgIHJldHVybiB3cztcbiAgICB9KTtcbiAgfTtcblxuICBXZWJTb2NrZXRQbHVzLnByb3RvdHlwZS5fZGVzdHJveVdzID0gZnVuY3Rpb24gX2Rlc3Ryb3lXcygpIHtcbiAgICB2YXIgd3MgPSB0aGlzLl93cztcbiAgICBpZiAoIXdzKSByZXR1cm47XG4gICAgd3Mub25vcGVuID0gbnVsbDtcbiAgICB3cy5vbmNsb3NlID0gbnVsbDtcbiAgICB3cy5vbmVycm9yID0gbnVsbDtcbiAgICB3cy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgIHRoaXMuX3dzID0gbnVsbDtcbiAgICB3cy5jbG9zZSgpO1xuICB9O1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG5cblxuICBXZWJTb2NrZXRQbHVzLnByb3RvdHlwZS5vbmJlZm9yZWV2ZW50ID0gZnVuY3Rpb24gb25iZWZvcmVldmVudChldmVudCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBheWxvYWQgPSBBcnJheShfbGVuMiA+IDMgPyBfbGVuMiAtIDMgOiAwKSwgX2tleTIgPSAzOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBwYXlsb2FkW19rZXkyIC0gM10gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGRlYnVnJDMuYXBwbHkodW5kZWZpbmVkLCBbZXZlbnQgKyAnOiAnICsgZnJvbSArICcgLT4gJyArIHRvXS5jb25jYXQocGF5bG9hZCkpO1xuICB9O1xuXG4gIFdlYlNvY2tldFBsdXMucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uIG9ub3BlbigpIHtcbiAgICB0aGlzLmVtaXQoT1BFTik7XG4gIH07XG5cbiAgV2ViU29ja2V0UGx1cy5wcm90b3R5cGUub25jb25uZWN0ZWQgPSBmdW5jdGlvbiBvbmNvbm5lY3RlZCgpIHtcbiAgICB0aGlzLl9zdGFydENvbm5lY3Rpb25LZWVwZXIoKTtcbiAgfTtcblxuICBXZWJTb2NrZXRQbHVzLnByb3RvdHlwZS5vbmxlYXZlY29ubmVjdGVkID0gZnVuY3Rpb24gb25sZWF2ZWNvbm5lY3RlZChldmVudCwgZnJvbSwgdG8pIHtcbiAgICB0aGlzLl9zdG9wQ29ubmVjdGlvbktlZXBlcigpO1xuICAgIHRoaXMuX2Rlc3Ryb3lXcygpO1xuICAgIGlmICh0byA9PT0gJ29mZmxpbmUnIHx8IHRvID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgdGhpcy5lbWl0KERJU0NPTk5FQ1QpO1xuICAgIH1cbiAgfTtcblxuICBXZWJTb2NrZXRQbHVzLnByb3RvdHlwZS5vbnBhdXNlID0gZnVuY3Rpb24gb25wYXVzZSgpIHtcbiAgICB0aGlzLmVtaXQoT0ZGTElORSk7XG4gIH07XG5cbiAgV2ViU29ja2V0UGx1cy5wcm90b3R5cGUub25iZWZvcmVyZXN1bWUgPSBmdW5jdGlvbiBvbmJlZm9yZXJlc3VtZSgpIHtcbiAgICB0aGlzLmVtaXQoT05MSU5FKTtcbiAgfTtcblxuICBXZWJTb2NrZXRQbHVzLnByb3RvdHlwZS5vbnJlY29ubmVjdCA9IGZ1bmN0aW9uIG9ucmVjb25uZWN0KCkge1xuICAgIHRoaXMuZW1pdChSRUNPTk5FQ1QpO1xuICB9O1xuXG4gIFdlYlNvY2tldFBsdXMucHJvdG90eXBlLm9uZGlzY29ubmVjdGVkID0gZnVuY3Rpb24gb25kaXNjb25uZWN0ZWQoZXZlbnQsIGZyb20sIHRvKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgYXR0ZW1wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcblxuICAgIHZhciBkZWxheSA9IERFRkFVTFRfUkVUUllfU1RSQVRFR1kuY2FsbChudWxsLCBhdHRlbXB0KTtcbiAgICBkZWJ1ZyQzKCdzY2hlZHVsZSBhdHRlbXB0PScgKyBhdHRlbXB0ICsgJyBkZWxheT0nICsgZGVsYXkpO1xuICAgIHRoaXMuZW1pdChTQ0hFRFVMRSwgYXR0ZW1wdCwgZGVsYXkpO1xuICAgIGlmICh0aGlzLl9fc2NoZWR1bGVkUmV0cnkpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9fc2NoZWR1bGVkUmV0cnkpO1xuICAgIH1cbiAgICB0aGlzLl9fc2NoZWR1bGVkUmV0cnkgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpczQuaXMoJ2Rpc2Nvbm5lY3RlZCcpKSB7XG4gICAgICAgIF90aGlzNC5yZXRyeShhdHRlbXB0KTtcbiAgICAgIH1cbiAgICB9LCBkZWxheSk7XG4gIH07XG5cbiAgV2ViU29ja2V0UGx1cy5wcm90b3R5cGUub25yZXRyeSA9IGZ1bmN0aW9uIG9ucmV0cnkoZXZlbnQsIGZyb20sIHRvKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICB2YXIgYXR0ZW1wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMDtcblxuICAgIHRoaXMuZW1pdChSRVRSWSwgYXR0ZW1wdCk7XG4gICAgdGhpcy5fb3BlbigpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzNS5jYW4oJ3JlY29ubmVjdCcpID8gX3RoaXM1LnJlY29ubmVjdCgpIDogX3RoaXM1Ll9kZXN0cm95V3MoKTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXM1LmNhbignZmFpbCcpICYmIF90aGlzNS5mYWlsKGF0dGVtcHQgKyAxKTtcbiAgICB9KTtcbiAgfTtcblxuICBXZWJTb2NrZXRQbHVzLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24gb25lcnJvcihldmVudCwgZnJvbSwgdG8sIGVycm9yKSB7XG4gICAgdGhpcy5lbWl0KEVSUk9SLCBlcnJvcik7XG4gIH07XG5cbiAgV2ViU29ja2V0UGx1cy5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGdsb2JhbCQxLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGlmICh0aGlzLl9fcGF1c2UpIGdsb2JhbCQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCB0aGlzLl9fcGF1c2UpO1xuICAgICAgaWYgKHRoaXMuX19yZXN1bWUpIGdsb2JhbCQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMuX19yZXN1bWUpO1xuICAgIH1cbiAgfTtcblxuICBXZWJTb2NrZXRQbHVzLnByb3RvdHlwZS5jaGVja0Nvbm5lY3Rpb25BdmFpbGFiaWxpdHkgPSBmdW5jdGlvbiBjaGVja0Nvbm5lY3Rpb25BdmFpbGFiaWxpdHkoKSB7XG4gICAgdmFyIG5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdBUEknO1xuXG4gICAgaWYgKCF0aGlzLmlzKCdjb25uZWN0ZWQnKSkge1xuICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMuY3VycmVudDtcbiAgICAgIGNvbnNvbGUud2FybihuYW1lICsgJyBzaG91bGQgbm90IGJlIGNhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9uIGlzICcgKyBjdXJyZW50U3RhdGUpO1xuICAgICAgaWYgKHRoaXMuaXMoJ2Rpc2Nvbm5lY3RlZCcpIHx8IHRoaXMuaXMoJ3JlY29ubmVjdGluZycpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignZGlzY29ubmVjdCBhbmQgcmVjb25uZWN0IGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkIHRvIGF2b2lkIHN1Y2ggY2FsbHMuJyk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gdW5hdmFpbGFibGUnKTtcbiAgICB9XG4gIH07XG5cbiAgLy8ganNkb2MtaWdub3JlLXN0YXJ0XG5cblxuICAvLyBqc2RvYy1pZ25vcmUtZW5kXG4gIFdlYlNvY2tldFBsdXMucHJvdG90eXBlLl9waW5nID0gZnVuY3Rpb24gX3BpbmcoKSB7XG4gICAgZGVidWckMygncGluZycpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnBpbmcoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCd3ZWJzb2NrZXQgcGluZyBlcnJvcjogJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcblxuICBXZWJTb2NrZXRQbHVzLnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gcGluZygpIHtcbiAgICBpZiAodGhpcy5fd3MucGluZykge1xuICAgICAgdGhpcy5fd3MucGluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RoZSBXZWJTb2NrZXQgaW1wbGVtZW50IGRvZXMgbm90IHN1cHBvcnQgc2VuZGluZyBwaW5nIGZyYW1lLlxcbiAgICAgICAgT3ZlcnJpZGUgcGluZyBtZXRob2QgdG8gdXNlIGFwcGxpY2F0aW9uIGRlZmluZWQgcGluZy9wb25nIG1lY2hhbmlzbS4nKTtcbiAgICB9XG4gIH07XG5cbiAgV2ViU29ja2V0UGx1cy5wcm90b3R5cGUuX3Bvc3Rwb25lVGltZW91dFRpbWVyID0gZnVuY3Rpb24gX3Bvc3Rwb25lVGltZW91dFRpbWVyKCkge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgZGVidWckMygnX3Bvc3Rwb25lVGltZW91dFRpbWVyJyk7XG4gICAgdGhpcy5fY2xlYXJUaW1lb3V0VGltZXJzKCk7XG4gICAgdGhpcy5fdGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBkZWJ1ZyQzKCd0aW1lb3V0Jyk7XG4gICAgICBfdGhpczYuZGlzY29ubmVjdCgpO1xuICAgIH0sIFRJTUVPVVRfVElNRSk7XG4gIH07XG5cbiAgV2ViU29ja2V0UGx1cy5wcm90b3R5cGUuX2NsZWFyVGltZW91dFRpbWVycyA9IGZ1bmN0aW9uIF9jbGVhclRpbWVvdXRUaW1lcnMoKSB7XG4gICAgaWYgKHRoaXMuX3RpbWVvdXRUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRUaW1lcik7XG4gICAgfVxuICB9O1xuXG4gIFdlYlNvY2tldFBsdXMucHJvdG90eXBlLl9zdGFydENvbm5lY3Rpb25LZWVwZXIgPSBmdW5jdGlvbiBfc3RhcnRDb25uZWN0aW9uS2VlcGVyKCkge1xuICAgIGRlYnVnJDMoJ3N0YXJ0IGNvbm5lY3Rpb24ga2VlcGVyJyk7XG4gICAgdGhpcy5faGVhcnRiZWF0VGltZXIgPSBzZXRJbnRlcnZhbCh0aGlzLl9waW5nLmJpbmQodGhpcyksIEhFQVJUQkVBVF9USU1FKTtcbiAgICB2YXIgYWRkTGlzdGVuZXIgPSB0aGlzLl93cy5hZGRMaXN0ZW5lciB8fCB0aGlzLl93cy5hZGRFdmVudExpc3RlbmVyO1xuICAgIGFkZExpc3RlbmVyLmNhbGwodGhpcy5fd3MsICdtZXNzYWdlJywgdGhpcy5fX3Bvc3Rwb25lVGltZW91dFRpbWVyKTtcbiAgICBhZGRMaXN0ZW5lci5jYWxsKHRoaXMuX3dzLCAncG9uZycsIHRoaXMuX19wb3N0cG9uZVRpbWVvdXRUaW1lcik7XG4gICAgdGhpcy5fcG9zdHBvbmVUaW1lb3V0VGltZXIoKTtcbiAgfTtcblxuICBXZWJTb2NrZXRQbHVzLnByb3RvdHlwZS5fc3RvcENvbm5lY3Rpb25LZWVwZXIgPSBmdW5jdGlvbiBfc3RvcENvbm5lY3Rpb25LZWVwZXIoKSB7XG4gICAgZGVidWckMygnc3RvcCBjb25uZWN0aW9uIGtlZXBlcicpO1xuICAgIC8vIHdlYnNvY2tldHMvd3MjNDg5XG4gICAgdmFyIHJlbW92ZUxpc3RlbmVyID0gdGhpcy5fd3MucmVtb3ZlTGlzdGVuZXIgfHwgdGhpcy5fd3MucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgICByZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMuX3dzLCAnbWVzc2FnZScsIHRoaXMuX19wb3N0cG9uZVRpbWVvdXRUaW1lcik7XG4gICAgcmVtb3ZlTGlzdGVuZXIuY2FsbCh0aGlzLl93cywgJ3BvbmcnLCB0aGlzLl9fcG9zdHBvbmVUaW1lb3V0VGltZXIpO1xuICAgIHRoaXMuX2NsZWFyVGltZW91dFRpbWVycygpO1xuICAgIGlmICh0aGlzLl9oZWFydGJlYXRUaW1lcikge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9oZWFydGJlYXRUaW1lcik7XG4gICAgfVxuICB9O1xuXG4gIFdlYlNvY2tldFBsdXMucHJvdG90eXBlLl9oYW5kbGVDbG9zZSA9IGZ1bmN0aW9uIF9oYW5kbGVDbG9zZShldmVudCkge1xuICAgIGRlYnVnJDMoJ3dzIGNsb3NlZCBbJyArIGV2ZW50LmNvZGUgKyAnXSAnICsgZXZlbnQucmVhc29uKTtcbiAgICAvLyBzb2NrZXQgY2xvc2VkIG1hbnVhbGx5LCBpZ25vcmUgY2xvc2UgZXZlbnQuXG4gICAgaWYgKHRoaXMuaXNGaW5pc2hlZCgpKSByZXR1cm47XG4gICAgdGhpcy5oYW5kbGVDbG9zZShldmVudCk7XG4gIH07XG5cbiAgV2ViU29ja2V0UGx1cy5wcm90b3R5cGUuaGFuZGxlQ2xvc2UgPSBmdW5jdGlvbiBoYW5kbGVDbG9zZSgpIHtcbiAgICAvLyByZWNvbm5lY3RcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgfTtcblxuICAvLyBqc2RvYy1pZ25vcmUtc3RhcnRcblxuXG4gIC8vIGpzZG9jLWlnbm9yZS1lbmRcbiAgV2ViU29ja2V0UGx1cy5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIHNlbmQoZGF0YSkge1xuICAgIGRlYnVnJDMoJ3NlbmQnLCBkYXRhKTtcbiAgICB0aGlzLl93cy5zZW5kKGRhdGEpO1xuICB9O1xuXG4gIFdlYlNvY2tldFBsdXMucHJvdG90eXBlLl9oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gX2hhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICBkZWJ1ZyQzKCdtZXNzYWdlJywgZXZlbnQuZGF0YSk7XG4gICAgdGhpcy5oYW5kbGVNZXNzYWdlKGV2ZW50LmRhdGEpO1xuICB9O1xuXG4gIFdlYlNvY2tldFBsdXMucHJvdG90eXBlLmhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICB0aGlzLmVtaXQoTUVTU0FHRSwgbWVzc2FnZSk7XG4gIH07XG5cbiAgcmV0dXJuIFdlYlNvY2tldFBsdXM7XG59KGV2ZW50ZW1pdHRlcjMpLCBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsICdfcGluZycsIFtyZXF1aXJlQ29ubmVjdGVkXSwgX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX2NsYXNzLnByb3RvdHlwZSwgJ19waW5nJyksIF9jbGFzcy5wcm90b3R5cGUpLCBfYXBwbHlEZWNvcmF0ZWREZXNjcmlwdG9yKF9jbGFzcy5wcm90b3R5cGUsICdzZW5kJywgW3JlcXVpcmVDb25uZWN0ZWRdLCBfT2JqZWN0JGdldE93blByb3BlcnR5RGVzY3JpcHRvcihfY2xhc3MucHJvdG90eXBlLCAnc2VuZCcpLCBfY2xhc3MucHJvdG90eXBlKSwgX2NsYXNzKTtcblxuXG5zdGF0ZU1hY2hpbmUuY3JlYXRlKHtcbiAgdGFyZ2V0OiBXZWJTb2NrZXRQbHVzLnByb3RvdHlwZSxcbiAgaW5pdGlhbDoge1xuICAgIHN0YXRlOiAnaW5pdGlhbGl6ZWQnLFxuICAgIGV2ZW50OiAnaW5pdCcsXG4gICAgZGVmZXI6IHRydWVcbiAgfSxcbiAgdGVybWluYWw6ICdjbG9zZWQnLFxuICBldmVudHM6IFt7XG4gICAgbmFtZTogJ29wZW4nLFxuICAgIGZyb206ICdpbml0aWFsaXplZCcsXG4gICAgdG86ICdjb25uZWN0ZWQnXG4gIH0sIHtcbiAgICBuYW1lOiAnZGlzY29ubmVjdCcsXG4gICAgZnJvbTogJ2Nvbm5lY3RlZCcsXG4gICAgdG86ICdkaXNjb25uZWN0ZWQnXG4gIH0sIHtcbiAgICBuYW1lOiAncmV0cnknLFxuICAgIGZyb206ICdkaXNjb25uZWN0ZWQnLFxuICAgIHRvOiAncmVjb25uZWN0aW5nJ1xuICB9LCB7XG4gICAgbmFtZTogJ2ZhaWwnLFxuICAgIGZyb206ICdyZWNvbm5lY3RpbmcnLFxuICAgIHRvOiAnZGlzY29ubmVjdGVkJ1xuICB9LCB7XG4gICAgbmFtZTogJ3JlY29ubmVjdCcsXG4gICAgZnJvbTogJ3JlY29ubmVjdGluZycsXG4gICAgdG86ICdjb25uZWN0ZWQnXG4gIH0sIHtcbiAgICBuYW1lOiAncGF1c2UnLFxuICAgIGZyb206IFsnY29ubmVjdGVkJywgJ2Rpc2Nvbm5lY3RlZCcsICdyZWNvbm5lY3RpbmcnXSxcbiAgICB0bzogJ29mZmxpbmUnXG4gIH0sIHt9LCB7XG4gICAgbmFtZTogJ3Jlc3VtZScsXG4gICAgZnJvbTogJ29mZmxpbmUnLFxuICAgIHRvOiAnZGlzY29ubmVjdGVkJ1xuICB9LCB7XG4gICAgbmFtZTogJ2Nsb3NlJyxcbiAgICBmcm9tOiBbJ2Nvbm5lY3RlZCcsICdkaXNjb25uZWN0ZWQnLCAncmVjb25uZWN0aW5nJywgJ29mZmxpbmUnXSxcbiAgICB0bzogJ2Nsb3NlZCdcbiAgfSwge1xuICAgIG5hbWU6ICd0aHJvdycsXG4gICAgZnJvbTogJyonLFxuICAgIHRvOiAnZXJyb3InXG4gIH1dXG59KTtcblxuLy8gMTkuMS4yLjUgT2JqZWN0LmZyZWV6ZShPKVxuXG52YXIgbWV0YSA9IF9tZXRhLm9uRnJlZXplO1xuXG5fb2JqZWN0U2FwKCdmcmVlemUnLCBmdW5jdGlvbiAoJGZyZWV6ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZnJlZXplKGl0KSB7XG4gICAgcmV0dXJuICRmcmVlemUgJiYgX2lzT2JqZWN0KGl0KSA/ICRmcmVlemUobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTtcblxudmFyIGZyZWV6ZSA9IF9jb3JlLk9iamVjdC5mcmVlemU7XG5cbnZhciBmcmVlemUkMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogZnJlZXplLCBfX2VzTW9kdWxlOiB0cnVlIH07XG59KTtcblxudmFyIF9PYmplY3QkZnJlZXplID0gdW53cmFwRXhwb3J0cyhmcmVlemUkMSk7XG5cbnZhciBlcnJvciA9IF9PYmplY3QkZnJlZXplKHtcbiAgMTAwMDoge1xuICAgIG5hbWU6ICdDTE9TRV9OT1JNQUwnXG4gIH0sXG4gIDEwMDY6IHtcbiAgICBuYW1lOiAnQ0xPU0VfQUJOT1JNQUwnXG4gIH0sXG4gIDQxMDA6IHtcbiAgICBuYW1lOiAnQVBQX05PVF9BVkFJTEFCTEUnLFxuICAgIG1lc3NhZ2U6ICdBcHAgbm90IGV4aXN0cyBvciByZWFsdGltZSBtZXNzYWdlIHNlcnZpY2UgaXMgZGlzYWJsZWQuJ1xuICB9LFxuICA0MTAyOiB7XG4gICAgbmFtZTogJ1NJR05BVFVSRV9GQUlMRUQnLFxuICAgIG1lc3NhZ2U6ICdMb2dpbiBzaWduYXR1cmUgbWlzbWF0Y2guJ1xuICB9LFxuICA0MTAzOiB7XG4gICAgbmFtZTogJ0lOVkFMSURfTE9HSU4nLFxuICAgIG1lc3NhZ2U6ICdNYWxmb3JtZWQgY2xpZW50SWQuJ1xuICB9LFxuICA0MTA1OiB7XG4gICAgbmFtZTogJ1NFU1NJT05fUkVRVUlSRUQnLFxuICAgIG1lc3NhZ2U6ICdNZXNzYWdlIHNlbnQgYmVmb3JlIHNlc3Npb24gb3BlbmVkLidcbiAgfSxcbiAgNDEwNzoge1xuICAgIG5hbWU6ICdSRUFEX1RJTUVPVVQnXG4gIH0sXG4gIDQxMDg6IHtcbiAgICBuYW1lOiAnTE9HSU5fVElNRU9VVCdcbiAgfSxcbiAgNDEwOToge1xuICAgIG5hbWU6ICdGUkFNRV9UT09fTE9ORydcbiAgfSxcbiAgNDExMDoge1xuICAgIG5hbWU6ICdJTlZBTElEX09SSUdJTicsXG4gICAgbWVzc2FnZTogJ0FjY2VzcyBkZW5pZWQgYnkgZG9tYWluIHdoaXRlbGlzdC4nXG4gIH0sXG4gIDQxMTE6IHtcbiAgICBuYW1lOiAnU0VTU0lPTl9DT05GTElDVCdcbiAgfSxcbiAgNDExMjoge1xuICAgIG5hbWU6ICdTRVNTSU9OX1RPS0VOX0VYUElSRUQnXG4gIH0sXG4gIDQxMTM6IHtcbiAgICBuYW1lOiAnQVBQX1FVT1RBX0VYQ0VFREVEJyxcbiAgICBtZXNzYWdlOiAnVGhlIGRhaWx5IGFjdGl2ZSB1c2VycyBsaW1pdCBleGNlZWRlZC4nXG4gIH0sXG4gIDQxMTY6IHtcbiAgICBuYW1lOiAnTUVTU0FHRV9TRU5UX1FVT1RBX0VYQ0VFREVEJyxcbiAgICBtZXNzYWdlOiAnQ29tbWFuZCBzZW50IHRvbyBmYXN0LidcbiAgfSxcbiAgNDIwMDoge1xuICAgIG5hbWU6ICdJTlRFUk5BTF9FUlJPUicsXG4gICAgbWVzc2FnZTogJ0ludGVybmFsIGVycm9yLCBwbGVhc2UgY29udGFjdCBMZWFuQ2xvdWQgZm9yIHN1cHBvcnQuJ1xuICB9LFxuICA0MzAxOiB7XG4gICAgbmFtZTogJ0NPTlZFUlNBVElPTl9BUElfRkFJTEVEJyxcbiAgICBtZXNzYWdlOiAnVXBzdHJlYW0gQ29udmVyc2F0b2luIEFQSSBmYWlsZWQsIHNlZSBlcnJvci5kZXRhaWwgZm9yIGRldGFpbHMuJ1xuICB9LFxuICA0MzAyOiB7XG4gICAgbmFtZTogJ0NPTlZFUlNBVElPTl9TSUdOQVRVUkVfRkFJTEVEJyxcbiAgICBtZXNzYWdlOiAnQ29udmVyc2F0aW9uIGFjdGlvbiBzaWduYXR1cmUgbWlzbWF0Y2guJ1xuICB9LFxuICA0MzAzOiB7XG4gICAgbmFtZTogJ0NPTlZFUlNBVElPTl9OT1RfRk9VTkQnXG4gIH0sXG4gIDQzMDQ6IHtcbiAgICBuYW1lOiAnQ09OVkVSU0FUSU9OX0ZVTEwnXG4gIH0sXG4gIDQzMDU6IHtcbiAgICBuYW1lOiAnQ09OVkVSU0FUSU9OX1JFSkVDVEVEX0JZX0FQUCcsXG4gICAgbWVzc2FnZTogJ0NvbnZlcnNhdGlvbiBhY3Rpb24gcmVqZWN0ZWQgYnkgaG9vay4nXG4gIH0sXG4gIDQzMDY6IHtcbiAgICBuYW1lOiAnQ09OVkVSU0FUSU9OX1VQREFURV9GQUlMRUQnXG4gIH0sXG4gIDQzMDc6IHtcbiAgICBuYW1lOiAnQ09OVkVSU0FUSU9OX1JFQURfT05MWSdcbiAgfSxcbiAgNDMwODoge1xuICAgIG5hbWU6ICdDT05WRVJTQVRJT05fTk9UX0FMTE9XRUQnXG4gIH0sXG4gIDQzMDk6IHtcbiAgICBuYW1lOiAnQ09OVkVSU0FUSU9OX1VQREFURV9SRUpFQ1RFRCcsXG4gICAgbWVzc2FnZTogJ0NvbnZlcnNhdGlvbiB1cGRhdGUgcmVqZWN0ZWQgYmVjYXVzZSB0aGUgY2xpZW50IGlzIG5vdCBhIG1lbWJlci4nXG4gIH0sXG4gIDQzMTA6IHtcbiAgICBuYW1lOiAnQ09OVkVSU0FUSU9OX1FVRVJZX0ZBSUxFRCcsXG4gICAgbWVzc2FnZTogJ0NvbnZlcnNhdGlvbiBxdWVyeSBmYWlsZWQgYmVjYXVzZSBpdCBpcyB0b28gZXhwYW5zaXZlLidcbiAgfSxcbiAgNDMxMToge1xuICAgIG5hbWU6ICdDT05WRVJTQVRJT05fTE9HX0ZBSUxFRCdcbiAgfSxcbiAgNDMxMjoge1xuICAgIG5hbWU6ICdDT05WRVJTQVRJT05fTE9HX1JFSkVDVEVEJyxcbiAgICBtZXNzYWdlOiAnTWVzc2FnZSBxdWVyeSByZWplY3RlZCBiZWNhdXNlIHRoZSBjbGllbnQgaXMgbm90IGEgbWVtYmVyIG9mIHRoZSBjb252ZXJzYXRpb24uJ1xuICB9LFxuICA0MzEzOiB7XG4gICAgbmFtZTogJ1NZU1RFTV9DT05WRVJTQVRJT05fUkVRVUlSRUQnXG4gIH0sXG4gIDQzMTQ6IHtcbiAgICBuYW1lOiAnTk9STUFMX0NPTlZFUlNBVElPTl9SRVFVSVJFRCdcbiAgfSxcbiAgNDMxNToge1xuICAgIG5hbWU6ICdDT05WRVJTQVRJT05fQkxBQ0tMSVNURUQnLFxuICAgIG1lc3NhZ2U6ICdCbGFja2xpc3RlZCBpbiB0aGUgY29udmVyc2F0aW9uLidcbiAgfSxcbiAgNDMxNjoge1xuICAgIG5hbWU6ICdUUkFOU0lFTlRfQ09OVkVSU0FUSU9OX1JFUVVJUkVEJ1xuICB9LFxuICA0MzE3OiB7XG4gICAgbmFtZTogJ0NPTlZFUlNBVElPTl9NRU1CRVJTSElQX1JFUVVJUkVEJ1xuICB9LFxuICA0MzE4OiB7XG4gICAgbmFtZTogJ0NPTlZFUlNBVElPTl9BUElfUVVPVEFfRVhDRUVERUQnLFxuICAgIG1lc3NhZ2U6ICdMZWFuQ2xvdWQgQVBJIHF1b3RhIGV4Y2VlZGVkLiBZb3UgbWF5IHVwZ3JhZGUgeW91ciBwbGFuLidcbiAgfSxcbiAgNDMyMzoge1xuICAgIG5hbWU6ICdURU1QT1JBUllfQ09OVkVSU0FUSU9OX0VYUElSRUQnLFxuICAgIG1lc3NhZ2U6ICdUZW1wb3JhcnkgY29udmVyc2F0aW9uIGV4cGlyZWQgb3IgZG9lcyBub3QgZXhpc3QuJ1xuICB9LFxuICA0NDAxOiB7XG4gICAgbmFtZTogJ0lOVkFMSURfTUVTU0FHSU5HX1RBUkdFVCcsXG4gICAgbWVzc2FnZTogJ0NvbnZlcnNhdGlvbiBkb2VzIG5vdCBleGlzdCBvciBjbGllbnQgaXMgbm90IGEgbWVtYmVyLidcbiAgfSxcbiAgNDQwMjoge1xuICAgIG5hbWU6ICdNRVNTQUdFX1JFSkVDVEVEX0JZX0FQUCcsXG4gICAgbWVzc2FnZTogJ01lc3NhZ2UgcmVqZWN0ZWQgYnkgaG9vay4nXG4gIH0sXG4gIDQ0MDM6IHtcbiAgICBuYW1lOiAnTUVTU0FHRV9PV05FUlNISVBfUkVRVUlSRUQnXG4gIH0sXG4gIDQ0MDQ6IHtcbiAgICBuYW1lOiAnTUVTU0FHRV9OT1RfRk9VTkQnXG4gIH0sXG4gIDQ0MDU6IHtcbiAgICBuYW1lOiAnTUVTU0FHRV9VUERBVEVfUkVKRUNURURfQllfQVBQJyxcbiAgICBtZXNzYWdlOiAnTWVzc2FnZSB1cGRhdGUgcmVqZWN0ZWQgYnkgaG9vay4nXG4gIH0sXG4gIDQ0MDY6IHtcbiAgICBuYW1lOiAnTUVTU0FHRV9FRElUX0RJU0FCTEVEJ1xuICB9LFxuICA0NDA3OiB7XG4gICAgbmFtZTogJ01FU1NBR0VfUkVDQUxMX0RJU0FCTEVEJ1xuICB9XG59KTtcblxudmFyIEVycm9yQ29kZSA9IF9PYmplY3QkZnJlZXplKF9PYmplY3Qka2V5cyhlcnJvcikucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGNvZGUpIHtcbiAgcmV0dXJuIF9PYmplY3QkYXNzaWduKHJlc3VsdCwgX2RlZmluZVByb3BlcnR5KHt9LCBlcnJvcltjb2RlXS5uYW1lLCBOdW1iZXIoY29kZSkpKTtcbn0sIHt9KSk7XG5cbnZhciBjcmVhdGVFcnJvciQxID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IoX3JlZikge1xuICB2YXIgY29kZSA9IF9yZWYuY29kZSxcbiAgICAgIHJlYXNvbiA9IF9yZWYucmVhc29uLFxuICAgICAgYXBwQ29kZSA9IF9yZWYuYXBwQ29kZSxcbiAgICAgIGRldGFpbCA9IF9yZWYuZGV0YWlsLFxuICAgICAgZXJyb3JNZXNzYWdlID0gX3JlZi5lcnJvcjtcblxuICB2YXIgbWVzc2FnZSA9IHJlYXNvbiB8fCBkZXRhaWwgfHwgZXJyb3JNZXNzYWdlO1xuICB2YXIgbmFtZSA9IHJlYXNvbjtcbiAgaWYgKCFtZXNzYWdlICYmIGVycm9yW2NvZGVdKSB7XG4gICAgbmFtZSA9IGVycm9yW2NvZGVdLm5hbWU7XG5cbiAgICBtZXNzYWdlID0gZXJyb3JbY29kZV0ubWVzc2FnZSB8fCBuYW1lO1xuICB9XG4gIGlmICghbWVzc2FnZSkge1xuICAgIG1lc3NhZ2UgPSAnVW5rbm93IEVycm9yOiAnICsgY29kZTtcbiAgfVxuICB2YXIgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gX09iamVjdCRhc3NpZ24oZXJyLCB7XG4gICAgY29kZTogY29kZSxcbiAgICBhcHBDb2RlOiBhcHBDb2RlLFxuICAgIGRldGFpbDogZGV0YWlsLFxuICAgIG5hbWU6IG5hbWVcbiAgfSk7XG59O1xuXG52YXIgZGVidWckNCA9IGJyb3dzZXIoJ0xDOkNvbm5lY3Rpb24nKTtcblxudmFyIENPTU1BTkRfVElNRU9VVCA9IDIwMDAwO1xuXG52YXIgQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChfV2ViU29ja2V0UGx1cykge1xuICBfaW5oZXJpdHMoQ29ubmVjdGlvbiwgX1dlYlNvY2tldFBsdXMpO1xuXG4gIGZ1bmN0aW9uIENvbm5lY3Rpb24oZ2V0VXJsLCBfcmVmKSB7XG4gICAgdmFyIGZvcm1hdCA9IF9yZWYuZm9ybWF0LFxuICAgICAgICB2ZXJzaW9uID0gX3JlZi52ZXJzaW9uO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbm5lY3Rpb24pO1xuXG4gICAgZGVidWckNCgnaW5pdGlhbGl6aW5nIENvbm5lY3Rpb24nKTtcbiAgICB2YXIgcHJvdG9jb2xTdHJpbmcgPSAnbGMuJyArIGZvcm1hdCArICcuJyArIHZlcnNpb247XG4gICAgaWYgKCFpc1dlYXBwKSB7XG4gICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfV2ViU29ja2V0UGx1cy5jYWxsKHRoaXMsIGdldFVybCwgcHJvdG9jb2xTdHJpbmcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1dlYlNvY2tldFBsdXMuY2FsbCh0aGlzLCBnZXRVcmwoKS50aGVuKGZ1bmN0aW9uICh1cmxzKSB7XG4gICAgICAgIHJldHVybiB1cmxzLm1hcChmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgcmV0dXJuICcnICsgdXJsICsgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArICdzdWJwcm90b2NvbD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHByb3RvY29sU3RyaW5nKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSkpO1xuICAgIH1cbiAgICBfdGhpcy5fcHJvdG9jYWxGb3JtYXQgPSBmb3JtYXQ7XG4gICAgX3RoaXMuX2NvbW1hbmRzID0ge307XG4gICAgX3RoaXMuX3NlcmlhbElkID0gMDtcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xuICB9XG5cbiAgQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShjb21tYW5kKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHdhaXRpbmdGb3JSZXNwb25kID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdmFyIHNlcmlhbElkLCBtZXNzYWdlO1xuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHNlcmlhbElkID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgIGlmICh3YWl0aW5nRm9yUmVzcG9uZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlcmlhbElkICs9IDE7XG4gICAgICAgICAgICAgICAgc2VyaWFsSWQgPSB0aGlzLl9zZXJpYWxJZDtcbiAgICAgICAgICAgICAgICBjb21tYW5kLmkgPSBzZXJpYWxJZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkZWJ1ZyQ0LmVuYWJsZWQpIGRlYnVnJDQoJ+KGkSAlTyBzZW50JywgdHJpbSQxKGNvbW1hbmQpKTtcblxuICAgICAgICAgICAgICBtZXNzYWdlID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9wcm90b2NhbEZvcm1hdCA9PT0gJ3Byb3RvMmJhc2U2NCcpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gY29tbWFuZC50b0Jhc2U2NCgpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmQudG9BcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBjb21tYW5kLnRvQXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvbW1hbmQgKyAnIGlzIG5vdCBhIEdlbmVyaWNDb21tYW5kJyk7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcblxuICAgICAgICAgICAgICBfV2ViU29ja2V0UGx1cy5wcm90b3R5cGUuc2VuZC5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgIGlmICh3YWl0aW5nRm9yUmVzcG9uZCkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIG5ldyBfUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMyLl9jb21tYW5kc1tzZXJpYWxJZF0gPSB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgcmVqZWN0OiByZWplY3QsXG4gICAgICAgICAgICAgICAgICB0aW1lb3V0OiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzMi5fY29tbWFuZHNbc2VyaWFsSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGRlYnVnJDQuZW5hYmxlZCkgZGVidWckNCgn4pyXICVPIHRpbWVvdXQnLCB0cmltJDEoY29tbWFuZCkpO1xuICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChjcmVhdGVFcnJvciQxKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAnQ29tbWFuZCBUaW1lb3V0IFtjbWQ6JyArIGNvbW1hbmQuY21kICsgJyBvcDonICsgY29tbWFuZC5vcCArICddJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdDT01NQU5EX1RJTUVPVVQnXG4gICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpczIuX2NvbW1hbmRzW3NlcmlhbElkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSwgQ09NTUFORF9USU1FT1VUKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBzZW5kKF94Mikge1xuICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbmQ7XG4gIH0oKTtcblxuICBDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShtc2cpIHtcbiAgICB2YXIgbWVzc2FnZSA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgbWVzc2FnZSA9IEdlbmVyaWNDb21tYW5kLmRlY29kZShtc2cpO1xuICAgICAgaWYgKGRlYnVnJDQuZW5hYmxlZCkgZGVidWckNCgn4oaTICVPIHJlY2VpdmVkJywgdHJpbSQxKG1lc3NhZ2UpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0RlY29kZSBtZXNzYWdlIGZhaWxlZCcsIG1zZyk7XG4gICAgfVxuICAgIHZhciBzZXJpYWxJZCA9IG1lc3NhZ2UuaTtcbiAgICBpZiAoc2VyaWFsSWQpIHtcbiAgICAgIGlmICh0aGlzLl9jb21tYW5kc1tzZXJpYWxJZF0pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2NvbW1hbmRzW3NlcmlhbElkXS50aW1lb3V0KTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuY21kID09PSBDb21tYW5kVHlwZS5lcnJvcikge1xuICAgICAgICAgIHRoaXMuX2NvbW1hbmRzW3NlcmlhbElkXS5yZWplY3QoY3JlYXRlRXJyb3IkMShtZXNzYWdlLmVycm9yTWVzc2FnZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2NvbW1hbmRzW3NlcmlhbElkXS5yZXNvbHZlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9jb21tYW5kc1tzZXJpYWxJZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1VuZXhwZWN0ZWQgY29tbWFuZCByZWNlaXZlZCB3aXRoIHNlcmlhbElkIFsnICsgc2VyaWFsSWQgKyAnXSxcXG4gICAgICAgICB3aGljaCBoYXZlIHRpbWVkIG91dCBvciBuZXZlciBiZWVuIHJlcXVlc3RlZC4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UuY21kID09PSBDb21tYW5kVHlwZS5lcnJvcikge1xuICAgICAgdGhpcy5lbWl0KEVSUk9SLCBjcmVhdGVFcnJvciQxKG1lc3NhZ2UuZXJyb3JNZXNzYWdlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdChNRVNTQUdFLCBtZXNzYWdlKTtcbiAgICB9XG4gIH07XG5cbiAgQ29ubmVjdGlvbi5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uIHBpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZChuZXcgR2VuZXJpY0NvbW1hbmQoe1xuICAgICAgY21kOiBDb21tYW5kVHlwZS5lY2hvXG4gICAgfSkpLmNhdGNoKGZ1bmN0aW9uIChlcnJvciQkMSkge1xuICAgICAgcmV0dXJuIGRlYnVnJDQoJ3BpbmcgZmFpbGVkOicsIGVycm9yJCQxKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQ29ubmVjdGlvbjtcbn0oV2ViU29ja2V0UGx1cyk7XG5cbnZhciBjaGVja1R5cGUgPSBmdW5jdGlvbiBjaGVja1R5cGUobWlkZGxld2FyZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcGFyYW0uY29uc3RydWN0b3I7XG5cbiAgICByZXR1cm4gX1Byb21pc2UucmVzb2x2ZShwYXJhbSkudGhlbihtaWRkbGV3YXJlKS50aGVuKHRhcChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQgfHwgcmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ01pZGRsZXdhcmVbJyArIChtaWRkbGV3YXJlLl9wbHVnaW5OYW1lIHx8ICdhbm9ueW1vdXMgcGx1Z2luJykgKyAnOicgKyAobWlkZGxld2FyZS5uYW1lIHx8ICdhbm9ueW1vdXMgbWlkZGxld2FyZScpICsgJ10gcGFyYW0vcmV0dXJuIHR5cGVzIG5vdCBtYXRjaC4gSXQgcmV0dXJucyAnICsgcmVzdWx0ICsgJyB3aGlsZSBhICcgKyBwYXJhbS5jb25zdHJ1Y3Rvci5uYW1lICsgJyBleHBlY3RlZC4nKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdNaWRkbGV3YXJlWycgKyAobWlkZGxld2FyZS5fcGx1Z2luTmFtZSB8fCAnYW5vbnltb3VzIHBsdWdpbicpICsgJzonICsgKG1pZGRsZXdhcmUubmFtZSB8fCAnYW5vbnltb3VzIG1pZGRsZXdhcmUnKSArICddIHBhcmFtL3JldHVybiB0eXBlcyBub3QgbWF0Y2guIEl0IHJldHVybnMgYSAnICsgcmVzdWx0LmNvbnN0cnVjdG9yLm5hbWUgKyAnIHdoaWxlIGEgJyArIHBhcmFtLmNvbnN0cnVjdG9yLm5hbWUgKyAnIGV4cGVjdGVkLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSkpO1xuICB9O1xufTtcblxudmFyIGFwcGx5RGVjb3JhdG9ycyA9IGZ1bmN0aW9uIGFwcGx5RGVjb3JhdG9ycyhkZWNvcmF0b3JzLCB0YXJnZXQpIHtcbiAgaWYgKGRlY29yYXRvcnMpIHtcbiAgICBkZWNvcmF0b3JzLmZvckVhY2goZnVuY3Rpb24gKGRlY29yYXRvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGVjb3JhdG9yKHRhcmdldCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZGVjb3JhdG9yLl9wbHVnaW5OYW1lKSB7XG4gICAgICAgICAgZXJyb3IubWVzc2FnZSArPSAnWycgKyBkZWNvcmF0b3IuX3BsdWdpbk5hbWUgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBhcHBseU1pZGRsZXdhcmVzID0gZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlcyhtaWRkbGV3YXJlcykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHJldHVybiBlbnN1cmVBcnJheShtaWRkbGV3YXJlcykucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91c1Byb21pc2UsIG1pZGRsZXdhcmUpIHtcbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UudGhlbihjaGVja1R5cGUobWlkZGxld2FyZSkpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAobWlkZGxld2FyZS5fcGx1Z2luTmFtZSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgIGVycm9yLm1lc3NhZ2UgKz0gJ1snICsgbWlkZGxld2FyZS5fcGx1Z2luTmFtZSArICddJztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0pO1xuICAgIH0sIF9Qcm9taXNlLnJlc29sdmUodGFyZ2V0KSk7XG4gIH07XG59O1xuXG52YXIgYXBwbHlEaXNwYXRjaGVyID0gZnVuY3Rpb24gYXBwbHlEaXNwYXRjaGVyKGRpc3BhdGNoZXJzLCBwYXlsb2FkKSB7XG4gIHJldHVybiBlbnN1cmVBcnJheShkaXNwYXRjaGVycykucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHRQcm9taXNlLCBkaXNwYXRjaGVyKSB7XG4gICAgcmV0dXJuIHJlc3VsdFByb21pc2UudGhlbihmdW5jdGlvbiAoc2hvdWxkRGlzcGF0Y2gpIHtcbiAgICAgIHJldHVybiBzaG91bGREaXNwYXRjaCA9PT0gZmFsc2UgPyBmYWxzZSA6IGRpc3BhdGNoZXIuYXBwbHkodW5kZWZpbmVkLCBfdG9Db25zdW1hYmxlQXJyYXkocGF5bG9hZCkpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKGRpc3BhdGNoZXIuX3BsdWdpbk5hbWUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGVycm9yLm1lc3NhZ2UgKz0gJ1snICsgZGlzcGF0Y2hlci5fcGx1Z2luTmFtZSArICddJztcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICB9LCBfUHJvbWlzZS5yZXNvbHZlKHRydWUpKTtcbn07XG5cbnZhciB2ZXJzaW9uID0gXCI0LjAuMVwiO1xuXG52YXIgZGVidWckNSA9IGJyb3dzZXIoJ0xDOlJlYWx0aW1lJyk7XG52YXIgZGVidWdSZXF1ZXN0ID0gYnJvd3NlcignTEM6cmVxdWVzdCcpO1xuXG52YXIgcm91dGVyQ2FjaGUgPSBuZXcgQ2FjaGUoJ3B1c2gtcm91dGVyJyk7XG5cbnZhciBSZWFsdGltZSA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhSZWFsdGltZSwgX0V2ZW50RW1pdHRlcik7XG5cbiAgLyoqXG4gICAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtICB7U3RyaW5nfSBvcHRpb25zLmFwcElkXG4gICAqIEBwYXJhbSAge1N0cmluZ30gb3B0aW9ucy5hcHBLZXkg77yIc2luY2UgNC4wLjDvvIlcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbb3B0aW9ucy5yZWdpb249J2NuJ10g6IqC54K5IGlkXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnB1c2hPZmZsaW5lTWVzc2FnZXM9ZmFsc2VdIOWQr+eUqOaOqOmAgeemu+e6v+a2iOaBr+aooeW8j++8iOm7mOiupOS4uuWPkemAgeacquivu+a2iOaBr+mAmuefpeaooeW8j++8iVxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5ub0JpbmFyeT1mYWxzZV0g6K6+572uIFdlYlNvY2tldCDkvb/nlKjlrZfnrKbkuLLmoLzlvI/mlLblj5Hmtojmga/vvIjpu5jorqTkuLrkuozov5vliLbmoLzlvI/vvInjgIJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOmAgueUqOS6jiBXZWJTb2NrZXQg5a6e546w5LiN5pSv5oyB5LqM6L+b5Yi25pWw5o2u5qC85byP55qE5oOF5Ya1XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnNzbD10cnVlXSDkvb/nlKggd3NzIOi/m+ihjOi/nuaOpVxuICAgKiBAcGFyYW0gIHtTdHJpbmd8T2JqZWN0fSBbb3B0aW9ucy5zZXJ2ZXJdIOaMh+WumuengeaciemDqOe9sueahOacjeWKoeWZqOWfn+WQje+8iHNpbmNlIDQuMC4w77yJXG4gICAqIEBwYXJhbSAge1N0cmluZ3xTdHJpbmdbXX0gW29wdGlvbnMuUlRNU2VydmVyc10g5oyH5a6a56eB5pyJ6YOo572y55qEIFJUTSDmnI3liqHlmajlnLDlnYDvvIhzaW5jZSA0LjAuMO+8iVxuICAgKiBAcGFyYW0gIHtQbHVnaW5bXX0gW29wdGlvbnMucGx1Z2luc10g5Yqg6L295o+S5Lu277yIc2luY2UgMy4xLjDvvIlcbiAgICovXG4gIGZ1bmN0aW9uIFJlYWx0aW1lKF9yZWYpIHtcbiAgICB2YXIgcGx1Z2lucyA9IF9yZWYucGx1Z2lucyxcbiAgICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ3BsdWdpbnMnXSk7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVhbHRpbWUpO1xuXG4gICAgZGVidWckNSgnaW5pdGlhbGl6aW5nIFJlYWx0aW1lICVzICVPJywgdmVyc2lvbiwgb3B0aW9ucyk7XG5cbiAgICB2YXIgX3RoaXMyID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpKTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hcHBJZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FwcElkIFsnICsgb3B0aW9ucy5hcHBJZCArICddIGlzIG5vdCBhIHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYXBwS2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXBwS2V5IFsnICsgb3B0aW9ucy5hcHBLZXkgKyAnXSBpcyBub3QgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgX3RoaXMyLl9vcHRpb25zID0gX09iamVjdCRhc3NpZ24oe1xuICAgICAgYXBwSWQ6IHVuZGVmaW5lZCxcbiAgICAgIGFwcEtleTogdW5kZWZpbmVkLFxuICAgICAgcmVnaW9uOiAnY24nLFxuICAgICAgcHVzaE9mZmxpbmVNZXNzYWdlczogZmFsc2UsXG4gICAgICBub0JpbmFyeTogZmFsc2UsXG4gICAgICBzc2w6IHRydWUsXG4gICAgICBSVE1TZXJ2ZXJOYW1lOiBwcm9jZXNzLmVudi5SVE1fU0VSVkVSX05BTUUgLy8gdW5kb2N1bWVudGVkIG9uIHB1cnBvc2UsIGludGVybmFsIHVzZSBvbmx5XG4gICAgfSwgb3B0aW9ucyk7XG4gICAgX3RoaXMyLl9jYWNoZSA9IG5ldyBDYWNoZSgnZW5kcG9pbnRzJyk7XG4gICAgdmFyIF90aGlzID0gaW50ZXJuYWwoX3RoaXMyKTtcbiAgICBfdGhpcy5jbGllbnRzID0gbmV3IF9TZXQoKTtcbiAgICBfdGhpcy5wZW5kaW5nQ2xpZW50cyA9IG5ldyBfU2V0KCk7XG4gICAgdmFyIG1lcmdlZFBsdWdpbnMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGVuc3VyZUFycmF5KFJlYWx0aW1lLl9fcHJlUmVnaXN0ZXJlZFBsdWdpbnMpKSwgX3RvQ29uc3VtYWJsZUFycmF5KGVuc3VyZUFycmF5KHBsdWdpbnMpKSk7XG4gICAgZGVidWckNSgnVXNpbmcgcGx1Z2lucyAlbycsIG1lcmdlZFBsdWdpbnMubWFwKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIHJldHVybiBwbHVnaW4ubmFtZTtcbiAgICB9KSk7XG4gICAgX3RoaXMyLl9wbHVnaW5zID0gbWVyZ2VkUGx1Z2lucy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgcGx1Z2luKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIGZvciAodmFyIGhvb2sgaW4gcGx1Z2luKSB7XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBsdWdpbiwgaG9vaykgJiYgaG9vayAhPT0gJ25hbWUnKSB7XG4gICAgICAgICAgaWYgKHBsdWdpbi5uYW1lKSB7XG4gICAgICAgICAgICBlbnN1cmVBcnJheShwbHVnaW5baG9va10pLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICB2YWx1ZS5fcGx1Z2luTmFtZSA9IHBsdWdpbi5uYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgIHJlc3VsdFtob29rXSA9IGVuc3VyZUFycmF5KHJlc3VsdFtob29rXSkuY29uY2F0KHBsdWdpbltob29rXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xuICAgIC8vIG9uUmVhbHRpbWVDcmVhdGUgaG9va1xuICAgIGFwcGx5RGVjb3JhdG9ycyhfdGhpczIuX3BsdWdpbnMub25SZWFsdGltZUNyZWF0ZSwgX3RoaXMyKTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgUmVhbHRpbWUucHJvdG90eXBlLl9yZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmMyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlKF9yZWYyKSB7XG4gICAgICB2YXIgbWV0aG9kID0gX3JlZjIubWV0aG9kLFxuICAgICAgICAgIF9yZWYyJHZlcnNpb24gPSBfcmVmMi52ZXJzaW9uLFxuICAgICAgICAgIHZlcnNpb24kJDEgPSBfcmVmMiR2ZXJzaW9uID09PSB1bmRlZmluZWQgPyAnMS4xJyA6IF9yZWYyJHZlcnNpb24sXG4gICAgICAgICAgcGF0aCA9IF9yZWYyLnBhdGgsXG4gICAgICAgICAgcXVlcnkgPSBfcmVmMi5xdWVyeSxcbiAgICAgICAgICBoZWFkZXJzID0gX3JlZjIuaGVhZGVycyxcbiAgICAgICAgICBfcmVmMiRkYXRhID0gX3JlZjIuZGF0YSxcbiAgICAgICAgICBkYXRhID0gX3JlZjIkZGF0YSA9PT0gdW5kZWZpbmVkID8ge30gOiBfcmVmMiRkYXRhO1xuXG4gICAgICB2YXIgX29wdGlvbnMsIGFwcElkLCByZWdpb24sIHNlcnZlciwgX3JlZjQsIGFwaSwgdXJsLCBvcHRpb25zO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSB0aGlzLl9vcHRpb25zLCBhcHBJZCA9IF9vcHRpb25zLmFwcElkLCByZWdpb24gPSBfb3B0aW9ucy5yZWdpb24sIHNlcnZlciA9IF9vcHRpb25zLnNlcnZlcjtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLl9nZXRTZXJ2ZXJVcmxzKHtcbiAgICAgICAgICAgICAgICBhcHBJZDogYXBwSWQsXG4gICAgICAgICAgICAgICAgcmVnaW9uOiByZWdpb24sXG4gICAgICAgICAgICAgICAgc2VydmVyOiBzZXJ2ZXJcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgX3JlZjQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBhcGkgPSBfcmVmNC5hcGk7XG4gICAgICAgICAgICAgIHVybCA9ICdodHRwczovLycgKyBhcGkgKyAnLycgKyB2ZXJzaW9uJCQxICsgcGF0aDtcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IF9leHRlbmRzJDEoe1xuICAgICAgICAgICAgICAgICAgJ1gtTEMtSWQnOiB0aGlzLl9vcHRpb25zLmFwcElkLFxuICAgICAgICAgICAgICAgICAgJ1gtTEMtS2V5JzogdGhpcy5fb3B0aW9ucy5hcHBLZXlcbiAgICAgICAgICAgICAgICB9LCBoZWFkZXJzKSxcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgZGVidWdSZXF1ZXN0KCdSZXE6ICVPICVPJywgdXJsLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgncmV0dXJuJywgYXhpb3MkMSh1cmwsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgZGVidWdSZXF1ZXN0KCdSZXM6ICVPICVPICVPJywgdXJsLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IkJDEpIHtcbiAgICAgICAgICAgICAgICBkZWJ1Z1JlcXVlc3QoJ0Vycm9yOiAlTyAlTyAlTycsIHVybCwgZXJyb3IkJDEucmVzcG9uc2Uuc3RhdHVzLCBlcnJvciQkMS5yZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IkJDEucmVzcG9uc2UgJiYgZXJyb3IkJDEucmVzcG9uc2UuZGF0YSAmJiBlcnJvciQkMS5yZXNwb25zZS5kYXRhLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yJDEoZXJyb3IkJDEucmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yJCQxO1xuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBfcmVxdWVzdChfeCkge1xuICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXF1ZXN0O1xuICB9KCk7XG5cbiAgUmVhbHRpbWUucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24gX29wZW4oKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5fb3BlblByb21pc2UpIHJldHVybiB0aGlzLl9vcGVuUHJvbWlzZTtcblxuICAgIHZhciBmb3JtYXQgPSAncHJvdG9idWYyJztcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5ub0JpbmFyeSkge1xuICAgICAgLy8g5LiN5Y+R6YCBIGJpbmFyeSBkYXRh77yMZmFsbGJhY2sgdG8gYmFzZTY0IHN0cmluZ1xuICAgICAgZm9ybWF0ID0gJ3Byb3RvMmJhc2U2NCc7XG4gICAgfVxuICAgIHZhciB2ZXJzaW9uJCQxID0gMztcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5wdXNoT2ZmbGluZU1lc3NhZ2VzKSB7XG4gICAgICAvLyDkuI3mjqjpgIHnprvnur/mtojmga/vvIzogIzmmK/lj5HpgIHlr7nor53nmoTmnKror7vpgJrnn6VcbiAgICAgIHZlcnNpb24kJDEgPSAxO1xuICAgIH1cbiAgICB2YXIgcHJvdG9jb2wgPSB7XG4gICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgIHZlcnNpb246IHZlcnNpb24kJDFcbiAgICB9O1xuICAgIHRoaXMuX29wZW5Qcm9taXNlID0gbmV3IF9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGRlYnVnJDUoJ05vIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQsIGNyZWF0ZSBhIG5ldyBvbmUuJyk7XG4gICAgICB2YXIgY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5fZ2V0UlRNU2VydmVycyhfdGhpczMuX29wdGlvbnMpO1xuICAgICAgfSwgcHJvdG9jb2wpO1xuICAgICAgY29ubmVjdGlvbi5vbihPUEVOLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKGNvbm5lY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICBjb25uZWN0aW9uLm9uKEVSUk9SLCByZWplY3QpO1xuICAgICAgY29ubmVjdGlvbi5vbihNRVNTQUdFLCBfdGhpczMuX2Rpc3BhdGNoQ29tbWFuZC5iaW5kKF90aGlzMykpO1xuICAgICAgLyoqXG4gICAgICAgKiDov57mjqXmlq3lvIDjgIJcbiAgICAgICAqIOi/nuaOpeaWreW8gOWPr+iDveaYr+WboOS4uiBTREsg6L+b5YWl5LqG56a757q/54q25oCB77yIc2VlIHtAbGluayBSZWFsdGltZSNldmVudDpPRkZMSU5Ffe+8ie+8jOaIlumVv+aXtumXtOayoeacieaUtuWIsOacjeWKoeWZqOW/g+i3s+OAglxuICAgICAgICog6L+e5o6l5pat5byA5ZCO5omA5pyJ55qE572R57uc5pON5L2c6YO95Lya5aSx6LSl77yM6K+35Zyo6L+e5o6l5pat5byA5ZCO56aB55So55u45YWz55qEIFVJIOWFg+e0oOOAglxuICAgICAgICogQGV2ZW50IFJlYWx0aW1lI0RJU0NPTk5FQ1RcbiAgICAgICAqL1xuICAgICAgLyoqXG4gICAgICAgKiDorqHliJLlnKjkuIDmrrXml7bpl7TlkI7lsJ3or5Xph43mlrDov57mjqVcbiAgICAgICAqIEBldmVudCBSZWFsdGltZSNTQ0hFRFVMRVxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGF0dGVtcHQg5bCd6K+V6YeN6L+e55qE5qyh5pWwXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsYXkg5bu26L+f55qE5q+r56eS5pWwXG4gICAgICAgKi9cbiAgICAgIC8qKlxuICAgICAgICog5q2j5Zyo5bCd6K+V6YeN5paw6L+e5o6lXG4gICAgICAgKiBAZXZlbnQgUmVhbHRpbWUjUkVUUllcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhdHRlbXB0IOWwneivlemHjei/nueahOasoeaVsFxuICAgICAgICovXG4gICAgICAvKipcbiAgICAgICAqIOi/nuaOpeaBouWkjeato+W4uOOAglxuICAgICAgICog6K+36YeN5paw5ZCv55So5ZyoIHtAbGluayBSZWFsdGltZSNldmVudDpESVNDT05ORUNUfSDkuovku7bkuK3npoHnlKjnmoTnm7jlhbMgVUkg5YWD57SgXG4gICAgICAgKiBAZXZlbnQgUmVhbHRpbWUjUkVDT05ORUNUXG4gICAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAgKiDlrqLmiLfnq6/ov57mjqXmlq3lvIBcbiAgICAgICAqIEBldmVudCBJTUNsaWVudCNESVNDT05ORUNUXG4gICAgICAgKiBAc2VlIFJlYWx0aW1lI2V2ZW50OkRJU0NPTk5FQ1RcbiAgICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAgICovXG4gICAgICAvKipcbiAgICAgICAqIOiuoeWIkuWcqOS4gOauteaXtumXtOWQjuWwneivlemHjeaWsOi/nuaOpVxuICAgICAgICogQGV2ZW50IElNQ2xpZW50I1NDSEVEVUxFXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gYXR0ZW1wdCDlsJ3or5Xph43ov57nmoTmrKHmlbBcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSDlu7bov5/nmoTmr6vnp5LmlbBcbiAgICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAgICovXG4gICAgICAvKipcbiAgICAgICAqIOato+WcqOWwneivlemHjeaWsOi/nuaOpVxuICAgICAgICogQGV2ZW50IElNQ2xpZW50I1JFVFJZXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gYXR0ZW1wdCDlsJ3or5Xph43ov57nmoTmrKHmlbBcbiAgICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICog5a6i5oi356uv6L+b5YWl56a757q/54q25oCB44CCXG4gICAgICAgKiDov5npgJrluLjmhI/lkbPnnYDnvZHnu5zlt7Lmlq3lvIDvvIzmiJbogIUge0BsaW5rIFJlYWx0aW1lI3BhdXNlfSDooqvosIPnlKhcbiAgICAgICAqIEBldmVudCBSZWFsdGltZSNPRkZMSU5FXG4gICAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgICAqL1xuICAgICAgLyoqXG4gICAgICAgKiDlrqLmiLfnq6/mgaLlpI3lnKjnur/nirbmgIFcbiAgICAgICAqIOi/memAmuW4uOaEj+WRs+edgOe9kee7nOW3suaBouWkje+8jOaIluiAhSB7QGxpbmsgUmVhbHRpbWUjcmVzdW1lfSDooqvosIPnlKhcbiAgICAgICAqIEBldmVudCBSZWFsdGltZSNPTkxJTkVcbiAgICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAgICovXG4gICAgICAvKipcbiAgICAgICAqIOi/m+WFpeemu+e6v+eKtuaAgeOAglxuICAgICAgICog6L+Z6YCa5bi45oSP5ZGz552A572R57uc5bey5pat5byA77yM5oiW6ICFIHtAbGluayBSZWFsdGltZSNwYXVzZX0g6KKr6LCD55SoXG4gICAgICAgKiBAZXZlbnQgSU1DbGllbnQjT0ZGTElORVxuICAgICAgICogQHNpbmNlIDMuNC4wXG4gICAgICAgKi9cbiAgICAgIC8qKlxuICAgICAgICog5oGi5aSN5Zyo57q/54q25oCBXG4gICAgICAgKiDov5npgJrluLjmhI/lkbPnnYDnvZHnu5zlt7LmgaLlpI3vvIzmiJbogIUge0BsaW5rIFJlYWx0aW1lI3Jlc3VtZX0g6KKr6LCD55SoXG4gICAgICAgKiBAZXZlbnQgSU1DbGllbnQjT05MSU5FXG4gICAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgICAqL1xuXG4gICAgICAvLyBldmVudCBwcm94eVxuICAgICAgW0RJU0NPTk5FQ1QsIFJFQ09OTkVDVCwgUkVUUlksIFNDSEVEVUxFLCBPRkZMSU5FLCBPTkxJTkVdLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uLm9uKGV2ZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBheWxvYWQgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIHBheWxvYWRbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVidWckNShldmVudCArICcgZXZlbnQgZW1pdHRlZC4gJW8nLCBwYXlsb2FkKTtcbiAgICAgICAgICBfdGhpczMuZW1pdC5hcHBseShfdGhpczMsIFtldmVudF0uY29uY2F0KHBheWxvYWQpKTtcbiAgICAgICAgICBpZiAoZXZlbnQgIT09IFJFQ09OTkVDVCkge1xuICAgICAgICAgICAgaW50ZXJuYWwoX3RoaXMzKS5jbGllbnRzLmZvckVhY2goZnVuY3Rpb24gKGNsaWVudCkge1xuICAgICAgICAgICAgICBjbGllbnQuZW1pdC5hcHBseShjbGllbnQsIFtldmVudF0uY29uY2F0KHBheWxvYWQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIG92ZXJyaWRlIGhhbmRsZUNsb3NlXG4gICAgICBjb25uZWN0aW9uLmhhbmRsZUNsb3NlID0gZnVuY3Rpb24gaGFuZGxlQ2xvc2UoZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzRmF0YWwgPSBbRXJyb3JDb2RlLkFQUF9OT1RfQVZBSUxBQkxFLCBFcnJvckNvZGUuSU5WQUxJRF9MT0dJTiwgRXJyb3JDb2RlLklOVkFMSURfT1JJR0lOXS5zb21lKGZ1bmN0aW9uIChlcnJvckNvZGUpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3JDb2RlID09PSBldmVudC5jb2RlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzRmF0YWwpIHtcbiAgICAgICAgICAvLyBpbiB0aGVzZSBjYXNlcywgU0RLIHNob3VsZCB0aHJvdy5cbiAgICAgICAgICB0aGlzLnRocm93KGNyZWF0ZUVycm9yJDEoZXZlbnQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZWNvbm5lY3RcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGludGVybmFsKF90aGlzMykuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fb3BlblByb21pc2U7XG4gIH07XG5cbiAgUmVhbHRpbWUucHJvdG90eXBlLl9nZXRSVE1TZXJ2ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmNSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMihvcHRpb25zKSB7XG4gICAgICB2YXIgaW5mbywgY2FjaGVkRW5kUG9pbnRzO1xuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuUlRNU2VydmVycykge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KCdyZXR1cm4nLCBzaHVmZmxlXzEoZW5zdXJlQXJyYXkob3B0aW9ucy5SVE1TZXJ2ZXJzKSkpO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGluZm8gPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGNhY2hlZEVuZFBvaW50cyA9IHRoaXMuX2NhY2hlLmdldCgnZW5kcG9pbnRzJyk7XG5cbiAgICAgICAgICAgICAgaWYgKCFjYWNoZWRFbmRQb2ludHMpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA3O1xuICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkRW5kUG9pbnRzO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGluZm8gPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLl9mZXRjaFJUTVNlcnZlcnMob3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIGluZm8gPSBfY29udGV4dDIuc2VudDtcblxuICAgICAgICAgICAgICB0aGlzLl9jYWNoZS5zZXQoJ2VuZHBvaW50cycsIGluZm8sIGluZm8udHRsICogMTAwMCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgIGRlYnVnJDUoJ2VuZHBvaW50IGluZm86ICVPJywgaW5mbyk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KCdyZXR1cm4nLCBbaW5mby5zZXJ2ZXIsIGluZm8uc2Vjb25kYXJ5XSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBfZ2V0UlRNU2VydmVycyhfeDIpIHtcbiAgICAgIHJldHVybiBfcmVmNS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0UlRNU2VydmVycztcbiAgfSgpO1xuXG4gIFJlYWx0aW1lLl9nZXRTZXJ2ZXJVcmxzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmNyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhfcmVmNikge1xuICAgICAgdmFyIGFwcElkID0gX3JlZjYuYXBwSWQsXG4gICAgICAgICAgcmVnaW9uID0gX3JlZjYucmVnaW9uLFxuICAgICAgICAgIHNlcnZlciA9IF9yZWY2LnNlcnZlcjtcbiAgICAgIHZhciBjYWNoZWRSb3V0ZXI7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGRlYnVnJDUoJ2ZldGNoIHNlcnZlciB1cmxzJyk7XG5cbiAgICAgICAgICAgICAgaWYgKCFzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoISh0eXBlb2Ygc2VydmVyICE9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdCgncmV0dXJuJywgc2VydmVyKTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdCgncmV0dXJuJywge1xuICAgICAgICAgICAgICAgIFJUTVJvdXRlcjogc2VydmVyLFxuICAgICAgICAgICAgICAgIGFwaTogc2VydmVyXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIF9jb250ZXh0My50MCA9IHJlZ2lvbjtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSBfY29udGV4dDMudDAgPT09ICdjbicgPyA4IDogX2NvbnRleHQzLnQwID09PSAndXMnID8gMTIgOiAxMztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgY2FjaGVkUm91dGVyID0gcm91dGVyQ2FjaGUuZ2V0KGFwcElkKTtcblxuICAgICAgICAgICAgICBpZiAoIWNhY2hlZFJvdXRlcikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdCgncmV0dXJuJywgY2FjaGVkUm91dGVyKTtcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoJ3JldHVybicsIGF4aW9zJDEuZ2V0KCdodHRwczovL2FwcC1yb3V0ZXIubGVhbmNsb3VkLmNuLzIvcm91dGUnLCB7XG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICBhcHBJZDogYXBwSWRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDIwMDAwXG4gICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMuZGF0YTtcbiAgICAgICAgICAgICAgfSkudGhlbih0YXAoZGVidWckNSkpLnRoZW4oZnVuY3Rpb24gKF9yZWY4KSB7XG4gICAgICAgICAgICAgICAgdmFyIFJUTVJvdXRlciA9IF9yZWY4LnJ0bV9yb3V0ZXJfc2VydmVyLFxuICAgICAgICAgICAgICAgICAgICBhcGkgPSBfcmVmOC5hcGlfc2VydmVyLFxuICAgICAgICAgICAgICAgICAgICBfcmVmOCR0dGwgPSBfcmVmOC50dGwsXG4gICAgICAgICAgICAgICAgICAgIHR0bCA9IF9yZWY4JHR0bCA9PT0gdW5kZWZpbmVkID8gMzYwMCA6IF9yZWY4JHR0bDtcblxuICAgICAgICAgICAgICAgIGlmICghUlRNUm91dGVyKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3J0bSByb3V0ZXIgbm90IGV4aXN0cycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2VydmVyVXJscyA9IHtcbiAgICAgICAgICAgICAgICAgIFJUTVJvdXRlcjogUlRNUm91dGVyLFxuICAgICAgICAgICAgICAgICAgYXBpOiBhcGlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJvdXRlckNhY2hlLnNldChhcHBJZCwgc2VydmVyVXJscywgdHRsICogMTAwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcnZlclVybHM7XG4gICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBhcHBJZC5zbGljZSgwLCA4KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBSVE1Sb3V0ZXI6IGlkICsgJy5ydG0ubG5jbGQubmV0JyxcbiAgICAgICAgICAgICAgICAgIGFwaTogaWQgKyAnLmFwaS5sbmNsZC5uZXQnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdCgncmV0dXJuJywge1xuICAgICAgICAgICAgICAgIFJUTVJvdXRlcjogJ3JvdXRlci1hMC1wdXNoLmxlYW5jbG91ZC5jbicsXG4gICAgICAgICAgICAgICAgYXBpOiAndXMtYXBpLmxlYW5jbG91ZC5jbidcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVnaW9uIFsnICsgcmVnaW9uICsgJ10gaXMgbm90IHN1cHBvcnRlZC4nKTtcblxuICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIF9nZXRTZXJ2ZXJVcmxzKF94Mykge1xuICAgICAgcmV0dXJuIF9yZWY3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXRTZXJ2ZXJVcmxzO1xuICB9KCk7XG5cbiAgUmVhbHRpbWUuX2ZldGNoUlRNU2VydmVycyA9IGZ1bmN0aW9uIF9mZXRjaFJUTVNlcnZlcnMoX3JlZjkpIHtcbiAgICB2YXIgYXBwSWQgPSBfcmVmOS5hcHBJZCxcbiAgICAgICAgcmVnaW9uID0gX3JlZjkucmVnaW9uLFxuICAgICAgICBzc2wgPSBfcmVmOS5zc2wsXG4gICAgICAgIHNlcnZlciA9IF9yZWY5LnNlcnZlcixcbiAgICAgICAgUlRNU2VydmVyTmFtZSA9IF9yZWY5LlJUTVNlcnZlck5hbWU7XG5cbiAgICBkZWJ1ZyQ1KCdmZXRjaCBlbmRwb2ludCBpbmZvJyk7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNlcnZlclVybHMoeyBhcHBJZDogYXBwSWQsIHJlZ2lvbjogcmVnaW9uLCBzZXJ2ZXI6IHNlcnZlciB9KS50aGVuKHRhcChkZWJ1ZyQ1KSkudGhlbihmdW5jdGlvbiAoX3JlZjEwKSB7XG4gICAgICB2YXIgUlRNUm91dGVyID0gX3JlZjEwLlJUTVJvdXRlcjtcbiAgICAgIHJldHVybiBheGlvcyQxLmdldCgnaHR0cHM6Ly8nICsgUlRNUm91dGVyICsgJy92MS9yb3V0ZScsIHtcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgYXBwSWQ6IGFwcElkLFxuICAgICAgICAgIHNlY3VyZTogc3NsLFxuICAgICAgICAgIGZlYXR1cmVzOiBpc1dlYXBwID8gJ3dlY2hhdCcgOiB1bmRlZmluZWQsXG4gICAgICAgICAgc2VydmVyOiBSVE1TZXJ2ZXJOYW1lLFxuICAgICAgICAgIF90OiBEYXRlLm5vdygpXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVvdXQ6IDIwMDAwXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgcmV0dXJuIHJlcy5kYXRhO1xuICAgICAgfSkudGhlbih0YXAoZGVidWckNSkpO1xuICAgIH0pO1xuICB9O1xuXG4gIFJlYWx0aW1lLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbiBfY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuX29wZW5Qcm9taXNlKSB7XG4gICAgICB0aGlzLl9vcGVuUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX29wZW5Qcm9taXNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiDmiYvliqjov5vooYzph43ov57jgIJcbiAgICogU0RLIOWcqOe9kee7nOWHuueOsOW8guW4uOaXtuS8muiHquWKqOaMieeFp+S4gOWumueahOaXtumXtOmXtOmalOWwneivlemHjei/nu+8jOiwg+eUqOivpeaWueazleS8mueri+WNs+WwneivlemHjei/nuW5tumHjee9rumHjei/nuWwneivleiuoeaVsOWZqOOAglxuICAgKiDlj6rog73lnKggYFNDSEVEVUxFYCDkuovku7bkuYvlkI7vvIxgUkVUUllgIOS6i+S7tuS5i+WJjeiwg+eUqO+8jOWmguaenOW9k+WJjee9kee7nOato+W4uOaIluiAheato+WcqOi/m+ihjOmHjei/nu+8jOiwg+eUqOivpeaWueazleS8muaKm+W8guW4uOOAglxuICAgKi9cblxuXG4gIFJlYWx0aW1lLnByb3RvdHlwZS5yZXRyeSA9IGZ1bmN0aW9uIHJldHJ5KCkge1xuICAgIHZhciBfaW50ZXJuYWwgPSBpbnRlcm5hbCh0aGlzKSxcbiAgICAgICAgY29ubmVjdGlvbiA9IF9pbnRlcm5hbC5jb25uZWN0aW9uO1xuXG4gICAgaWYgKCFjb25uZWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQnKTtcbiAgICB9XG4gICAgaWYgKGNvbm5lY3Rpb24uY2Fubm90KCdyZXRyeScpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJ5aW5nIG5vdCBhbGxvd2VkIHdoZW4gbm90IGRpc2Nvbm5lY3RlZC4gdGhlIGNvbm5lY3Rpb24gaXMgbm93ICcgKyBjb25uZWN0aW9uLmN1cnJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29ubmVjdGlvbi5yZXRyeSgpO1xuICB9O1xuICAvKipcbiAgICog5pqC5YGc77yM5L2/IFNESyDov5vlhaXnprvnur/nirbmgIHjgIJcbiAgICog5L2g5Y+v5Lul5Zyo572R57uc5pat5byA44CB5bqU55So6L+b5YWl5ZCO5Y+w562J5pe25Yi76LCD55So6K+l5pa55rOV6K6pIFNESyDov5vlhaXnprvnur/nirbmgIHvvIznprvnur/nirbmgIHkuIvkuI3kvJrlsJ3or5Xph43ov57jgIJcbiAgICog5Zyo5rWP6KeI5Zmo5LitIFNESyDkvJroh6rliqjnm5HlkKznvZHnu5zlj5jljJbvvIzlm6DmraTml6DpnIDmiYvliqjosIPnlKjor6Xmlrnms5XjgIJcbiAgICpcbiAgICogQHNpbmNlIDMuNC4wXG4gICAqIEBzZWUgUmVhbHRpbWUjZXZlbnQ6T0ZGTElORVxuICAgKi9cblxuXG4gIFJlYWx0aW1lLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIC8vIOi/meS4quaWueazleW4uOW4uOWcqOe9kee7nOaWreW8gOOAgei/m+WFpeWQjuWPsOaXtuiiq+iwg+eUqO+8jOatpOaXtiBjb25uZWN0aW9uIOWPr+iDveayoeacieW7uueri+aIluiAheW3sue7jyBjbG9zZeOAglxuICAgIC8vIOWboOatpOS4jeWDjyByZXRyee+8jOi/meS4quaWueazleW6lOivpeWwveWPr+iDvSBsb29zZVxuICAgIHZhciBfaW50ZXJuYWwyID0gaW50ZXJuYWwodGhpcyksXG4gICAgICAgIGNvbm5lY3Rpb24gPSBfaW50ZXJuYWwyLmNvbm5lY3Rpb247XG5cbiAgICBpZiAoIWNvbm5lY3Rpb24pIHJldHVybjtcbiAgICBpZiAoY29ubmVjdGlvbi5jYW4oJ3BhdXNlJykpIGNvbm5lY3Rpb24ucGF1c2UoKTtcbiAgfTtcbiAgLyoqXG4gICAqIOaBouWkjeWcqOe6v+eKtuaAgeOAglxuICAgKiDkvaDlj6/ku6XlnKjnvZHnu5zmgaLlpI3jgIHlupTnlKjlm57liLDliY3lj7DnrYnml7bliLvosIPnlKjor6Xmlrnms5XorqkgU0RLIOaBouWkjeWcqOe6v+eKtuaAge+8jOaBouWkjeWcqOe6v+eKtuaAgeWQjiBTREsg5Lya5byA5aeL5bCd6K+V6YeN6L+e44CCXG4gICAqXG4gICAqIEBzaW5jZSAzLjQuMFxuICAgKiBAc2VlIFJlYWx0aW1lI2V2ZW50Ok9OTElORVxuICAgKi9cblxuXG4gIFJlYWx0aW1lLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgLy8g5LiOIHBhdXNlIOS4gOagt++8jOi/meS4quaWueazleW6lOivpeWwveWPr+iDvSBsb29zZVxuICAgIHZhciBfaW50ZXJuYWwzID0gaW50ZXJuYWwodGhpcyksXG4gICAgICAgIGNvbm5lY3Rpb24gPSBfaW50ZXJuYWwzLmNvbm5lY3Rpb247XG5cbiAgICBpZiAoIWNvbm5lY3Rpb24pIHJldHVybjtcbiAgICBpZiAoY29ubmVjdGlvbi5jYW4oJ3Jlc3VtZScpKSBjb25uZWN0aW9uLnJlc3VtZSgpO1xuICB9O1xuXG4gIFJlYWx0aW1lLnByb3RvdHlwZS5fcmVnaXN0ZXJQZW5kaW5nID0gZnVuY3Rpb24gX3JlZ2lzdGVyUGVuZGluZyh2YWx1ZSkge1xuICAgIGludGVybmFsKHRoaXMpLnBlbmRpbmdDbGllbnRzLmFkZCh2YWx1ZSk7XG4gIH07XG5cbiAgUmVhbHRpbWUucHJvdG90eXBlLl9kZXJlZ2lzdGVyUGVuZGluZyA9IGZ1bmN0aW9uIF9kZXJlZ2lzdGVyUGVuZGluZyhjbGllbnQpIHtcbiAgICBpbnRlcm5hbCh0aGlzKS5wZW5kaW5nQ2xpZW50cy5kZWxldGUoY2xpZW50KTtcbiAgfTtcblxuICBSZWFsdGltZS5wcm90b3R5cGUuX3JlZ2lzdGVyID0gZnVuY3Rpb24gX3JlZ2lzdGVyKGNsaWVudCkge1xuICAgIGludGVybmFsKHRoaXMpLmNsaWVudHMuYWRkKGNsaWVudCk7XG4gIH07XG5cbiAgUmVhbHRpbWUucHJvdG90eXBlLl9kZXJlZ2lzdGVyID0gZnVuY3Rpb24gX2RlcmVnaXN0ZXIoY2xpZW50KSB7XG4gICAgdmFyIF90aGlzID0gaW50ZXJuYWwodGhpcyk7XG4gICAgX3RoaXMuY2xpZW50cy5kZWxldGUoY2xpZW50KTtcbiAgICBpZiAoX3RoaXMuY2xpZW50cy5zaXplICsgX3RoaXMucGVuZGluZ0NsaWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5fY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgUmVhbHRpbWUucHJvdG90eXBlLl9kaXNwYXRjaENvbW1hbmQgPSBmdW5jdGlvbiBfZGlzcGF0Y2hDb21tYW5kKGNvbW1hbmQpIHtcbiAgICByZXR1cm4gYXBwbHlEaXNwYXRjaGVyKHRoaXMuX3BsdWdpbnMuYmVmb3JlQ29tbWFuZERpc3BhdGNoLCBbY29tbWFuZCwgdGhpc10pLnRoZW4oZnVuY3Rpb24gKHNob3VsZERpc3BhdGNoKSB7XG4gICAgICAvLyBubyBwbHVnaW4gaGFuZGxlZCB0aGlzIGNvbW1hbmRcbiAgICAgIGlmIChzaG91bGREaXNwYXRjaCkgcmV0dXJuIGRlYnVnJDUoJ1tXQVJOXSBVbmV4cGVjdGVkIG1lc3NhZ2UgcmVjZWl2ZWQ6ICVPJywgdHJpbSQxKGNvbW1hbmQpKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gUmVhbHRpbWU7XG59KGV2ZW50ZW1pdHRlcjMpO1xuXG52YXIgcm5nQnJvd3NlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBJbiB0aGVcbi8vIGJyb3dzZXIgdGhpcyBpcyBhIGxpdHRsZSBjb21wbGljYXRlZCBkdWUgdG8gdW5rbm93biBxdWFsaXR5IG9mIE1hdGgucmFuZG9tKClcbi8vIGFuZCBpbmNvbnNpc3RlbnQgc3VwcG9ydCBmb3IgdGhlIGBjcnlwdG9gIEFQSS4gIFdlIGRvIHRoZSBiZXN0IHdlIGNhbiB2aWFcbi8vIGZlYXR1cmUtZGV0ZWN0aW9uXG5cbi8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi5cbnZhciBnZXRSYW5kb21WYWx1ZXMgPSAodHlwZW9mKGNyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZihtc0NyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pKTtcbmlmIChnZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0byBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIHZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG4gICAgcmV0dXJuIHJuZHM4O1xuICB9O1xufSBlbHNlIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgcm5kcyA9IG5ldyBBcnJheSgxNik7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXRoUk5HKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBybmRzO1xuICB9O1xufVxufSk7XG5cbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xudmFyIGJ5dGVUb0hleCA9IFtdO1xuZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgMjU2OyArK2kkMSkge1xuICBieXRlVG9IZXhbaSQxXSA9IChpJDEgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbn1cblxuZnVuY3Rpb24gYnl0ZXNUb1V1aWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGJ0aCA9IGJ5dGVUb0hleDtcbiAgcmV0dXJuIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXTtcbn1cblxudmFyIGJ5dGVzVG9VdWlkXzEgPSBieXRlc1RvVXVpZDtcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG5cbiAgaWYgKHR5cGVvZihvcHRpb25zKSA9PSAnc3RyaW5nJykge1xuICAgIGJ1ZiA9IG9wdGlvbnMgPT09ICdiaW5hcnknID8gbmV3IEFycmF5KDE2KSA6IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nQnJvd3NlcikoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSAocm5kc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyArK2lpKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgYnl0ZXNUb1V1aWRfMShybmRzKTtcbn1cblxudmFyIHY0XzEgPSB2NDtcblxudmFyIElURVJBVE9SJDQgPSBfd2tzKCdpdGVyYXRvcicpO1xuXG52YXIgY29yZV9pc0l0ZXJhYmxlID0gX2NvcmUuaXNJdGVyYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTyA9IE9iamVjdChpdCk7XG4gIHJldHVybiBPW0lURVJBVE9SJDRdICE9PSB1bmRlZmluZWRcbiAgICB8fCAnQEBpdGVyYXRvcicgaW4gT1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICB8fCBfaXRlcmF0b3JzLmhhc093blByb3BlcnR5KF9jbGFzc29mKE8pKTtcbn07XG5cbnZhciBpc0l0ZXJhYmxlID0gY29yZV9pc0l0ZXJhYmxlO1xuXG52YXIgaXNJdGVyYWJsZSQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBpc0l0ZXJhYmxlLCBfX2VzTW9kdWxlOiB0cnVlIH07XG59KTtcblxudW53cmFwRXhwb3J0cyhpc0l0ZXJhYmxlJDEpO1xuXG52YXIgY29yZV9nZXRJdGVyYXRvciA9IF9jb3JlLmdldEl0ZXJhdG9yID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpdGVyRm4gPSBjb3JlX2dldEl0ZXJhdG9yTWV0aG9kKGl0KTtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBfYW5PYmplY3QoaXRlckZuLmNhbGwoaXQpKTtcbn07XG5cbnZhciBnZXRJdGVyYXRvciA9IGNvcmVfZ2V0SXRlcmF0b3I7XG5cbnZhciBnZXRJdGVyYXRvciQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBnZXRJdGVyYXRvciwgX19lc01vZHVsZTogdHJ1ZSB9O1xufSk7XG5cbnZhciBfZ2V0SXRlcmF0b3IgPSB1bndyYXBFeHBvcnRzKGdldEl0ZXJhdG9yJDEpO1xuXG52YXIgc2xpY2VkVG9BcnJheSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXG5cbnZhciBfaXNJdGVyYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGlzSXRlcmFibGUkMSk7XG5cblxuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZ2V0SXRlcmF0b3IkMSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG4gICAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pID0gKDAsIF9nZXRJdGVyYXRvcjMuZGVmYXVsdCkoYXJyKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSBlbHNlIGlmICgoMCwgX2lzSXRlcmFibGUzLmRlZmF1bHQpKE9iamVjdChhcnIpKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xufSk7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IHVud3JhcEV4cG9ydHMoc2xpY2VkVG9BcnJheSk7XG5cbnZhciBpc0VudW0kMSA9IF9vYmplY3RQaWUuZjtcbnZhciBfb2JqZWN0VG9BcnJheSA9IGZ1bmN0aW9uIChpc0VudHJpZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBPID0gX3RvSW9iamVjdChpdCk7XG4gICAgdmFyIGtleXMgPSBfb2JqZWN0S2V5cyhPKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBpKSBpZiAoaXNFbnVtJDEuY2FsbChPLCBrZXkgPSBrZXlzW2krK10pKSB7XG4gICAgICByZXN1bHQucHVzaChpc0VudHJpZXMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH07XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcblxudmFyICR2YWx1ZXMgPSBfb2JqZWN0VG9BcnJheShmYWxzZSk7XG5cbl9leHBvcnQoX2V4cG9ydC5TLCAnT2JqZWN0Jywge1xuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcyhpdCkge1xuICAgIHJldHVybiAkdmFsdWVzKGl0KTtcbiAgfVxufSk7XG5cbnZhciB2YWx1ZXMkMSA9IF9jb3JlLk9iamVjdC52YWx1ZXM7XG5cbnZhciB2YWx1ZXMkMiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogdmFsdWVzJDEsIF9fZXNNb2R1bGU6IHRydWUgfTtcbn0pO1xuXG52YXIgX09iamVjdCR2YWx1ZXMgPSB1bndyYXBFeHBvcnRzKHZhbHVlcyQyKTtcblxudmFyIGJhc2U2NEFycmF5YnVmZmVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uKCl7XG5cbiAgdmFyIGNoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XG5cbiAgLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxuICB2YXIgbG9va3VwID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG4gIH1cblxuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLFxuICAgIGksIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gXCJcIjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTMpIHtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2kgKyAxXSAmIDE1KSA8PCAyKSB8IChieXRlc1tpICsgMl0gPj4gNildO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG5cbiAgICBpZiAoKGxlbiAlIDMpID09PSAyKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArIFwiPVwiO1xuICAgIH0gZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U2NDtcbiAgfTtcblxuICBleHBvcnRzLmRlY29kZSA9ICBmdW5jdGlvbihiYXNlNjQpIHtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsXG4gICAgbGVuID0gYmFzZTY0Lmxlbmd0aCwgaSwgcCA9IDAsXG4gICAgZW5jb2RlZDEsIGVuY29kZWQyLCBlbmNvZGVkMywgZW5jb2RlZDQ7XG5cbiAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gXCI9XCIpIHtcbiAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLFxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgZW5jb2RlZDEgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSldO1xuICAgICAgZW5jb2RlZDIgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSsxKV07XG4gICAgICBlbmNvZGVkMyA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKzIpXTtcbiAgICAgIGVuY29kZWQ0ID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkrMyldO1xuXG4gICAgICBieXRlc1twKytdID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheWJ1ZmZlcjtcbiAgfTtcbn0pKCk7XG59KTtcbnZhciBiYXNlNjRBcnJheWJ1ZmZlcl8xID0gYmFzZTY0QXJyYXlidWZmZXIuZW5jb2RlO1xudmFyIGJhc2U2NEFycmF5YnVmZmVyXzIgPSBiYXNlNjRBcnJheWJ1ZmZlci5kZWNvZGU7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxudmFyIF9saXN0Q2FjaGVDbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxudmFyIGVxXzEgPSBlcTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxXzEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG52YXIgX2Fzc29jSW5kZXhPZiA9IGFzc29jSW5kZXhPZjtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gX2Fzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIF9saXN0Q2FjaGVEZWxldGUgPSBsaXN0Q2FjaGVEZWxldGU7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBfYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG52YXIgX2xpc3RDYWNoZUdldCA9IGxpc3RDYWNoZUdldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIF9hc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG52YXIgX2xpc3RDYWNoZUhhcyA9IGxpc3RDYWNoZUhhcztcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IF9hc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIF9saXN0Q2FjaGVTZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gX2xpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBfbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBfbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBfbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBfbGlzdENhY2hlU2V0O1xuXG52YXIgX0xpc3RDYWNoZSA9IExpc3RDYWNoZTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IF9MaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbnZhciBfc3RhY2tDbGVhciA9IHN0YWNrQ2xlYXI7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9zdGFja0RlbGV0ZSA9IHN0YWNrRGVsZXRlO1xuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbnZhciBfc3RhY2tHZXQgPSBzdGFja0dldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxudmFyIF9zdGFja0hhcyA9IHN0YWNrSGFzO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IF9yb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxudmFyIF9jb3JlSnNEYXRhID0gY29yZUpzRGF0YTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhfY29yZUpzRGF0YSAmJiBfY29yZUpzRGF0YS5rZXlzICYmIF9jb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxudmFyIF9pc01hc2tlZCA9IGlzTWFza2VkO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvJDEgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmckMSA9IGZ1bmNQcm90byQxLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmckMS5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxudmFyIF90b1NvdXJjZSA9IHRvU291cmNlO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byQyID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvJDcgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nJDIgPSBmdW5jUHJvdG8kMi50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkNiA9IG9iamVjdFByb3RvJDcuaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmckMi5jYWxsKGhhc093blByb3BlcnR5JDYpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0XzEodmFsdWUpIHx8IF9pc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uXzEodmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdChfdG9Tb3VyY2UodmFsdWUpKTtcbn1cblxudmFyIF9iYXNlSXNOYXRpdmUgPSBiYXNlSXNOYXRpdmU7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG52YXIgX2dldFZhbHVlID0gZ2V0VmFsdWU7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBfZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gX2Jhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxudmFyIF9nZXROYXRpdmUgPSBnZXROYXRpdmU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBfZ2V0TmF0aXZlKF9yb290LCAnTWFwJyk7XG5cbnZhciBfTWFwID0gTWFwO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gX2dldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxudmFyIF9uYXRpdmVDcmVhdGUgPSBuYXRpdmVDcmVhdGU7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IF9uYXRpdmVDcmVhdGUgPyBfbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbnZhciBfaGFzaENsZWFyID0gaGFzaENsZWFyO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2hhc2hEZWxldGUgPSBoYXNoRGVsZXRlO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ4ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkNyA9IG9iamVjdFByb3RvJDguaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChfbmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkkNy5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbnZhciBfaGFzaEdldCA9IGhhc2hHZXQ7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQ5ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkkOCA9IG9iamVjdFByb3RvJDkuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gX25hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eSQ4LmNhbGwoZGF0YSwga2V5KTtcbn1cblxudmFyIF9oYXNoSGFzID0gaGFzaEhhcztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEJDEgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChfbmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQkMSA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIF9oYXNoU2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IF9oYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBfaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IF9oYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gX2hhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBfaGFzaFNldDtcblxudmFyIF9IYXNoID0gSGFzaDtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBfSGFzaCxcbiAgICAnbWFwJzogbmV3IChfTWFwIHx8IF9MaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgX0hhc2hcbiAgfTtcbn1cblxudmFyIF9tYXBDYWNoZUNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG52YXIgX2lzS2V5YWJsZSA9IGlzS2V5YWJsZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIF9pc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxudmFyIF9nZXRNYXBEYXRhID0gZ2V0TWFwRGF0YTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gX2dldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX21hcENhY2hlRGVsZXRlID0gbWFwQ2FjaGVEZWxldGU7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIF9nZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbnZhciBfbWFwQ2FjaGVHZXQgPSBtYXBDYWNoZUdldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIF9nZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbnZhciBfbWFwQ2FjaGVIYXMgPSBtYXBDYWNoZUhhcztcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gX2dldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIF9tYXBDYWNoZVNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gX21hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gX21hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IF9tYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBfbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gX21hcENhY2hlU2V0O1xuXG52YXIgX01hcENhY2hlID0gTWFwQ2FjaGU7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIF9MaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghX01hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBfTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgX3N0YWNrU2V0ID0gc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IF9MaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IF9zdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IF9zdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBfc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gX3N0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IF9zdGFja1NldDtcblxudmFyIF9TdGFjayA9IFN0YWNrO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQkMiA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCQyKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBfc2V0Q2FjaGVBZGQgPSBzZXRDYWNoZUFkZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG52YXIgX3NldENhY2hlSGFzID0gc2V0Q2FjaGVIYXM7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IF9NYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gX3NldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IF9zZXRDYWNoZUhhcztcblxudmFyIF9TZXRDYWNoZSA9IFNldENhY2hlO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgX2FycmF5U29tZSA9IGFycmF5U29tZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbnZhciBfY2FjaGVIYXMgPSBjYWNoZUhhcztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IF9TZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIV9hcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFfY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9lcXVhbEFycmF5cyA9IGVxdWFsQXJyYXlzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5JDEgPSBfcm9vdC5VaW50OEFycmF5O1xuXG52YXIgX1VpbnQ4QXJyYXkgPSBVaW50OEFycmF5JDE7XG5cbi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfbWFwVG9BcnJheSA9IG1hcFRvQXJyYXk7XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfc2V0VG9BcnJheSA9IHNldFRvQXJyYXk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHJDEgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUckMSA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnJDEgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyQxID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnJDEgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyQxID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnJDEgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWckMSA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyQxID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnJDEgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnJDEgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnJDEgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IF9TeW1ib2wkMSA/IF9TeW1ib2wkMS5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnJDE6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWckMTpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBfVWludDhBcnJheShvYmplY3QpLCBuZXcgX1VpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZyQxOlxuICAgIGNhc2UgZGF0ZVRhZyQxOlxuICAgIGNhc2UgbnVtYmVyVGFnJDE6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcV8xKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnJDE6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWckMTpcbiAgICBjYXNlIHN0cmluZ1RhZyQxOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnJDE6XG4gICAgICB2YXIgY29udmVydCA9IF9tYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWckMTpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUckMTtcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBfc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHJDE7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IF9lcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgX2VxdWFsQnlUYWcgPSBlcXVhbEJ5VGFnO1xuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbnZhciBfYXJyYXlQdXNoID0gYXJyYXlQdXNoO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheV8xKG9iamVjdCkgPyByZXN1bHQgOiBfYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbnZhciBfYmFzZUdldEFsbEtleXMgPSBiYXNlR2V0QWxsS2V5cztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2FycmF5RmlsdGVyID0gYXJyYXlGaWx0ZXI7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbnZhciBzdHViQXJyYXlfMSA9IHN0dWJBcnJheTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvJDEwID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUkMSA9IG9iamVjdFByb3RvJDEwLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5XzEgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gX2FycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlJDEuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxudmFyIF9nZXRTeW1ib2xzID0gZ2V0U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gX2Jhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c18xLCBfZ2V0U3ltYm9scyk7XG59XG5cbnZhciBfZ2V0QWxsS2V5cyA9IGdldEFsbEtleXM7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHJDIgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kMTEgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQ5ID0gb2JqZWN0UHJvdG8kMTEuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUckMixcbiAgICAgIG9ialByb3BzID0gX2dldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gX2dldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkkOS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9lcXVhbE9iamVjdHMgPSBlcXVhbE9iamVjdHM7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IF9nZXROYXRpdmUoX3Jvb3QsICdEYXRhVmlldycpO1xuXG52YXIgX0RhdGFWaWV3ID0gRGF0YVZpZXc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlJDIgPSBfZ2V0TmF0aXZlKF9yb290LCAnUHJvbWlzZScpO1xuXG52YXIgX1Byb21pc2UkMSA9IFByb21pc2UkMjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IF9nZXROYXRpdmUoX3Jvb3QsICdTZXQnKTtcblxudmFyIF9TZXQkMSA9IFNldDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBfZ2V0TmF0aXZlKF9yb290LCAnV2Vha01hcCcpO1xuXG52YXIgX1dlYWtNYXAkMSA9IFdlYWtNYXA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWckMiA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyQyID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWckMiA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWckMSA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnJDIgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IF90b1NvdXJjZShfRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSBfdG9Tb3VyY2UoX01hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSBfdG9Tb3VyY2UoX1Byb21pc2UkMSksXG4gICAgc2V0Q3RvclN0cmluZyA9IF90b1NvdXJjZShfU2V0JDEpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gX3RvU291cmNlKF9XZWFrTWFwJDEpO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gX2Jhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoX0RhdGFWaWV3ICYmIGdldFRhZyhuZXcgX0RhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnJDIpIHx8XG4gICAgKF9NYXAgJiYgZ2V0VGFnKG5ldyBfTWFwKSAhPSBtYXBUYWckMikgfHxcbiAgICAoX1Byb21pc2UkMSAmJiBnZXRUYWcoX1Byb21pc2UkMS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKF9TZXQkMSAmJiBnZXRUYWcobmV3IF9TZXQkMSkgIT0gc2V0VGFnJDIpIHx8XG4gICAgKF9XZWFrTWFwJDEgJiYgZ2V0VGFnKG5ldyBfV2Vha01hcCQxKSAhPSB3ZWFrTWFwVGFnJDEpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IF9iYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWckMiA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IF90b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnJDI7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZyQyO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnJDI7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnJDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbnZhciBfZ2V0VGFnID0gZ2V0VGFnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyQzID0gMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWckMiA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnJDEgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyQzID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQxMiA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDEwID0gb2JqZWN0UHJvdG8kMTIuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheV8xKG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXlfMShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnJDEgOiBfZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnJDEgOiBfZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyQyID8gb2JqZWN0VGFnJDMgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnJDIgPyBvYmplY3RUYWckMyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnJDMsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWckMyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcl8xJDEob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXJfMSQxKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBfU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5XzEob2JqZWN0KSlcbiAgICAgID8gX2VxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IF9lcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHJDMpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5JDEwLmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkkMTAuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IF9TdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBfU3RhY2spO1xuICByZXR1cm4gX2VxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxudmFyIF9iYXNlSXNFcXVhbERlZXAgPSBiYXNlSXNFcXVhbERlZXA7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2VfMSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZV8xKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gX2Jhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbnZhciBfYmFzZUlzRXF1YWwgPSBiYXNlSXNFcXVhbDtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUckNCA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyQyID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgX1N0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBfYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyQ0IHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyQyLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgX2Jhc2VJc01hdGNoID0gYmFzZUlzTWF0Y2g7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0XzEodmFsdWUpO1xufVxuXG52YXIgX2lzU3RyaWN0Q29tcGFyYWJsZSA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzXzEob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgX2lzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfZ2V0TWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbnZhciBfbWF0Y2hlc1N0cmljdENvbXBhcmFibGUgPSBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBfZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIF9tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBfYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbnZhciBfYmFzZU1hdGNoZXMgPSBiYXNlTWF0Y2hlcztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyQxID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wkMSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZV8xKHZhbHVlKSAmJiBfYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnJDEpO1xufVxuXG52YXIgaXNTeW1ib2xfMSA9IGlzU3ltYm9sJDE7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5XzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sXzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbnZhciBfaXNLZXkgPSBpc0tleTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgX01hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBfTWFwQ2FjaGU7XG5cbnZhciBtZW1vaXplXzEgPSBtZW1vaXplO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplXzEoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9tZW1vaXplQ2FwcGVkID0gbWVtb2l6ZUNhcHBlZDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBfbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxudmFyIF9zdHJpbmdUb1BhdGggPSBzdHJpbmdUb1BhdGg7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvJDEgPSBfU3ltYm9sJDEgPyBfU3ltYm9sJDEucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8kMSA/IHN5bWJvbFByb3RvJDEudG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXlfMSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBfYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2xfMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxudmFyIF9iYXNlVG9TdHJpbmcgPSBiYXNlVG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyQzKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBfYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxudmFyIHRvU3RyaW5nXzEgPSB0b1N0cmluZyQzO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheV8xKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gX2lzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IF9zdHJpbmdUb1BhdGgodG9TdHJpbmdfMSh2YWx1ZSkpO1xufVxuXG52YXIgX2Nhc3RQYXRoID0gY2FzdFBhdGg7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZJDEgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sXzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkkMSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG52YXIgX3RvS2V5ID0gdG9LZXk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gX2Nhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFtfdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxudmFyIF9iYXNlR2V0ID0gYmFzZUdldDtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IF9iYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxudmFyIGdldF8xID0gZ2V0O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxudmFyIF9iYXNlSGFzSW4gPSBiYXNlSGFzSW47XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBfY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gX3RvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGhfMShsZW5ndGgpICYmIF9pc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5XzEob2JqZWN0KSB8fCBpc0FyZ3VtZW50c18xKG9iamVjdCkpO1xufVxuXG52YXIgX2hhc1BhdGggPSBoYXNQYXRoO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgX2hhc1BhdGgob2JqZWN0LCBwYXRoLCBfYmFzZUhhc0luKTtcbn1cblxudmFyIGhhc0luXzEgPSBoYXNJbjtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUckNSA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyQzID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoX2lzS2V5KHBhdGgpICYmIF9pc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIF9tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShfdG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0XzEob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbl8xKG9iamVjdCwgcGF0aClcbiAgICAgIDogX2Jhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUckNSB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUckMyk7XG4gIH07XG59XG5cbnZhciBfYmFzZU1hdGNoZXNQcm9wZXJ0eSA9IGJhc2VNYXRjaGVzUHJvcGVydHk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbnZhciBpZGVudGl0eV8xID0gaWRlbnRpdHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbnZhciBfYmFzZVByb3BlcnR5ID0gYmFzZVByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIF9iYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbnZhciBfYmFzZVByb3BlcnR5RGVlcCA9IGJhc2VQcm9wZXJ0eURlZXA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gX2lzS2V5KHBhdGgpID8gX2Jhc2VQcm9wZXJ0eShfdG9LZXkocGF0aCkpIDogX2Jhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbnZhciBwcm9wZXJ0eV8xID0gcHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHlfMTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXlfMSh2YWx1ZSlcbiAgICAgID8gX2Jhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBfYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eV8xKHZhbHVlKTtcbn1cblxudmFyIF9iYXNlSXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWU7XG5cbi8qKlxuICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubGFzdChbMSwgMiwgM10pO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xufVxuXG52YXIgbGFzdF8xID0gbGFzdDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICB9XG4gIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuZ3RoO1xuICB9XG4gIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgc3RhcnQgPj4+PSAwO1xuXG4gIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VTbGljZSA9IGJhc2VTbGljZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIGdldCB0aGUgcGFyZW50IHZhbHVlIG9mLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBhcmVudCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcGFyZW50KG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogX2Jhc2VHZXQob2JqZWN0LCBfYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG59XG5cbnZhciBfcGFyZW50ID0gcGFyZW50O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwcm9wZXJ0eSBwYXRoIHRvIHVuc2V0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbnNldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IF9jYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICBvYmplY3QgPSBfcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W190b0tleShsYXN0XzEocGF0aCkpXTtcbn1cblxudmFyIF9iYXNlVW5zZXQgPSBiYXNlVW5zZXQ7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvJDEgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSQxID0gYXJyYXlQcm90byQxLnNwbGljZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICogaW5kZXhlcyBvciBjYXB0dXJpbmcgdGhlIHJlbW92ZWQgZWxlbWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA/IGluZGV4ZXMubGVuZ3RoIDogMCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgIGlmIChsZW5ndGggPT0gbGFzdEluZGV4IHx8IGluZGV4ICE9PSBwcmV2aW91cykge1xuICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICBpZiAoX2lzSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgIHNwbGljZSQxLmNhbGwoYXJyYXksIGluZGV4LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9iYXNlVW5zZXQoYXJyYXksIGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG52YXIgX2Jhc2VQdWxsQXQgPSBiYXNlUHVsbEF0O1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxuICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZFxuICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnB1bGxgXG4gKiB0byBwdWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgdmFsdWUuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDRdO1xuICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG4pIHtcbiAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gKiB9KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gKiAvLyA9PiBbMSwgM11cbiAqXG4gKiBjb25zb2xlLmxvZyhldmVucyk7XG4gKiAvLyA9PiBbMiwgNF1cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgPSBfYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgfVxuICB9XG4gIF9iYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIHJlbW92ZV8xID0gcmVtb3ZlO1xuXG4vLyAyMi4xLjMuOCBBcnJheS5wcm90b3R5cGUuZmluZChwcmVkaWNhdGUsIHRoaXNBcmcgPSB1bmRlZmluZWQpXG5cbnZhciAkZmluZCA9IF9hcnJheU1ldGhvZHMoNSk7XG52YXIgS0VZID0gJ2ZpbmQnO1xudmFyIGZvcmNlZCA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEtFWSBpbiBbXSkgQXJyYXkoMSlbS0VZXShmdW5jdGlvbiAoKSB7IGZvcmNlZCA9IGZhbHNlOyB9KTtcbl9leHBvcnQoX2V4cG9ydC5QICsgX2V4cG9ydC5GICogZm9yY2VkLCAnQXJyYXknLCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxudmFyIGZpbmQgPSBfY29yZS5BcnJheS5maW5kO1xuXG52YXIgZmluZCQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xubW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBmaW5kLCBfX2VzTW9kdWxlOiB0cnVlIH07XG59KTtcblxudmFyIF9BcnJheSRmaW5kID0gdW53cmFwRXhwb3J0cyhmaW5kJDEpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnJDMgPSAnW29iamVjdCBNYXBdJyxcbiAgICBzZXRUYWckMyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8kMTMgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSQxMSA9IG9iamVjdFByb3RvJDEzLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IG9iamVjdCwgY29sbGVjdGlvbiwgbWFwLCBvciBzZXQuXG4gKlxuICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gKiBwcm9wZXJ0aWVzLlxuICpcbiAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICogalF1ZXJ5LWxpa2UgY29sbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYGxlbmd0aGAgb2YgYDBgLlxuICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0VtcHR5KG51bGwpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSh0cnVlKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNBcnJheUxpa2VfMSh2YWx1ZSkgJiZcbiAgICAgIChpc0FycmF5XzEodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgaXNCdWZmZXJfMSQxKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXlfMSh2YWx1ZSkgfHwgaXNBcmd1bWVudHNfMSh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gIH1cbiAgdmFyIHRhZyA9IF9nZXRUYWcodmFsdWUpO1xuICBpZiAodGFnID09IG1hcFRhZyQzIHx8IHRhZyA9PSBzZXRUYWckMykge1xuICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgfVxuICBpZiAoX2lzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgIHJldHVybiAhX2Jhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5JDExLmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBpc0VtcHR5XzEgPSBpc0VtcHR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbnZhciBfYXJyYXlFYWNoID0gYXJyYXlFYWNoO1xuXG52YXIgZGVmaW5lUHJvcGVydHkkNCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IF9nZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSQxID0gZGVmaW5lUHJvcGVydHkkNDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBfZGVmaW5lUHJvcGVydHkkMSkge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxudmFyIF9iYXNlQXNzaWduVmFsdWUgPSBiYXNlQXNzaWduVmFsdWU7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQxNCA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDEyID0gb2JqZWN0UHJvdG8kMTQuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5JDEyLmNhbGwob2JqZWN0LCBrZXkpICYmIGVxXzEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgX2Jhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbnZhciBfYXNzaWduVmFsdWUgPSBhc3NpZ25WYWx1ZTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgX2Jhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxudmFyIF9jb3B5T2JqZWN0ID0gY29weU9iamVjdDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBfY29weU9iamVjdChzb3VyY2UsIGtleXNfMShzb3VyY2UpLCBvYmplY3QpO1xufVxuXG52YXIgX2Jhc2VBc3NpZ24gPSBiYXNlQXNzaWduO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9uYXRpdmVLZXlzSW4gPSBuYXRpdmVLZXlzSW47XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQxNSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDEzID0gb2JqZWN0UHJvdG8kMTUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3RfMShvYmplY3QpKSB7XG4gICAgcmV0dXJuIF9uYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IF9pc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eSQxMy5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2Jhc2VLZXlzSW4gPSBiYXNlS2V5c0luO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luJDEob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZV8xKG9iamVjdCkgPyBfYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogX2Jhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxudmFyIGtleXNJbl8xID0ga2V5c0luJDE7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIF9jb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luXzEoc291cmNlKSwgb2JqZWN0KTtcbn1cblxudmFyIF9iYXNlQXNzaWduSW4gPSBiYXNlQXNzaWduSW47XG5cbnZhciBfY2xvbmVCdWZmZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gJ29iamVjdCcgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmICdvYmplY3QnID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gX3Jvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVCdWZmZXI7XG59KTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBfY29weU9iamVjdChzb3VyY2UsIF9nZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbnZhciBfY29weVN5bWJvbHMgPSBjb3B5U3ltYm9scztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyQxID8gc3R1YkFycmF5XzEgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgX2FycmF5UHVzaChyZXN1bHQsIF9nZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIF9nZXRTeW1ib2xzSW4gPSBnZXRTeW1ib2xzSW47XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIF9jb3B5T2JqZWN0KHNvdXJjZSwgX2dldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG52YXIgX2NvcHlTeW1ib2xzSW4gPSBjb3B5U3ltYm9sc0luO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIF9iYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbl8xLCBfZ2V0U3ltYm9sc0luKTtcbn1cblxudmFyIF9nZXRBbGxLZXlzSW4gPSBnZXRBbGxLZXlzSW47XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byQxNiA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5JDE0ID0gb2JqZWN0UHJvdG8kMTYuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eSQxNC5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfaW5pdENsb25lQXJyYXkgPSBpbml0Q2xvbmVBcnJheTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgX1VpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IF9VaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBfY2xvbmVBcnJheUJ1ZmZlciA9IGNsb25lQXJyYXlCdWZmZXI7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gX2Nsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG52YXIgX2Nsb25lRGF0YVZpZXcgPSBjbG9uZURhdGFWaWV3O1xuXG4vKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgX2Nsb25lUmVnRXhwID0gY2xvbmVSZWdFeHA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvJDIgPSBfU3ltYm9sJDEgPyBfU3ltYm9sJDEucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YkMSA9IHN5bWJvbFByb3RvJDIgPyBzeW1ib2xQcm90byQyLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2xWYWx1ZU9mJDEgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZiQxLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxudmFyIF9jbG9uZVN5bWJvbCA9IGNsb25lU3ltYm9sO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IF9jbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxudmFyIF9jbG9uZVR5cGVkQXJyYXkgPSBjbG9uZVR5cGVkQXJyYXk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnJDIgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyQyID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIG1hcFRhZyQ0ID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnJDIgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWckMiA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyQ0ID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnJDIgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWckMiA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWckMiA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWckMyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyQxID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyQxID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyQxID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWckMSA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyQxID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnJDEgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnJDEgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyQxID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWckMSA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZyQyOlxuICAgICAgcmV0dXJuIF9jbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWckMjpcbiAgICBjYXNlIGRhdGVUYWckMjpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWckMzpcbiAgICAgIHJldHVybiBfY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWckMTogY2FzZSBmbG9hdDY0VGFnJDE6XG4gICAgY2FzZSBpbnQ4VGFnJDE6IGNhc2UgaW50MTZUYWckMTogY2FzZSBpbnQzMlRhZyQxOlxuICAgIGNhc2UgdWludDhUYWckMTogY2FzZSB1aW50OENsYW1wZWRUYWckMTogY2FzZSB1aW50MTZUYWckMTogY2FzZSB1aW50MzJUYWckMTpcbiAgICAgIHJldHVybiBfY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnJDQ6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZyQyOlxuICAgIGNhc2Ugc3RyaW5nVGFnJDI6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnJDI6XG4gICAgICByZXR1cm4gX2Nsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZyQ0OlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWckMjpcbiAgICAgIHJldHVybiBfY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG52YXIgX2luaXRDbG9uZUJ5VGFnID0gaW5pdENsb25lQnlUYWc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0XzEocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxudmFyIF9iYXNlQ3JlYXRlID0gYmFzZUNyZWF0ZTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFfaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IF9iYXNlQ3JlYXRlKF9nZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG52YXIgX2luaXRDbG9uZU9iamVjdCA9IGluaXRDbG9uZU9iamVjdDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyQ1ID0gJ1tvYmplY3QgTWFwXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlXzEodmFsdWUpICYmIF9nZXRUYWcodmFsdWUpID09IG1hcFRhZyQ1O1xufVxuXG52YXIgX2Jhc2VJc01hcCA9IGJhc2VJc01hcDtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNNYXAgPSBfbm9kZVV0aWwgJiYgX25vZGVVdGlsLmlzTWFwO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc01hcChuZXcgTWFwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc01hcCA9IG5vZGVJc01hcCA/IF9iYXNlVW5hcnkobm9kZUlzTWFwKSA6IF9iYXNlSXNNYXA7XG5cbnZhciBpc01hcF8xID0gaXNNYXA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzZXRUYWckNSA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZV8xKHZhbHVlKSAmJiBfZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWckNTtcbn1cblxudmFyIF9iYXNlSXNTZXQgPSBiYXNlSXNTZXQ7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzU2V0ID0gX25vZGVVdGlsICYmIF9ub2RlVXRpbC5pc1NldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTZXQobmV3IFNldCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBfYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBfYmFzZUlzU2V0O1xuXG52YXIgaXNTZXRfMSA9IGlzU2V0O1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyQzID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWckMiA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyQzID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWckMyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyQyID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnJDIgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyQxID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWckNiA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyQzID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnJDQgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWckMyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyQ2ID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnJDMgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWckMyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWckMiA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnJDMgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnJDQgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWckMiA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWckMiA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWckMiA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnJDIgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWckMiA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyQyID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyQyID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWckMiA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnJDIgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZyQzXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWckMl0gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZyQzXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWckNF0gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnJDNdID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnJDNdID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZyQyXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZyQyXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWckMl0gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnJDJdID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWckMl0gPSBjbG9uZWFibGVUYWdzW21hcFRhZyQ2XSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZyQzXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnJDRdID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnJDNdID0gY2xvbmVhYmxlVGFnc1tzZXRUYWckNl0gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWckM10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZyQzXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnJDJdID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWckMl0gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWckMl0gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZyQyXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnJDJdID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnJDJdID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZyQyXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0XzEodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXlfMSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IF9pbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBfY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gX2dldFRhZyh2YWx1ZSksXG4gICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnJDIgfHwgdGFnID09IGdlblRhZyQxO1xuXG4gICAgaWYgKGlzQnVmZmVyXzEkMSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBfY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnJDQgfHwgdGFnID09IGFyZ3NUYWckMyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IF9pbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gX2NvcHlTeW1ib2xzSW4odmFsdWUsIF9iYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgOiBfY29weVN5bWJvbHModmFsdWUsIF9iYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBfaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IF9TdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0XzEodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoaXNNYXBfMSh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgPyAoaXNGbGF0ID8gX2dldEFsbEtleXNJbiA6IF9nZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXNfMSk7XG5cbiAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gIF9hcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIF9hc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIF9iYXNlQ2xvbmUgPSBiYXNlQ2xvbmU7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHJDEgPSAxLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyQxID0gNDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gIHJldHVybiBfYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUckMSB8IENMT05FX1NZTUJPTFNfRkxBRyQxKTtcbn1cblxudmFyIGNsb25lRGVlcF8xID0gY2xvbmVEZWVwO1xuXG4vLyBJTUNsaWVudFxudmFyIElOVklURUQgPSAnaW52aXRlZCc7XG52YXIgS0lDS0VEID0gJ2tpY2tlZCc7XG52YXIgTUVNQkVSU19KT0lORUQgPSAnbWVtYmVyc2pvaW5lZCc7XG52YXIgTUVNQkVSU19MRUZUID0gJ21lbWJlcnNsZWZ0JztcbnZhciBNRU1CRVJfSU5GT19VUERBVEVEID0gJ21lbWJlcmluZm91cGRhdGVkJztcbnZhciBCTE9DS0VEID0gJ2Jsb2NrZWQnO1xudmFyIFVOQkxPQ0tFRCA9ICd1bmJsb2NrZWQnO1xudmFyIE1FTUJFUlNfQkxPQ0tFRCA9ICdtZW1iZXJzYmxvY2tlZCc7XG52YXIgTUVNQkVSU19VTkJMT0NLRUQgPSAnbWVtYmVyc3VuYmxvY2tlZCc7XG52YXIgTVVURUQgPSAnbXV0ZWQnO1xudmFyIFVOTVVURUQgPSAndW5tdXRlZCc7XG52YXIgTUVNQkVSU19NVVRFRCA9ICdtZW1iZXJzbXV0ZWQnO1xudmFyIE1FTUJFUlNfVU5NVVRFRCA9ICdtZW1iZXJzdW5tdXRlZCc7XG52YXIgTUVTU0FHRSQxID0gJ21lc3NhZ2UnO1xudmFyIFVOUkVBRF9NRVNTQUdFU19DT1VOVF9VUERBVEUgPSAndW5yZWFkbWVzc2FnZXNjb3VudHVwZGF0ZSc7XG52YXIgQ0xPU0UgPSAnY2xvc2UnO1xudmFyIENPTkZMSUNUID0gJ2NvbmZsaWN0JztcbnZhciBVTkhBTkRMRURfTUVTU0FHRSA9ICd1bmhhbmRsZWRtZXNzYWdlJztcbnZhciBDT05WRVJTQVRJT05fSU5GT19VUERBVEVEID0gJ2NvbnZlcnNhdGlvbmluZm91cGRhdGVkJztcblxuLy8gQ29udmVyc2F0aW9uXG52YXIgTEFTVF9ERUxJVkVSRURfQVRfVVBEQVRFID0gJ2xhc3RkZWxpdmVyZWRhdHVwZGF0ZSc7XG52YXIgTEFTVF9SRUFEX0FUX1VQREFURSA9ICdsYXN0cmVhZGF0dXBkYXRlJztcbnZhciBNRVNTQUdFX1JFQ0FMTCA9ICdtZXNzYWdlcmVjYWxsJztcbnZhciBNRVNTQUdFX1VQREFURSA9ICdtZXNzYWdldXBkYXRlJztcbnZhciBJTkZPX1VQREFURUQgPSAnaW5mb3VwZGF0ZWQnO1xuXG52YXIgRXZlbnQgPSBPYmplY3QuZnJlZXplKHtcblx0SU5WSVRFRDogSU5WSVRFRCxcblx0S0lDS0VEOiBLSUNLRUQsXG5cdE1FTUJFUlNfSk9JTkVEOiBNRU1CRVJTX0pPSU5FRCxcblx0TUVNQkVSU19MRUZUOiBNRU1CRVJTX0xFRlQsXG5cdE1FTUJFUl9JTkZPX1VQREFURUQ6IE1FTUJFUl9JTkZPX1VQREFURUQsXG5cdEJMT0NLRUQ6IEJMT0NLRUQsXG5cdFVOQkxPQ0tFRDogVU5CTE9DS0VELFxuXHRNRU1CRVJTX0JMT0NLRUQ6IE1FTUJFUlNfQkxPQ0tFRCxcblx0TUVNQkVSU19VTkJMT0NLRUQ6IE1FTUJFUlNfVU5CTE9DS0VELFxuXHRNVVRFRDogTVVURUQsXG5cdFVOTVVURUQ6IFVOTVVURUQsXG5cdE1FTUJFUlNfTVVURUQ6IE1FTUJFUlNfTVVURUQsXG5cdE1FTUJFUlNfVU5NVVRFRDogTUVNQkVSU19VTk1VVEVELFxuXHRNRVNTQUdFOiBNRVNTQUdFJDEsXG5cdFVOUkVBRF9NRVNTQUdFU19DT1VOVF9VUERBVEU6IFVOUkVBRF9NRVNTQUdFU19DT1VOVF9VUERBVEUsXG5cdENMT1NFOiBDTE9TRSxcblx0Q09ORkxJQ1Q6IENPTkZMSUNULFxuXHRVTkhBTkRMRURfTUVTU0FHRTogVU5IQU5ETEVEX01FU1NBR0UsXG5cdENPTlZFUlNBVElPTl9JTkZPX1VQREFURUQ6IENPTlZFUlNBVElPTl9JTkZPX1VQREFURUQsXG5cdExBU1RfREVMSVZFUkVEX0FUX1VQREFURTogTEFTVF9ERUxJVkVSRURfQVRfVVBEQVRFLFxuXHRMQVNUX1JFQURfQVRfVVBEQVRFOiBMQVNUX1JFQURfQVRfVVBEQVRFLFxuXHRNRVNTQUdFX1JFQ0FMTDogTUVTU0FHRV9SRUNBTEwsXG5cdE1FU1NBR0VfVVBEQVRFOiBNRVNTQUdFX1VQREFURSxcblx0SU5GT19VUERBVEVEOiBJTkZPX1VQREFURURcbn0pO1xuXG52YXIgX3JNZXNzYWdlU3RhdHVzO1xuXG4vKipcbiAqIOa2iOaBr+eKtuaAgeaemuS4vlxuICogQGVudW0ge1N5bWJvbH1cbiAqIEBzaW5jZSAzLjIuMFxuICogQG1lbWJlcm9mIG1vZHVsZTpsZWFuY2xvdWQtcmVhbHRpbWVcbiAqL1xudmFyIE1lc3NhZ2VTdGF0dXMgPSB7XG4gIC8qKiDliJ3lp4vnirbmgIHjgIHmnKrnn6XnirbmgIEgKi9cbiAgTk9ORTogX1N5bWJvbCgnbm9uZScpLFxuICAvKiog5q2j5Zyo5Y+R6YCBICovXG4gIFNFTkRJTkc6IF9TeW1ib2woJ3NlbmRpbmcnKSxcbiAgLyoqIOW3suWPkemAgSAqL1xuICBTRU5UOiBfU3ltYm9sKCdzZW50JyksXG4gIC8qKiDlt7LpgIHovr4gKi9cbiAgREVMSVZFUkVEOiBfU3ltYm9sKCdkZWxpdmVyZWQnKSxcbiAgLyoqIOWPkemAgeWksei0pSAqL1xuICBGQUlMRUQ6IF9TeW1ib2woJ2ZhaWxlZCcpXG59O1xuX09iamVjdCRmcmVlemUoTWVzc2FnZVN0YXR1cyk7XG5cbnZhciByTWVzc2FnZVN0YXR1cyA9IChfck1lc3NhZ2VTdGF0dXMgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9yTWVzc2FnZVN0YXR1cywgTWVzc2FnZVN0YXR1cy5OT05FLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9yTWVzc2FnZVN0YXR1cywgTWVzc2FnZVN0YXR1cy5TRU5ESU5HLCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9yTWVzc2FnZVN0YXR1cywgTWVzc2FnZVN0YXR1cy5TRU5ULCB0cnVlKSwgX2RlZmluZVByb3BlcnR5KF9yTWVzc2FnZVN0YXR1cywgTWVzc2FnZVN0YXR1cy5ERUxJVkVSRUQsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3JNZXNzYWdlU3RhdHVzLCBNZXNzYWdlU3RhdHVzLlJFQUQsIHRydWUpLCBfZGVmaW5lUHJvcGVydHkoX3JNZXNzYWdlU3RhdHVzLCBNZXNzYWdlU3RhdHVzLkZBSUxFRCwgdHJ1ZSksIF9yTWVzc2FnZVN0YXR1cyk7XG5cbnZhciBNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGltcGxlbWVudHMgQVZNZXNzYWdlXG4gICAqIEBwYXJhbSAge09iamVjdHxTdHJpbmd8QXJyYXlCdWZmZXJ9IGNvbnRlbnQg5raI5oGv5YaF5a65XG4gICAqL1xuICBmdW5jdGlvbiBNZXNzYWdlKGNvbnRlbnQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVzc2FnZSk7XG5cbiAgICBfT2JqZWN0JGFzc2lnbih0aGlzLCB7IGNvbnRlbnQ6IGNvbnRlbnQgfSwge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICogQG1lbWJlcm9mIE1lc3NhZ2UjXG4gICAgICAgKi9cbiAgICAgIGlkOiB2NF8xKCksXG4gICAgICAvKipcbiAgICAgICAqIOa2iOaBr+aJgOWcqOeahCBjb252ZXJzYXRpb24gaWRcbiAgICAgICAqIEBtZW1iZXJvZiBNZXNzYWdlI1xuICAgICAgICogQHR5cGUge1N0cmluZz99XG4gICAgICAgKi9cbiAgICAgIGNpZDogbnVsbCxcbiAgICAgIC8qKlxuICAgICAgICog5raI5oGv5Y+R6YCB5pe26Ze0XG4gICAgICAgKiBAbWVtYmVyb2YgTWVzc2FnZSNcbiAgICAgICAqIEB0eXBlIHtEYXRlfVxuICAgICAgICovXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAvKipcbiAgICAgICAqIOa2iOaBr+WPkemAgeiAhVxuICAgICAgICogQG1lbWJlcm9mIE1lc3NhZ2UjXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBmcm9tOiB1bmRlZmluZWQsXG4gICAgICAvKipcbiAgICAgICAqIOa2iOaBr+aPkOWPiueahOeUqOaIt1xuICAgICAgICogQHNpbmNlIDQuMC4wXG4gICAgICAgKiBAbWVtYmVyb2YgTWVzc2FnZSNcbiAgICAgICAqIEB0eXBlIHtTdHJpbmdbXX1cbiAgICAgICAqL1xuICAgICAgbWVudGlvbkxpc3Q6IFtdLFxuICAgICAgLyoqXG4gICAgICAgKiDmtojmga/mmK/lkKbmj5Dlj4rkuobmiYDmnInkurpcbiAgICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAgICogQG1lbWJlcm9mIE1lc3NhZ2UjXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgbWVudGlvbmVkQWxsOiBmYWxzZSxcbiAgICAgIF9tZW50aW9uZWQ6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5fc2V0U3RhdHVzKE1lc3NhZ2VTdGF0dXMuTk9ORSk7XG4gIH1cblxuICAvKipcbiAgICog5bCG5b2T5YmN5raI5oGv55qE5YaF5a655bqP5YiX5YyW5Li6IEpTT04g5a+56LGhXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cblxuICBNZXNzYWdlLnByb3RvdHlwZS5nZXRQYXlsb2FkID0gZnVuY3Rpb24gZ2V0UGF5bG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICB9O1xuXG4gIE1lc3NhZ2UucHJvdG90eXBlLl90b0pTT04gPSBmdW5jdGlvbiBfdG9KU09OKCkge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsXG4gICAgICAgIGNpZCA9IHRoaXMuY2lkLFxuICAgICAgICBmcm9tID0gdGhpcy5mcm9tLFxuICAgICAgICB0aW1lc3RhbXAgPSB0aGlzLnRpbWVzdGFtcCxcbiAgICAgICAgZGVsaXZlcmVkQXQgPSB0aGlzLmRlbGl2ZXJlZEF0LFxuICAgICAgICB1cGRhdGVkQXQgPSB0aGlzLnVwZGF0ZWRBdCxcbiAgICAgICAgbWVudGlvbkxpc3QgPSB0aGlzLm1lbnRpb25MaXN0LFxuICAgICAgICBtZW50aW9uZWRBbGwgPSB0aGlzLm1lbnRpb25lZEFsbCxcbiAgICAgICAgbWVudGlvbmVkID0gdGhpcy5tZW50aW9uZWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGlkLFxuICAgICAgY2lkOiBjaWQsXG4gICAgICBmcm9tOiBmcm9tLFxuICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXG4gICAgICBkZWxpdmVyZWRBdDogZGVsaXZlcmVkQXQsXG4gICAgICB1cGRhdGVkQXQ6IHVwZGF0ZWRBdCxcbiAgICAgIG1lbnRpb25MaXN0OiBtZW50aW9uTGlzdCxcbiAgICAgIG1lbnRpb25lZEFsbDogbWVudGlvbmVkQWxsLFxuICAgICAgbWVudGlvbmVkOiBtZW50aW9uZWRcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiDov5Tlm54gSlNPTiDmoLzlvI/nmoTmtojmga9cbiAgICogQHJldHVybiB7T2JqZWN0fSDov5Tlm57lgLzmmK/kuIDkuKogcGxhaW4gT2JqZWN0XG4gICAqL1xuXG5cbiAgTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiBfZXh0ZW5kcyQxKHt9LCB0aGlzLl90b0pTT04oKSwge1xuICAgICAgZGF0YTogdGhpcy5jb250ZW50XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIOi/lOWbniBKU09OIOagvOW8j+eahOa2iOaBr++8jOS4jiB0b0pTT04g5LiN5ZCM55qE5piv77yM6K+l5a+56LGh5YyF5ZCr5LqG5a6M5pW055qE5L+h5oGv77yM5Y+v5Lul6YCa6L+HIHtAbGluayBJTUNsaWVudCNwYXJzZU1lc3NhZ2V9IOWPjeW6j+WIl+WMluOAglxuICAgKiBAcmV0dXJuIHtPYmplY3R9IOi/lOWbnuWAvOaYr+S4gOS4qiBwbGFpbiBPYmplY3RcbiAgICogQHNpbmNlIDQuMC4wXG4gICAqL1xuXG5cbiAgTWVzc2FnZS5wcm90b3R5cGUudG9GdWxsSlNPTiA9IGZ1bmN0aW9uIHRvRnVsbEpTT04oKSB7XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQsXG4gICAgICAgIGlkID0gdGhpcy5pZCxcbiAgICAgICAgY2lkID0gdGhpcy5jaWQsXG4gICAgICAgIGZyb20gPSB0aGlzLmZyb20sXG4gICAgICAgIHRpbWVzdGFtcCA9IHRoaXMudGltZXN0YW1wLFxuICAgICAgICBkZWxpdmVyZWRBdCA9IHRoaXMuZGVsaXZlcmVkQXQsXG4gICAgICAgIF91cGRhdGVkQXQgPSB0aGlzLl91cGRhdGVkQXQsXG4gICAgICAgIG1lbnRpb25MaXN0ID0gdGhpcy5tZW50aW9uTGlzdCxcbiAgICAgICAgbWVudGlvbmVkQWxsID0gdGhpcy5tZW50aW9uZWRBbGw7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogY29udGVudCxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGNpZDogY2lkLFxuICAgICAgZnJvbTogZnJvbSxcbiAgICAgIHRpbWVzdGFtcDogZ2V0VGltZSh0aW1lc3RhbXApLFxuICAgICAgZGVsaXZlcmVkQXQ6IGdldFRpbWUoZGVsaXZlcmVkQXQpLFxuICAgICAgdXBkYXRlZEF0OiBnZXRUaW1lKF91cGRhdGVkQXQpLFxuICAgICAgbWVudGlvbkxpc3Q6IG1lbnRpb25MaXN0LFxuICAgICAgbWVudGlvbmVkQWxsOiBtZW50aW9uZWRBbGxcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiDmtojmga/nirbmgIHvvIzlgLzkuLoge0BsaW5rIG1vZHVsZTpsZWFuY2xvdWQtcmVhbHRpbWUuTWVzc2FnZVN0YXR1c30g5LmL5LiAXG4gICAqIEB0eXBlIHtTeW1ib2x9XG4gICAqIEByZWFkb25seVxuICAgKiBAc2luY2UgMy4yLjBcbiAgICovXG5cblxuICBNZXNzYWdlLnByb3RvdHlwZS5fc2V0U3RhdHVzID0gZnVuY3Rpb24gX3NldFN0YXR1cyhzdGF0dXMpIHtcbiAgICBpZiAoIXJNZXNzYWdlU3RhdHVzW3N0YXR1c10pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlIHN0YXR1cycpO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0dXMgPSBzdGF0dXM7XG4gIH07XG5cbiAgTWVzc2FnZS5wcm90b3R5cGUuX3VwZGF0ZU1lbnRpb25lZCA9IGZ1bmN0aW9uIF91cGRhdGVNZW50aW9uZWQoY2xpZW50KSB7XG4gICAgdGhpcy5fbWVudGlvbmVkID0gdGhpcy5mcm9tICE9PSBjbGllbnQgJiYgKHRoaXMubWVudGlvbmVkQWxsIHx8IHRoaXMubWVudGlvbkxpc3QuaW5kZXhPZihjbGllbnQpID4gLTEpO1xuICB9O1xuICAvKipcbiAgICog6I635Y+W5o+Q5Y+K55So5oi35YiX6KGoXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX0g5o+Q5Y+K55So5oi355qEIGlkIOWIl+ihqFxuICAgKi9cblxuXG4gIE1lc3NhZ2UucHJvdG90eXBlLmdldE1lbnRpb25MaXN0ID0gZnVuY3Rpb24gZ2V0TWVudGlvbkxpc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVudGlvbkxpc3Q7XG4gIH07XG4gIC8qKlxuICAgKiDorr7nva7mj5Dlj4rnlKjmiLfliJfooahcbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IGNsaWVudHMg5o+Q5Y+K55So5oi355qEIGlkIOWIl+ihqFxuICAgKiBAcmV0dXJuIHt0aGlzfSBzZWxmXG4gICAqL1xuXG5cbiAgTWVzc2FnZS5wcm90b3R5cGUuc2V0TWVudGlvbkxpc3QgPSBmdW5jdGlvbiBzZXRNZW50aW9uTGlzdChjbGllbnRzKSB7XG4gICAgdGhpcy5tZW50aW9uTGlzdCA9IGVuc3VyZUFycmF5KGNsaWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICog6K6+572u5piv5ZCm5o+Q5Y+K5omA5pyJ5Lq6XG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt2YWx1ZT10cnVlXVxuICAgKiBAcmV0dXJuIHt0aGlzfSBzZWxmXG4gICAqL1xuXG5cbiAgTWVzc2FnZS5wcm90b3R5cGUubWVudGlvbkFsbCA9IGZ1bmN0aW9uIG1lbnRpb25BbGwoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG4gICAgdGhpcy5tZW50aW9uZWRBbGwgPSBCb29sZWFuKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICog5Yik5pat57uZ5a6a55qE5YaF5a655piv5ZCm5piv5pyJ5pWI55qEIE1lc3NhZ2XvvIxcbiAgICog6K+l5pa55rOV5aeL57uI6L+U5ZueIHRydWVcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBpbXBsZW1lbnRzIEFWTWVzc2FnZS52YWxpZGF0ZVxuICAgKi9cblxuXG4gIE1lc3NhZ2UudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICog6Kej5p6Q5aSE55CG5raI5oGv5YaF5a65XG4gICAqIDxwcmU+XG4gICAqIOWmguaenOWtkOexu+aPkOS+m+S6hiBtZXNzYWdl77yM6L+U5Zue6K+lIG1lc3NhZ2VcbiAgICog5aaC5p6c5rKh5pyJ5o+Q5L6b77yM5bCGIGpzb24g5L2c5Li6IGNvbnRlbnQg5a6e5L6L5YyW5LiA5LiqIE1lc3NhZ2VcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSAganNvbiAgICBqc29uIOagvOW8j+eahOa2iOaBr+WGheWuuVxuICAgKiBAcGFyYW0gIHtNZXNzYWdlfSBtZXNzYWdlIOWtkOexu+aPkOS+m+eahCBtZXNzYWdlXG4gICAqIEByZXR1cm4ge01lc3NhZ2V9XG4gICAqIEBpbXBsZW1lbnRzIEFWTWVzc2FnZS5wYXJzZVxuICAgKi9cblxuXG4gIE1lc3NhZ2UucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShqc29uLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UgfHwgbmV3IHRoaXMoanNvbik7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE1lc3NhZ2UsIFt7XG4gICAga2V5OiAnc3RhdHVzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0dXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndGltZXN0YW1wJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90aW1lc3RhbXA7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5fdGltZXN0YW1wID0gZGVjb2RlRGF0ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5raI5oGv6YCB6L6+5pe26Ze0XG4gICAgICogQHR5cGUgez9EYXRlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZWxpdmVyZWRBdCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVsaXZlcmVkQXQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5fZGVsaXZlcmVkQXQgPSBkZWNvZGVEYXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmtojmga/kv67mlLnmiJbmkqTlm57ml7bpl7TvvIzlj6/ku6XpgJrov4fmr5TovoPlhbbkuI7mtojmga/nmoQgdGltZXN0YW1wIOaYr+WQpuebuOetieWIpOaWrea2iOaBr+aYr+WQpuiiq+S/ruaUuei/h+aIluaSpOWbnui/h+OAglxuICAgICAqIEB0eXBlIHtEYXRlfVxuICAgICAqIEBzaW5jZSAzLjUuMFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVkQXQnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZWRBdCB8fCB0aGlzLnRpbWVzdGFtcDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl91cGRhdGVkQXQgPSBkZWNvZGVEYXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlvZPliY3nlKjmiLfmmK/lkKblnKjor6Xmtojmga/kuK3ooqvmj5Dlj4pcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWVudGlvbmVkJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tZW50aW9uZWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1lc3NhZ2U7XG59KCk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5cbi8vIGRvY3VtZW50ZWQgaW4gLi4vaW5kZXguanNcbnZhciBtZXNzYWdlVHlwZSA9IGZ1bmN0aW9uIG1lc3NhZ2VUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IodHlwZSArICcgaXMgbm90IGEgTnVtYmVyJyk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB0YXJnZXQuVFlQRSA9IHR5cGU7XG4gICAgdGFyZ2V0LnZhbGlkYXRlID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgIHJldHVybiBqc29uLl9sY3R5cGUgPT09IHR5cGU7XG4gICAgfTtcbiAgICB0YXJnZXQucHJvdG90eXBlLl9nZXRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgX2xjdHlwZTogdHlwZSB9O1xuICAgIH07XG4gIH07XG59O1xuXG4vLyBkb2N1bWVudGVkIGluIC4uL2luZGV4LmpzXG52YXIgbWVzc2FnZUZpZWxkID0gZnVuY3Rpb24gbWVzc2FnZUZpZWxkKGZpZWxkcykge1xuICBpZiAodHlwZW9mIGZpZWxkcyAhPT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmllbGRzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihmaWVsZHMgKyAnIGlzIG5vdCBhbiBBcnJheScpO1xuICAgIH0gZWxzZSBpZiAoZmllbGRzLnNvbWUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJztcbiAgICB9KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmllbGRzIGNvbnRhaW5zIG5vbi1zdHJpbmcgdHlwZWQgbWVtYmVyJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgLy8gSUUxMCBIYWNrOlxuICAgIC8vIHN0YXRpYyBwcm9wZXJ0aWVzIGluIElFMTAgd2lsbCBub3QgYmUgaW5oZXJpdGVkIGZyb20gc3VwZXJcbiAgICAvLyBzZWFyY2ggZm9yIHBhcnNlIG1ldGhvZCBhbmQgYXNzaWduIGl0IG1hbnVhbGx5XG4gICAgdmFyIG9yaWdpbmFsQ3VzdG9tRmllbGRzID0gaXNJRTEwID8gZ2V0U3RhdGljUHJvcGVydHkodGFyZ2V0LCAnX2N1c3RvbUZpZWxkcycpIDogdGFyZ2V0Ll9jdXN0b21GaWVsZHM7XG4gICAgb3JpZ2luYWxDdXN0b21GaWVsZHMgPSBBcnJheS5pc0FycmF5KG9yaWdpbmFsQ3VzdG9tRmllbGRzKSA/IG9yaWdpbmFsQ3VzdG9tRmllbGRzIDogW107XG4gICAgdGFyZ2V0Ll9jdXN0b21GaWVsZHMgPSBvcmlnaW5hbEN1c3RvbUZpZWxkcy5jb25jYXQoZmllbGRzKTtcbiAgfTtcbn07XG5cbi8vIElFMTAgSGFjazpcbi8vIHN0YXRpYyBwcm9wZXJ0aWVzIGluIElFMTAgd2lsbCBub3QgYmUgaW5oZXJpdGVkIGZyb20gc3VwZXJcbi8vIHNlYXJjaCBmb3IgcGFyc2UgbWV0aG9kIGFuZCBhc3NpZ24gaXQgbWFudWFsbHlcblxudmFyIElFMTBDb21wYXRpYmxlID0gZnVuY3Rpb24gSUUxMENvbXBhdGlibGUodGFyZ2V0KSB7XG4gIGlmIChpc0lFMTApIHtcbiAgICB0YXJnZXQucGFyc2UgPSBnZXRTdGF0aWNQcm9wZXJ0eSh0YXJnZXQsICdwYXJzZScpO1xuICB9XG59O1xuXG52YXIgX2RlYywgX2NsYXNzJDE7XG5cbi8vIGpzZG9jLWlnbm9yZS1zdGFydFxuXG4vLyBqc2RvYy1pZ25vcmUtZW5kXG4vKipcbiAqIOaJgOacieWGhee9rueahOWvjOWqkuS9k+a2iOaBr+Wdh+e7p+aJv+iHquacrOexu1xuICogQGV4dGVuZHMgTWVzc2FnZVxuICovXG52YXIgVHlwZWRNZXNzYWdlID0gKF9kZWMgPSBtZXNzYWdlRmllbGQoWydfbGN0ZXh0JywgJ19sY2F0dHJzJ10pLCBfZGVjKF9jbGFzcyQxID0gZnVuY3Rpb24gKF9NZXNzYWdlKSB7XG4gIF9pbmhlcml0cyhUeXBlZE1lc3NhZ2UsIF9NZXNzYWdlKTtcblxuICBmdW5jdGlvbiBUeXBlZE1lc3NhZ2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFR5cGVkTWVzc2FnZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX01lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAgICogQHJldHVybiB7dGhpc30gc2VsZlxuICAgKi9cbiAgVHlwZWRNZXNzYWdlLnByb3RvdHlwZS5zZXRUZXh0ID0gZnVuY3Rpb24gc2V0VGV4dCh0ZXh0KSB7XG4gICAgdGhpcy5fbGN0ZXh0ID0gdGV4dDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG5cblxuICBUeXBlZE1lc3NhZ2UucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiBnZXRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9sY3RleHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRyaWJ1dGVzXG4gICAqIEByZXR1cm4ge3RoaXN9IHNlbGZcbiAgICovXG5cblxuICBUeXBlZE1lc3NhZ2UucHJvdG90eXBlLnNldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICB0aGlzLl9sY2F0dHJzID0gYXR0cmlidXRlcztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cblxuICBUeXBlZE1lc3NhZ2UucHJvdG90eXBlLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9sY2F0dHJzO1xuICB9O1xuXG4gIFR5cGVkTWVzc2FnZS5wcm90b3R5cGUuX2dldEN1c3RvbUZpZWxkcyA9IGZ1bmN0aW9uIF9nZXRDdXN0b21GaWVsZHMoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgZmllbGRzID0gQXJyYXkuaXNBcnJheSh0aGlzLmNvbnN0cnVjdG9yLl9jdXN0b21GaWVsZHMpID8gdGhpcy5jb25zdHJ1Y3Rvci5fY3VzdG9tRmllbGRzIDogW107XG4gICAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgZmllbGQpIHtcbiAgICAgIGlmICh0eXBlb2YgZmllbGQgIT09ICdzdHJpbmcnKSByZXR1cm4gcmVzdWx0O1xuICAgICAgcmVzdWx0W2ZpZWxkXSA9IF90aGlzMltmaWVsZF07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xuICB9O1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cblxuXG4gIFR5cGVkTWVzc2FnZS5wcm90b3R5cGUuX2dldFR5cGUgPSBmdW5jdGlvbiBfZ2V0VHlwZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cblxuICBUeXBlZE1lc3NhZ2UucHJvdG90eXBlLmdldFBheWxvYWQgPSBmdW5jdGlvbiBnZXRQYXlsb2FkKCkge1xuICAgIHJldHVybiBjb21wYWN0KF9PYmplY3QkYXNzaWduKHtcbiAgICAgIF9sY3RleHQ6IHRoaXMuZ2V0VGV4dCgpLFxuICAgICAgX2xjYXR0cnM6IHRoaXMuZ2V0QXR0cmlidXRlcygpXG4gICAgfSwgdGhpcy5fZ2V0Q3VzdG9tRmllbGRzKCksIHRoaXMuX2dldFR5cGUoKSkpO1xuICB9O1xuXG4gIFR5cGVkTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHZhciB0eXBlID0gdGhpcy50eXBlLFxuICAgICAgICB0ZXh0ID0gdGhpcy50ZXh0LFxuICAgICAgICBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLFxuICAgICAgICBzdW1tYXJ5ID0gdGhpcy5zdW1tYXJ5O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzJDEoe30sIF9NZXNzYWdlLnByb3RvdHlwZS5fdG9KU09OLmNhbGwodGhpcyksIHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgIHN1bW1hcnk6IHN1bW1hcnlcbiAgICB9KTtcbiAgfTtcblxuICBUeXBlZE1lc3NhZ2UucHJvdG90eXBlLnRvRnVsbEpTT04gPSBmdW5jdGlvbiB0b0Z1bGxKU09OKCkge1xuICAgIHJldHVybiBfZXh0ZW5kcyQxKHt9LCBfTWVzc2FnZS5wcm90b3R5cGUudG9GdWxsSlNPTi5jYWxsKHRoaXMpLCB7XG4gICAgICBkYXRhOiB0aGlzLmdldFBheWxvYWQoKVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiDop6PmnpDlpITnkIbmtojmga/lhoXlrrlcbiAgICogPHByZT5cbiAgICog5Li657uZ5a6a55qEIG1lc3NhZ2Ug6K6+572uIHRleHQg5LiOIGF0dHJpYnV0ZXMg5bGe5oCn77yM6L+U5Zue6K+lIG1lc3NhZ2VcbiAgICog5aaC5p6c5a2Q57G75rKh5pyJ5o+Q5L6bIG1lc3NhZ2XvvIxuZXcgdGhpcygpXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtICB7T2JqZWN0fSAganNvbiAgICBqc29uIOagvOW8j+eahOa2iOaBr+WGheWuuVxuICAgKiBAcGFyYW0gIHtUeXBlZE1lc3NhZ2V9IG1lc3NhZ2Ug5a2Q57G75o+Q5L6b55qEIG1lc3NhZ2VcbiAgICogQHJldHVybiB7VHlwZWRNZXNzYWdlfVxuICAgKiBAaW1wbGVtZW50cyBBVk1lc3NhZ2UucGFyc2VcbiAgICovXG5cblxuICBUeXBlZE1lc3NhZ2UucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShqc29uKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5ldyB0aGlzKCk7XG5cbiAgICBtZXNzYWdlLmNvbnRlbnQgPSBqc29uOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdmFyIGN1c3RvbUZpZWxkcyA9IGlzSUUxMCA/IGdldFN0YXRpY1Byb3BlcnR5KG1lc3NhZ2UuY29uc3RydWN0b3IsICdfY3VzdG9tRmllbGRzJykgOiBtZXNzYWdlLmNvbnN0cnVjdG9yLl9jdXN0b21GaWVsZHM7XG4gICAgdmFyIGZpZWxkcyA9IEFycmF5LmlzQXJyYXkoY3VzdG9tRmllbGRzKSA/IGN1c3RvbUZpZWxkcyA6IFtdO1xuICAgIGZpZWxkcyA9IGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgZmllbGQpIHtcbiAgICAgIGlmICh0eXBlb2YgZmllbGQgIT09ICdzdHJpbmcnKSByZXR1cm4gcmVzdWx0O1xuICAgICAgcmVzdWx0W2ZpZWxkXSA9IGpzb25bZmllbGRdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbiAgICBfT2JqZWN0JGFzc2lnbihtZXNzYWdlLCBmaWVsZHMpO1xuICAgIHJldHVybiBfTWVzc2FnZS5wYXJzZS5jYWxsKHRoaXMsIGpzb24sIG1lc3NhZ2UpO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhUeXBlZE1lc3NhZ2UsIFt7XG4gICAga2V5OiAndHlwZScsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuVFlQRTtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge1N0cmluZ30gKi9cblxuICB9LCB7XG4gICAga2V5OiAndGV4dCcsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0VGV4dCh0ZXh0KTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGV4dCgpO1xuICAgIH1cblxuICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhdHRyaWJ1dGVzJyxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChhdHRyaWJ1dGVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Zyo5a6i5oi356uv6ZyA6KaB5Lul5paH5pys5b2i5byP5bGV56S66K+l5raI5oGv5pe25pi+56S655qE5paH5qGI77yMXG4gICAgICog5aaCIDxjb2RlPlvnuqLljIVdIOaWsOaYpeW/q+S5kDwvY29kZT7jgIJcbiAgICAgKiDpu5jorqTlgLzkuLrmtojmga/nmoQgdGV4dOOAglxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N1bW1hcnknLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHlwZWRNZXNzYWdlO1xufShNZXNzYWdlKSkgfHwgX2NsYXNzJDEpO1xuXG52YXIgX2RlYyQxLCBfY2xhc3MkMjtcblxuLy8ganNkb2MtaWdub3JlLXN0YXJ0XG5cbi8vIGpzZG9jLWlnbm9yZS1lbmRcbi8qKlxuICog5bey5pKk5Zue57G75Z6L5raI5oGv77yM5b2T5raI5oGv6KKr5pKk5Zue5pe277yMU0RLIOS8muS9v+eUqOivpeexu+Wei+eahOa2iOaBr+abv+S7o+WOn+Wni+a2iOaBr1xuICogQGV4dGVuZHMgVHlwZWRNZXNzYWdlXG4gKi9cbnZhciBSZWNhbGxlZE1lc3NhZ2UgPSAoX2RlYyQxID0gbWVzc2FnZVR5cGUoLTEyNyksIF9kZWMkMShfY2xhc3MkMiA9IElFMTBDb21wYXRpYmxlKF9jbGFzcyQyID0gZnVuY3Rpb24gKF9UeXBlZE1lc3NhZ2UpIHtcbiAgX2luaGVyaXRzKFJlY2FsbGVkTWVzc2FnZSwgX1R5cGVkTWVzc2FnZSk7XG5cbiAgZnVuY3Rpb24gUmVjYWxsZWRNZXNzYWdlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZWNhbGxlZE1lc3NhZ2UpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9UeXBlZE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVjYWxsZWRNZXNzYWdlLCBbe1xuICAgIGtleTogJ3N1bW1hcnknLFxuXG4gICAgLyoqXG4gICAgICog5Zyo5a6i5oi356uv6ZyA6KaB5Lul5paH5pys5b2i5byP5bGV56S66K+l5raI5oGv5pe25pi+56S655qE5paH5qGI77yM5YC85Li6IDxjb2RlPlvor6Xmtojmga/lt7LmkqTlm55dPC9jb2RlPlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnW+ivpea2iOaBr+W3suaSpOWbnl0nO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZWNhbGxlZE1lc3NhZ2U7XG59KFR5cGVkTWVzc2FnZSkpIHx8IF9jbGFzcyQyKSB8fCBfY2xhc3MkMik7XG5cbnZhciBkZWJ1ZyQ2ID0gYnJvd3NlcignTEM6Q29udmVyc2F0aW9uJyk7XG5cbnZhciBzZXJpYWxpemVNZXNzYWdlID0gZnVuY3Rpb24gc2VyaWFsaXplTWVzc2FnZShtZXNzYWdlKSB7XG4gIHZhciBjb250ZW50ID0gbWVzc2FnZS5nZXRQYXlsb2FkKCk7XG4gIHZhciBtc2cgPSB2b2lkIDA7XG4gIHZhciBiaW5hcnlNc2cgPSB2b2lkIDA7XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBiaW5hcnlNc2cgPSBjb250ZW50O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJykge1xuICAgIG1zZyA9IF9KU09OJHN0cmluZ2lmeShjb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBtc2cgPSBjb250ZW50O1xuICB9XG4gIHJldHVybiB7IG1zZzogbXNnLCBiaW5hcnlNc2c6IGJpbmFyeU1zZyB9O1xufTtcblxudmFyIF9Mb2dzQ29tbWFuZCRRdWVyeURpciA9IExvZ3NDb21tYW5kLlF1ZXJ5RGlyZWN0aW9uLFxuICAgIE5FVyA9IF9Mb2dzQ29tbWFuZCRRdWVyeURpci5ORVcsXG4gICAgT0xEID0gX0xvZ3NDb21tYW5kJFF1ZXJ5RGlyLk9MRDtcblxuLyoqXG4gKiDljoblj7Lmtojmga/mn6Xor6LmlrnlkJHmnprkuL5cbiAqIEBlbnVtIHtOdW1iZXJ9XG4gKiBAc2luY2UgNC4wLjBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6bGVhbmNsb3VkLXJlYWx0aW1lXG4gKi9cblxudmFyIE1lc3NhZ2VRdWVyeURpcmVjdGlvbiA9IHtcbiAgLyoqIOS7juWQjuWQkeWJjSAqL1xuICBORVdfVE9fT0xEOiBPTEQsXG4gIC8qKiDku47liY3lkJHlkI4gKi9cbiAgT0xEX1RPX05FVzogTkVXXG59O1xuX09iamVjdCRmcmVlemUoTWVzc2FnZVF1ZXJ5RGlyZWN0aW9uKTtcblxudmFyIENvbnZlcnNhdGlvbkJhc2UgPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoQ29udmVyc2F0aW9uQmFzZSwgX0V2ZW50RW1pdHRlcik7XG5cbiAgLyoqXG4gICAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGZ1bmN0aW9uIENvbnZlcnNhdGlvbkJhc2UoX3JlZiwgY2xpZW50KSB7XG4gICAgdmFyIGlkID0gX3JlZi5pZCxcbiAgICAgICAgbGFzdE1lc3NhZ2VBdCA9IF9yZWYubGFzdE1lc3NhZ2VBdCxcbiAgICAgICAgbGFzdE1lc3NhZ2UgPSBfcmVmLmxhc3RNZXNzYWdlLFxuICAgICAgICBsYXN0RGVsaXZlcmVkQXQgPSBfcmVmLmxhc3REZWxpdmVyZWRBdCxcbiAgICAgICAgbGFzdFJlYWRBdCA9IF9yZWYubGFzdFJlYWRBdCxcbiAgICAgICAgX3JlZiR1bnJlYWRNZXNzYWdlc0NvID0gX3JlZi51bnJlYWRNZXNzYWdlc0NvdW50LFxuICAgICAgICB1bnJlYWRNZXNzYWdlc0NvdW50ID0gX3JlZiR1bnJlYWRNZXNzYWdlc0NvID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR1bnJlYWRNZXNzYWdlc0NvLFxuICAgICAgICBfcmVmJG1lbWJlcnMgPSBfcmVmLm1lbWJlcnMsXG4gICAgICAgIG1lbWJlcnMgPSBfcmVmJG1lbWJlcnMgPT09IHVuZGVmaW5lZCA/IFtdIDogX3JlZiRtZW1iZXJzLFxuICAgICAgICBfcmVmJG1lbnRpb25lZCA9IF9yZWYubWVudGlvbmVkLFxuICAgICAgICBtZW50aW9uZWQgPSBfcmVmJG1lbnRpb25lZCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmJG1lbnRpb25lZCxcbiAgICAgICAgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBbJ2lkJywgJ2xhc3RNZXNzYWdlQXQnLCAnbGFzdE1lc3NhZ2UnLCAnbGFzdERlbGl2ZXJlZEF0JywgJ2xhc3RSZWFkQXQnLCAndW5yZWFkTWVzc2FnZXNDb3VudCcsICdtZW1iZXJzJywgJ21lbnRpb25lZCddKTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb252ZXJzYXRpb25CYXNlKTtcblxuICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSk7XG5cbiAgICBfT2JqZWN0JGFzc2lnbihfdGhpcywgX2V4dGVuZHMkMSh7XG4gICAgICAvKipcbiAgICAgICAqIOWvueivnSBpZO+8jOWvueW6lCBfQ29udmVyc2F0aW9uIOihqOS4reeahCBvYmplY3RJZFxuICAgICAgICogQG1lbWJlcm9mIENvbnZlcnNhdGlvbkJhc2UjXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBpZDogaWQsXG4gICAgICAvKipcbiAgICAgICAqIOacgOWQjuS4gOadoea2iOaBr+aXtumXtFxuICAgICAgICogQG1lbWJlcm9mIENvbnZlcnNhdGlvbkJhc2UjXG4gICAgICAgKiBAdHlwZSB7P0RhdGV9XG4gICAgICAgKi9cbiAgICAgIGxhc3RNZXNzYWdlQXQ6IGxhc3RNZXNzYWdlQXQsXG4gICAgICAvKipcbiAgICAgICAqIOacgOWQjuS4gOadoea2iOaBr1xuICAgICAgICogQG1lbWJlcm9mIENvbnZlcnNhdGlvbkJhc2UjXG4gICAgICAgKiBAdHlwZSB7P01lc3NhZ2V9XG4gICAgICAgKi9cbiAgICAgIGxhc3RNZXNzYWdlOiBsYXN0TWVzc2FnZSxcbiAgICAgIC8qKlxuICAgICAgICog5Y+C5LiO6K+l5a+56K+d55qE55So5oi35YiX6KGoXG4gICAgICAgKiBAbWVtYmVyb2YgQ29udmVyc2F0aW9uQmFzZSNcbiAgICAgICAqIEB0eXBlIHtTdHJpbmdbXX1cbiAgICAgICAqL1xuICAgICAgbWVtYmVyczogbWVtYmVyc1xuICAgIH0sIHByb3BlcnRpZXMpKTtcbiAgICBfdGhpcy5tZW1iZXJzID0gX0FycmF5JGZyb20obmV3IF9TZXQoX3RoaXMubWVtYmVycykpO1xuICAgIF9PYmplY3QkYXNzaWduKGludGVybmFsKF90aGlzKSwge1xuICAgICAgbWVzc2FnZXNXYWl0aW5nRm9yUmVjZWlwdDoge30sXG4gICAgICBsYXN0RGVsaXZlcmVkQXQ6IGxhc3REZWxpdmVyZWRBdCxcbiAgICAgIGxhc3RSZWFkQXQ6IGxhc3RSZWFkQXQsXG4gICAgICB1bnJlYWRNZXNzYWdlc0NvdW50OiB1bnJlYWRNZXNzYWdlc0NvdW50LFxuICAgICAgbWVudGlvbmVkOiBtZW50aW9uZWRcbiAgICB9KTtcbiAgICBpZiAoY2xpZW50IGluc3RhbmNlb2YgSU1DbGllbnQpIHtcbiAgICAgIF90aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnZlcnNhdGlvbiBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggYSBjbGllbnQnKTtcbiAgICB9XG4gICAgaWYgKGRlYnVnJDYuZW5hYmxlZCkge1xuICAgICAgX09iamVjdCR2YWx1ZXMoRXZlbnQpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5vbihldmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXlsb2FkID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICBwYXlsb2FkW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfdGhpcy5fZGVidWcoZXZlbnQgKyAnIGV2ZW50IGVtaXR0ZWQuICVvJywgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIG9uQ29udmVyc2F0aW9uQ3JlYXRlIGhvb2tcbiAgICBhcHBseURlY29yYXRvcnMoX3RoaXMuX2NsaWVudC5fcGx1Z2lucy5vbkNvbnZlcnNhdGlvbkNyZWF0ZSwgX3RoaXMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiDlvZPliY3nlKjmiLfmmK/lkKblnKjor6Xlr7nor53nmoTmnKror7vmtojmga/kuK3ooqvmj5Dlj4pcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKi9cblxuXG4gIENvbnZlcnNhdGlvbkJhc2UucHJvdG90eXBlLl9zZXRVbnJlYWRNZXNzYWdlc01lbnRpb25lZCA9IGZ1bmN0aW9uIF9zZXRVbnJlYWRNZXNzYWdlc01lbnRpb25lZCh2YWx1ZSkge1xuICAgIGludGVybmFsKHRoaXMpLnVucmVhZE1lc3NhZ2VzTWVudGlvbmVkID0gQm9vbGVhbih2YWx1ZSk7XG4gIH07XG5cbiAgQ29udmVyc2F0aW9uQmFzZS5wcm90b3R5cGUuX3NldExhc3REZWxpdmVyZWRBdCA9IGZ1bmN0aW9uIF9zZXRMYXN0RGVsaXZlcmVkQXQodmFsdWUpIHtcbiAgICB2YXIgZGF0ZSA9IGRlY29kZURhdGUodmFsdWUpO1xuICAgIGlmICghKGRhdGUgPCBpbnRlcm5hbCh0aGlzKS5sYXN0RGVsaXZlcmVkQXQpKSB7XG4gICAgICBpbnRlcm5hbCh0aGlzKS5sYXN0RGVsaXZlcmVkQXQgPSBkYXRlO1xuICAgICAgLyoqXG4gICAgICAgKiDmnIDlkI7mtojmga/pgIHovr7ml7bpl7Tmm7TmlrBcbiAgICAgICAqIEBldmVudCBDb252ZXJzYXRpb25CYXNlI0xBU1RfREVMSVZFUkVEX0FUX1VQREFURVxuICAgICAgICogQHNpbmNlIDMuNC4wXG4gICAgICAgKi9cbiAgICAgIHRoaXMuZW1pdChMQVNUX0RFTElWRVJFRF9BVF9VUERBVEUpO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIOacgOWQjua2iOaBr+iiq+mYheivu+aXtumXtO+8jOW4uOeUqOadpeWunueOsOWPkemAgea2iOaBr+eahOOAjOW3suivu+OAjeagh+iusO+8jOWPr+mAmui/hyB7QGxpbmsgQ29udmVyc2F0aW9uI2ZldGNoUmVjZWlwdFRpbWVzdGFtcHN9IOiOt+WPluaIluabtOaWsOivpeWxnuaAp1xuICAgKiBAdHlwZSB7P0RhdGV9XG4gICAqIEBzaW5jZSAzLjQuMFxuICAgKi9cblxuXG4gIENvbnZlcnNhdGlvbkJhc2UucHJvdG90eXBlLl9zZXRMYXN0UmVhZEF0ID0gZnVuY3Rpb24gX3NldExhc3RSZWFkQXQodmFsdWUpIHtcbiAgICB2YXIgZGF0ZSA9IGRlY29kZURhdGUodmFsdWUpO1xuICAgIGlmICghKGRhdGUgPCBpbnRlcm5hbCh0aGlzKS5sYXN0UmVhZEF0KSkge1xuICAgICAgaW50ZXJuYWwodGhpcykubGFzdFJlYWRBdCA9IGRhdGU7XG4gICAgICAvKipcbiAgICAgICAqIOacgOWQjua2iOaBr+iiq+mYheivu+aXtumXtOabtOaWsFxuICAgICAgICogQGV2ZW50IENvbnZlcnNhdGlvbkJhc2UjTEFTVF9SRUFEX0FUX1VQREFURVxuICAgICAgICogQHNpbmNlIDMuNC4wXG4gICAgICAgKi9cbiAgICAgIHRoaXMuZW1pdChMQVNUX1JFQURfQVRfVVBEQVRFKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIOi/lOWbniBKU09OIOagvOW8j+eahOWvueivne+8jOS4jiB0b0pTT04g5LiN5ZCM55qE5piv77yM6K+l5a+56LGh5YyF5ZCr5LqG5a6M5pW055qE5L+h5oGv77yM5Y+v5Lul6YCa6L+HIHtAbGluayBJTUNsaWVudCNwYXJzZUNvbnZlcnNhdGlvbn0g5Y+N5bqP5YiX5YyW44CCXG4gICAqIEByZXR1cm4ge09iamVjdH0g6L+U5Zue5YC85piv5LiA5LiqIHBsYWluIE9iamVjdFxuICAgKiBAc2luY2UgNC4wLjBcbiAgICovXG5cblxuICBDb252ZXJzYXRpb25CYXNlLnByb3RvdHlwZS50b0Z1bGxKU09OID0gZnVuY3Rpb24gdG9GdWxsSlNPTigpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLFxuICAgICAgICBtZW1iZXJzID0gdGhpcy5tZW1iZXJzLFxuICAgICAgICBsYXN0TWVzc2FnZUF0ID0gdGhpcy5sYXN0TWVzc2FnZUF0LFxuICAgICAgICBsYXN0RGVsaXZlcmVkQXQgPSB0aGlzLmxhc3REZWxpdmVyZWRBdCxcbiAgICAgICAgbGFzdFJlYWRBdCA9IHRoaXMubGFzdFJlYWRBdCxcbiAgICAgICAgbGFzdE1lc3NhZ2UgPSB0aGlzLmxhc3RNZXNzYWdlLFxuICAgICAgICB1bnJlYWRNZXNzYWdlc0NvdW50ID0gdGhpcy51bnJlYWRNZXNzYWdlc0NvdW50O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIG1lbWJlcnM6IG1lbWJlcnMsXG4gICAgICBsYXN0TWVzc2FnZUF0OiBnZXRUaW1lKGxhc3RNZXNzYWdlQXQpLFxuICAgICAgbGFzdERlbGl2ZXJlZEF0OiBnZXRUaW1lKGxhc3REZWxpdmVyZWRBdCksXG4gICAgICBsYXN0UmVhZEF0OiBnZXRUaW1lKGxhc3RSZWFkQXQpLFxuICAgICAgbGFzdE1lc3NhZ2U6IGxhc3RNZXNzYWdlID8gbGFzdE1lc3NhZ2UudG9GdWxsSlNPTigpIDogdW5kZWZpbmVkLFxuICAgICAgdW5yZWFkTWVzc2FnZXNDb3VudDogdW5yZWFkTWVzc2FnZXNDb3VudFxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIOi/lOWbniBKU09OIOagvOW8j+eahOWvueivnVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IOi/lOWbnuWAvOaYr+S4gOS4qiBwbGFpbiBPYmplY3RcbiAgICogQHNpbmNlIDQuMC4wXG4gICAqL1xuXG5cbiAgQ29udmVyc2F0aW9uQmFzZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsXG4gICAgICAgIG1lbWJlcnMgPSB0aGlzLm1lbWJlcnMsXG4gICAgICAgIGxhc3RNZXNzYWdlQXQgPSB0aGlzLmxhc3RNZXNzYWdlQXQsXG4gICAgICAgIGxhc3REZWxpdmVyZWRBdCA9IHRoaXMubGFzdERlbGl2ZXJlZEF0LFxuICAgICAgICBsYXN0UmVhZEF0ID0gdGhpcy5sYXN0UmVhZEF0LFxuICAgICAgICBsYXN0TWVzc2FnZSA9IHRoaXMubGFzdE1lc3NhZ2UsXG4gICAgICAgIHVucmVhZE1lc3NhZ2VzQ291bnQgPSB0aGlzLnVucmVhZE1lc3NhZ2VzQ291bnQsXG4gICAgICAgIHVucmVhZE1lc3NhZ2VzTWVudGlvbmVkID0gdGhpcy51bnJlYWRNZXNzYWdlc01lbnRpb25lZDtcblxuICAgIHJldHVybiB7XG4gICAgICBpZDogaWQsXG4gICAgICBtZW1iZXJzOiBtZW1iZXJzLFxuICAgICAgbGFzdE1lc3NhZ2VBdDogbGFzdE1lc3NhZ2VBdCxcbiAgICAgIGxhc3REZWxpdmVyZWRBdDogbGFzdERlbGl2ZXJlZEF0LFxuICAgICAgbGFzdFJlYWRBdDogbGFzdFJlYWRBdCxcbiAgICAgIGxhc3RNZXNzYWdlOiBsYXN0TWVzc2FnZSA/IGxhc3RNZXNzYWdlLnRvSlNPTigpIDogdW5kZWZpbmVkLFxuICAgICAgdW5yZWFkTWVzc2FnZXNDb3VudDogdW5yZWFkTWVzc2FnZXNDb3VudCxcbiAgICAgIHVucmVhZE1lc3NhZ2VzTWVudGlvbmVkOiB1bnJlYWRNZXNzYWdlc01lbnRpb25lZFxuICAgIH07XG4gIH07XG5cbiAgQ29udmVyc2F0aW9uQmFzZS5wcm90b3R5cGUuX2RlYnVnID0gZnVuY3Rpb24gX2RlYnVnKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcGFyYW1zID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIHBhcmFtc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGRlYnVnJDYuYXBwbHkodW5kZWZpbmVkLCBwYXJhbXMuY29uY2F0KFsnWycgKyB0aGlzLmlkICsgJ10nXSkpO1xuICB9O1xuXG4gIENvbnZlcnNhdGlvbkJhc2UucHJvdG90eXBlLl9zZW5kID0gZnVuY3Rpb24gX3NlbmQoY29tbWFuZCkge1xuICAgIHZhciBfY2xpZW50O1xuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICBpZiAoY29tbWFuZC5jbWQgPT09IG51bGwpIHtcbiAgICAgIGNvbW1hbmQuY21kID0gJ2NvbnYnO1xuICAgIH1cbiAgICBpZiAoY29tbWFuZC5jbWQgPT09ICdjb252JyAmJiBjb21tYW5kLmNvbnZNZXNzYWdlID09PSBudWxsKSB7XG4gICAgICBjb21tYW5kLmNvbnZNZXNzYWdlID0gbmV3IENvbnZDb21tYW5kKCk7XG4gICAgfVxuICAgIGlmIChjb21tYW5kLmNvbnZNZXNzYWdlICYmIGNvbW1hbmQuY29udk1lc3NhZ2UuY2lkID09PSBudWxsKSB7XG4gICAgICBjb21tYW5kLmNvbnZNZXNzYWdlLmNpZCA9IHRoaXMuaWQ7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgfVxuXG4gICAgcmV0dXJuIChfY2xpZW50ID0gdGhpcy5fY2xpZW50KS5fc2VuZC5hcHBseShfY2xpZW50LCBbY29tbWFuZF0uY29uY2F0KGFyZ3MpKTtcbiAgfTtcblxuICAvKipcbiAgICog5Y+R6YCB5raI5oGvXG4gICAqIEBwYXJhbSAge01lc3NhZ2V9IG1lc3NhZ2Ug5raI5oGv77yMTWVzc2FnZSDlj4rlhbblrZDnsbvnmoTlrp7kvotcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzaW5jZSB2My4zLjDvvIzlj5HpgIHpgInpoblcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2llbnRdIHNpbmNlIHYzLjMuMe+8jOaYr+WQpuS9nOS4uuaaguaAgea2iOaBr+WPkemAgVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlY2VpcHRdIOaYr+WQpumcgOimgeWbnuaJp++8jOS7heWcqOaZrumAmuWvueivneS4reacieaViFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpbGxdIHNpbmNlIHYzLjQuMO+8jOaYr+WQpuaMh+Wumuivpea2iOaBr+S9nOS4uuOAjOaOiee6v+a2iOaBr+OAjeWPkemAge+8jFxuICAgKiDjgIzmjonnur/mtojmga/jgI3kvJrlu7bov5/liLDlvZPliY3nlKjmiLfmjonnur/lkI7lj5HpgIHvvIzluLjnlKjmnaXlrp7njrDjgIzkuIvnur/pgJrnn6XjgI3lip/og71cbiAgICogQHBhcmFtIHtNZXNzYWdlUHJpb3JpdHl9IFtvcHRpb25zLnByaW9yaXR5XSDmtojmga/kvJjlhYjnuqfvvIzku4XlnKjmmoLmgIHlr7nor53kuK3mnInmlYjvvIxcbiAgICogc2VlOiB7QGxpbmsgbW9kdWxlOmxlYW5jbG91ZC1yZWFsdGltZS5NZXNzYWdlUHJpb3JpdHkgTWVzc2FnZVByaW9yaXR5fVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucHVzaERhdGFdIOa2iOaBr+WvueW6lOeahOemu+e6v+aOqOmAgeWGheWuue+8jOWmguaenOa2iOaBr+aOpeaUtuaWueS4jeWcqOe6v++8jOS8muaOqOmAgeaMh+WumueahOWGheWuueOAguWFtue7k+aehOivtOaYjuWPguingToge0BsaW5rIGh0dHBzOi8vdXJsLmxlYW5hcHAuY24vcHVzaERhdGEg5o6o6YCB5raI5oGv5YaF5a65fVxuICAgKiBAcmV0dXJuIHtQcm9taXNlLjxNZXNzYWdlPn0g5Y+R6YCB55qE5raI5oGvXG4gICAqL1xuXG5cbiAgQ29udmVyc2F0aW9uQmFzZS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX09iamVjdCRhc3NpZ24yLCB0cmFuc2llbnQsIHJlY2VpcHQsIHByaW9yaXR5LCBwdXNoRGF0YSwgd2lsbCwgX3NlcmlhbGl6ZU1lc3NhZ2UsIG1zZywgYmluYXJ5TXNnLCBjb21tYW5kLCByZXNDb21tYW5kLCBfcmVzQ29tbWFuZCRhY2tNZXNzYWcsIHVpZCwgdCwgY29kZSwgcmVhc29uLCBhcHBDb2RlO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgdGhpcy5fZGVidWcobWVzc2FnZSwgJ3NlbmQnKTtcblxuICAgICAgICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobWVzc2FnZSArICcgaXMgbm90IGEgTWVzc2FnZScpO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIF9PYmplY3QkYXNzaWduMiA9IF9PYmplY3QkYXNzaWduKHt9LFxuICAgICAgICAgICAgICAvLyBzdXBwb3J0IE1lc3NhZ2Ugc3RhdGljIHByb3BlcnR5OiBzZW5kT3B0aW9uc1xuICAgICAgICAgICAgICBtZXNzYWdlLmNvbnN0cnVjdG9yLnNlbmRPcHRpb25zLFxuICAgICAgICAgICAgICAvLyBzdXBwb3J0IE1lc3NhZ2Ugc3RhdGljIHByb3BlcnR5OiBnZXRTZW5kT3B0aW9uc1xuICAgICAgICAgICAgICB0eXBlb2YgbWVzc2FnZS5jb25zdHJ1Y3Rvci5nZXRTZW5kT3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IG1lc3NhZ2UuY29uc3RydWN0b3IuZ2V0U2VuZE9wdGlvbnMobWVzc2FnZSkgOiB7fSwgb3B0aW9ucyksIHRyYW5zaWVudCA9IF9PYmplY3QkYXNzaWduMi50cmFuc2llbnQsIHJlY2VpcHQgPSBfT2JqZWN0JGFzc2lnbjIucmVjZWlwdCwgcHJpb3JpdHkgPSBfT2JqZWN0JGFzc2lnbjIucHJpb3JpdHksIHB1c2hEYXRhID0gX09iamVjdCRhc3NpZ24yLnB1c2hEYXRhLCB3aWxsID0gX09iamVjdCRhc3NpZ24yLndpbGw7XG5cbiAgICAgICAgICAgICAgaWYgKHJlY2VpcHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc2llbnQpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigncmVjZWlwdCBvcHRpb24gaXMgaWdub3JlZCBhcyB0aGUgY29udmVyc2F0aW9uIGlzIHRyYW5zaWVudC4nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRyYW5zaWVudCkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdyZWNlaXB0IG9wdGlvbiBpcyBpZ25vcmVkIGFzIHRoZSBtZXNzYWdlIGlzIHNlbnQgdHJhbnNpZW50bHkuJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1lbWJlcnMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdyZWNlaXB0IG9wdGlvbiBpcyByZWNvbW1lbmRlZCB0byBiZSB1c2VkIGluIG9uZS1vbi1vbmUgY29udmVyc2F0aW9uLicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHByaW9yaXR5ICYmICF0aGlzLnRyYW5zaWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigncHJpb3JpdHkgb3B0aW9uIGlzIGlnbm9yZWQgYXMgdGhlIGNvbnZlcnNhdGlvbiBpcyBub3QgdHJhbnNpZW50LicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9PYmplY3QkYXNzaWduKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICBjaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgZnJvbTogdGhpcy5fY2xpZW50LmlkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBtZXNzYWdlLl9zZXRTdGF0dXMoTWVzc2FnZVN0YXR1cy5TRU5ESU5HKTtcbiAgICAgICAgICAgICAgX3NlcmlhbGl6ZU1lc3NhZ2UgPSBzZXJpYWxpemVNZXNzYWdlKG1lc3NhZ2UpLCBtc2cgPSBfc2VyaWFsaXplTWVzc2FnZS5tc2csIGJpbmFyeU1zZyA9IF9zZXJpYWxpemVNZXNzYWdlLmJpbmFyeU1zZztcbiAgICAgICAgICAgICAgY29tbWFuZCA9IG5ldyBHZW5lcmljQ29tbWFuZCh7XG4gICAgICAgICAgICAgICAgY21kOiAnZGlyZWN0JyxcbiAgICAgICAgICAgICAgICBkaXJlY3RNZXNzYWdlOiBuZXcgRGlyZWN0Q29tbWFuZCh7XG4gICAgICAgICAgICAgICAgICBtc2c6IG1zZyxcbiAgICAgICAgICAgICAgICAgIGJpbmFyeU1zZzogYmluYXJ5TXNnLFxuICAgICAgICAgICAgICAgICAgY2lkOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgICAgcjogcmVjZWlwdCxcbiAgICAgICAgICAgICAgICAgIHRyYW5zaWVudDogdHJhbnNpZW50LFxuICAgICAgICAgICAgICAgICAgZHQ6IG1lc3NhZ2UuaWQsXG4gICAgICAgICAgICAgICAgICBwdXNoRGF0YTogX0pTT04kc3RyaW5naWZ5KHB1c2hEYXRhKSxcbiAgICAgICAgICAgICAgICAgIHdpbGw6IHdpbGwsXG4gICAgICAgICAgICAgICAgICBtZW50aW9uUGlkczogbWVzc2FnZS5tZW50aW9uTGlzdCxcbiAgICAgICAgICAgICAgICAgIG1lbnRpb25BbGw6IG1lc3NhZ2UubWVudGlvbmVkQWxsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTA7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmQoY29tbWFuZCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIHJlc0NvbW1hbmQgPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0cmFuc2llbnQpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfcmVzQ29tbWFuZCRhY2tNZXNzYWcgPSByZXNDb21tYW5kLmFja01lc3NhZ2UsIHVpZCA9IF9yZXNDb21tYW5kJGFja01lc3NhZy51aWQsIHQgPSBfcmVzQ29tbWFuZCRhY2tNZXNzYWcudCwgY29kZSA9IF9yZXNDb21tYW5kJGFja01lc3NhZy5jb2RlLCByZWFzb24gPSBfcmVzQ29tbWFuZCRhY2tNZXNzYWcucmVhc29uLCBhcHBDb2RlID0gX3Jlc0NvbW1hbmQkYWNrTWVzc2FnLmFwcENvZGU7XG5cbiAgICAgICAgICAgICAgaWYgKCEoY29kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvciQxKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICAgICAgICAgIGFwcENvZGU6IGFwcENvZGVcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgIF9PYmplY3QkYXNzaWduKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICBpZDogdWlkLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5sYXN0TWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgIHRoaXMubGFzdE1lc3NhZ2VBdCA9IG1lc3NhZ2UudGltZXN0YW1wO1xuXG4gICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICBtZXNzYWdlLl9zZXRTdGF0dXMoTWVzc2FnZVN0YXR1cy5TRU5UKTtcbiAgICAgICAgICAgICAgaWYgKHJlY2VpcHQpIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbCh0aGlzKS5tZXNzYWdlc1dhaXRpbmdGb3JSZWNlaXB0W21lc3NhZ2UuaWRdID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCBtZXNzYWdlKTtcblxuICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDI2O1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0WydjYXRjaCddKDEwKTtcblxuICAgICAgICAgICAgICBtZXNzYWdlLl9zZXRTdGF0dXMoTWVzc2FnZVN0YXR1cy5GQUlMRUQpO1xuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dC50MDtcblxuICAgICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzEwLCAyNl1dKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBzZW5kKF94LCBfeDIpIHtcbiAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBzZW5kO1xuICB9KCk7XG5cbiAgQ29udmVyc2F0aW9uQmFzZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIobWVzc2FnZSwgbmV3TWVzc2FnZSwgcmVjYWxsKSB7XG4gICAgICB2YXIgbXNnLCBiaW5hcnlNc2csIGNvbnRlbnQsIGlkLCBjaWQsIHRpbWVzdGFtcCwgZnJvbSwgX3N0YXR1cztcblxuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygncGF0Y2ggJU8gJU8gJU8nLCBtZXNzYWdlLCBuZXdNZXNzYWdlLCByZWNhbGwpO1xuXG4gICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UgaW5zdGFuY2VvZiBNZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZnJvbSAhPT0gdGhpcy5fY2xpZW50LmlkKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXBkYXRpbmcgbWVzc2FnZSBmcm9tIG90aGVycyBpcyBub3QgYWxsb3dlZCcpO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uuc3RhdHVzICE9PSBNZXNzYWdlU3RhdHVzLlNFTlQgJiYgbWVzc2FnZS5zdGF0dXMgIT09IE1lc3NhZ2VTdGF0dXMuREVMSVZFUkVEKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWVzc2FnZSBpcyBub3Qgc2VudCcpO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGlmIChtZXNzYWdlLmlkICYmIG1lc3NhZ2UudGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobWVzc2FnZSArICcgaXMgbm90IGEgTWVzc2FnZScpO1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBtc2cgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGJpbmFyeU1zZyA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICBpZiAoIXJlY2FsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBzZXJpYWxpemVNZXNzYWdlKG5ld01lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIG1zZyA9IGNvbnRlbnQubXNnO1xuICAgICAgICAgICAgICAgIGJpbmFyeU1zZyA9IGNvbnRlbnQuYmluYXJ5TXNnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kKG5ldyBHZW5lcmljQ29tbWFuZCh7XG4gICAgICAgICAgICAgICAgY21kOiBDb21tYW5kVHlwZS5wYXRjaCxcbiAgICAgICAgICAgICAgICBvcDogT3BUeXBlLm1vZGlmeSxcbiAgICAgICAgICAgICAgICBwYXRjaE1lc3NhZ2U6IG5ldyBQYXRjaENvbW1hbmQoe1xuICAgICAgICAgICAgICAgICAgcGF0Y2hlczogW25ldyBQYXRjaEl0ZW0oe1xuICAgICAgICAgICAgICAgICAgICBjaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgICAgIG1pZDogbWVzc2FnZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBOdW1iZXIobWVzc2FnZS50aW1lc3RhbXApLFxuICAgICAgICAgICAgICAgICAgICByZWNhbGw6IHJlY2FsbCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbXNnLFxuICAgICAgICAgICAgICAgICAgICBiaW5hcnlNc2c6IGJpbmFyeU1zZyxcbiAgICAgICAgICAgICAgICAgICAgbWVudGlvblBpZHM6IG5ld01lc3NhZ2UubWVudGlvbkxpc3QsXG4gICAgICAgICAgICAgICAgICAgIG1lbnRpb25BbGw6IG5ld01lc3NhZ2UubWVudGlvbmVkQWxsXG4gICAgICAgICAgICAgICAgICB9KV0sXG4gICAgICAgICAgICAgICAgICBsYXN0UGF0Y2hUaW1lOiB0aGlzLl9jbGllbnQuX2xhc3RQYXRjaFRpbWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIGlkID0gbWVzc2FnZS5pZCwgY2lkID0gbWVzc2FnZS5jaWQsIHRpbWVzdGFtcCA9IG1lc3NhZ2UudGltZXN0YW1wLCBmcm9tID0gbWVzc2FnZS5mcm9tLCBfc3RhdHVzID0gbWVzc2FnZS5fc3RhdHVzO1xuXG4gICAgICAgICAgICAgIF9PYmplY3QkYXNzaWduKG5ld01lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgY2lkOiBjaWQsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICAgICAgICBfc3RhdHVzOiBfc3RhdHVzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0TWVzc2FnZS5pZCA9PT0gbmV3TWVzc2FnZS5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdE1lc3NhZ2UgPSBuZXdNZXNzYWdlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KCdyZXR1cm4nLCBuZXdNZXNzYWdlKTtcblxuICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIF91cGRhdGUoX3gzLCBfeDQsIF94NSkge1xuICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF91cGRhdGU7XG4gIH0oKTtcblxuICAvKipcbiAgICog6I635Y+W5a+56K+d5Lq65pWw77yM5oiW5pqC5oCB5a+56K+d55qE5Zyo57q/5Lq65pWwXG4gICAqIEByZXR1cm4ge1Byb21pc2UuPE51bWJlcj59XG4gICAqL1xuXG5cbiAgQ29udmVyc2F0aW9uQmFzZS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWY0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKCkge1xuICAgICAgdmFyIHJlc0NvbW1hbmQ7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdjb3VudCcpO1xuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kKG5ldyBHZW5lcmljQ29tbWFuZCh7XG4gICAgICAgICAgICAgICAgb3A6ICdjb3VudCdcbiAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHJlc0NvbW1hbmQgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoJ3JldHVybicsIHJlc0NvbW1hbmQuY29udk1lc3NhZ2UuY291bnQpO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBjb3VudCgpIHtcbiAgICAgIHJldHVybiBfcmVmNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBjb3VudDtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiDkv67mlLnlt7Llj5HpgIHnmoTmtojmga9cbiAgICogQHBhcmFtIHtBVk1lc3NhZ2V9IG1lc3NhZ2Ug6KaB5L+u5pS555qE5raI5oGv77yM6K+l5raI5oGv5b+F6aG75piv55Sx5b2T5YmN55So5oi35Y+R6YCB55qE44CC5Lmf5Y+v5Lul5o+Q5L6b5LiA5Liq5YyF5ZCr5raI5oGvIHtpZCwgdGltZXN0YW1wfSDnmoTlr7nosaFcbiAgICogQHBhcmFtIHtBVk1lc3NhZ2V9IG5ld01lc3NhZ2Ug5paw55qE5raI5oGvXG4gICAqIEByZXR1cm4ge1Byb21pc2UuPEFWTWVzc2FnZT59IOabtOaWsOWQjueahOa2iOaBr1xuICAgKi9cblxuXG4gIENvbnZlcnNhdGlvbkJhc2UucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjUgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQobWVzc2FnZSwgbmV3TWVzc2FnZSkge1xuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAobmV3TWVzc2FnZSBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG5ld01lc3NhZ2UgKyAnIGlzIG5vdCBhIE1lc3NhZ2UnKTtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdCgncmV0dXJuJywgdGhpcy5fdXBkYXRlKG1lc3NhZ2UsIG5ld01lc3NhZ2UsIGZhbHNlKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZShfeDYsIF94Nykge1xuICAgICAgcmV0dXJuIF9yZWY1LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiDmkqTlm57lt7Llj5HpgIHnmoTmtojmga9cbiAgICogQHBhcmFtIHtBVk1lc3NhZ2V9IG1lc3NhZ2Ug6KaB5pKk5Zue55qE5raI5oGv77yM6K+l5raI5oGv5b+F6aG75piv55Sx5b2T5YmN55So5oi35Y+R6YCB55qE44CC5Lmf5Y+v5Lul5o+Q5L6b5LiA5Liq5YyF5ZCr5raI5oGvIHtpZCwgdGltZXN0YW1wfSDnmoTlr7nosaFcbiAgICogQHJldHVybiB7UHJvbWlzZS48UmVjYWxsZWRNZXNzYWdlPn0g5LiA5p2h5bey5pKk5Zue55qE5raI5oGvXG4gICAqL1xuXG5cbiAgQ29udmVyc2F0aW9uQmFzZS5wcm90b3R5cGUucmVjYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmNiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlNShtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KCdyZXR1cm4nLCB0aGlzLl91cGRhdGUobWVzc2FnZSwgbmV3IFJlY2FsbGVkTWVzc2FnZSgpLCB0cnVlKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTUsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIHJlY2FsbChfeDgpIHtcbiAgICAgIHJldHVybiBfcmVmNi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiByZWNhbGw7XG4gIH0oKTtcblxuICAvKipcbiAgICog5p+l6K+i5raI5oGv6K6w5b2VXG4gICAqIOWmguaenOS7hemcgOWunueOsOa2iOaBr+WQkeWJjeiusOW9lee/u+mhteafpeivoumcgOaxgu+8jOW7uuiuruS9v+eUqCB7QGxpbmsgQ29udmVyc2F0aW9uI2NyZWF0ZU1lc3NhZ2VzSXRlcmF0b3J944CCXG4gICAqIOS4jeiuuuS9leenjeaWueWQke+8jOiOt+W+l+eahOa2iOaBr+mDveaYr+aMieeFp+aXtumXtOWNh+W6j+aOkuWIl+eahOOAglxuICAgKiBzdGFydENsb3NlZCDkuI4gZW5kQ2xvc2VkIOeUqOS6juaMh+WumuafpeivouWMuumXtOeahOW8gOmXreOAglxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLmxpbWl0XSDpmZDliLbmn6Xor6Lnu5PmnpznmoTmlbDph4/vvIznm67liY3mnI3liqHnq6/pu5jorqTkuLogMjBcbiAgICogQHBhcmFtICB7TnVtYmVyfSAgIFtvcHRpb25zLnR5cGVdIOaMh+WumuafpeivoueahOWvjOWqkuS9k+a2iOaBr+exu+Wei++8jOS4jeaMh+WumuWImeafpeivouaJgOaciea2iOaBr+OAglxuICAgKiBAcGFyYW0gIHtNZXNzYWdlUXVlcnlEaXJlY3Rpb259IFtvcHRpb25zLmRpcmVjdGlvbl0g5p+l6K+i55qE5pa55ZCR44CCXG4gICAqIOWcqOS4jeaMh+WumueahOaDheWGteS4i+WmguaenCBzdGFydFRpbWUg5aSn5LqOIGVuZFRpbWXvvIzliJnkuLrku47mlrDliLDml6fmn6Xor6LvvIzlj6/ku6Xlrp7njrDliqDovb3ogYrlpKnorrDlvZXnrYnlnLrmma/jgIJcbiAgICog5aaC5p6cIHN0YXJ0VGltZSDlsI/kuo4gZW5kVGltZe+8jOWImeS4uuS7juaXp+WIsOaWsOafpeivou+8jOWPr+S7peWunueOsOW8ueW5leetieWcuuaZr+OAglxuICAgKiBAcGFyYW0gIHtEYXRlfSAgIFtvcHRpb25zLnN0YXJ0VGltZV0g5LuO6K+l5pe26Ze05byA5aeL5p+l6K+i77yM5LiN5Lyg5YiZ5LuO5b2T5YmN5pe26Ze05byA5aeL5p+l6K+iXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW29wdGlvbnMuc3RhcnRNZXNzYWdlSWRdIOS7juivpea2iOaBr+S5i+WJjeW8gOWni+afpeivou+8jOmcgOimgeS4jiBzdGFydFRpbWUg5ZCM5pe25L2/55So77yM5Li66Ziy5q2i5p+Q5pe25Yi75pyJ6YeN5aSN5raI5oGvXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59W29wdGlvbnMuc3RhcnRDbG9zZWRdIOaMh+WumuafpeivouiMg+WbtOaYr+WQpuWMheaLrOW8gOWni+eahOaXtumXtOeCue+8jOm7mOiupOS4jeWMheaLrFxuICAgKiBAcGFyYW0gIHtEYXRlfSAgIFtvcHRpb25zLmVuZFRpbWVdIOafpeivouWIsOivpeaXtumXtOS4uuatou+8jOS4jeS8oOWImeafpeivouacgOaXqea2iOaBr+S4uuatolxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtvcHRpb25zLmVuZE1lc3NhZ2VJZF0g5p+l6K+i5Yiw6K+l5raI5oGv5Li65q2i77yM6ZyA6KaB5LiOIGVuZFRpbWUg5ZCM5pe25L2/55So77yM5Li66Ziy5q2i5p+Q5pe25Yi75pyJ6YeN5aSN5raI5oGvXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59W29wdGlvbnMuZW5kQ2xvc2VkXSDmjIflrprmn6Xor6LojIPlm7TmmK/lkKbljIXmi6znu5PmnZ/nmoTml7bpl7TngrnvvIzpu5jorqTkuI3ljIXmi6xcbiAgICpcbiAgICogQHBhcmFtICB7RGF0ZX0gICBbb3B0aW9ucy5iZWZvcmVUaW1lXSBERVBSRUNBVEVEOiDkvb/nlKggc3RhcnRUaW1lIOS7o+abv+OAgumZkOWItuafpeivoue7k+aenOS4uuWwj+S6juivpeaXtumXtOS5i+WJjeeahOa2iOaBr++8jOS4jeS8oOWImeS4uuW9k+WJjeaXtumXtFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtvcHRpb25zLmJlZm9yZU1lc3NhZ2VJZF0gREVQUkVDQVRFRDog5L2/55SoIHN0YXJ0TWVzc2FnZUlkIOS7o+abv+OAglxuICAgKiDpmZDliLbmn6Xor6Lnu5PmnpzkuLror6Xmtojmga/kuYvliY3nmoTmtojmga/vvIzpnIDopoHkuI4gYmVmb3JlVGltZSDlkIzml7bkvb/nlKjvvIzkuLrpmLLmraLmn5Dml7bliLvmnInph43lpI3mtojmga9cbiAgICogQHBhcmFtICB7RGF0ZX0gICBbb3B0aW9ucy5hZnRlclRpbWVdIERFUFJFQ0FURUQ6IOS9v+eUqCBlbmRUaW1lIOS7o+abv+OAgumZkOWItuafpeivoue7k+aenOS4uuWkp+S6juivpeaXtumXtOS5i+WJjeeahOa2iOaBr1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtvcHRpb25zLmFmdGVyTWVzc2FnZUlkXSBERVBSRUNBVEVEOiDkvb/nlKggZW5kTWVzc2FnZUlkIOS7o+abv+OAglxuICAgKiDpmZDliLbmn6Xor6Lnu5PmnpzkuLror6Xmtojmga/kuYvlkI7nmoTmtojmga/vvIzpnIDopoHkuI4gYWZ0ZXJUaW1lIOWQjOaXtuS9v+eUqO+8jOS4uumYsuatouafkOaXtuWIu+aciemHjeWkjea2iOaBr1xuICAgKiBAcmV0dXJuIHtQcm9taXNlLjxNZXNzYWdlW10+fSDmtojmga/liJfooahcbiAgICovXG5cblxuICBDb252ZXJzYXRpb25CYXNlLnByb3RvdHlwZS5xdWVyeU1lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmNyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlNygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICB2YXIgYmVmb3JlVGltZSwgYmVmb3JlTWVzc2FnZUlkLCBhZnRlclRpbWUsIGFmdGVyTWVzc2FnZUlkLCBsaW1pdCwgZGlyZWN0aW9uLCB0eXBlLCBzdGFydFRpbWUsIHN0YXJ0TWVzc2FnZUlkLCBzdGFydENsb3NlZCwgZW5kVGltZSwgZW5kTWVzc2FnZUlkLCBlbmRDbG9zZWQsIGNvbmRpdGlvbnMsIHJlc0NvbW1hbmQ7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdxdWVyeSBtZXNzYWdlcyAlTycsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICBiZWZvcmVUaW1lID0gb3B0aW9ucy5iZWZvcmVUaW1lLCBiZWZvcmVNZXNzYWdlSWQgPSBvcHRpb25zLmJlZm9yZU1lc3NhZ2VJZCwgYWZ0ZXJUaW1lID0gb3B0aW9ucy5hZnRlclRpbWUsIGFmdGVyTWVzc2FnZUlkID0gb3B0aW9ucy5hZnRlck1lc3NhZ2VJZCwgbGltaXQgPSBvcHRpb25zLmxpbWl0LCBkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbiwgdHlwZSA9IG9wdGlvbnMudHlwZSwgc3RhcnRUaW1lID0gb3B0aW9ucy5zdGFydFRpbWUsIHN0YXJ0TWVzc2FnZUlkID0gb3B0aW9ucy5zdGFydE1lc3NhZ2VJZCwgc3RhcnRDbG9zZWQgPSBvcHRpb25zLnN0YXJ0Q2xvc2VkLCBlbmRUaW1lID0gb3B0aW9ucy5lbmRUaW1lLCBlbmRNZXNzYWdlSWQgPSBvcHRpb25zLmVuZE1lc3NhZ2VJZCwgZW5kQ2xvc2VkID0gb3B0aW9ucy5lbmRDbG9zZWQ7XG5cbiAgICAgICAgICAgICAgaWYgKCEoYmVmb3JlTWVzc2FnZUlkIHx8IGJlZm9yZVRpbWUgfHwgYWZ0ZXJNZXNzYWdlSWQgfHwgYWZ0ZXJUaW1lKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignREVQUkVDQVRJT046IHF1ZXJ5TWVzc2FnZXMgb3B0aW9ucyBiZWZvcmVUaW1lLCBiZWZvcmVNZXNzYWdlSWQsIGFmdGVyVGltZSBhbmQgYWZ0ZXJNZXNzYWdlSWQgYXJlIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2Ygc3RhcnRUaW1lLCBzdGFydE1lc3NhZ2VJZCwgZW5kVGltZSBhbmQgZW5kTWVzc2FnZUlkLicpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdCgncmV0dXJuJywgdGhpcy5xdWVyeU1lc3NhZ2VzKHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IGJlZm9yZVRpbWUsXG4gICAgICAgICAgICAgICAgc3RhcnRNZXNzYWdlSWQ6IGJlZm9yZU1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICBlbmRUaW1lOiBhZnRlclRpbWUsXG4gICAgICAgICAgICAgICAgZW5kTWVzc2FnZUlkOiBhZnRlck1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICBsaW1pdDogbGltaXRcbiAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGlmICghKHN0YXJ0TWVzc2FnZUlkICYmICFzdGFydFRpbWUpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxdWVyeSBvcHRpb24gc3RhcnRNZXNzYWdlSWQgbXVzdCBiZSB1c2VkIHdpdGggb3B0aW9uIHN0YXJ0VGltZScpO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGlmICghKGVuZE1lc3NhZ2VJZCAmJiAhZW5kVGltZSkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3F1ZXJ5IG9wdGlvbiBlbmRNZXNzYWdlSWQgbXVzdCBiZSB1c2VkIHdpdGggb3B0aW9uIGVuZFRpbWUnKTtcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBjb25kaXRpb25zID0ge1xuICAgICAgICAgICAgICAgIHQ6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBtaWQ6IHN0YXJ0TWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgIHRJbmNsdWRlZDogc3RhcnRDbG9zZWQsXG4gICAgICAgICAgICAgICAgdHQ6IGVuZFRpbWUsXG4gICAgICAgICAgICAgICAgdG1pZDogZW5kTWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgIHR0SW5jbHVkZWQ6IGVuZENsb3NlZCxcbiAgICAgICAgICAgICAgICBsOiBsaW1pdCxcbiAgICAgICAgICAgICAgICBsY3R5cGU6IHR5cGVcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAoY29uZGl0aW9ucy50IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbnMudCA9IGNvbmRpdGlvbnMudC5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvbnMudHQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9ucy50dCA9IGNvbmRpdGlvbnMudHQuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbnMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmRpdGlvbnMudHQgPiBjb25kaXRpb25zLnQpIHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25zLmRpcmVjdGlvbiA9IE1lc3NhZ2VRdWVyeURpcmVjdGlvbi5PTERfVE9fTkVXO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kKG5ldyBHZW5lcmljQ29tbWFuZCh7XG4gICAgICAgICAgICAgICAgY21kOiAnbG9ncycsXG4gICAgICAgICAgICAgICAgbG9nc01lc3NhZ2U6IG5ldyBMb2dzQ29tbWFuZChfT2JqZWN0JGFzc2lnbihjb25kaXRpb25zLCB7XG4gICAgICAgICAgICAgICAgICBjaWQ6IHRoaXMuaWRcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICByZXNDb21tYW5kID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KCdyZXR1cm4nLCBfUHJvbWlzZS5hbGwocmVzQ29tbWFuZC5sb2dzTWVzc2FnZS5sb2dzLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWY5ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KF9yZWY4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbXNnSWQgPSBfcmVmOC5tc2dJZCxcbiAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBfcmVmOC50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgICAgcGF0Y2hUaW1lc3RhbXAgPSBfcmVmOC5wYXRjaFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICBmcm9tID0gX3JlZjguZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICBhY2tBdCA9IF9yZWY4LmFja0F0LFxuICAgICAgICAgICAgICAgICAgICAgIHJlYWRBdCA9IF9yZWY4LnJlYWRBdCxcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX3JlZjguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICBtZW50aW9uQWxsID0gX3JlZjgubWVudGlvbkFsbCxcbiAgICAgICAgICAgICAgICAgICAgICBtZW50aW9uUGlkcyA9IF9yZWY4Lm1lbnRpb25QaWRzLFxuICAgICAgICAgICAgICAgICAgICAgIGJpbiA9IF9yZWY4LmJpbjtcbiAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlRGF0YSwgbWVzc2FnZSwgc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbjogYmluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBtc2dJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaWQ6IF90aGlzMi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGl2ZXJlZEF0OiBhY2tBdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IHBhdGNoVGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbnRpb25MaXN0OiBtZW50aW9uUGlkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZW50aW9uZWRBbGw6IG1lbnRpb25BbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLl9jbGllbnQucGFyc2VNZXNzYWdlKG1lc3NhZ2VEYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IE1lc3NhZ2VTdGF0dXMuU0VOVDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMyLm1lbWJlcnMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFja0F0KSBzdGF0dXMgPSBNZXNzYWdlU3RhdHVzLkRFTElWRVJFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWNrQXQpIF90aGlzMi5fc2V0TGFzdERlbGl2ZXJlZEF0KGFja0F0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVhZEF0KSBfdGhpczIuX3NldExhc3RSZWFkQXQocmVhZEF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLl9zZXRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoJ3JldHVybicsIG1lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWU2LCBfdGhpczIpO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gxMCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSgpKSkpO1xuXG4gICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlNywgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gcXVlcnlNZXNzYWdlcygpIHtcbiAgICAgIHJldHVybiBfcmVmNy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBxdWVyeU1lc3NhZ2VzO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIOiOt+WPlua2iOaBr+e/u+mhtei/reS7o+WZqFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0gIHtEYXRlfSAgIFtvcHRpb25zLmJlZm9yZVRpbWVdIOmZkOWItui1t+Wni+afpeivoue7k+aenOS4uuWwj+S6juivpeaXtumXtOS5i+WJjeeahOa2iOaBr++8jOS4jeS8oOWImeS4uuW9k+WJjeaXtumXtFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtvcHRpb25zLmJlZm9yZU1lc3NhZ2VJZF0g6ZmQ5Yi26LW35aeL5p+l6K+i57uT5p6c5Li66K+l5raI5oGv5LmL5YmN55qE5raI5oGv77yM6ZyA6KaB5LiOIGJlZm9yZVRpbWUg5ZCM5pe25L2/55So77yM5Li66Ziy5q2i5p+Q5pe25Yi75pyJ6YeN5aSN5raI5oGvXG4gICAqIEBwYXJhbSAge051bWJlcn0gW29wdGlvbnMubGltaXRdIOmZkOWItuavj+mhteafpeivoue7k+aenOeahOaVsOmHj++8jOebruWJjeacjeWKoeerr+m7mOiupOS4uiAyMFxuICAgKiBAcmV0dXJuIHtBc3luY0l0ZXJhdGVyLjxQcm9taXNlLjxJdGVyYXRvclJlc3VsdDxNZXNzYWdlW10+Pj59IFtBc3luY0l0ZXJhdG9yXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hc3luYy1pdGVyYXRpb25977yM6LCD55So5YW2IG5leHQg5pa55rOV6L+U5Zue6I635Y+W5LiL5LiA6aG15raI5oGv55qEIFByb21pc2VcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIG1lc3NhZ2VJdGVyYXRvciA9IGNvbnZlcnNhdGlvbi5jcmVhdGVNZXNzYWdlc0l0ZXJhdG9yKHsgbGltaXQ6IDEwIH0pO1xuICAgKiBtZXNzYWdlSXRlcmF0b3IubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAqICAgLy8gcmVzdWx0OiB7XG4gICAqICAgLy8gICB2YWx1ZTogW21lc3NhZ2UxLCAuLi4sIG1lc3NhZ2UxMF0sXG4gICAqICAgLy8gICBkb25lOiBmYWxzZSxcbiAgICogICAvLyB9XG4gICAqIH0pO1xuICAgKiBtZXNzYWdlSXRlcmF0b3IubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAqICAgLy8gcmVzdWx0OiB7XG4gICAqICAgLy8gICB2YWx1ZTogW21lc3NhZ2UxMSwgLi4uLCBtZXNzYWdlMjBdLFxuICAgKiAgIC8vICAgZG9uZTogZmFsc2UsXG4gICAqICAgLy8gfVxuICAgKiB9KTtcbiAgICogbWVzc2FnZUl0ZXJhdG9yLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgKiAgIC8vIE5vIG1vcmUgbWVzc2FnZXNcbiAgICogICAvLyByZXN1bHQ6IHsgdmFsdWU6IFtdLCBkb25lOiB0cnVlIH1cbiAgICogfSk7XG4gICAqL1xuXG5cbiAgQ29udmVyc2F0aW9uQmFzZS5wcm90b3R5cGUuY3JlYXRlTWVzc2FnZXNJdGVyYXRvciA9IGZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VzSXRlcmF0b3IoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgX3JlZjEwID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgYmVmb3JlVGltZSA9IF9yZWYxMC5iZWZvcmVUaW1lLFxuICAgICAgICBiZWZvcmVNZXNzYWdlSWQgPSBfcmVmMTAuYmVmb3JlTWVzc2FnZUlkLFxuICAgICAgICBsaW1pdCA9IF9yZWYxMC5saW1pdDtcblxuICAgIHZhciBwcm9taXNlID0gdm9pZCAwO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBpZiAocHJvbWlzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZmlyc3QgY2FsbFxuICAgICAgICAgIHByb21pc2UgPSBfdGhpczMucXVlcnlNZXNzYWdlcyh7XG4gICAgICAgICAgICBsaW1pdDogbGltaXQsXG4gICAgICAgICAgICBzdGFydFRpbWU6IGJlZm9yZVRpbWUsXG4gICAgICAgICAgICBzdGFydE1lc3NhZ2VJZDogYmVmb3JlTWVzc2FnZUlkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAocHJldk1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBpZiAocHJldk1lc3NhZ2VzLmxlbmd0aCA9PT0gMCB8fCBwcmV2TWVzc2FnZXMubGVuZ3RoIDwgbGltaXQpIHtcbiAgICAgICAgICAgICAgLy8gbm8gbW9yZSBtZXNzYWdlc1xuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLnF1ZXJ5TWVzc2FnZXMoe1xuICAgICAgICAgICAgICBzdGFydFRpbWU6IHByZXZNZXNzYWdlc1swXS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgIHN0YXJ0TWVzc2FnZUlkOiBwcmV2TWVzc2FnZXNbMF0uaWQsXG4gICAgICAgICAgICAgIGxpbWl0OiBsaW1pdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IF9BcnJheSRmcm9tKHZhbHVlKSxcbiAgICAgICAgICAgIGRvbmU6IHZhbHVlLmxlbmd0aCA9PT0gMCB8fCB2YWx1ZS5sZW5ndGggPCBsaW1pdFxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIOWwhuivpeS8muivneagh+iusOS4uuW3suivu1xuICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn0gc2VsZlxuICAgKi9cblxuXG4gIENvbnZlcnNhdGlvbkJhc2UucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYxMSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlOCgpIHtcbiAgICAgIHZhciBjbGllbnQ7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMudW5yZWFkTWVzc2FnZXNDb3VudCA9IDA7XG4gICAgICAgICAgICAgIHRoaXMuX3NldFVucmVhZE1lc3NhZ2VzTWVudGlvbmVkKGZhbHNlKTtcbiAgICAgICAgICAgICAgLy8g6Lez6L+H5pqC5oCB5Lya6K+dXG5cbiAgICAgICAgICAgICAgaWYgKCF0aGlzLnRyYW5zaWVudCkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguYWJydXB0KCdyZXR1cm4nLCB0aGlzKTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjbGllbnQgPSB0aGlzLl9jbGllbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKCFpbnRlcm5hbChjbGllbnQpLnJlYWRDb252ZXJzYXRpb25zQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWwoY2xpZW50KS5yZWFkQ29udmVyc2F0aW9uc0J1ZmZlciA9IG5ldyBfU2V0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaW50ZXJuYWwoY2xpZW50KS5yZWFkQ29udmVyc2F0aW9uc0J1ZmZlci5hZGQodGhpcyk7XG4gICAgICAgICAgICAgIGNsaWVudC5fZG9TZW5kUmVhZCgpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdCgncmV0dXJuJywgdGhpcyk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTgsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICByZXR1cm4gX3JlZjExLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlYWQ7XG4gIH0oKTtcblxuICBDb252ZXJzYXRpb25CYXNlLnByb3RvdHlwZS5faGFuZGxlUmVjZWlwdCA9IGZ1bmN0aW9uIF9oYW5kbGVSZWNlaXB0KF9yZWYxMikge1xuICAgIHZhciBtZXNzYWdlSWQgPSBfcmVmMTIubWVzc2FnZUlkLFxuICAgICAgICB0aW1lc3RhbXAgPSBfcmVmMTIudGltZXN0YW1wLFxuICAgICAgICByZWFkID0gX3JlZjEyLnJlYWQ7XG5cbiAgICBpZiAocmVhZCkge1xuICAgICAgdGhpcy5fc2V0TGFzdFJlYWRBdCh0aW1lc3RhbXApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRMYXN0RGVsaXZlcmVkQXQodGltZXN0YW1wKTtcbiAgICB9XG5cbiAgICB2YXIgX2ludGVybmFsID0gaW50ZXJuYWwodGhpcyksXG4gICAgICAgIG1lc3NhZ2VzV2FpdGluZ0ZvclJlY2VpcHQgPSBfaW50ZXJuYWwubWVzc2FnZXNXYWl0aW5nRm9yUmVjZWlwdDtcblxuICAgIHZhciBtZXNzYWdlID0gbWVzc2FnZXNXYWl0aW5nRm9yUmVjZWlwdFttZXNzYWdlSWRdO1xuICAgIGlmICghbWVzc2FnZSkgcmV0dXJuO1xuICAgIG1lc3NhZ2UuX3NldFN0YXR1cyhNZXNzYWdlU3RhdHVzLkRFTElWRVJFRCk7XG4gICAgbWVzc2FnZS5kZWxpdmVyZWRBdCA9IHRpbWVzdGFtcDtcbiAgICBkZWxldGUgbWVzc2FnZXNXYWl0aW5nRm9yUmVjZWlwdFttZXNzYWdlSWRdO1xuICB9O1xuXG4gIC8qKlxuICAgKiDmm7TmlrDlr7nor53nmoTmnIDmlrDlm57miafml7bpl7TmiLPvvIhsYXN0RGVsaXZlcmVkQXTjgIFsYXN0UmVhZEF077yJXG4gICAqIEBzaW5jZSAzLjQuMFxuICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn0gdGhpc1xuICAgKi9cblxuXG4gIENvbnZlcnNhdGlvbkJhc2UucHJvdG90eXBlLmZldGNoUmVjZWlwdFRpbWVzdGFtcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYxMyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlOSgpIHtcbiAgICAgIHZhciBfcmVmMTQsIF9yZWYxNCRjb252TWVzc2FnZSwgbWF4UmVhZFRpbWVzdGFtcCwgbWF4QWNrVGltZXN0YW1wO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlOSQoX2NvbnRleHQ5KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmQobmV3IEdlbmVyaWNDb21tYW5kKHtcbiAgICAgICAgICAgICAgICBvcDogJ21heF9yZWFkJ1xuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgX3JlZjE0ID0gX2NvbnRleHQ5LnNlbnQ7XG4gICAgICAgICAgICAgIF9yZWYxNCRjb252TWVzc2FnZSA9IF9yZWYxNC5jb252TWVzc2FnZTtcbiAgICAgICAgICAgICAgbWF4UmVhZFRpbWVzdGFtcCA9IF9yZWYxNCRjb252TWVzc2FnZS5tYXhSZWFkVGltZXN0YW1wO1xuICAgICAgICAgICAgICBtYXhBY2tUaW1lc3RhbXAgPSBfcmVmMTQkY29udk1lc3NhZ2UubWF4QWNrVGltZXN0YW1wO1xuXG4gICAgICAgICAgICAgIHRoaXMuX3NldExhc3REZWxpdmVyZWRBdChtYXhBY2tUaW1lc3RhbXApO1xuICAgICAgICAgICAgICB0aGlzLl9zZXRMYXN0UmVhZEF0KG1heFJlYWRUaW1lc3RhbXApO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LmFicnVwdCgncmV0dXJuJywgdGhpcyk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTksIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIGZldGNoUmVjZWlwdFRpbWVzdGFtcHMoKSB7XG4gICAgICByZXR1cm4gX3JlZjEzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZldGNoUmVjZWlwdFRpbWVzdGFtcHM7XG4gIH0oKTtcblxuICBDb252ZXJzYXRpb25CYXNlLnByb3RvdHlwZS5fZmV0Y2hBbGxSZWNlaXB0VGltZXN0YW1wcyA9IGZ1bmN0aW9uIF9mZXRjaEFsbFJlY2VpcHRUaW1lc3RhbXBzKCkge1xuICAgIHZhciBjb252TWVzc2FnZSA9IG5ldyBDb252Q29tbWFuZCh7XG4gICAgICBxdWVyeUFsbE1lbWJlcnM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZChuZXcgR2VuZXJpY0NvbW1hbmQoe1xuICAgICAgb3A6ICdtYXhfcmVhZCcsXG4gICAgICBjb252TWVzc2FnZTogY29udk1lc3NhZ2VcbiAgICB9KSkudGhlbihmdW5jdGlvbiAoX3JlZjE1KSB7XG4gICAgICB2YXIgbWF4UmVhZFR1cGxlcyA9IF9yZWYxNS5jb252TWVzc2FnZS5tYXhSZWFkVHVwbGVzO1xuICAgICAgcmV0dXJuIG1heFJlYWRUdXBsZXMuZmlsdGVyKGZ1bmN0aW9uIChtYXhSZWFkVHVwbGUpIHtcbiAgICAgICAgcmV0dXJuIG1heFJlYWRUdXBsZS5tYXhBY2tUaW1lc3RhbXAgfHwgbWF4UmVhZFR1cGxlLm1heFJlYWRUaW1lc3RhbXA7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKF9yZWYxNikge1xuICAgICAgICB2YXIgcGlkID0gX3JlZjE2LnBpZCxcbiAgICAgICAgICAgIG1heEFja1RpbWVzdGFtcCA9IF9yZWYxNi5tYXhBY2tUaW1lc3RhbXAsXG4gICAgICAgICAgICBtYXhSZWFkVGltZXN0YW1wID0gX3JlZjE2Lm1heFJlYWRUaW1lc3RhbXA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGlkOiBwaWQsXG4gICAgICAgICAgbGFzdERlbGl2ZXJlZEF0OiBkZWNvZGVEYXRlKG1heEFja1RpbWVzdGFtcCksXG4gICAgICAgICAgbGFzdFJlYWRBdDogZGVjb2RlRGF0ZShtYXhSZWFkVGltZXN0YW1wKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKENvbnZlcnNhdGlvbkJhc2UsIFt7XG4gICAga2V5OiAndW5yZWFkTWVzc2FnZXNNZW50aW9uZWQnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGludGVybmFsKHRoaXMpLnVucmVhZE1lc3NhZ2VzTWVudGlvbmVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VucmVhZE1lc3NhZ2VzQ291bnQnLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHRoaXMudW5yZWFkTWVzc2FnZXNDb3VudCkge1xuICAgICAgICBpbnRlcm5hbCh0aGlzKS51bnJlYWRNZXNzYWdlc0NvdW50ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2NsaWVudC5lbWl0KFVOUkVBRF9NRVNTQUdFU19DT1VOVF9VUERBVEUsIFt0aGlzXSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOW9k+WJjeeUqOaIt+WcqOivpeWvueivneeahOacquivu+a2iOaBr+aVsFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGludGVybmFsKHRoaXMpLnVucmVhZE1lc3NhZ2VzQ291bnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGFzdE1lc3NhZ2VBdCcsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHZhciB0aW1lID0gZGVjb2RlRGF0ZSh2YWx1ZSk7XG4gICAgICBpZiAodGltZSA8PSB0aGlzLl9sYXN0TWVzc2FnZUF0KSByZXR1cm47XG4gICAgICB0aGlzLl9sYXN0TWVzc2FnZUF0ID0gdGltZTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xhc3RNZXNzYWdlQXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOacgOWQjua2iOaBr+mAgei+vuaXtumXtO+8jOW4uOeUqOadpeWunueOsOa2iOaBr+eahOOAjOW3sumAgei+vuOAjeagh+iusO+8jOWPr+mAmui/hyB7QGxpbmsgQ29udmVyc2F0aW9uI2ZldGNoUmVjZWlwdFRpbWVzdGFtcHN9IOiOt+WPluaIluabtOaWsOivpeWxnuaAp1xuICAgICAqIEB0eXBlIHs/RGF0ZX1cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbGFzdERlbGl2ZXJlZEF0JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLm1lbWJlcnMubGVuZ3RoICE9PSAyKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBpbnRlcm5hbCh0aGlzKS5sYXN0RGVsaXZlcmVkQXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbGFzdFJlYWRBdCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5tZW1iZXJzLmxlbmd0aCAhPT0gMikgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gaW50ZXJuYWwodGhpcykubGFzdFJlYWRBdDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29udmVyc2F0aW9uQmFzZTtcbn0oZXZlbnRlbWl0dGVyMyk7XG5cbi8qKlxuICog5a+56K+d5oiQ5ZGY6KeS6Imy5p6a5Li+XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHNpbmNlIDQuMC4wXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmxlYW5jbG91ZC1yZWFsdGltZVxuICovXG52YXIgQ29udmVyc2F0aW9uTWVtYmVyUm9sZSA9IHtcbiAgLyoqIOeuoeeQhuWRmCAqL1xuICBNQU5BR0VSOiAnTWFuYWdlcicsXG4gIC8qKiDmiJDlkZggKi9cbiAgTUVNQkVSOiAnTWVtYmVyJ1xufTtcbl9PYmplY3QkZnJlZXplKENvbnZlcnNhdGlvbk1lbWJlclJvbGUpO1xuXG52YXIgQ29udmVyc2F0aW9uTWVtYmVySW5mbyA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIOWvueivneaIkOWRmOWxnuaAp++8jOS/neWtmOS6huaIkOWRmOS4juafkOS4quWvueivneebuOWFs+eahOWxnuaAp++8jOWvueW6lCBfQ29udmVyc2F0aW9uTWVtYmVySW5mbyDooahcbiAgICogQHNpbmNlIDQuMC4wXG4gICAqL1xuICBmdW5jdGlvbiBDb252ZXJzYXRpb25NZW1iZXJJbmZvKF9yZWYpIHtcbiAgICB2YXIgY29udmVyc2F0aW9uID0gX3JlZi5jb252ZXJzYXRpb24sXG4gICAgICAgIG1lbWJlcklkID0gX3JlZi5tZW1iZXJJZCxcbiAgICAgICAgcm9sZSA9IF9yZWYucm9sZTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb252ZXJzYXRpb25NZW1iZXJJbmZvKTtcblxuICAgIGlmICghY29udmVyc2F0aW9uKSB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnNhdGlvbiByZXF1cmllZCcpO1xuICAgIGlmICghbWVtYmVySWQpIHRocm93IG5ldyBFcnJvcignbWVtYmVySWQgcmVxdXJpZWQnKTtcbiAgICBfT2JqZWN0JGFzc2lnbihpbnRlcm5hbCh0aGlzKSwge1xuICAgICAgY29udmVyc2F0aW9uOiBjb252ZXJzYXRpb24sXG4gICAgICBtZW1iZXJJZDogbWVtYmVySWQsXG4gICAgICByb2xlOiByb2xlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICog5a+56K+dIElkXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEByZWFkb25seVxuICAgKi9cblxuXG4gIENvbnZlcnNhdGlvbk1lbWJlckluZm8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICB2YXIgY29udmVyc2F0aW9uSWQgPSB0aGlzLmNvbnZlcnNhdGlvbklkLFxuICAgICAgICBtZW1iZXJJZCA9IHRoaXMubWVtYmVySWQsXG4gICAgICAgIHJvbGUgPSB0aGlzLnJvbGUsXG4gICAgICAgIGlzT3duZXIgPSB0aGlzLmlzT3duZXI7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29udmVyc2F0aW9uSWQ6IGNvbnZlcnNhdGlvbklkLFxuICAgICAgbWVtYmVySWQ6IG1lbWJlcklkLFxuICAgICAgcm9sZTogcm9sZSxcbiAgICAgIGlzT3duZXI6IGlzT3duZXJcbiAgICB9O1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhDb252ZXJzYXRpb25NZW1iZXJJbmZvLCBbe1xuICAgIGtleTogJ2NvbnZlcnNhdGlvbklkJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBpbnRlcm5hbCh0aGlzKS5jb252ZXJzYXRpb24uaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOaIkOWRmCBJZFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ21lbWJlcklkJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBpbnRlcm5hbCh0aGlzKS5tZW1iZXJJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICog6KeS6ImyXG4gICAgICogQHR5cGUge21vZHVsZTpsZWFuY2xvdWQtcmVhbHRpbWUuQ29udmVyc2F0aW9uTWVtYmVyUm9sZSB8IFN0cmluZ31cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncm9sZScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gaW50ZXJuYWwodGhpcykucm9sZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog5piv5ZCm5piv566h55CG5ZGYXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2lzT3duZXInLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVtYmVySWQgPT09IGludGVybmFsKHRoaXMpLmNvbnZlcnNhdGlvbi5jcmVhdG9yO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb252ZXJzYXRpb25NZW1iZXJJbmZvO1xufSgpO1xuXG52YXIgZGVidWckNyA9IGJyb3dzZXIoJ0xDOlNpZ25hdHVyZUZhY3RvcnlSdW5uZXInKTtcblxuZnVuY3Rpb24gX3ZhbGlkYXRlU2lnbmF0dXJlKCkge1xuICB2YXIgc2lnbmF0dXJlUmVzdWx0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIHNpZ25hdHVyZSA9IHNpZ25hdHVyZVJlc3VsdC5zaWduYXR1cmUsXG4gICAgICB0aW1lc3RhbXAgPSBzaWduYXR1cmVSZXN1bHQudGltZXN0YW1wLFxuICAgICAgbm9uY2UgPSBzaWduYXR1cmVSZXN1bHQubm9uY2U7XG5cbiAgaWYgKHR5cGVvZiBzaWduYXR1cmUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0aW1lc3RhbXAgIT09ICdudW1iZXInIHx8IHR5cGVvZiBub25jZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBzaWduYXR1cmUnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgIG5vbmNlOiBub25jZVxuICB9O1xufVxuXG52YXIgcnVuU2lnbmF0dXJlRmFjdG9yeSA9IChmdW5jdGlvbiAoc2lnbmF0dXJlRmFjdG9yeSwgcGFyYW1zKSB7XG4gIHJldHVybiBfUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgZGVidWckNygnY2FsbCBzaWduYXR1cmVGYWN0b3J5IHdpdGggJU8nLCBwYXJhbXMpO1xuICAgIHJldHVybiBzaWduYXR1cmVGYWN0b3J5LmFwcGx5KHVuZGVmaW5lZCwgX3RvQ29uc3VtYWJsZUFycmF5KHBhcmFtcykpO1xuICB9KS50aGVuKHRhcChmdW5jdGlvbiAoc2lnbmF0dXJlUmVzdWx0KSB7XG4gICAgcmV0dXJuIGRlYnVnJDcoJ3NpZ24gcmVzdWx0ICVPJywgc2lnbmF0dXJlUmVzdWx0KTtcbiAgfSksIGZ1bmN0aW9uIChlcnJvcikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIGVycm9yLm1lc3NhZ2UgPSAnc2lnbiBlcnJvcjogJyArIGVycm9yLm1lc3NhZ2U7XG4gICAgZGVidWckNyhlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pLnRoZW4oX3ZhbGlkYXRlU2lnbmF0dXJlKTtcbn0pO1xuXG4vKipcbiAqIOmDqOWIhuWksei0peW8guW4uFxuICogQHR5cGVkZWYgT3BlcmF0aW9uRmFpbHVyZUVycm9yXG4gKiBAdHlwZSB7RXJyb3J9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSDlvILluLjkv6Hmga9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IGNsaWVudElkcyDlm6DkuLror6Xljp/lm6DlpLHotKXnmoQgY2xpZW50IGlkIOWIl+ihqFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjb2RlXSDplJnor6/noIFcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZGV0YWlsXSDor6bnu4bkv6Hmga9cbiAqL1xuXG4vKipcbiAqIOmDqOWIhuaIkOWKn+eahOe7k+aenFxuICogQHR5cGVkZWYgUGFydGlhbGx5U3VjY2Vzc1xuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHN1Y2Nlc3NmdWxDbGllbnRJZHMg5oiQ5Yqf55qEIGNsaWVudCBpZCDliJfooahcbiAqIEBwcm9wZXJ0eSB7T3BlcmF0aW9uRmFpbHVyZUVycm9yW119IGZhaWx1cmVzIOWksei0peeahOW8guW4uOWIl+ihqFxuICovXG5cbi8qKlxuICog5YiG6aG15p+l6K+i57uT5p6cXG4gKiBAdHlwZWRlZiBQYWdlZFJlc3VsdHNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJvcGVydHkge1RbXX0gcmVzdWx0cyDmn6Xor6Lnu5PmnpxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmV4dF0g5a2Y5Zyo6KGo56S66L+Y5pyJ5pu05aSa57uT5p6c77yM5Zyo5LiL5qyh5p+l6K+i5Lit5bim5LiK5Y+v5a6e546w57+76aG144CCXG4gKi9cblxudmFyIGNyZWF0ZVBhcnRpYWxseVN1Y2Nlc3MgPSBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsbHlTdWNjZXNzKF9yZWYpIHtcbiAgdmFyIGFsbG93ZWRQaWRzID0gX3JlZi5hbGxvd2VkUGlkcyxcbiAgICAgIGZhaWxlZFBpZHMgPSBfcmVmLmZhaWxlZFBpZHM7XG4gIHJldHVybiB7XG4gICAgc3VjY2Vzc2Z1bENsaWVudElkczogYWxsb3dlZFBpZHMsXG4gICAgZmFpbHVyZXM6IGZhaWxlZFBpZHMubWFwKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgdmFyIHBpZHMgPSBfcmVmMi5waWRzLFxuICAgICAgICAgIGVycm9yJCQxID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ3BpZHMnXSk7XG5cbiAgICAgIHJldHVybiBfT2JqZWN0JGFzc2lnbihjcmVhdGVFcnJvciQxKGVycm9yJCQxKSwgeyBjbGllbnRJZHM6IHBpZHMgfSk7XG4gICAgfSlcbiAgfTtcbn07XG5cbi8qKlxuICogQGV4dGVuZHMgQ29udmVyc2F0aW9uQmFzZVxuICogQHByaXZhdGVcbiAqIEBhYnN0cmFjdFxuICovXG5cbnZhciBQZXJzaXN0ZW50Q29udmVyc2F0aW9uID0gZnVuY3Rpb24gKF9Db252ZXJzYXRpb25CYXNlKSB7XG4gIF9pbmhlcml0cyhQZXJzaXN0ZW50Q29udmVyc2F0aW9uLCBfQ29udmVyc2F0aW9uQmFzZSk7XG5cbiAgZnVuY3Rpb24gUGVyc2lzdGVudENvbnZlcnNhdGlvbihkYXRhLCBfcmVmMywgY2xpZW50KSB7XG4gICAgdmFyIGNyZWF0b3IgPSBfcmVmMy5jcmVhdG9yLFxuICAgICAgICBjcmVhdGVkQXQgPSBfcmVmMy5jcmVhdGVkQXQsXG4gICAgICAgIHVwZGF0ZWRBdCA9IF9yZWYzLnVwZGF0ZWRBdCxcbiAgICAgICAgX3JlZjMkdHJhbnNpZW50ID0gX3JlZjMudHJhbnNpZW50LFxuICAgICAgICB0cmFuc2llbnQgPSBfcmVmMyR0cmFuc2llbnQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZjMkdHJhbnNpZW50LFxuICAgICAgICBfcmVmMyRzeXN0ZW0gPSBfcmVmMy5zeXN0ZW0sXG4gICAgICAgIHN5c3RlbSA9IF9yZWYzJHN5c3RlbSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmMyRzeXN0ZW0sXG4gICAgICAgIF9yZWYzJG11dGVkID0gX3JlZjMubXV0ZWQsXG4gICAgICAgIG11dGVkID0gX3JlZjMkbXV0ZWQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZjMkbXV0ZWQsXG4gICAgICAgIF9yZWYzJG11dGVkTWVtYmVycyA9IF9yZWYzLm11dGVkTWVtYmVycyxcbiAgICAgICAgbXV0ZWRNZW1iZXJzID0gX3JlZjMkbXV0ZWRNZW1iZXJzID09PSB1bmRlZmluZWQgPyBbXSA6IF9yZWYzJG11dGVkTWVtYmVycyxcbiAgICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMywgWydjcmVhdG9yJywgJ2NyZWF0ZWRBdCcsICd1cGRhdGVkQXQnLCAndHJhbnNpZW50JywgJ3N5c3RlbScsICdtdXRlZCcsICdtdXRlZE1lbWJlcnMnXSk7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGVyc2lzdGVudENvbnZlcnNhdGlvbik7XG5cbiAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29udmVyc2F0aW9uQmFzZS5jYWxsKHRoaXMsIF9leHRlbmRzJDEoe30sIGRhdGEsIHtcbiAgICAgIC8qKlxuICAgICAgICog5a+56K+d5Yib5bu66ICFXG4gICAgICAgKiBAbWVtYmVyb2YgUGVyc2lzdGVudENvbnZlcnNhdGlvbiNcbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIGNyZWF0b3I6IGNyZWF0b3IsXG4gICAgICAvKipcbiAgICAgICAqIOWvueivneWIm+W7uuaXtumXtFxuICAgICAgICogQG1lbWJlcm9mIFBlcnNpc3RlbnRDb252ZXJzYXRpb24jXG4gICAgICAgKiBAdHlwZSB7RGF0ZX1cbiAgICAgICAqL1xuICAgICAgY3JlYXRlZEF0OiBjcmVhdGVkQXQsXG4gICAgICAvKipcbiAgICAgICAqIOWvueivneabtOaWsOaXtumXtFxuICAgICAgICogQG1lbWJlcm9mIFBlcnNpc3RlbnRDb252ZXJzYXRpb24jXG4gICAgICAgKiBAdHlwZSB7RGF0ZX1cbiAgICAgICAqL1xuICAgICAgdXBkYXRlZEF0OiB1cGRhdGVkQXQsXG4gICAgICAvKipcbiAgICAgICAqIOWvueivpeWvueivneiuvue9ruS6humdmemfs+eahOeUqOaIt+WIl+ihqFxuICAgICAgICogQG1lbWJlcm9mIFBlcnNpc3RlbnRDb252ZXJzYXRpb24jXG4gICAgICAgKiBAdHlwZSB7P1N0cmluZ1tdfVxuICAgICAgICovXG4gICAgICBtdXRlZE1lbWJlcnM6IG11dGVkTWVtYmVycyxcbiAgICAgIC8qKlxuICAgICAgICog5pqC5oCB5a+56K+d5qCH6K6wXG4gICAgICAgKiBAbWVtYmVyb2YgUGVyc2lzdGVudENvbnZlcnNhdGlvbiNcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICovXG4gICAgICB0cmFuc2llbnQ6IHRyYW5zaWVudCxcbiAgICAgIC8qKlxuICAgICAgICog57O757uf5a+56K+d5qCH6K6wXG4gICAgICAgKiBAbWVtYmVyb2YgUGVyc2lzdGVudENvbnZlcnNhdGlvbiNcbiAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICogQHNpbmNlIDMuMy4wXG4gICAgICAgKi9cbiAgICAgIHN5c3RlbTogc3lzdGVtLFxuICAgICAgLyoqXG4gICAgICAgKiDlvZPliY3nlKjmiLfpnZnpn7Por6Xlr7nor53moIforrBcbiAgICAgICAqIEBtZW1iZXJvZiBQZXJzaXN0ZW50Q29udmVyc2F0aW9uI1xuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIG11dGVkOiBtdXRlZCxcbiAgICAgIF9hdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzXG4gICAgfSksIGNsaWVudCkpO1xuXG4gICAgX3RoaXMuX3Jlc2V0KCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIOiOt+WPluWvueivneeahOiHquWumuS5ieWxnuaAp1xuICAgKiBAc2luY2UgMy4yLjBcbiAgICogQHBhcmFtICB7U3RyaW5nfSBrZXkga2V5IOWxnuaAp+eahOmUruWQje+8jCd4JyDlr7nlupQgQ29udmVyc2F0aW9uIOihqOS4reeahCB4IOWIl1xuICAgKiBAcmV0dXJuIHtBbnl9IOWxnuaAp+eahOWAvFxuICAgKi9cbiAgUGVyc2lzdGVudENvbnZlcnNhdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIHJldHVybiBpbnRlcm5hbCh0aGlzKS5jdXJyZW50QXR0cmlidXRlc1trZXldO1xuICB9O1xuXG4gIC8qKlxuICAgKiDorr7nva7lr7nor53nmoToh6rlrprkuYnlsZ7mgKdcbiAgICogQHNpbmNlIDMuMi4wXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkg5bGe5oCn55qE6ZSu5ZCN77yMJ3gnIOWvueW6lCBDb252ZXJzYXRpb24g6KGo5Lit55qEIHgg5YiX77yM5pSv5oyB5L2/55SoICd4Lnkueicg5p2l5L+u5pS55a+56LGh55qE6YOo5YiG5a2X5q6144CCXG4gICAqIEBwYXJhbSB7QW55fSB2YWx1ZSDlsZ7mgKfnmoTlgLxcbiAgICogQHJldHVybiB7dGhpc30gc2VsZlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAvLyDorr7nva7lr7nor53nmoQgY29sb3Ig5bGe5oCnXG4gICAqIGNvbnZlcnNhdGlvbi5zZXQoJ2NvbG9yJywge1xuICAgKiAgIHRleHQ6ICcjMDAwJyxcbiAgICogICBiYWNrZ3JvdW5kOiAnI0RERCcsXG4gICAqIH0pO1xuICAgKiAvLyDorr7nva7lr7nor53nmoQgY29sb3IudGV4dCDlsZ7mgKdcbiAgICogY29udmVyc2F0aW9uLnNldCgnY29sb3IudGV4dCcsICcjMzMzJyk7XG4gICAqL1xuXG5cbiAgUGVyc2lzdGVudENvbnZlcnNhdGlvbi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9kZWJ1Zygnc2V0IFsnICsga2V5ICsgJ106ICcgKyB2YWx1ZSk7XG5cbiAgICB2YXIgX2ludGVybmFsID0gaW50ZXJuYWwodGhpcyksXG4gICAgICAgIHBlbmRpbmdBdHRyaWJ1dGVzID0gX2ludGVybmFsLnBlbmRpbmdBdHRyaWJ1dGVzO1xuXG4gICAgdmFyIHBlbmRpbmdLZXlzID0gX09iamVjdCRrZXlzKHBlbmRpbmdBdHRyaWJ1dGVzKTtcbiAgICAvLyBzdXBwb3NlIHBlbmRpbmdBdHRyaWJ1dGVzID0geyAnYS5iJzoge30gfVxuICAgIC8vIHNldCAnYScgb3IgJ2EuYic6IGRlbGV0ZSAnYS5iJ1xuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJ14nICsga2V5KTtcbiAgICB2YXIgY2hpbGRLZXlzID0gcGVuZGluZ0tleXMuZmlsdGVyKHJlLnRlc3QuYmluZChyZSkpO1xuICAgIGNoaWxkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBkZWxldGUgcGVuZGluZ0F0dHJpYnV0ZXNba107XG4gICAgfSk7XG4gICAgaWYgKGNoaWxkS2V5cy5sZW5ndGgpIHtcbiAgICAgIHBlbmRpbmdBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2V0ICdhLmMnOiBub3RoaW5nIHRvIGRvXG4gICAgICAvLyBzZXQgJ2EuYi5jLmQnOiBhc3NpZ24gYzogeyBkOiB7fSB9IHRvICdhLmInXG4gICAgICAvLyBDQVVUSU9OOiBub24tc3RhbmRhcmQgQVBJLCBwcm92aWRlZCBieSBjb3JlLWpzXG4gICAgICB2YXIgcGFyZW50S2V5ID0gX0FycmF5JGZpbmQocGVuZGluZ0tleXMsIGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrZXkuaW5kZXhPZihrKSA9PT0gMDtcbiAgICAgIH0pOyAvLyAnYS5iJ1xuICAgICAgaWYgKHBhcmVudEtleSkge1xuICAgICAgICBzZXRWYWx1ZShwZW5kaW5nQXR0cmlidXRlc1twYXJlbnRLZXldLCBrZXkuc2xpY2UocGFyZW50S2V5Lmxlbmd0aCArIDEpLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZW5kaW5nQXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2J1aWxkQ3VycmVudEF0dHJpYnV0ZXMoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBQZXJzaXN0ZW50Q29udmVyc2F0aW9uLnByb3RvdHlwZS5fYnVpbGRDdXJyZW50QXR0cmlidXRlcyA9IGZ1bmN0aW9uIF9idWlsZEN1cnJlbnRBdHRyaWJ1dGVzKCkge1xuICAgIHZhciBfaW50ZXJuYWwyID0gaW50ZXJuYWwodGhpcyksXG4gICAgICAgIHBlbmRpbmdBdHRyaWJ1dGVzID0gX2ludGVybmFsMi5wZW5kaW5nQXR0cmlidXRlcztcblxuICAgIGludGVybmFsKHRoaXMpLmN1cnJlbnRBdHRyaWJ1dGVzID0gX09iamVjdCRrZXlzKHBlbmRpbmdBdHRyaWJ1dGVzKS5yZWR1Y2UoZnVuY3Rpb24gKHRhcmdldCwgaykge1xuICAgICAgcmV0dXJuIHNldFZhbHVlKHRhcmdldCwgaywgcGVuZGluZ0F0dHJpYnV0ZXNba10pO1xuICAgIH0sIGNsb25lRGVlcF8xKHRoaXMuX2F0dHJpYnV0ZXMpKTtcbiAgfTtcblxuICBQZXJzaXN0ZW50Q29udmVyc2F0aW9uLnByb3RvdHlwZS5fdXBkYXRlU2VydmVyQXR0cmlidXRlcyA9IGZ1bmN0aW9uIF91cGRhdGVTZXJ2ZXJBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIF9PYmplY3Qka2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBzZXRWYWx1ZShfdGhpczIuX2F0dHJpYnV0ZXMsIGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICB9KTtcbiAgICB0aGlzLl9idWlsZEN1cnJlbnRBdHRyaWJ1dGVzKCk7XG4gIH07XG5cbiAgUGVyc2lzdGVudENvbnZlcnNhdGlvbi5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gX3Jlc2V0KCkge1xuICAgIGludGVybmFsKHRoaXMpLnBlbmRpbmdBdHRyaWJ1dGVzID0ge307XG4gICAgaW50ZXJuYWwodGhpcykuY3VycmVudEF0dHJpYnV0ZXMgPSB0aGlzLl9hdHRyaWJ1dGVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiDkv53lrZjlvZPliY3lr7nor53nmoTlsZ7mgKfoh7PmnI3liqHlmahcbiAgICogQHJldHVybiB7UHJvbWlzZS48dGhpcz59IHNlbGZcbiAgICovXG5cblxuICBQZXJzaXN0ZW50Q29udmVyc2F0aW9uLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmNCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgdmFyIGF0dHIsIGNvbnZNZXNzYWdlLCByZXNDb21tYW5kO1xuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdzYXZlJyk7XG4gICAgICAgICAgICAgIGF0dHIgPSBpbnRlcm5hbCh0aGlzKS5wZW5kaW5nQXR0cmlidXRlcztcblxuICAgICAgICAgICAgICBpZiAoIWlzRW1wdHlfMShhdHRyKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ25vdGhpbmcgdG91Y2hlZCwgcmVzb2x2ZSB3aXRoIHNlbGYnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgncmV0dXJuJywgdGhpcyk7XG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ2F0dHI6ICVPJywgYXR0cik7XG4gICAgICAgICAgICAgIGNvbnZNZXNzYWdlID0gbmV3IENvbnZDb21tYW5kKHtcbiAgICAgICAgICAgICAgICBhdHRyOiBuZXcgSnNvbk9iamVjdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgZGF0YTogX0pTT04kc3RyaW5naWZ5KGVuY29kZSQxKGF0dHIpKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmQobmV3IEdlbmVyaWNDb21tYW5kKHtcbiAgICAgICAgICAgICAgICBvcDogJ3VwZGF0ZScsXG4gICAgICAgICAgICAgICAgY29udk1lc3NhZ2U6IGNvbnZNZXNzYWdlXG4gICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICByZXNDb21tYW5kID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZWRBdCA9IHJlc0NvbW1hbmQuY29udk1lc3NhZ2UudWRhdGU7XG4gICAgICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBpbnRlcm5hbCh0aGlzKS5jdXJyZW50QXR0cmlidXRlcztcbiAgICAgICAgICAgICAgaW50ZXJuYWwodGhpcykucGVuZGluZ0F0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgncmV0dXJuJywgdGhpcyk7XG5cbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gc2F2ZSgpIHtcbiAgICAgIHJldHVybiBfcmVmNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBzYXZlO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIOS7juacjeWKoeWZqOabtOaWsOWvueivneeahOWxnuaAp1xuICAgKiBAcmV0dXJuIHtQcm9taXNlLjx0aGlzPn0gc2VsZlxuICAgKi9cblxuXG4gIFBlcnNpc3RlbnRDb252ZXJzYXRpb24ucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmNSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgIHZhciBxdWVyeTtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcXVlcnkgPSB0aGlzLl9jbGllbnQuZ2V0UXVlcnkoKS5lcXVhbFRvKCdvYmplY3RJZCcsIHRoaXMuaWQpO1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiBxdWVyeS5maW5kKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoJ3JldHVybicsIHRoaXMpO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBmZXRjaCgpIHtcbiAgICAgIHJldHVybiBfcmVmNS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBmZXRjaDtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiDpnZnpn7PvvIzlrqLmiLfnq6/mi5Lnu53mlLbliLDmnI3liqHlmajnq6/nmoTnprvnur/mjqjpgIHpgJrnn6VcbiAgICogQHJldHVybiB7UHJvbWlzZS48dGhpcz59IHNlbGZcbiAgICovXG5cblxuICBQZXJzaXN0ZW50Q29udmVyc2F0aW9uLnByb3RvdHlwZS5tdXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmNiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ211dGUnKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VuZChuZXcgR2VuZXJpY0NvbW1hbmQoe1xuICAgICAgICAgICAgICAgIG9wOiAnbXV0ZSdcbiAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGlmICghdGhpcy50cmFuc2llbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGVkTWVtYmVycyA9IHVuaW9uKHRoaXMubXV0ZWRNZW1iZXJzLCBbdGhpcy5fY2xpZW50LmlkXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoJ3JldHVybicsIHRoaXMpO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBtdXRlKCkge1xuICAgICAgcmV0dXJuIF9yZWY2LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG11dGU7XG4gIH0oKTtcblxuICAvKipcbiAgICog5Y+W5raI6Z2Z6Z+zXG4gICAqIEByZXR1cm4ge1Byb21pc2UuPHRoaXM+fSBzZWxmXG4gICAqL1xuXG5cbiAgUGVyc2lzdGVudENvbnZlcnNhdGlvbi5wcm90b3R5cGUudW5tdXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmNyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlNCgpIHtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ3VubXV0ZScpO1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kKG5ldyBHZW5lcmljQ29tbWFuZCh7XG4gICAgICAgICAgICAgICAgb3A6ICd1bm11dGUnXG4gICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBpZiAoIXRoaXMudHJhbnNpZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubXV0ZWRNZW1iZXJzID0gZGlmZmVyZW5jZSh0aGlzLm11dGVkTWVtYmVycywgW3RoaXMuX2NsaWVudC5pZF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCdyZXR1cm4nLCB0aGlzKTtcblxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gdW5tdXRlKCkge1xuICAgICAgcmV0dXJuIF9yZWY3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVubXV0ZTtcbiAgfSgpO1xuXG4gIFBlcnNpc3RlbnRDb252ZXJzYXRpb24ucHJvdG90eXBlLl9hcHBlbmRDb252ZXJzYXRpb25TaWduYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWY4ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KGNvbW1hbmQsIGFjdGlvbiwgY2xpZW50SWRzKSB7XG4gICAgICB2YXIgcGFyYW1zLCBzaWduYXR1cmVSZXN1bHQ7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGlmICghdGhpcy5fY2xpZW50Lm9wdGlvbnMuY29udmVyc2F0aW9uU2lnbmF0dXJlRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHBhcmFtcyA9IFt0aGlzLmlkLCB0aGlzLl9jbGllbnQuaWQsIGNsaWVudElkcy5zb3J0KCksIGFjdGlvbl07XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJ1blNpZ25hdHVyZUZhY3RvcnkodGhpcy5fY2xpZW50Lm9wdGlvbnMuY29udmVyc2F0aW9uU2lnbmF0dXJlRmFjdG9yeSwgcGFyYW1zKTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBzaWduYXR1cmVSZXN1bHQgPSBfY29udGV4dDUuc2VudDtcblxuICAgICAgICAgICAgICBfT2JqZWN0JGFzc2lnbihjb21tYW5kLmNvbnZNZXNzYWdlLCBrZXlSZW1hcCh7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAncycsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiAndCcsXG4gICAgICAgICAgICAgICAgbm9uY2U6ICduJ1xuICAgICAgICAgICAgICB9LCBzaWduYXR1cmVSZXN1bHQpKTtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gX2FwcGVuZENvbnZlcnNhdGlvblNpZ25hdHVyZShfeCwgX3gyLCBfeDMpIHtcbiAgICAgIHJldHVybiBfcmVmOC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfYXBwZW5kQ29udmVyc2F0aW9uU2lnbmF0dXJlO1xuICB9KCk7XG5cbiAgUGVyc2lzdGVudENvbnZlcnNhdGlvbi5wcm90b3R5cGUuX2FwcGVuZEJsYWNrbGlzdFNpZ25hdHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjkgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoY29tbWFuZCwgYWN0aW9uLCBjbGllbnRJZHMpIHtcbiAgICAgIHZhciBwYXJhbXMsIHNpZ25hdHVyZVJlc3VsdDtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jbGllbnQub3B0aW9ucy5ibGFja2xpc3RTaWduYXR1cmVGYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcGFyYW1zID0gW3RoaXMuX2NsaWVudC5pZCwgdGhpcy5pZCwgY2xpZW50SWRzLnNvcnQoKSwgYWN0aW9uXTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gcnVuU2lnbmF0dXJlRmFjdG9yeSh0aGlzLl9jbGllbnQub3B0aW9ucy5ibGFja2xpc3RTaWduYXR1cmVGYWN0b3J5LCBwYXJhbXMpO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHNpZ25hdHVyZVJlc3VsdCA9IF9jb250ZXh0Ni5zZW50O1xuXG4gICAgICAgICAgICAgIF9PYmplY3QkYXNzaWduKGNvbW1hbmQuYmxhY2tsaXN0TWVzc2FnZSwga2V5UmVtYXAoe1xuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ3MnLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogJ3QnLFxuICAgICAgICAgICAgICAgIG5vbmNlOiAnbidcbiAgICAgICAgICAgICAgfSwgc2lnbmF0dXJlUmVzdWx0KSk7XG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTYsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIF9hcHBlbmRCbGFja2xpc3RTaWduYXR1cmUoX3g0LCBfeDUsIF94Nikge1xuICAgICAgcmV0dXJuIF9yZWY5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcHBlbmRCbGFja2xpc3RTaWduYXR1cmU7XG4gIH0oKTtcblxuICAvKipcbiAgICog5aKe5Yqg5oiQ5ZGYXG4gICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfSBjbGllbnRJZHMg5paw5aKe5oiQ5ZGYIGNsaWVudCBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlLjxQYXJ0aWFsbHlTdWNjZXNzPn0g6YOo5YiG5oiQ5Yqf57uT5p6c77yM5YyF5ZCr5LqG5oiQ5Yqf55qEIGlkIOWIl+ihqOOAgeWksei0peWOn+WboOS4juWvueW6lOeahCBpZCDliJfooahcbiAgICovXG5cblxuICBQZXJzaXN0ZW50Q29udmVyc2F0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYxMCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhjbGllbnRJZHMpIHtcbiAgICAgIHZhciBjb21tYW5kLCBfcmVmMTEsIGNvbnZNZXNzYWdlLCBhbGxvd2VkUGlkcztcblxuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnYWRkJywgY2xpZW50SWRzKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjbGllbnRJZHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY2xpZW50SWRzID0gW2NsaWVudElkc107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb21tYW5kID0gbmV3IEdlbmVyaWNDb21tYW5kKHtcbiAgICAgICAgICAgICAgICBvcDogJ2FkZCcsXG4gICAgICAgICAgICAgICAgY29udk1lc3NhZ2U6IG5ldyBDb252Q29tbWFuZCh7XG4gICAgICAgICAgICAgICAgICBtOiBjbGllbnRJZHNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA1O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBwZW5kQ29udmVyc2F0aW9uU2lnbmF0dXJlKGNvbW1hbmQsICdhZGQnLCBjbGllbnRJZHMpO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmQoY29tbWFuZCk7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgX3JlZjExID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICAgIGNvbnZNZXNzYWdlID0gX3JlZjExLmNvbnZNZXNzYWdlO1xuICAgICAgICAgICAgICBhbGxvd2VkUGlkcyA9IF9yZWYxMS5jb252TWVzc2FnZS5hbGxvd2VkUGlkcztcblxuICAgICAgICAgICAgICBpZiAoIXRoaXMudHJhbnNpZW50ICYmICF0aGlzLnN5c3RlbSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWVtYmVycyA9IHVuaW9uKHRoaXMubWVtYmVycywgYWxsb3dlZFBpZHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KCdyZXR1cm4nLCBjcmVhdGVQYXJ0aWFsbHlTdWNjZXNzKGNvbnZNZXNzYWdlKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWU3LCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBhZGQoX3g3KSB7XG4gICAgICByZXR1cm4gX3JlZjEwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZDtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiDliZTpmaTmiJDlkZhcbiAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IGNsaWVudElkcyDmiJDlkZggY2xpZW50IGlkXG4gICAqIEByZXR1cm4ge1Byb21pc2UuPFBhcnRpYWxseVN1Y2Nlc3M+fSDpg6jliIbmiJDlip/nu5PmnpzvvIzljIXlkKvkuobmiJDlip/nmoQgaWQg5YiX6KGo44CB5aSx6LSl5Y6f5Zug5LiO5a+55bqU55qEIGlkIOWIl+ihqFxuICAgKi9cblxuXG4gIFBlcnNpc3RlbnRDb252ZXJzYXRpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjEyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KGNsaWVudElkcykge1xuICAgICAgdmFyIGNvbW1hbmQsIF9yZWYxMywgY29udk1lc3NhZ2UsIGFsbG93ZWRQaWRzO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdyZW1vdmUnLCBjbGllbnRJZHMpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNsaWVudElkcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjbGllbnRJZHMgPSBbY2xpZW50SWRzXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbW1hbmQgPSBuZXcgR2VuZXJpY0NvbW1hbmQoe1xuICAgICAgICAgICAgICAgIG9wOiAncmVtb3ZlJyxcbiAgICAgICAgICAgICAgICBjb252TWVzc2FnZTogbmV3IENvbnZDb21tYW5kKHtcbiAgICAgICAgICAgICAgICAgIG06IGNsaWVudElkc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDU7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcHBlbmRDb252ZXJzYXRpb25TaWduYXR1cmUoY29tbWFuZCwgJ3JlbW92ZScsIGNsaWVudElkcyk7XG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA3O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VuZChjb21tYW5kKTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfcmVmMTMgPSBfY29udGV4dDguc2VudDtcbiAgICAgICAgICAgICAgY29udk1lc3NhZ2UgPSBfcmVmMTMuY29udk1lc3NhZ2U7XG4gICAgICAgICAgICAgIGFsbG93ZWRQaWRzID0gX3JlZjEzLmNvbnZNZXNzYWdlLmFsbG93ZWRQaWRzO1xuXG4gICAgICAgICAgICAgIGlmICghdGhpcy50cmFuc2llbnQgJiYgIXRoaXMuc3lzdGVtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZW1iZXJzID0gZGlmZmVyZW5jZSh0aGlzLm1lbWJlcnMsIGFsbG93ZWRQaWRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdCgncmV0dXJuJywgY3JlYXRlUGFydGlhbGx5U3VjY2Vzcyhjb252TWVzc2FnZSkpO1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlOCwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlKF94OCkge1xuICAgICAgcmV0dXJuIF9yZWYxMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiByZW1vdmU7XG4gIH0oKTtcblxuICAvKipcbiAgICog77yI5b2T5YmN55So5oi377yJ5Yqg5YWl6K+l5a+56K+dXG4gICAqIEByZXR1cm4ge1Byb21pc2UuPHRoaXM+fSBzZWxmXG4gICAqL1xuXG5cbiAgUGVyc2lzdGVudENvbnZlcnNhdGlvbi5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjE0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5KCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ2pvaW4nKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoJ3JldHVybicsIHRoaXMuYWRkKHRoaXMuX2NsaWVudC5pZCkudGhlbihmdW5jdGlvbiAoX3JlZjE1KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZhaWx1cmVzID0gX3JlZjE1LmZhaWx1cmVzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZhaWx1cmVzWzBdKSB0aHJvdyBmYWlsdXJlc1swXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzO1xuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTksIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIGpvaW4oKSB7XG4gICAgICByZXR1cm4gX3JlZjE0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpvaW47XG4gIH0oKTtcblxuICAvKipcbiAgICog77yI5b2T5YmN55So5oi377yJ6YCA5Ye66K+l5a+56K+dXG4gICAqIEByZXR1cm4ge1Byb21pc2UuPHRoaXM+fSBzZWxmXG4gICAqL1xuXG5cbiAgUGVyc2lzdGVudENvbnZlcnNhdGlvbi5wcm90b3R5cGUucXVpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjE2ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMCgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAkKF9jb250ZXh0MTApIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTAucHJldiA9IF9jb250ZXh0MTAubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygncXVpdCcpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoJ3JldHVybicsIHRoaXMucmVtb3ZlKHRoaXMuX2NsaWVudC5pZCkudGhlbihmdW5jdGlvbiAoX3JlZjE3KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZhaWx1cmVzID0gX3JlZjE3LmZhaWx1cmVzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZhaWx1cmVzWzBdKSB0aHJvdyBmYWlsdXJlc1swXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM0O1xuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUxMCwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gcXVpdCgpIHtcbiAgICAgIHJldHVybiBfcmVmMTYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVpdDtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiDlnKjor6Xlr7nor53kuK3npoHoqIDmiJDlkZhcbiAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IGNsaWVudElkcyDmiJDlkZggY2xpZW50IGlkXG4gICAqIEByZXR1cm4ge1Byb21pc2UuPFBhcnRpYWxseVN1Y2Nlc3M+fSDpg6jliIbmiJDlip/nu5PmnpzvvIzljIXlkKvkuobmiJDlip/nmoQgaWQg5YiX6KGo44CB5aSx6LSl5Y6f5Zug5LiO5a+55bqU55qEIGlkIOWIl+ihqFxuICAgKi9cblxuXG4gIFBlcnNpc3RlbnRDb252ZXJzYXRpb24ucHJvdG90eXBlLm11dGVNZW1iZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmMTggPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTExKGNsaWVudElkcykge1xuICAgICAgdmFyIGNvbW1hbmQsIF9yZWYxOSwgY29udk1lc3NhZ2U7XG5cbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMSQoX2NvbnRleHQxMSkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdtdXRlJywgY2xpZW50SWRzKTtcbiAgICAgICAgICAgICAgY2xpZW50SWRzID0gZW5zdXJlQXJyYXkoY2xpZW50SWRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICBjb21tYW5kID0gbmV3IEdlbmVyaWNDb21tYW5kKHtcbiAgICAgICAgICAgICAgICBvcDogT3BUeXBlLmFkZF9zaHV0dXAsXG4gICAgICAgICAgICAgICAgY29udk1lc3NhZ2U6IG5ldyBDb252Q29tbWFuZCh7XG4gICAgICAgICAgICAgICAgICBtOiBjbGllbnRJZHNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmQoY29tbWFuZCk7XG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgX3JlZjE5ID0gX2NvbnRleHQxMS5zZW50O1xuICAgICAgICAgICAgICBjb252TWVzc2FnZSA9IF9yZWYxOS5jb252TWVzc2FnZTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuYWJydXB0KCdyZXR1cm4nLCBjcmVhdGVQYXJ0aWFsbHlTdWNjZXNzKGNvbnZNZXNzYWdlKSk7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUxMSwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gbXV0ZU1lbWJlcnMoX3g5KSB7XG4gICAgICByZXR1cm4gX3JlZjE4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG11dGVNZW1iZXJzO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIOWcqOivpeWvueivneS4reino+mZpOaIkOWRmOemgeiogFxuICAgKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0gY2xpZW50SWRzIOaIkOWRmCBjbGllbnQgaWRcbiAgICogQHJldHVybiB7UHJvbWlzZS48UGFydGlhbGx5U3VjY2Vzcz59IOmDqOWIhuaIkOWKn+e7k+aenO+8jOWMheWQq+S6huaIkOWKn+eahCBpZCDliJfooajjgIHlpLHotKXljp/lm6DkuI7lr7nlupTnmoQgaWQg5YiX6KGoXG4gICAqL1xuXG5cbiAgUGVyc2lzdGVudENvbnZlcnNhdGlvbi5wcm90b3R5cGUudW5tdXRlTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjIwID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMihjbGllbnRJZHMpIHtcbiAgICAgIHZhciBjb21tYW5kLCBfcmVmMjEsIGNvbnZNZXNzYWdlO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMTIkKF9jb250ZXh0MTIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygndW5tdXRlJywgY2xpZW50SWRzKTtcbiAgICAgICAgICAgICAgY2xpZW50SWRzID0gZW5zdXJlQXJyYXkoY2xpZW50SWRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICBjb21tYW5kID0gbmV3IEdlbmVyaWNDb21tYW5kKHtcbiAgICAgICAgICAgICAgICBvcDogT3BUeXBlLnJlbW92ZV9zaHV0dXAsXG4gICAgICAgICAgICAgICAgY29udk1lc3NhZ2U6IG5ldyBDb252Q29tbWFuZCh7XG4gICAgICAgICAgICAgICAgICBtOiBjbGllbnRJZHNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmQoY29tbWFuZCk7XG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgX3JlZjIxID0gX2NvbnRleHQxMi5zZW50O1xuICAgICAgICAgICAgICBjb252TWVzc2FnZSA9IF9yZWYyMS5jb252TWVzc2FnZTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuYWJydXB0KCdyZXR1cm4nLCBjcmVhdGVQYXJ0aWFsbHlTdWNjZXNzKGNvbnZNZXNzYWdlKSk7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUxMiwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gdW5tdXRlTWVtYmVycyhfeDEwKSB7XG4gICAgICByZXR1cm4gX3JlZjIwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVubXV0ZU1lbWJlcnM7XG4gIH0oKTtcblxuICAvKipcbiAgICog5p+l6K+i6K+l5a+56K+d56aB6KiA5oiQ5ZGY5YiX6KGoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxpbWl0XSDov5Tlm57nmoTmiJDlkZjmlbDph4/vvIzmnI3liqHlmajpu5jorqTlgLwgMTBcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm5leHRdIOS7juaMh+WumiBuZXh0IOW8gOWni+afpeivou+8jOS4jiBsaW1pdCDkuIDotbfkvb/nlKjlj6/ku6XlrozmiJDnv7vpobXjgIJcbiAgICogQHJldHVybiB7UGFnZWRSZXN1bHRzLjxzdHJpbmc+fSDmn6Xor6Lnu5PmnpzjgILlhbbkuK3nmoQgY3VyZXNlciDlrZjlnKjooajnpLrov5jmnInmm7TlpJrnu5PmnpzjgIJcbiAgICovXG5cblxuICBQZXJzaXN0ZW50Q29udmVyc2F0aW9uLnByb3RvdHlwZS5xdWVyeU11dGVkTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjIyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMygpIHtcbiAgICAgIHZhciBfcmVmMjMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIGxpbWl0ID0gX3JlZjIzLmxpbWl0LFxuICAgICAgICAgIG5leHQgPSBfcmVmMjMubmV4dDtcblxuICAgICAgdmFyIGNvbW1hbmQsIF9yZWYyNCwgX3JlZjI0JGNvbnZNZXNzYWdlLCBtLCBuZXdOZXh0O1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMTMkKF9jb250ZXh0MTMpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTMucHJldiA9IF9jb250ZXh0MTMubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygncXVlcnkgbXV0ZWQ6IGxpbWl0ICVPLCBuZXh0OiAlTycsIGxpbWl0LCBuZXh0KTtcbiAgICAgICAgICAgICAgY29tbWFuZCA9IG5ldyBHZW5lcmljQ29tbWFuZCh7XG4gICAgICAgICAgICAgICAgb3A6IE9wVHlwZS5xdWVyeV9zaHV0dXAsXG4gICAgICAgICAgICAgICAgY29udk1lc3NhZ2U6IG5ldyBDb252Q29tbWFuZCh7XG4gICAgICAgICAgICAgICAgICBsaW1pdDogbGltaXQsXG4gICAgICAgICAgICAgICAgICBuZXh0OiBuZXh0XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kKGNvbW1hbmQpO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIF9yZWYyNCA9IF9jb250ZXh0MTMuc2VudDtcbiAgICAgICAgICAgICAgX3JlZjI0JGNvbnZNZXNzYWdlID0gX3JlZjI0LmNvbnZNZXNzYWdlO1xuICAgICAgICAgICAgICBtID0gX3JlZjI0JGNvbnZNZXNzYWdlLm07XG4gICAgICAgICAgICAgIG5ld05leHQgPSBfcmVmMjQkY29udk1lc3NhZ2UubmV4dDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuYWJydXB0KCdyZXR1cm4nLCB7XG4gICAgICAgICAgICAgICAgcmVzdWx0czogbSxcbiAgICAgICAgICAgICAgICBuZXh0OiBuZXdOZXh0XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMy5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlMTMsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIHF1ZXJ5TXV0ZWRNZW1iZXJzKCkge1xuICAgICAgcmV0dXJuIF9yZWYyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBxdWVyeU11dGVkTWVtYmVycztcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiDlsIbnlKjmiLfliqDlhaXor6Xlr7nor53pu5HlkI3ljZVcbiAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IGNsaWVudElkcyDmiJDlkZggY2xpZW50IGlkXG4gICAqIEByZXR1cm4ge1Byb21pc2UuPFBhcnRpYWxseVN1Y2Nlc3M+fSDpg6jliIbmiJDlip/nu5PmnpzvvIzljIXlkKvkuobmiJDlip/nmoQgaWQg5YiX6KGo44CB5aSx6LSl5Y6f5Zug5LiO5a+55bqU55qEIGlkIOWIl+ihqFxuICAgKi9cblxuXG4gIFBlcnNpc3RlbnRDb252ZXJzYXRpb24ucHJvdG90eXBlLmJsb2NrTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjI1ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNChjbGllbnRJZHMpIHtcbiAgICAgIHZhciBjb21tYW5kLCBfcmVmMjYsIGJsYWNrbGlzdE1lc3NhZ2U7XG5cbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNCQoX2NvbnRleHQxNCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNC5wcmV2ID0gX2NvbnRleHQxNC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdibG9jaycsIGNsaWVudElkcyk7XG4gICAgICAgICAgICAgIGNsaWVudElkcyA9IGVuc3VyZUFycmF5KGNsaWVudElkcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgY29tbWFuZCA9IG5ldyBHZW5lcmljQ29tbWFuZCh7XG4gICAgICAgICAgICAgICAgY21kOiAnYmxhY2tsaXN0JyxcbiAgICAgICAgICAgICAgICBvcDogT3BUeXBlLmJsb2NrLFxuICAgICAgICAgICAgICAgIGJsYWNrbGlzdE1lc3NhZ2U6IG5ldyBCbGFja2xpc3RDb21tYW5kKHtcbiAgICAgICAgICAgICAgICAgIHNyY0NpZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgIHRvUGlkczogY2xpZW50SWRzXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDU7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcHBlbmRCbGFja2xpc3RTaWduYXR1cmUoY29tbWFuZCwgJ2NvbnZlcnNhdGlvbi1ibG9jay1jbGllbnRzJywgY2xpZW50SWRzKTtcblxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VuZChjb21tYW5kKTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfcmVmMjYgPSBfY29udGV4dDE0LnNlbnQ7XG4gICAgICAgICAgICAgIGJsYWNrbGlzdE1lc3NhZ2UgPSBfcmVmMjYuYmxhY2tsaXN0TWVzc2FnZTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuYWJydXB0KCdyZXR1cm4nLCBjcmVhdGVQYXJ0aWFsbHlTdWNjZXNzKGJsYWNrbGlzdE1lc3NhZ2UpKTtcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUxNCwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gYmxvY2tNZW1iZXJzKF94MTIpIHtcbiAgICAgIHJldHVybiBfcmVmMjUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2tNZW1iZXJzO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIOWwhueUqOaIt+enu+WHuuivpeWvueivnem7keWQjeWNlVxuICAgKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0gY2xpZW50SWRzIOaIkOWRmCBjbGllbnQgaWRcbiAgICogQHJldHVybiB7UHJvbWlzZS48UGFydGlhbGx5U3VjY2Vzcz59IOmDqOWIhuaIkOWKn+e7k+aenO+8jOWMheWQq+S6huaIkOWKn+eahCBpZCDliJfooajjgIHlpLHotKXljp/lm6DkuI7lr7nlupTnmoQgaWQg5YiX6KGoXG4gICAqL1xuXG5cbiAgUGVyc2lzdGVudENvbnZlcnNhdGlvbi5wcm90b3R5cGUudW5ibG9ja01lbWJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYyNyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMTUoY2xpZW50SWRzKSB7XG4gICAgICB2YXIgY29tbWFuZCwgX3JlZjI4LCBibGFja2xpc3RNZXNzYWdlO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMTUkKF9jb250ZXh0MTUpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTUucHJldiA9IF9jb250ZXh0MTUubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygndW5ibG9jaycsIGNsaWVudElkcyk7XG4gICAgICAgICAgICAgIGNsaWVudElkcyA9IGVuc3VyZUFycmF5KGNsaWVudElkcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgY29tbWFuZCA9IG5ldyBHZW5lcmljQ29tbWFuZCh7XG4gICAgICAgICAgICAgICAgY21kOiAnYmxhY2tsaXN0JyxcbiAgICAgICAgICAgICAgICBvcDogT3BUeXBlLnVuYmxvY2ssXG4gICAgICAgICAgICAgICAgYmxhY2tsaXN0TWVzc2FnZTogbmV3IEJsYWNrbGlzdENvbW1hbmQoe1xuICAgICAgICAgICAgICAgICAgc3JjQ2lkOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgICAgdG9QaWRzOiBjbGllbnRJZHNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxNS5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZEJsYWNrbGlzdFNpZ25hdHVyZShjb21tYW5kLCAnY29udmVyc2F0aW9uLXVuYmxvY2stY2xpZW50cycsIGNsaWVudElkcyk7XG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgX2NvbnRleHQxNS5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmQoY29tbWFuZCk7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgX3JlZjI4ID0gX2NvbnRleHQxNS5zZW50O1xuICAgICAgICAgICAgICBibGFja2xpc3RNZXNzYWdlID0gX3JlZjI4LmJsYWNrbGlzdE1lc3NhZ2U7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE1LmFicnVwdCgncmV0dXJuJywgY3JlYXRlUGFydGlhbGx5U3VjY2VzcyhibGFja2xpc3RNZXNzYWdlKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlMTUsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIHVuYmxvY2tNZW1iZXJzKF94MTMpIHtcbiAgICAgIHJldHVybiBfcmVmMjcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5ibG9ja01lbWJlcnM7XG4gIH0oKTtcblxuICAvKipcbiAgICog5p+l6K+i6K+l5a+56K+d6buR5ZCN5Y2VXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxpbWl0XSDov5Tlm57nmoTmiJDlkZjmlbDph4/vvIzmnI3liqHlmajpu5jorqTlgLwgMTBcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm5leHRdIOS7juaMh+WumiBuZXh0IOW8gOWni+afpeivou+8jOS4jiBsaW1pdCDkuIDotbfkvb/nlKjlj6/ku6XlrozmiJDnv7vpobVcbiAgICogQHJldHVybiB7UGFnZWRSZXN1bHRzLjxzdHJpbmc+fSDmn6Xor6Lnu5PmnpzjgILlhbbkuK3nmoQgY3VyZXNlciDlrZjlnKjooajnpLrov5jmnInmm7TlpJrnu5PmnpzjgIJcbiAgICovXG5cblxuICBQZXJzaXN0ZW50Q29udmVyc2F0aW9uLnByb3RvdHlwZS5xdWVyeUJsb2NrZWRNZW1iZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmMjkgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE2KCkge1xuICAgICAgdmFyIF9yZWYzMCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgbGltaXQgPSBfcmVmMzAubGltaXQsXG4gICAgICAgICAgbmV4dCA9IF9yZWYzMC5uZXh0O1xuXG4gICAgICB2YXIgY29tbWFuZCwgX3JlZjMxLCBfcmVmMzEkYmxhY2tsaXN0TWVzc2EsIGJsb2NrZWRQaWRzLCBuZXdOZXh0O1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMTYkKF9jb250ZXh0MTYpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTYucHJldiA9IF9jb250ZXh0MTYubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygncXVlcnkgYmxvY2tlZDogbGltaXQgJU8sIG5leHQ6ICVPJywgbGltaXQsIG5leHQpO1xuICAgICAgICAgICAgICBjb21tYW5kID0gbmV3IEdlbmVyaWNDb21tYW5kKHtcbiAgICAgICAgICAgICAgICBjbWQ6ICdibGFja2xpc3QnLFxuICAgICAgICAgICAgICAgIG9wOiBPcFR5cGUucXVlcnksXG4gICAgICAgICAgICAgICAgYmxhY2tsaXN0TWVzc2FnZTogbmV3IEJsYWNrbGlzdENvbW1hbmQoe1xuICAgICAgICAgICAgICAgICAgc3JjQ2lkOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgICAgbGltaXQ6IGxpbWl0LFxuICAgICAgICAgICAgICAgICAgbmV4dDogbmV4dFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBfY29udGV4dDE2Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VuZChjb21tYW5kKTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBfcmVmMzEgPSBfY29udGV4dDE2LnNlbnQ7XG4gICAgICAgICAgICAgIF9yZWYzMSRibGFja2xpc3RNZXNzYSA9IF9yZWYzMS5ibGFja2xpc3RNZXNzYWdlO1xuICAgICAgICAgICAgICBibG9ja2VkUGlkcyA9IF9yZWYzMSRibGFja2xpc3RNZXNzYS5ibG9ja2VkUGlkcztcbiAgICAgICAgICAgICAgbmV3TmV4dCA9IF9yZWYzMSRibGFja2xpc3RNZXNzYS5uZXh0O1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNi5hYnJ1cHQoJ3JldHVybicsIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBibG9ja2VkUGlkcyxcbiAgICAgICAgICAgICAgICBuZXh0OiBuZXdOZXh0XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlMTYsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIHF1ZXJ5QmxvY2tlZE1lbWJlcnMoKSB7XG4gICAgICByZXR1cm4gX3JlZjI5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXJ5QmxvY2tlZE1lbWJlcnM7XG4gIH0oKTtcblxuICAvKipcbiAgICog6I635Y+W5omA5pyJ5oiQ5ZGY55qE5a+56K+d5bGe5oCnXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAcmV0dXJuIHtQcm9taXNlLjxDb252ZXJzYXRpb25NZW1iZXJJbmZvW10+fSDmiYDmnInmiJDlkZjnmoTlr7nor53lsZ7mgKfliJfooahcbiAgICovXG5cblxuICBQZXJzaXN0ZW50Q29udmVyc2F0aW9uLnByb3RvdHlwZS5nZXRBbGxNZW1iZXJJbmZvID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmMzIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE3KCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciByZXNwb25zZSwgbWVtYmVySW5mb3MsIG1lbWJlckluZm9NYXA7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMTckKF9jb250ZXh0MTcpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTcucHJldiA9IF9jb250ZXh0MTcubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDE3Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50Ll9yZXF1ZXN0V2l0aFNlc3Npb25Ub2tlbih7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBwYXRoOiAnL2NsYXNzZXMvX0NvbnZlcnNhdGlvbk1lbWJlckluZm8nLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICB3aGVyZTogeyBjaWQ6IHRoaXMuaWQgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dDE3LnNlbnQ7XG4gICAgICAgICAgICAgIG1lbWJlckluZm9zID0gcmVzcG9uc2UucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnZlcnNhdGlvbk1lbWJlckluZm8oe1xuICAgICAgICAgICAgICAgICAgY29udmVyc2F0aW9uOiBfdGhpczUsXG4gICAgICAgICAgICAgICAgICBtZW1iZXJJZDogaW5mby5jbGllbnRJZCxcbiAgICAgICAgICAgICAgICAgIHJvbGU6IGluZm8ucm9sZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbWVtYmVySW5mb01hcCA9IHt9O1xuXG4gICAgICAgICAgICAgIG1lbWJlckluZm9zLmZvckVhY2goZnVuY3Rpb24gKG1lbWJlckluZm8pIHtcbiAgICAgICAgICAgICAgICBtZW1iZXJJbmZvTWFwW21lbWJlckluZm8ubWVtYmVySWRdID0gbWVtYmVySW5mbztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRoaXMubWVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChtZW1iZXJJZCkge1xuICAgICAgICAgICAgICAgIG1lbWJlckluZm9NYXBbbWVtYmVySWRdID0gbmV3IENvbnZlcnNhdGlvbk1lbWJlckluZm8oe1xuICAgICAgICAgICAgICAgICAgY29udmVyc2F0aW9uOiBfdGhpczUsXG4gICAgICAgICAgICAgICAgICBtZW1iZXJJZDogbWVtYmVySWQsXG4gICAgICAgICAgICAgICAgICByb2xlOiBDb252ZXJzYXRpb25NZW1iZXJSb2xlLk1FTUJFUlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaW50ZXJuYWwodGhpcykubWVtYmVySW5mb01hcCA9IG1lbWJlckluZm9NYXA7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LmFicnVwdCgncmV0dXJuJywgdGhpcy5tZW1iZXJzLm1hcChmdW5jdGlvbiAobWVtYmVySWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVtYmVySW5mb01hcFttZW1iZXJJZF07XG4gICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTcuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTE3LCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBnZXRBbGxNZW1iZXJJbmZvKCkge1xuICAgICAgcmV0dXJuIF9yZWYzMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRBbGxNZW1iZXJJbmZvO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIOiOt+WPluaMh+WumuaIkOWRmOeahOWvueivneWxnuaAp1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQHJldHVybiB7UHJvbWlzZS48Q29udmVyc2F0aW9uTWVtYmVySW5mbz59IOaMh+WumuaIkOWRmOeahOWvueivneWxnuaAp1xuICAgKi9cblxuXG4gIFBlcnNpc3RlbnRDb252ZXJzYXRpb24ucHJvdG90eXBlLmdldE1lbWJlckluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYzMyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMTgobWVtYmVySWQpIHtcbiAgICAgIHZhciBfaW50ZXJuYWwzLCBtZW1iZXJJbmZvTWFwO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMTgkKF9jb250ZXh0MTgpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTgucHJldiA9IF9jb250ZXh0MTgubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoISh0aGlzLm1lbWJlcnMuaW5kZXhPZihtZW1iZXJJZCkgPT09IC0xKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTgubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVtYmVySWQgKyAnIGlzIG5vdCB0aGUgbXVtYmVyIG9mIGNvbnZlcnNhdGlvblsnICsgdGhpcy5pZCArICddJyk7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgX2ludGVybmFsMyA9IGludGVybmFsKHRoaXMpLCBtZW1iZXJJbmZvTWFwID0gX2ludGVybmFsMy5tZW1iZXJJbmZvTWFwO1xuXG4gICAgICAgICAgICAgIGlmIChtZW1iZXJJbmZvTWFwICYmIG1lbWJlckluZm9NYXBbbWVtYmVySWRdKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxOC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9jb250ZXh0MTgubmV4dCA9IDY7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFsbE1lbWJlckluZm8oKTtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOC5hYnJ1cHQoJ3JldHVybicsIGludGVybmFsKHRoaXMpLm1lbWJlckluZm9NYXBbbWVtYmVySWRdKTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTguc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTE4LCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBnZXRNZW1iZXJJbmZvKF94MTUpIHtcbiAgICAgIHJldHVybiBfcmVmMzMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0TWVtYmVySW5mbztcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiDmm7TmlrDmjIflrprnlKjmiLfnmoTop5LoibJcbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZW1iZXJJZCDmiJDlkZggSWRcbiAgICogQHBhcmFtIHttb2R1bGU6bGVhbmNsb3VkLXJlYWx0aW1lLkNvbnZlcnNhdGlvbk1lbWJlclJvbGUgfCBTdHJpbmd9IHJvbGUg6KeS6ImyXG4gICAqIEByZXR1cm4ge1Byb21pc2UuPHRoaXM+fSBzZWxmXG4gICAqL1xuXG5cbiAgUGVyc2lzdGVudENvbnZlcnNhdGlvbi5wcm90b3R5cGUudXBkYXRlTWVtYmVyUm9sZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjM0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxOShtZW1iZXJJZCwgcm9sZSkge1xuICAgICAgdmFyIF9pbnRlcm5hbDQsIG1lbWJlckluZm9zO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMTkkKF9jb250ZXh0MTkpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTkucHJldiA9IF9jb250ZXh0MTkubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnbXV0ZScpO1xuICAgICAgICAgICAgICBfY29udGV4dDE5Lm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VuZChuZXcgR2VuZXJpY0NvbW1hbmQoe1xuICAgICAgICAgICAgICAgIG9wOiBPcFR5cGUubWVtYmVyX2luZm9fdXBkYXRlLFxuICAgICAgICAgICAgICAgIGNvbnZNZXNzYWdlOiBuZXcgQ29udkNvbW1hbmQoe1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2xpZW50SWQ6IG1lbWJlcklkLFxuICAgICAgICAgICAgICAgICAgaW5mbzogbmV3IENvbnZNZW1iZXJJbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgcGlkOiBtZW1iZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogcm9sZVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgX2ludGVybmFsNCA9IGludGVybmFsKHRoaXMpLCBtZW1iZXJJbmZvcyA9IF9pbnRlcm5hbDQubWVtYmVySW5mb3M7XG5cbiAgICAgICAgICAgICAgaWYgKG1lbWJlckluZm9zICYmIG1lbWJlckluZm9zW21lbWJlcklkXSkge1xuICAgICAgICAgICAgICAgIGludGVybmFsKG1lbWJlckluZm9zW21lbWJlcklkXSkucm9sZSA9IHJvbGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTkuYWJydXB0KCdyZXR1cm4nLCB0aGlzKTtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTkuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTE5LCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVNZW1iZXJSb2xlKF94MTYsIF94MTcpIHtcbiAgICAgIHJldHVybiBfcmVmMzQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlTWVtYmVyUm9sZTtcbiAgfSgpO1xuXG4gIFBlcnNpc3RlbnRDb252ZXJzYXRpb24ucHJvdG90eXBlLnRvRnVsbEpTT04gPSBmdW5jdGlvbiB0b0Z1bGxKU09OKCkge1xuICAgIHZhciBjcmVhdG9yID0gdGhpcy5jcmVhdG9yLFxuICAgICAgICBzeXN0ZW0gPSB0aGlzLnN5c3RlbSxcbiAgICAgICAgdHJhbnNpZW50ID0gdGhpcy50cmFuc2llbnQsXG4gICAgICAgIGNyZWF0ZWRBdCA9IHRoaXMuY3JlYXRlZEF0LFxuICAgICAgICB1cGRhdGVkQXQgPSB0aGlzLnVwZGF0ZWRBdCxcbiAgICAgICAgX2F0dHJpYnV0ZXMgPSB0aGlzLl9hdHRyaWJ1dGVzO1xuXG4gICAgcmV0dXJuIF9leHRlbmRzJDEoe30sIF9Db252ZXJzYXRpb25CYXNlLnByb3RvdHlwZS50b0Z1bGxKU09OLmNhbGwodGhpcyksIHtcbiAgICAgIGNyZWF0b3I6IGNyZWF0b3IsXG4gICAgICBzeXN0ZW06IHN5c3RlbSxcbiAgICAgIHRyYW5zaWVudDogdHJhbnNpZW50LFxuICAgICAgY3JlYXRlZEF0OiBnZXRUaW1lKGNyZWF0ZWRBdCksXG4gICAgICB1cGRhdGVkQXQ6IGdldFRpbWUodXBkYXRlZEF0KVxuICAgIH0sIF9hdHRyaWJ1dGVzKTtcbiAgfTtcblxuICBQZXJzaXN0ZW50Q29udmVyc2F0aW9uLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgdmFyIGNyZWF0b3IgPSB0aGlzLmNyZWF0b3IsXG4gICAgICAgIHN5c3RlbSA9IHRoaXMuc3lzdGVtLFxuICAgICAgICB0cmFuc2llbnQgPSB0aGlzLnRyYW5zaWVudCxcbiAgICAgICAgbXV0ZWQgPSB0aGlzLm11dGVkLFxuICAgICAgICBtdXRlZE1lbWJlcnMgPSB0aGlzLm11dGVkTWVtYmVycyxcbiAgICAgICAgY3JlYXRlZEF0ID0gdGhpcy5jcmVhdGVkQXQsXG4gICAgICAgIHVwZGF0ZWRBdCA9IHRoaXMudXBkYXRlZEF0LFxuICAgICAgICBfYXR0cmlidXRlcyA9IHRoaXMuX2F0dHJpYnV0ZXM7XG5cbiAgICByZXR1cm4gX2V4dGVuZHMkMSh7fSwgX0NvbnZlcnNhdGlvbkJhc2UucHJvdG90eXBlLnRvSlNPTi5jYWxsKHRoaXMpLCB7XG4gICAgICBjcmVhdG9yOiBjcmVhdG9yLFxuICAgICAgc3lzdGVtOiBzeXN0ZW0sXG4gICAgICB0cmFuc2llbnQ6IHRyYW5zaWVudCxcbiAgICAgIG11dGVkOiBtdXRlZCxcbiAgICAgIG11dGVkTWVtYmVyczogbXV0ZWRNZW1iZXJzLFxuICAgICAgY3JlYXRlZEF0OiBjcmVhdGVkQXQsXG4gICAgICB1cGRhdGVkQXQ6IHVwZGF0ZWRBdFxuICAgIH0sIF9hdHRyaWJ1dGVzKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoUGVyc2lzdGVudENvbnZlcnNhdGlvbiwgW3tcbiAgICBrZXk6ICdjcmVhdGVkQXQnLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl9jcmVhdGVkQXQgPSBkZWNvZGVEYXRlKHZhbHVlKTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZWRBdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVkQXQnLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl91cGRhdGVkQXQgPSBkZWNvZGVEYXRlKHZhbHVlKTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZWRBdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlr7nor53lkI3lrZfvvIzlr7nlupQgX0NvbnZlcnNhdGlvbiDooajkuK3nmoQgbmFtZVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ25hbWUnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KCduYW1lJyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5zZXQoJ25hbWUnLCB2YWx1ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBlcnNpc3RlbnRDb252ZXJzYXRpb247XG59KENvbnZlcnNhdGlvbkJhc2UpO1xuXG4vKipcbiAqIOaZrumAmuWvueivnVxuICpcbiAqIOaXoOazleebtOaOpeWunuS+i+WMlu+8jOivt+S9v+eUqCB7QGxpbmsgSU1DbGllbnQjY3JlYXRlQ29udmVyc2F0aW9ufSDliJvlu7rmlrDnmoTmma7pgJrlr7nor53jgIJcbiAqIEBleHRlbmRzIFBlcnNpc3RlbnRDb252ZXJzYXRpb25cbiAqIEBwdWJsaWNcbiAqL1xuXG52YXIgQ29udmVyc2F0aW9uID0gZnVuY3Rpb24gKF9QZXJzaXN0ZW50Q29udmVyc2F0aSkge1xuICBfaW5oZXJpdHMoQ29udmVyc2F0aW9uLCBfUGVyc2lzdGVudENvbnZlcnNhdGkpO1xuXG4gIGZ1bmN0aW9uIENvbnZlcnNhdGlvbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29udmVyc2F0aW9uKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUGVyc2lzdGVudENvbnZlcnNhdGkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICByZXR1cm4gQ29udmVyc2F0aW9uO1xufShQZXJzaXN0ZW50Q29udmVyc2F0aW9uKTtcblxuLyoqXG4gKiDogYrlpKnlrqTjgIJcbiAqXG4gKiDml6Dms5Xnm7TmjqXlrp7kvovljJbvvIzor7fkvb/nlKgge0BsaW5rIElNQ2xpZW50I2NyZWF0ZUNoYXRSb29tfSDliJvlu7rmlrDnmoTogYrlpKnlrqTjgIJcbiAqIEBzaW5jZSA0LjAuMFxuICogQGV4dGVuZHMgUGVyc2lzdGVudENvbnZlcnNhdGlvblxuICogQHB1YmxpY1xuICovXG5cbnZhciBDaGF0Um9vbSA9IGZ1bmN0aW9uIChfUGVyc2lzdGVudENvbnZlcnNhdGkpIHtcbiAgX2luaGVyaXRzKENoYXRSb29tLCBfUGVyc2lzdGVudENvbnZlcnNhdGkpO1xuXG4gIGZ1bmN0aW9uIENoYXRSb29tKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaGF0Um9vbSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1BlcnNpc3RlbnRDb252ZXJzYXRpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIENoYXRSb29tO1xufShQZXJzaXN0ZW50Q29udmVyc2F0aW9uKTtcblxuLyoqXG4gKiDmnI3liqHlj7fjgIJcbiAqXG4gKiDmnI3liqHlj7fkuI3mlK/mjIHlnKjlrqLmiLfnq6/liJvlu7rjgIJcbiAqIEBzaW5jZSA0LjAuMFxuICogQGV4dGVuZHMgUGVyc2lzdGVudENvbnZlcnNhdGlvblxuICogQHB1YmxpY1xuICovXG5cbnZhciBTZXJ2aWNlQ29udmVyc2F0aW9uID0gZnVuY3Rpb24gKF9QZXJzaXN0ZW50Q29udmVyc2F0aSkge1xuICBfaW5oZXJpdHMoU2VydmljZUNvbnZlcnNhdGlvbiwgX1BlcnNpc3RlbnRDb252ZXJzYXRpKTtcblxuICBmdW5jdGlvbiBTZXJ2aWNlQ29udmVyc2F0aW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZXJ2aWNlQ29udmVyc2F0aW9uKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUGVyc2lzdGVudENvbnZlcnNhdGkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICAvKipcbiAgICog6K6i6ZiF6K+l5pyN5Yqh5Y+3XG4gICAqIEByZXR1cm4ge1Byb21pc2UuPHRoaXM+fSBzZWxmXG4gICAqL1xuICBTZXJ2aWNlQ29udmVyc2F0aW9uLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCB0aGlzLmpvaW4oKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBzdWJzY3JpYmUoKSB7XG4gICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzY3JpYmU7XG4gIH0oKTtcblxuICAvKipcbiAgICog6YCA6K6i6K+l5pyN5Yqh5Y+3XG4gICAqIEByZXR1cm4ge1Byb21pc2UuPHRoaXM+fSBzZWxmXG4gICAqL1xuXG5cbiAgU2VydmljZUNvbnZlcnNhdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdCgncmV0dXJuJywgdGhpcy5xdWl0KCkpO1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgfSgpO1xuXG4gIHJldHVybiBTZXJ2aWNlQ29udmVyc2F0aW9uO1xufShQZXJzaXN0ZW50Q29udmVyc2F0aW9uKTtcblxudmFyIHRyYW5zZm9ybU5vdEZvdW5kRXJyb3IgPSBmdW5jdGlvbiB0cmFuc2Zvcm1Ob3RGb3VuZEVycm9yKGVycm9yJCQxKSB7XG4gIHJldHVybiBlcnJvciQkMS5jb2RlID09PSBFcnJvckNvZGUuQ09OVkVSU0FUSU9OX05PVF9GT1VORCA/IGNyZWF0ZUVycm9yJDEoeyBjb2RlOiBFcnJvckNvZGUuVEVNUE9SQVJZX0NPTlZFUlNBVElPTl9FWFBJUkVEIH0pIDogZXJyb3IkJDE7XG59O1xuXG4vKipcbiAqIOS4tOaXtuWvueivnVxuICogQHNpbmNlIDQuMC4wXG4gKiBAZXh0ZW5kcyBDb252ZXJzYXRpb25CYXNlXG4gKiBAcHVibGljXG4gKi9cblxudmFyIFRlbXBvcmFyeUNvbnZlcnNhdGlvbiA9IGZ1bmN0aW9uIChfQ29udmVyc2F0aW9uQmFzZSkge1xuICBfaW5oZXJpdHMoVGVtcG9yYXJ5Q29udmVyc2F0aW9uLCBfQ29udmVyc2F0aW9uQmFzZSk7XG5cbiAgLyoqXG4gICAqIOaXoOazleebtOaOpeWunuS+i+WMlu+8jOivt+S9v+eUqCB7QGxpbmsgSU1DbGllbnQjY3JlYXRlVGVtcG9yYXJ5Q29udmVyc2F0aW9ufSDliJvlu7rmlrDnmoTkuLTml7blr7nor53jgIJcbiAgICovXG4gIGZ1bmN0aW9uIFRlbXBvcmFyeUNvbnZlcnNhdGlvbihkYXRhLCBfcmVmLCBjbGllbnQpIHtcbiAgICB2YXIgZXhwaXJlZEF0ID0gX3JlZi5leHBpcmVkQXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGVtcG9yYXJ5Q29udmVyc2F0aW9uKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29udmVyc2F0aW9uQmFzZS5jYWxsKHRoaXMsIF9leHRlbmRzJDEoe30sIGRhdGEsIHtcbiAgICAgIGV4cGlyZWRBdDogZXhwaXJlZEF0XG4gICAgfSksIGNsaWVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIOWvueivneWkseaViOaXtumXtFxuICAgKiBAdHlwZSB7RGF0ZX1cbiAgICovXG5cblxuICBUZW1wb3JhcnlDb252ZXJzYXRpb24ucHJvdG90eXBlLl9zZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgdmFyIF9Db252ZXJzYXRpb25CYXNlJHBybyxcbiAgICAgICAgICBfbGVuLFxuICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgX2tleSxcbiAgICAgICAgICBfYXJncyA9IGFyZ3VtZW50cztcblxuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGlmICghdGhpcy5leHBpcmVkKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvciQxKHsgY29kZTogRXJyb3JDb2RlLlRFTVBPUkFSWV9DT05WRVJTQVRJT05fRVhQSVJFRCB9KTtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjtcblxuICAgICAgICAgICAgICBmb3IgKF9sZW4gPSBfYXJncy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gX2FyZ3NbX2tleV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgcmV0dXJuIChfQ29udmVyc2F0aW9uQmFzZSRwcm8gPSBfQ29udmVyc2F0aW9uQmFzZS5wcm90b3R5cGUuX3NlbmQpLmNhbGwuYXBwbHkoX0NvbnZlcnNhdGlvbkJhc2UkcHJvLCBbdGhpc10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhcmdzKSkpO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIF9jb250ZXh0LnNlbnQpO1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA5O1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0WydjYXRjaCddKDIpO1xuICAgICAgICAgICAgICB0aHJvdyB0cmFuc2Zvcm1Ob3RGb3VuZEVycm9yKF9jb250ZXh0LnQwKTtcblxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzIsIDldXSk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gX3NlbmQoKSB7XG4gICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3NlbmQ7XG4gIH0oKTtcblxuICBUZW1wb3JhcnlDb252ZXJzYXRpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgdmFyIF9Db252ZXJzYXRpb25CYXNlJHBybzIsXG4gICAgICAgICAgX2xlbjIsXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgICBfa2V5MixcbiAgICAgICAgICBfYXJnczIgPSBhcmd1bWVudHM7XG5cbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAwO1xuXG4gICAgICAgICAgICAgIGZvciAoX2xlbjIgPSBfYXJnczIubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXkyXSA9IF9hcmdzMltfa2V5Ml07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIHJldHVybiAoX0NvbnZlcnNhdGlvbkJhc2UkcHJvMiA9IF9Db252ZXJzYXRpb25CYXNlLnByb3RvdHlwZS5zZW5kKS5jYWxsLmFwcGx5KF9Db252ZXJzYXRpb25CYXNlJHBybzIsIFt0aGlzXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKSk7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoJ3JldHVybicsIF9jb250ZXh0Mi5zZW50KTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDc7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MlsnY2F0Y2gnXSgwKTtcbiAgICAgICAgICAgICAgdGhyb3cgdHJhbnNmb3JtTm90Rm91bmRFcnJvcihfY29udGV4dDIudDApO1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1swLCA3XV0pO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAgICByZXR1cm4gX3JlZjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VuZDtcbiAgfSgpO1xuXG4gIFRlbXBvcmFyeUNvbnZlcnNhdGlvbi5wcm90b3R5cGUudG9GdWxsSlNPTiA9IGZ1bmN0aW9uIHRvRnVsbEpTT04oKSB7XG4gICAgdmFyIGV4cGlyZWRBdCA9IHRoaXMuZXhwaXJlZEF0O1xuXG4gICAgcmV0dXJuIF9leHRlbmRzJDEoe30sIF9Db252ZXJzYXRpb25CYXNlLnByb3RvdHlwZS50b0Z1bGxKU09OLmNhbGwodGhpcyksIHtcbiAgICAgIGV4cGlyZWRBdDogZ2V0VGltZShleHBpcmVkQXQpXG4gICAgfSk7XG4gIH07XG5cbiAgVGVtcG9yYXJ5Q29udmVyc2F0aW9uLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgdmFyIGV4cGlyZWRBdCA9IHRoaXMuZXhwaXJlZEF0LFxuICAgICAgICBleHBpcmVkID0gdGhpcy5leHBpcmVkO1xuXG4gICAgcmV0dXJuIF9leHRlbmRzJDEoe30sIF9Db252ZXJzYXRpb25CYXNlLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzKSwge1xuICAgICAgZXhwaXJlZEF0OiBleHBpcmVkQXQsXG4gICAgICBleHBpcmVkOiBleHBpcmVkXG4gICAgfSk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFRlbXBvcmFyeUNvbnZlcnNhdGlvbiwgW3tcbiAgICBrZXk6ICdleHBpcmVkQXQnLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLl9leHBpcmVkQXQgPSBkZWNvZGVEYXRlKHZhbHVlKTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2V4cGlyZWRBdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlr7nor53mmK/lkKblt7LlpLHmlYhcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZXhwaXJlZCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5leHBpcmVkQXQgPCBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUZW1wb3JhcnlDb252ZXJzYXRpb247XG59KENvbnZlcnNhdGlvbkJhc2UpO1xuXG52YXIgZGVidWckOCA9IGJyb3dzZXIoJ0xDOkNvbnZlcnNhdGlvblF1ZXJ5Jyk7XG5cbnZhciBDb252ZXJzYXRpb25RdWVyeSA9IGZ1bmN0aW9uICgpIHtcbiAgQ29udmVyc2F0aW9uUXVlcnkuX2VuY29kZSA9IGZ1bmN0aW9uIF9lbmNvZGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4geyBfX3R5cGU6ICdEYXRlJywgaXNvOiB2YWx1ZS50b0pTT04oKSB9O1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiB2YWx1ZS5zb3VyY2U7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBDb252ZXJzYXRpb25RdWVyeS5fcXVvdGUgPSBmdW5jdGlvbiBfcXVvdGUocykge1xuICAgIHJldHVybiAnXFxcXFEnICsgcy5yZXBsYWNlKCdcXFxcRScsICdcXFxcRVxcXFxcXFxcRVxcXFxRJykgKyAnXFxcXEUnO1xuICB9O1xuXG4gIENvbnZlcnNhdGlvblF1ZXJ5Ll9jYWxjdWxhdGVGbGFnID0gZnVuY3Rpb24gX2NhbGN1bGF0ZUZsYWcob3B0aW9ucykge1xuICAgIHJldHVybiBbJ3dpdGhMYXN0TWVzc2FnZXNSZWZyZXNoZWQnLCAnY29tcGFjdCddLnJlZHVjZShcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIGZ1bmN0aW9uIChwcmV2LCBrZXkpIHtcbiAgICAgIHJldHVybiAocHJldiA8PCAxKSArIEJvb2xlYW4ob3B0aW9uc1trZXldKTtcbiAgICB9LCAwKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgQ29udmVyc2F0aW9uUXVlcnlcbiAgICogQHBhcmFtICB7SU1DbGllbnR9IGNsaWVudFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIENvbnZlcnNhdGlvblF1ZXJ5KGNsaWVudCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb252ZXJzYXRpb25RdWVyeSk7XG5cbiAgICB0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5fd2hlcmUgPSB7fTtcbiAgICB0aGlzLl9leHRyYU9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIENvbnZlcnNhdGlvblF1ZXJ5LnByb3RvdHlwZS5fYWRkQ29uZGl0aW9uID0gZnVuY3Rpb24gX2FkZENvbmRpdGlvbihrZXksIGNvbmRpdGlvbiwgdmFsdWUpIHtcbiAgICAvLyBDaGVjayBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBjb25kaXRpb25cbiAgICBpZiAoIXRoaXMuX3doZXJlW2tleV0pIHtcbiAgICAgIHRoaXMuX3doZXJlW2tleV0gPSB7fTtcbiAgICB9XG4gICAgdGhpcy5fd2hlcmVba2V5XVtjb25kaXRpb25dID0gdGhpcy5jb25zdHJ1Y3Rvci5fZW5jb2RlKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBDb252ZXJzYXRpb25RdWVyeS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHZhciBqc29uID0ge1xuICAgICAgd2hlcmU6IHRoaXMuX3doZXJlLFxuICAgICAgZmxhZzogdGhpcy5jb25zdHJ1Y3Rvci5fY2FsY3VsYXRlRmxhZyh0aGlzLl9leHRyYU9wdGlvbnMpXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIHRoaXMuX3NraXAgIT09ICd1bmRlZmluZWQnKSBqc29uLnNraXAgPSB0aGlzLl9za2lwO1xuICAgIGlmICh0eXBlb2YgdGhpcy5fbGltaXQgIT09ICd1bmRlZmluZWQnKSBqc29uLmxpbWl0ID0gdGhpcy5fbGltaXQ7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9vcmRlciAhPT0gJ3VuZGVmaW5lZCcpIGpzb24uc29ydCA9IHRoaXMuX29yZGVyO1xuICAgIGRlYnVnJDgoanNvbik7XG4gICAgcmV0dXJuIGpzb247XG4gIH07XG5cbiAgLyoqXG4gICAqIOWinuWKoOafpeivouadoeS7tu+8jOaMh+WumuiBiuWkqeWupOeahOe7hOWRmOWMheWQq+afkOS6m+aIkOWRmOWNs+WPr+i/lOWbnlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwZWVySWRzIC0g5oiQ5ZGYIElEIOWIl+ihqFxuICAgKiBAcmV0dXJuIHtDb252ZXJzYXRpb25RdWVyeX0gc2VsZlxuICAgKi9cblxuXG4gIENvbnZlcnNhdGlvblF1ZXJ5LnByb3RvdHlwZS5jb250YWluc01lbWJlcnMgPSBmdW5jdGlvbiBjb250YWluc01lbWJlcnMocGVlcklkcykge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5zQWxsKCdtJywgcGVlcklkcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIOWinuWKoOafpeivouadoeS7tu+8jOaMh+WumuiBiuWkqeWupOeahOe7hOWRmOadoeS7tua7oei2s+adoeS7tueahOaJjei/lOWbnlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSAtIOaIkOWRmCBJRCDliJfooahcbiAgICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRlU2VsZiAtIOaYr+WQpuWMheWQq+iHquW3sVxuICAgKiBAcmV0dXJuIHtDb252ZXJzYXRpb25RdWVyeX0gc2VsZlxuICAgKi9cblxuXG4gIENvbnZlcnNhdGlvblF1ZXJ5LnByb3RvdHlwZS53aXRoTWVtYmVycyA9IGZ1bmN0aW9uIHdpdGhNZW1iZXJzKHBlZXJJZHMsIGluY2x1ZGVTZWxmKSB7XG4gICAgdmFyIHBlZXJJZHNTZXQgPSBuZXcgX1NldChwZWVySWRzKTtcbiAgICBpZiAoaW5jbHVkZVNlbGYpIHtcbiAgICAgIHBlZXJJZHNTZXQuYWRkKHRoaXMuX2NsaWVudC5pZCk7XG4gICAgfVxuICAgIHRoaXMuc2l6ZUVxdWFsVG8oJ20nLCBwZWVySWRzU2V0LnNpemUpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5zTWVtYmVycyhfQXJyYXkkZnJvbShwZWVySWRzU2V0KSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIOWinuWKoOafpeivouadoeS7tu+8jOW9kyBjb252ZXJzYXRpb24g55qE5bGe5oCn5Lit5a+55bqU55qE5a2X5q615ruh6Laz562J5LqO5p2h5Lu25pe25Y2z5Y+v6L+U5ZueXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEByZXR1cm4ge0NvbnZlcnNhdGlvblF1ZXJ5fSBzZWxmXG4gICAqL1xuXG5cbiAgQ29udmVyc2F0aW9uUXVlcnkucHJvdG90eXBlLmVxdWFsVG8gPSBmdW5jdGlvbiBlcXVhbFRvKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl93aGVyZVtrZXldID0gdGhpcy5jb25zdHJ1Y3Rvci5fZW5jb2RlKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICog5aKe5Yqg5p+l6K+i5p2h5Lu277yM5b2TIGNvbnZlcnNhdGlvbiDnmoTlsZ7mgKfkuK3lr7nlupTnmoTlrZfmrrXmu6HotrPlsI/kuo7mnaHku7bml7bljbPlj6/ov5Tlm55cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHJldHVybiB7Q29udmVyc2F0aW9uUXVlcnl9IHNlbGZcbiAgICovXG5cblxuICBDb252ZXJzYXRpb25RdWVyeS5wcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENvbmRpdGlvbihrZXksICckbHQnLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIOWinuWKoOafpeivouadoeS7tu+8jOW9kyBjb252ZXJzYXRpb24g55qE5bGe5oCn5Lit5a+55bqU55qE5a2X5q615ruh6Laz5bCP5LqO562J5LqO5p2h5Lu25pe25Y2z5Y+v6L+U5ZueXG4gICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtDb252ZXJzYXRpb25RdWVyeX0gc2VsZlxuICAgKi9cblxuXG4gIENvbnZlcnNhdGlvblF1ZXJ5LnByb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWxUbyA9IGZ1bmN0aW9uIGxlc3NUaGFuT3JFcXVhbFRvKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ29uZGl0aW9uKGtleSwgJyRsdGUnLCB2YWx1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIOWinuWKoOafpeivouadoeS7tu+8jOW9kyBjb252ZXJzYXRpb24g55qE5bGe5oCn5Lit5a+55bqU55qE5a2X5q615ruh6Laz5aSn5LqO5p2h5Lu25pe25Y2z5Y+v6L+U5ZueXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEByZXR1cm4ge0NvbnZlcnNhdGlvblF1ZXJ5fSBzZWxmXG4gICAqL1xuXG4gIENvbnZlcnNhdGlvblF1ZXJ5LnByb3RvdHlwZS5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ29uZGl0aW9uKGtleSwgJyRndCcsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICog5aKe5Yqg5p+l6K+i5p2h5Lu277yM5b2TIGNvbnZlcnNhdGlvbiDnmoTlsZ7mgKfkuK3lr7nlupTnmoTlrZfmrrXmu6HotrPlpKfkuo7nrYnkuo7mnaHku7bml7bljbPlj6/ov5Tlm55cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHJldHVybiB7Q29udmVyc2F0aW9uUXVlcnl9IHNlbGZcbiAgICovXG5cbiAgQ29udmVyc2F0aW9uUXVlcnkucHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbFRvID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsVG8oa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDb25kaXRpb24oa2V5LCAnJGd0ZScsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICog5aKe5Yqg5p+l6K+i5p2h5Lu277yM5b2TIGNvbnZlcnNhdGlvbiDnmoTlsZ7mgKfkuK3lr7nlupTnmoTlrZfmrrXmu6HotrPkuI3nrYnkuo7mnaHku7bml7bljbPlj6/ov5Tlm55cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogQHJldHVybiB7Q29udmVyc2F0aW9uUXVlcnl9IHNlbGZcbiAgICovXG5cblxuICBDb252ZXJzYXRpb25RdWVyeS5wcm90b3R5cGUubm90RXF1YWxUbyA9IGZ1bmN0aW9uIG5vdEVxdWFsVG8oa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDb25kaXRpb24oa2V5LCAnJG5lJywgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiDlop7liqDmn6Xor6LmnaHku7bvvIzlvZMgY29udmVyc2F0aW9uIOWtmOWcqOaMh+WumueahOWtl+auteaXtuWNs+WPr+i/lOWbnlxuICAgKlxuICAgKiBAc2luY2UgMy41LjBcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcmV0dXJuIHtDb252ZXJzYXRpb25RdWVyeX0gc2VsZlxuICAgKi9cblxuXG4gIENvbnZlcnNhdGlvblF1ZXJ5LnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbiBleGlzdHMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENvbmRpdGlvbihrZXksICckZXhpc3RzJywgdHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIOWinuWKoOafpeivouadoeS7tu+8jOW9kyBjb252ZXJzYXRpb24g5LiN5a2Y5Zyo5oyH5a6a55qE5a2X5q615pe25Y2z5Y+v6L+U5ZueXG4gICAqXG4gICAqIEBzaW5jZSAzLjUuMFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge0NvbnZlcnNhdGlvblF1ZXJ5fSBzZWxmXG4gICAqL1xuXG5cbiAgQ29udmVyc2F0aW9uUXVlcnkucHJvdG90eXBlLmRvZXNOb3RFeGlzdCA9IGZ1bmN0aW9uIGRvZXNOb3RFeGlzdChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ29uZGl0aW9uKGtleSwgJyRleGlzdHMnLCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIOWinuWKoOafpeivouadoeS7tu+8jOW9kyBjb252ZXJzYXRpb24g55qE5bGe5oCn5Lit5a+55bqU55qE5a2X5q615a+55bqU55qE5YC85YyF5ZCr5Zyo5oyH5a6a5YC85Lit5pe25Y2z5Y+v6L+U5ZueXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHZhbHVlc1xuICAgKiBAcmV0dXJuIHtDb252ZXJzYXRpb25RdWVyeX0gc2VsZlxuICAgKi9cblxuXG4gIENvbnZlcnNhdGlvblF1ZXJ5LnByb3RvdHlwZS5jb250YWluZWRJbiA9IGZ1bmN0aW9uIGNvbnRhaW5lZEluKGtleSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENvbmRpdGlvbihrZXksICckaW4nLCB2YWx1ZXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiDlop7liqDmn6Xor6LmnaHku7bvvIzlvZMgY29udmVyc2F0aW9uIOeahOWxnuaAp+S4reWvueW6lOeahOWtl+auteWvueW6lOeahOWAvOS4jeWMheWQq+WcqOaMh+WumuWAvOS4reaXtuWNs+WPr+i/lOWbnlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB2YWx1ZXNcbiAgICogQHJldHVybiB7Q29udmVyc2F0aW9uUXVlcnl9IHNlbGZcbiAgICovXG5cblxuICBDb252ZXJzYXRpb25RdWVyeS5wcm90b3R5cGUubm90Q29udGFpbnNJbiA9IGZ1bmN0aW9uIG5vdENvbnRhaW5zSW4oa2V5LCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ29uZGl0aW9uKGtleSwgJyRuaW4nLCB2YWx1ZXMpO1xuICB9O1xuICAvKipcbiAgICog5aKe5Yqg5p+l6K+i5p2h5Lu277yM5b2TY29udmVyc2F0aW9u55qE5bGe5oCn5Lit5a+55bqU55qE5a2X5q615Lit55qE5YWD57Sg5YyF5ZCr5omA5pyJ55qE5YC85omN5Y+v6L+U5ZueXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHZhbHVlc1xuICAgKiBAcmV0dXJuIHtDb252ZXJzYXRpb25RdWVyeX0gc2VsZlxuICAgKi9cblxuXG4gIENvbnZlcnNhdGlvblF1ZXJ5LnByb3RvdHlwZS5jb250YWluc0FsbCA9IGZ1bmN0aW9uIGNvbnRhaW5zQWxsKGtleSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENvbmRpdGlvbihrZXksICckYWxsJywgdmFsdWVzKTtcbiAgfTtcblxuICAvKipcbiAgICog5aKe5Yqg5p+l6K+i5p2h5Lu277yM5b2TIGNvbnZlcnNhdGlvbiDnmoTlsZ7mgKfkuK3lr7nlupTnmoTlrZfmrrXlr7nlupTnmoTlgLzljIXlkKvmraTlrZfnrKbkuLLljbPlj6/ov5Tlm55cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViU3RyaW5nXG4gICAqIEByZXR1cm4ge0NvbnZlcnNhdGlvblF1ZXJ5fSBzZWxmXG4gICAqL1xuXG5cbiAgQ29udmVyc2F0aW9uUXVlcnkucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMoa2V5LCBzdWJTdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ29uZGl0aW9uKGtleSwgJyRyZWdleCcsIENvbnZlcnNhdGlvblF1ZXJ5Ll9xdW90ZShzdWJTdHJpbmcpKTtcbiAgfTtcblxuICAvKipcbiAgICog5aKe5Yqg5p+l6K+i5p2h5Lu277yM5b2TIGNvbnZlcnNhdGlvbiDnmoTlsZ7mgKfkuK3lr7nlupTnmoTlrZfmrrXlr7nlupTnmoTlgLzku6XmraTlrZfnrKbkuLLotbflp4vljbPlj6/ov5Tlm55cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4XG4gICAqIEByZXR1cm4ge0NvbnZlcnNhdGlvblF1ZXJ5fSBzZWxmXG4gICAqL1xuXG5cbiAgQ29udmVyc2F0aW9uUXVlcnkucHJvdG90eXBlLnN0YXJ0c1dpdGggPSBmdW5jdGlvbiBzdGFydHNXaXRoKGtleSwgcHJlZml4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENvbmRpdGlvbihrZXksICckcmVnZXgnLCAnXicgKyBDb252ZXJzYXRpb25RdWVyeS5fcXVvdGUocHJlZml4KSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIOWinuWKoOafpeivouadoeS7tu+8jOW9kyBjb252ZXJzYXRpb24g55qE5bGe5oCn5Lit5a+55bqU55qE5a2X5q615a+55bqU55qE5YC85Lul5q2k5a2X56ym5Liy57uT5p2f5Y2z5Y+v6L+U5ZueXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN1ZmZpeFxuICAgKiBAcmV0dXJuIHtDb252ZXJzYXRpb25RdWVyeX0gc2VsZlxuICAgKi9cblxuXG4gIENvbnZlcnNhdGlvblF1ZXJ5LnByb3RvdHlwZS5lbmRzV2l0aCA9IGZ1bmN0aW9uIGVuZHNXaXRoKGtleSwgc3VmZml4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENvbmRpdGlvbihrZXksICckcmVnZXgnLCBDb252ZXJzYXRpb25RdWVyeS5fcXVvdGUoc3VmZml4KSArICckJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIOWinuWKoOafpeivouadoeS7tu+8jOW9kyBjb252ZXJzYXRpb24g55qE5bGe5oCn5Lit5a+55bqU55qE5a2X5q615a+55bqU55qE5YC85ruh6Laz5o+Q5L6b55qE5q2j5YiZ6KGo6L6+5byP5Y2z5Y+v6L+U5ZueXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4XG4gICAqIEByZXR1cm4ge0NvbnZlcnNhdGlvblF1ZXJ5fSBzZWxmXG4gICAqL1xuXG5cbiAgQ29udmVyc2F0aW9uUXVlcnkucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiBtYXRjaGVzKGtleSwgcmVnZXgpIHtcbiAgICB0aGlzLl9hZGRDb25kaXRpb24oa2V5LCAnJHJlZ2V4JywgcmVnZXgpO1xuICAgIC8vIEphdmFzY3JpcHQgcmVnZXggb3B0aW9ucyBzdXBwb3J0IG1pZyBhcyBpbmxpbmUgb3B0aW9ucyBidXQgc3RvcmUgdGhlbVxuICAgIC8vIGFzIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdC4gV2Ugc3VwcG9ydCBtaSAmIHNob3VsZCBtaWdyYXRlIHRoZW0gdG9cbiAgICAvLyBtb2RpZmllcnNcbiAgICB2YXIgX21vZGlmaWVycyA9ICcnO1xuICAgIGlmIChyZWdleC5pZ25vcmVDYXNlKSB7XG4gICAgICBfbW9kaWZpZXJzICs9ICdpJztcbiAgICB9XG4gICAgaWYgKHJlZ2V4Lm11bHRpbGluZSkge1xuICAgICAgX21vZGlmaWVycyArPSAnbSc7XG4gICAgfVxuXG4gICAgaWYgKF9tb2RpZmllcnMgJiYgX21vZGlmaWVycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2FkZENvbmRpdGlvbihrZXksICckb3B0aW9ucycsIF9tb2RpZmllcnMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICog5re75Yqg5p+l6K+i57qm5p2f5p2h5Lu277yM5p+l5om+IGtleSDnsbvlnovmmK/mlbDnu4TvvIzor6XmlbDnu4TnmoTplb/luqbljLnphY3mj5DkvpvnmoTmlbDlgLxcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gICAqIEByZXR1cm4ge0NvbnZlcnNhdGlvblF1ZXJ5fSBzZWxmXG4gICAqL1xuXG5cbiAgQ29udmVyc2F0aW9uUXVlcnkucHJvdG90eXBlLnNpemVFcXVhbFRvID0gZnVuY3Rpb24gc2l6ZUVxdWFsVG8oa2V5LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ29uZGl0aW9uKGtleSwgJyRzaXplJywgbGVuZ3RoKTtcbiAgfTtcblxuICAvKipcbiAgICog6K6+572u6L+U5Zue6ZuG5ZCI55qE5aSn5bCP5LiK6ZmQXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdCAtIOS4iumZkFxuICAgKiBAcmV0dXJuIHtDb252ZXJzYXRpb25RdWVyeX0gc2VsZlxuICAgKi9cblxuXG4gIENvbnZlcnNhdGlvblF1ZXJ5LnByb3RvdHlwZS5saW1pdCA9IGZ1bmN0aW9uIGxpbWl0KF9saW1pdCkge1xuICAgIHRoaXMuX2xpbWl0ID0gX2xpbWl0O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiDorr7nva7ov5Tlm57pm4blkIjnmoTotbflp4vkvY3nva7vvIzkuIDoiKznlKjkuo7liIbpobVcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNraXAgLSDotbflp4vkvY3nva7ot7Pov4flh6DkuKrlr7nosaFcbiAgICogQHJldHVybiB7Q29udmVyc2F0aW9uUXVlcnl9IHNlbGZcbiAgICovXG5cblxuICBDb252ZXJzYXRpb25RdWVyeS5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAoX3NraXApIHtcbiAgICB0aGlzLl9za2lwID0gX3NraXA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIOiuvue9rui/lOWbnumbhuWQiOaMieeFp+aMh+Wummtleei/m+ihjOWinuW6j+aOkuWIl1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge0NvbnZlcnNhdGlvblF1ZXJ5fSBzZWxmXG4gICAqL1xuXG5cbiAgQ29udmVyc2F0aW9uUXVlcnkucHJvdG90eXBlLmFzY2VuZGluZyA9IGZ1bmN0aW9uIGFzY2VuZGluZyhrZXkpIHtcbiAgICB0aGlzLl9vcmRlciA9IGtleTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICog6K6+572u6L+U5Zue6ZuG5ZCI5oyJ54Wn5oyH5a6aa2V56L+b6KGM5aKe5bqP5o6S5YiX77yM5aaC5p6c5bey6K6+572u5YW25LuW5o6S5bqP77yM5Y6f5o6S5bqP55qE5LyY5YWI57qn6L6D6auYXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHJldHVybiB7Q29udmVyc2F0aW9uUXVlcnl9IHNlbGZcbiAgICovXG5cblxuICBDb252ZXJzYXRpb25RdWVyeS5wcm90b3R5cGUuYWRkQXNjZW5kaW5nID0gZnVuY3Rpb24gYWRkQXNjZW5kaW5nKGtleSkge1xuICAgIGlmICh0aGlzLl9vcmRlcikge1xuICAgICAgdGhpcy5fb3JkZXIgKz0gJywnICsga2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vcmRlciA9IGtleTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIOiuvue9rui/lOWbnumbhuWQiOaMieeFp+aMh+WumiBrZXkg6L+b6KGM6ZmN5bqP5o6S5YiXXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHJldHVybiB7Q29udmVyc2F0aW9uUXVlcnl9IHNlbGZcbiAgICovXG5cblxuICBDb252ZXJzYXRpb25RdWVyeS5wcm90b3R5cGUuZGVzY2VuZGluZyA9IGZ1bmN0aW9uIGRlc2NlbmRpbmcoa2V5KSB7XG4gICAgdGhpcy5fb3JkZXIgPSAnLScgKyBrZXk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIOiuvue9rui/lOWbnumbhuWQiOaMieeFp+aMh+WumiBrZXkg6L+b6KGM6ZmN5bqP5o6S5YiX77yM5aaC5p6c5bey6K6+572u5YW25LuW5o6S5bqP77yM5Y6f5o6S5bqP55qE5LyY5YWI57qn6L6D6auYXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHJldHVybiB7Q29udmVyc2F0aW9uUXVlcnl9IHNlbGZcbiAgICovXG5cblxuICBDb252ZXJzYXRpb25RdWVyeS5wcm90b3R5cGUuYWRkRGVzY2VuZGluZyA9IGZ1bmN0aW9uIGFkZERlc2NlbmRpbmcoa2V5KSB7XG4gICAgaWYgKHRoaXMuX29yZGVyKSB7XG4gICAgICB0aGlzLl9vcmRlciArPSAnLC0nICsga2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vcmRlciA9ICctJyArIGtleTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIOiuvue9rui/lOWbnueahCBjb252ZXJzYXRpb25zIOWIt+aWsOacgOWQjuS4gOadoea2iOaBr1xuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbZW5hYmxlZD10cnVlXVxuICAgKiBAcmV0dXJuIHtDb252ZXJzYXRpb25RdWVyeX0gc2VsZlxuICAgKi9cblxuXG4gIENvbnZlcnNhdGlvblF1ZXJ5LnByb3RvdHlwZS53aXRoTGFzdE1lc3NhZ2VzUmVmcmVzaGVkID0gZnVuY3Rpb24gd2l0aExhc3RNZXNzYWdlc1JlZnJlc2hlZCgpIHtcbiAgICB2YXIgZW5hYmxlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcblxuICAgIHRoaXMuX2V4dHJhT3B0aW9ucy53aXRoTGFzdE1lc3NhZ2VzUmVmcmVzaGVkID0gZW5hYmxlZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICog6K6+572u6L+U5Zue55qEIGNvbnZlcnNhdGlvbnMg5Li657K+566A5qih5byP77yM5Y2z5LiN5ZCr5oiQ5ZGY5YiX6KGoXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtlbmFibGVkPXRydWVdXG4gICAqIEByZXR1cm4ge0NvbnZlcnNhdGlvblF1ZXJ5fSBzZWxmXG4gICAqL1xuXG5cbiAgQ29udmVyc2F0aW9uUXVlcnkucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbiBjb21wYWN0KCkge1xuICAgIHZhciBlbmFibGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG4gICAgdGhpcy5fZXh0cmFPcHRpb25zLmNvbXBhY3QgPSBlbmFibGVkO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiDmiafooYzmn6Xor6JcbiAgICogQHJldHVybiB7UHJvbWlzZS48Q29udmVyc2F0aW9uQmFzZVtdPn1cbiAgICovXG5cblxuICBDb252ZXJzYXRpb25RdWVyeS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIHRoaXMuX2NsaWVudC5fZXhlY3V0ZVF1ZXJ5KHRoaXMpKTtcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIGZpbmQoKSB7XG4gICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBmaW5kO1xuICB9KCk7XG5cbiAgcmV0dXJuIENvbnZlcnNhdGlvblF1ZXJ5O1xufSgpO1xuXG52YXIgZGVidWckOSA9IGJyb3dzZXIoJ0xDOlNlc3Npb25NYW5hZ2VyJyk7XG5cbnZhciBTZXNzaW9uTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2Vzc2lvbk1hbmFnZXIoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICByZWZyZXNoID0gX3JlZi5yZWZyZXNoLFxuICAgICAgICBvbkJlZm9yZUdldFNlc3Npb25Ub2tlbiA9IF9yZWYub25CZWZvcmVHZXRTZXNzaW9uVG9rZW47XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2Vzc2lvbk1hbmFnZXIpO1xuXG4gICAgdGhpcy5yZWZyZXNoID0gcmVmcmVzaDtcbiAgICB0aGlzLl9vbkJlZm9yZUdldFNlc3Npb25Ub2tlbiA9IG9uQmVmb3JlR2V0U2Vzc2lvblRva2VuO1xuICAgIHRoaXMuc2V0U2Vzc2lvblRva2VuKG51bGwsIDApO1xuICB9XG5cbiAgU2Vzc2lvbk1hbmFnZXIucHJvdG90eXBlLnNldFNlc3Npb25Ub2tlbiA9IGZ1bmN0aW9uIHNldFNlc3Npb25Ub2tlbih0b2tlbiwgdHRsKSB7XG4gICAgZGVidWckOSgnc2V0IHNlc3Npb24gdG9rZW4nLCB0b2tlbiwgdHRsKTtcbiAgICB2YXIgc2Vzc2lvblRva2VuID0gbmV3IEV4cGlyYWJsZSh0b2tlbiwgdHRsICogMTAwMCk7XG4gICAgdGhpcy5fc2Vzc2lvblRva2VuID0gc2Vzc2lvblRva2VuO1xuICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nU2Vzc2lvblRva2VuUHJvbWlzZTtcbiAgICByZXR1cm4gc2Vzc2lvblRva2VuO1xuICB9O1xuXG4gIFNlc3Npb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRTZXNzaW9uVG9rZW5Bc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShwcm9taXNlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgY3VycmVudFNlc3Npb25Ub2tlbjtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvblRva2VuID0gdGhpcy5fc2Vzc2lvblRva2VuO1xuXG4gICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdTZXNzaW9uVG9rZW5Qcm9taXNlID0gcHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyByZXZlcnQsIG90aGVyd2lzZSB0aGUgZm9sbG93aW5nIGdldFNlc3Npb25Ub2tlbiBjYWxsc1xuICAgICAgICAgICAgICAgIC8vIHdpbGwgYWxsIGJlIHJlamVjdGVkXG4gICAgICAgICAgICAgICAgX3RoaXMuX3Nlc3Npb25Ub2tlbiA9IGN1cnJlbnRTZXNzaW9uVG9rZW47XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IHRoaXMuc2V0U2Vzc2lvblRva2VuO1xuICAgICAgICAgICAgICBfY29udGV4dC50MSA9IHRoaXM7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQyID0gX3RvQ29uc3VtYWJsZUFycmF5O1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdTZXNzaW9uVG9rZW5Qcm9taXNlO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQzID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgX2NvbnRleHQudDQgPSAoMCwgX2NvbnRleHQudDIpKF9jb250ZXh0LnQzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgncmV0dXJuJywgX2NvbnRleHQudDAuYXBwbHkuY2FsbChfY29udGV4dC50MCwgX2NvbnRleHQudDEsIF9jb250ZXh0LnQ0KSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gc2V0U2Vzc2lvblRva2VuQXN5bmMoX3gyKSB7XG4gICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2V0U2Vzc2lvblRva2VuQXN5bmM7XG4gIH0oKTtcblxuICBTZXNzaW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0U2Vzc2lvblRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmMyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgIHZhciBfcmVmNCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgX3JlZjQkYXV0b1JlZnJlc2ggPSBfcmVmNC5hdXRvUmVmcmVzaCxcbiAgICAgICAgICBhdXRvUmVmcmVzaCA9IF9yZWY0JGF1dG9SZWZyZXNoID09PSB1bmRlZmluZWQgPyB0cnVlIDogX3JlZjQkYXV0b1JlZnJlc2g7XG5cbiAgICAgIHZhciBfcmVmNSwgdmFsdWUsIG9yaWdpbmFsVmFsdWUsIF9yZWY2LCBuZXdWYWx1ZTtcblxuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBkZWJ1ZyQ5KCdnZXQgc2Vzc2lvbiB0b2tlbicpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fb25CZWZvcmVHZXRTZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkJlZm9yZUdldFNlc3Npb25Ub2tlbih0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSB0aGlzLl9zZXNzaW9uVG9rZW47XG5cbiAgICAgICAgICAgICAgaWYgKF9jb250ZXh0Mi50MCkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdTZXNzaW9uVG9rZW5Qcm9taXNlO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0Mi5zZW50O1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9yZWY1ID0gX2NvbnRleHQyLnQwO1xuICAgICAgICAgICAgICB2YWx1ZSA9IF9yZWY1LnZhbHVlO1xuICAgICAgICAgICAgICBvcmlnaW5hbFZhbHVlID0gX3JlZjUub3JpZ2luYWxWYWx1ZTtcblxuICAgICAgICAgICAgICBpZiAoISh2YWx1ZSA9PT0gRXhwaXJhYmxlLkVYUElSRUQgJiYgYXV0b1JlZnJlc2ggJiYgdGhpcy5yZWZyZXNoKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZWJ1ZyQ5KCdyZWZyZXNoIGV4cGlyZWQgc2Vzc2lvbiB0b2tlbicpO1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE0O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTZXNzaW9uVG9rZW5Bc3luYyh0aGlzLnJlZnJlc2godGhpcywgb3JpZ2luYWxWYWx1ZSkpO1xuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBfcmVmNiA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgICAgICBuZXdWYWx1ZSA9IF9yZWY2LnZhbHVlO1xuXG4gICAgICAgICAgICAgIGRlYnVnJDkoJ3Nlc3Npb24gdG9rZW4nLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KCdyZXR1cm4nLCBuZXdWYWx1ZSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgIGRlYnVnJDkoJ3Nlc3Npb24gdG9rZW4nLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KCdyZXR1cm4nLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBnZXRTZXNzaW9uVG9rZW4oKSB7XG4gICAgICByZXR1cm4gX3JlZjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0U2Vzc2lvblRva2VuO1xuICB9KCk7XG5cbiAgU2Vzc2lvbk1hbmFnZXIucHJvdG90eXBlLnJldm9rZSA9IGZ1bmN0aW9uIHJldm9rZSgpIHtcbiAgICBpZiAodGhpcy5fc2Vzc2lvblRva2VuKSB0aGlzLl9zZXNzaW9uVG9rZW4uZXhwaXJlZEF0ID0gLTE7XG4gIH07XG5cbiAgcmV0dXJuIFNlc3Npb25NYW5hZ2VyO1xufSgpO1xuXG52YXIgX2RlYyQyLCBfZGVjMiwgX2NsYXNzJDM7XG5cbmZ1bmN0aW9uIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IkMSh0YXJnZXQsIHByb3BlcnR5LCBkZWNvcmF0b3JzLCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7XG4gIHZhciBkZXNjID0ge307XG4gIE9iamVjdFsna2UnICsgJ3lzJ10oZGVzY3JpcHRvcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVzY1trZXldID0gZGVzY3JpcHRvcltrZXldO1xuICB9KTtcbiAgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7XG4gIGRlc2MuY29uZmlndXJhYmxlID0gISFkZXNjLmNvbmZpZ3VyYWJsZTtcblxuICBpZiAoJ3ZhbHVlJyBpbiBkZXNjIHx8IGRlc2MuaW5pdGlhbGl6ZXIpIHtcbiAgICBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgfVxuXG4gIGRlc2MgPSBkZWNvcmF0b3JzLnNsaWNlKCkucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAoZGVzYywgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5LCBkZXNjKSB8fCBkZXNjO1xuICB9LCBkZXNjKTtcblxuICBpZiAoY29udGV4dCAmJiBkZXNjLmluaXRpYWxpemVyICE9PSB2b2lkIDApIHtcbiAgICBkZXNjLnZhbHVlID0gZGVzYy5pbml0aWFsaXplciA/IGRlc2MuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMDtcbiAgICBkZXNjLmluaXRpYWxpemVyID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkge1xuICAgIE9iamVjdFsnZGVmaW5lJyArICdQcm9wZXJ0eSddKHRhcmdldCwgcHJvcGVydHksIGRlc2MpO1xuICAgIGRlc2MgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGRlc2M7XG59XG5cbnZhciBkZWJ1ZyQxMCA9IGJyb3dzZXIoJ0xDOklNQ2xpZW50Jyk7XG5cbnZhciBJTlZJVEVEJDEgPSBJTlZJVEVELFxuICAgIEtJQ0tFRCQxID0gS0lDS0VELFxuICAgIE1FTUJFUlNfSk9JTkVEJDEgPSBNRU1CRVJTX0pPSU5FRCxcbiAgICBNRU1CRVJTX0xFRlQkMSA9IE1FTUJFUlNfTEVGVCxcbiAgICBNRU1CRVJfSU5GT19VUERBVEVEJDEgPSBNRU1CRVJfSU5GT19VUERBVEVELFxuICAgIEJMT0NLRUQkMSA9IEJMT0NLRUQsXG4gICAgVU5CTE9DS0VEJDEgPSBVTkJMT0NLRUQsXG4gICAgTUVNQkVSU19CTE9DS0VEJDEgPSBNRU1CRVJTX0JMT0NLRUQsXG4gICAgTUVNQkVSU19VTkJMT0NLRUQkMSA9IE1FTUJFUlNfVU5CTE9DS0VELFxuICAgIE1VVEVEJDEgPSBNVVRFRCxcbiAgICBVTk1VVEVEJDEgPSBVTk1VVEVELFxuICAgIE1FTUJFUlNfTVVURUQkMSA9IE1FTUJFUlNfTVVURUQsXG4gICAgTUVNQkVSU19VTk1VVEVEJDEgPSBNRU1CRVJTX1VOTVVURUQsXG4gICAgTUVTU0FHRSQyID0gTUVTU0FHRSQxLFxuICAgIFVOUkVBRF9NRVNTQUdFU19DT1VOVF9VUERBVEUkMSA9IFVOUkVBRF9NRVNTQUdFU19DT1VOVF9VUERBVEUsXG4gICAgQ0xPU0UkMSA9IENMT1NFLFxuICAgIENPTkZMSUNUJDEgPSBDT05GTElDVCxcbiAgICBVTkhBTkRMRURfTUVTU0FHRSQxID0gVU5IQU5ETEVEX01FU1NBR0UsXG4gICAgQ09OVkVSU0FUSU9OX0lORk9fVVBEQVRFRCQxID0gQ09OVkVSU0FUSU9OX0lORk9fVVBEQVRFRCxcbiAgICBNRVNTQUdFX1JFQ0FMTCQxID0gTUVTU0FHRV9SRUNBTEwsXG4gICAgTUVTU0FHRV9VUERBVEUkMSA9IE1FU1NBR0VfVVBEQVRFLFxuICAgIElORk9fVVBEQVRFRCQxID0gSU5GT19VUERBVEVEO1xuXG5cbnZhciBpc1RlbXBvcmFyeUNvbnZlcnNhdHJpb25JZCA9IGZ1bmN0aW9uIGlzVGVtcG9yYXJ5Q29udmVyc2F0cmlvbklkKGlkKSB7XG4gIHJldHVybiAoL15fdG1wOi8udGVzdChpZClcbiAgKTtcbn07XG5cbi8qKlxuICogMSBwYXRjaC1tc2dcbiAqIDEgdGVtcC1jb252LW1zZ1xuICogMCBhdXRvLWJpbmQtZGV2aWNlaWQtYW5kLWluc3RhbGxhdGlvblxuICogMSB0cmFuc2llbnQtbXNnLWFja1xuICogMSBrZWVwLW5vdGlmaWNhdGlvblxuICogMSBwYXJ0aWFsLWZhaWxlZC1tc2dcbiAqIEBpZ25vcmVcbiAqL1xudmFyIGNvbmZpZ0JpdG1hcCA9IDU5O1xuXG52YXIgSU1DbGllbnQgPSAoX2RlYyQyID0gdGhyb3R0bGUoMTAwMCksIF9kZWMyID0gdGhyb3R0bGUoMTAwMCksIF9jbGFzcyQzID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKElNQ2xpZW50LCBfRXZlbnRFbWl0dGVyKTtcblxuICAvKipcbiAgICog5peg5rOV55u05o6l5a6e5L6L5YyW77yM6K+35L2/55SoIHtAbGluayBSZWFsdGltZSNjcmVhdGVJTUNsaWVudH0g5Yib5bu65paw55qEIElNQ2xpZW5044CCXG4gICAqXG4gICAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICAgKi9cbiAgZnVuY3Rpb24gSU1DbGllbnQoaWQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHByb3BzID0gYXJndW1lbnRzWzJdO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElNQ2xpZW50KTtcblxuICAgIGlmICghKGlkID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGlkID09PSAnc3RyaW5nJykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NsaWVudCBpZCBbJyArIGlkICsgJ10gaXMgbm90IGEgU3RyaW5nJyk7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0V2ZW50RW1pdHRlci5jYWxsKHRoaXMpKTtcblxuICAgIF9PYmplY3QkYXNzaWduKF90aGlzLCB7XG4gICAgICAvKipcbiAgICAgICAqIEB2YXIgaWQge1N0cmluZ30g5a6i5oi356uvIGlkXG4gICAgICAgKiBAbWVtYmVyb2YgSU1DbGllbnQjXG4gICAgICAgKi9cbiAgICAgIGlkOiBpZCxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9LCBwcm9wcyk7XG5cbiAgICBpZiAoIV90aGlzLl9tZXNzYWdlUGFyc2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lNQ2xpZW50IG11c3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIE1lc3NhZ2VQYXJzZXInKTtcbiAgICB9XG4gICAgX3RoaXMuX2NvbnZlcnNhdGlvbkNhY2hlID0gbmV3IENhY2hlKCdjbGllbnQ6JyArIF90aGlzLmlkKTtcbiAgICBfdGhpcy5fYWNrTWVzc2FnZUJ1ZmZlciA9IHt9O1xuICAgIGludGVybmFsKF90aGlzKS5sYXN0UGF0Y2hUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBpbnRlcm5hbChfdGhpcykubGFzdE5vdGlmaWNhdGlvblRpbWUgPSB1bmRlZmluZWQ7XG4gICAgaW50ZXJuYWwoX3RoaXMpLl9ldmVudGVtaXR0ZXIgPSBuZXcgZXZlbnRlbWl0dGVyMygpO1xuICAgIGlmIChkZWJ1ZyQxMC5lbmFibGVkKSB7XG4gICAgICBfT2JqZWN0JHZhbHVlcyhFdmVudCkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLm9uKGV2ZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBheWxvYWQgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgIHBheWxvYWRbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9kZWJ1ZyhldmVudCArICcgZXZlbnQgZW1pdHRlZC4gJW8nLCBwYXlsb2FkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gb25JTUNsaWVudENyZWF0ZSBob29rXG4gICAgYXBwbHlEZWNvcmF0b3JzKF90aGlzLl9wbHVnaW5zLm9uSU1DbGllbnRDcmVhdGUsIF90aGlzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBJTUNsaWVudC5wcm90b3R5cGUuX2RlYnVnID0gZnVuY3Rpb24gX2RlYnVnKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcGFyYW1zID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIHBhcmFtc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGRlYnVnJDEwLmFwcGx5KHVuZGVmaW5lZCwgcGFyYW1zLmNvbmNhdChbJ1snICsgdGhpcy5pZCArICddJ10pKTtcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG5cbiAgSU1DbGllbnQucHJvdG90eXBlLl9kaXNwYXRjaENvbW1hbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShjb21tYW5kKSB7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgdGhpcy5fZGVidWcodHJpbSQxKGNvbW1hbmQpLCAncmVjZWl2ZWQnKTtcbiAgICAgICAgICAgICAgaWYgKGNvbW1hbmQuc2VydmVyVHMpIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbCh0aGlzKS5sYXN0Tm90aWZpY2F0aW9uVGltZSA9IGdldFRpbWUoZGVjb2RlRGF0ZShjb21tYW5kLnNlcnZlclRzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBjb21tYW5kLmNtZDtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IF9jb250ZXh0LnQwID09PSBDb21tYW5kVHlwZS5jb252ID8gNSA6IF9jb250ZXh0LnQwID09PSBDb21tYW5kVHlwZS5kaXJlY3QgPyA2IDogX2NvbnRleHQudDAgPT09IENvbW1hbmRUeXBlLnNlc3Npb24gPyA3IDogX2NvbnRleHQudDAgPT09IENvbW1hbmRUeXBlLnVucmVhZCA/IDggOiBfY29udGV4dC50MCA9PT0gQ29tbWFuZFR5cGUucmNwID8gOSA6IF9jb250ZXh0LnQwID09PSBDb21tYW5kVHlwZS5wYXRjaCA/IDEwIDogMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIHRoaXMuX2Rpc3BhdGNoQ29udk1lc3NhZ2UoY29tbWFuZCkpO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIHRoaXMuX2Rpc3BhdGNoRGlyZWN0TWVzc2FnZShjb21tYW5kKSk7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgncmV0dXJuJywgdGhpcy5fZGlzcGF0Y2hTZXNzaW9uTWVzc2FnZShjb21tYW5kKSk7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgncmV0dXJuJywgdGhpcy5fZGlzcGF0Y2hVbnJlYWRNZXNzYWdlKGNvbW1hbmQpKTtcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCB0aGlzLl9kaXNwYXRjaFJjcE1lc3NhZ2UoY29tbWFuZCkpO1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KCdyZXR1cm4nLCB0aGlzLl9kaXNwYXRjaFBhdGNoTWVzc2FnZShjb21tYW5kKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoJ3JldHVybicsIHRoaXMuZW1pdChVTkhBTkRMRURfTUVTU0FHRSQxLCBjb21tYW5kKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gX2Rpc3BhdGNoQ29tbWFuZChfeDIpIHtcbiAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9kaXNwYXRjaENvbW1hbmQ7XG4gIH0oKTtcblxuICBJTUNsaWVudC5wcm90b3R5cGUuX2Rpc3BhdGNoU2Vzc2lvbk1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKG1lc3NhZ2UpIHtcbiAgICAgIHZhciBfbWVzc2FnZSRzZXNzaW9uTWVzc2EsIGNvZGUsIHJlYXNvbjtcblxuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfbWVzc2FnZSRzZXNzaW9uTWVzc2EgPSBtZXNzYWdlLnNlc3Npb25NZXNzYWdlLCBjb2RlID0gX21lc3NhZ2Ukc2Vzc2lvbk1lc3NhLmNvZGUsIHJlYXNvbiA9IF9tZXNzYWdlJHNlc3Npb25NZXNzYS5yZWFzb247XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IG1lc3NhZ2Uub3A7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gX2NvbnRleHQyLnQwID09PSBPcFR5cGUuY2xvc2VkID8gNCA6IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGludGVybmFsKHRoaXMpLl9ldmVudGVtaXR0ZXIuZW1pdCgnY2xvc2UnKTtcblxuICAgICAgICAgICAgICBpZiAoIShjb2RlID09PSBFcnJvckNvZGUuU0VTU0lPTl9DT05GTElDVCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdCgncmV0dXJuJywgdGhpcy5lbWl0KENPTkZMSUNUJDEsIHtcbiAgICAgICAgICAgICAgICByZWFzb246IHJlYXNvblxuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoJ3JldHVybicsIHRoaXMuZW1pdChDTE9TRSQxLCB7XG4gICAgICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgICAgICByZWFzb246IHJlYXNvblxuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KFVOSEFORExFRF9NRVNTQUdFJDEsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBzZXNzaW9uIGNvbW1hbmQnKTtcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIF9kaXNwYXRjaFNlc3Npb25NZXNzYWdlKF94Mykge1xuICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9kaXNwYXRjaFNlc3Npb25NZXNzYWdlO1xuICB9KCk7XG5cbiAgSU1DbGllbnQucHJvdG90eXBlLl9kaXNwYXRjaFVucmVhZE1lc3NhZ2UgPSBmdW5jdGlvbiBfZGlzcGF0Y2hVbnJlYWRNZXNzYWdlKF9yZWYzKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgX3JlZjMkdW5yZWFkTWVzc2FnZSA9IF9yZWYzLnVucmVhZE1lc3NhZ2UsXG4gICAgICAgIGNvbnZzID0gX3JlZjMkdW5yZWFkTWVzc2FnZS5jb252cyxcbiAgICAgICAgbm90aWZUaW1lID0gX3JlZjMkdW5yZWFkTWVzc2FnZS5ub3RpZlRpbWU7XG5cbiAgICBpbnRlcm5hbCh0aGlzKS5sYXN0VW5yZWFkTm90aWZUaW1lID0gbm90aWZUaW1lO1xuICAgIC8vIGVuc3VyZSBhbGwgY29udmVyc3Rpb25zIGFyZSBjYWNoZWRcbiAgICByZXR1cm4gdGhpcy5nZXRDb252ZXJzYXRpb25zKGNvbnZzLm1hcChmdW5jdGlvbiAoY29udikge1xuICAgICAgcmV0dXJuIGNvbnYuY2lkO1xuICAgIH0pKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8vIHVwZGF0ZSBjb252ZXJzYXRpb25zIGRhdGFcbiAgICAgICAgX1Byb21pc2UuYWxsKGNvbnZzLm1hcChmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICAgICAgICB2YXIgY2lkID0gX3JlZjQuY2lkLFxuICAgICAgICAgICAgICB1bnJlYWQgPSBfcmVmNC51bnJlYWQsXG4gICAgICAgICAgICAgIG1pZCA9IF9yZWY0Lm1pZCxcbiAgICAgICAgICAgICAgdHMgPSBfcmVmNC50aW1lc3RhbXAsXG4gICAgICAgICAgICAgIGZyb20gPSBfcmVmNC5mcm9tLFxuICAgICAgICAgICAgICBkYXRhID0gX3JlZjQuZGF0YSxcbiAgICAgICAgICAgICAgYmluYXJ5TXNnID0gX3JlZjQuYmluYXJ5TXNnLFxuICAgICAgICAgICAgICBwYXRjaFRpbWVzdGFtcCA9IF9yZWY0LnBhdGNoVGltZXN0YW1wLFxuICAgICAgICAgICAgICBtZW50aW9uZWQgPSBfcmVmNC5tZW50aW9uZWQ7XG5cbiAgICAgICAgICB2YXIgY29udmVyc2F0aW9uID0gX3RoaXMyLl9jb252ZXJzYXRpb25DYWNoZS5nZXQoY2lkKTtcbiAgICAgICAgICAvLyBkZWxldGVkIGNvbnZlcnNhdGlvblxuICAgICAgICAgIGlmICghY29udmVyc2F0aW9uKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgdGltZXN0YW1wID0gdm9pZCAwO1xuICAgICAgICAgIGlmICh0cykge1xuICAgICAgICAgICAgdGltZXN0YW1wID0gZGVjb2RlRGF0ZSh0cyk7XG4gICAgICAgICAgICBjb252ZXJzYXRpb24ubGFzdE1lc3NhZ2VBdCA9IHRpbWVzdGFtcDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKG1pZCA/IF90aGlzMi5fbWVzc2FnZVBhcnNlci5wYXJzZShiaW5hcnlNc2cgfHwgZGF0YSkudGhlbihmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VQcm9wcyA9IHtcbiAgICAgICAgICAgICAgaWQ6IG1pZCxcbiAgICAgICAgICAgICAgY2lkOiBjaWQsXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IHBhdGNoVGltZXN0YW1wLFxuICAgICAgICAgICAgICBmcm9tOiBmcm9tXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX09iamVjdCRhc3NpZ24obWVzc2FnZSwgbWVzc2FnZVByb3BzKTtcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5sYXN0TWVzc2FnZSA9IG1lc3NhZ2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICB9KSA6IF9Qcm9taXNlLnJlc29sdmUoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb252ZXJzYXRpb24uX3NldFVucmVhZE1lc3NhZ2VzTWVudGlvbmVkKG1lbnRpb25lZCk7XG4gICAgICAgICAgICB2YXIgY291bnROb3RVcGRhdGVkID0gdW5yZWFkID09PSBpbnRlcm5hbChjb252ZXJzYXRpb24pLnVucmVhZE1lc3NhZ2VzQ291bnQ7XG4gICAgICAgICAgICBpZiAoY291bnROb3RVcGRhdGVkKSByZXR1cm4gbnVsbDsgLy8gdG8gYmUgZmlsdGVyZWRcbiAgICAgICAgICAgIC8vIG1hbmlwdWxhdGUgaW50ZXJuYWwgcHJvcGVydHkgZGlyZWN0bHkgdG8gc2tpcCB1bnJlYWRtZXNzYWdlc2NvdW50dXBkYXRlIGV2ZW50XG4gICAgICAgICAgICBpbnRlcm5hbChjb252ZXJzYXRpb24pLnVucmVhZE1lc3NhZ2VzQ291bnQgPSB1bnJlYWQ7XG4gICAgICAgICAgICByZXR1cm4gY29udmVyc2F0aW9uO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIGZpbHRlciBjb252ZXJzYXRpb25zIHdpdGhvdXQgdW5yZWFkIGNvdW50IHVwZGF0ZVxuICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAoY29udmVyc2F0aW9ucykge1xuICAgICAgICAgIHJldHVybiBjb252ZXJzYXRpb25zLmZpbHRlcihmdW5jdGlvbiAoY29udmVyc2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udmVyc2F0aW9uO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChjb252ZXJzYXRpb25zKSB7XG4gICAgICBpZiAoY29udmVyc2F0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOacquivu+a2iOaBr+aVsOebruabtOaWsFxuICAgICAgICAgKiBAZXZlbnQgSU1DbGllbnQjVU5SRUFEX01FU1NBR0VTX0NPVU5UX1VQREFURVxuICAgICAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgICAgICogQHBhcmFtIHtDb252ZXJzYXRpb25bXX0gY29udmVyc2F0aW9ucyDmnKror7vmtojmga/mlbDnm67mnInmm7TmlrDnmoTlr7nor53liJfooahcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzMi5lbWl0KFVOUkVBRF9NRVNTQUdFU19DT1VOVF9VUERBVEUkMSwgY29udmVyc2F0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgSU1DbGllbnQucHJvdG90eXBlLl9kaXNwYXRjaFJjcE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWY1ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKG1lc3NhZ2UpIHtcbiAgICAgIHZhciByY3BNZXNzYWdlLCByZWFkLCBjb252ZXJzYXRpb25JZCwgbWVzc2FnZUlkLCB0aW1lc3RhbXAsIGNvbnZlcnNhdGlvbjtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcmNwTWVzc2FnZSA9IG1lc3NhZ2UucmNwTWVzc2FnZSwgcmVhZCA9IG1lc3NhZ2UucmNwTWVzc2FnZS5yZWFkO1xuICAgICAgICAgICAgICBjb252ZXJzYXRpb25JZCA9IHJjcE1lc3NhZ2UuY2lkO1xuICAgICAgICAgICAgICBtZXNzYWdlSWQgPSByY3BNZXNzYWdlLmlkO1xuICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBkZWNvZGVEYXRlKHJjcE1lc3NhZ2UudCk7XG4gICAgICAgICAgICAgIGNvbnZlcnNhdGlvbiA9IHRoaXMuX2NvbnZlcnNhdGlvbkNhY2hlLmdldChjb252ZXJzYXRpb25JZCk7XG4gICAgICAgICAgICAgIC8vIGNvbnZlcnNhdGlvbiBub3QgY2FjaGVkIG1lYW5zIHRoZSBjbGllbnQgZG9lcyBub3Qgc2VuZCB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgICAvLyBkdXJpbmcgdGhpcyBzZXNzaW9uXG5cbiAgICAgICAgICAgICAgaWYgKGNvbnZlcnNhdGlvbikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KCdyZXR1cm4nKTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjb252ZXJzYXRpb24uX2hhbmRsZVJlY2VpcHQoeyBtZXNzYWdlSWQ6IG1lc3NhZ2VJZCwgdGltZXN0YW1wOiB0aW1lc3RhbXAsIHJlYWQ6IHJlYWQgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIF9kaXNwYXRjaFJjcE1lc3NhZ2UoX3g0KSB7XG4gICAgICByZXR1cm4gX3JlZjUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2Rpc3BhdGNoUmNwTWVzc2FnZTtcbiAgfSgpO1xuXG4gIElNQ2xpZW50LnByb3RvdHlwZS5fZGlzcGF0Y2hQYXRjaE1lc3NhZ2UgPSBmdW5jdGlvbiBfZGlzcGF0Y2hQYXRjaE1lc3NhZ2UoX3JlZjYpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciBwYXRjaGVzID0gX3JlZjYucGF0Y2hNZXNzYWdlLnBhdGNoZXM7XG5cbiAgICAvLyBlbnN1cmUgYWxsIGNvbnZlcnN0aW9ucyBhcmUgY2FjaGVkXG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29udmVyc2F0aW9ucyhwYXRjaGVzLm1hcChmdW5jdGlvbiAocGF0Y2gpIHtcbiAgICAgIHJldHVybiBwYXRjaC5jaWQ7XG4gICAgfSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9Qcm9taXNlLmFsbChwYXRjaGVzLm1hcChmdW5jdGlvbiAoX3JlZjcpIHtcbiAgICAgICAgdmFyIGNpZCA9IF9yZWY3LmNpZCxcbiAgICAgICAgICAgIG1pZCA9IF9yZWY3Lm1pZCxcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IF9yZWY3LnRpbWVzdGFtcCxcbiAgICAgICAgICAgIHJlY2FsbCA9IF9yZWY3LnJlY2FsbCxcbiAgICAgICAgICAgIGRhdGEgPSBfcmVmNy5kYXRhLFxuICAgICAgICAgICAgcGF0Y2hUaW1lc3RhbXAgPSBfcmVmNy5wYXRjaFRpbWVzdGFtcCxcbiAgICAgICAgICAgIGZyb20gPSBfcmVmNy5mcm9tLFxuICAgICAgICAgICAgYmluYXJ5TXNnID0gX3JlZjcuYmluYXJ5TXNnLFxuICAgICAgICAgICAgbWVudGlvbkFsbCA9IF9yZWY3Lm1lbnRpb25BbGwsXG4gICAgICAgICAgICBtZW50aW9uUGlkcyA9IF9yZWY3Lm1lbnRpb25QaWRzO1xuXG4gICAgICAgIHZhciBjb252ZXJzYXRpb24gPSBfdGhpczMuX2NvbnZlcnNhdGlvbkNhY2hlLmdldChjaWQpO1xuICAgICAgICAvLyBkZWxldGVkIGNvbnZlcnNhdGlvblxuICAgICAgICBpZiAoIWNvbnZlcnNhdGlvbikgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpczMuX21lc3NhZ2VQYXJzZXIucGFyc2UoYmluYXJ5TXNnIHx8IGRhdGEpLnRoZW4oZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICB2YXIgcGF0Y2hUaW1lID0gZ2V0VGltZShkZWNvZGVEYXRlKHBhdGNoVGltZXN0YW1wKSk7XG4gICAgICAgICAgdmFyIG1lc3NhZ2VQcm9wcyA9IHtcbiAgICAgICAgICAgIGlkOiBtaWQsXG4gICAgICAgICAgICBjaWQ6IGNpZCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICAgICAgdXBkYXRlZEF0OiBwYXRjaFRpbWUsXG4gICAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgICAgbWVudGlvbkxpc3Q6IG1lbnRpb25QaWRzLFxuICAgICAgICAgICAgbWVudGlvbmVkQWxsOiBtZW50aW9uQWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBfT2JqZWN0JGFzc2lnbihtZXNzYWdlLCBtZXNzYWdlUHJvcHMpO1xuICAgICAgICAgIG1lc3NhZ2UuX3NldFN0YXR1cyhNZXNzYWdlU3RhdHVzLlNFTlQpO1xuICAgICAgICAgIG1lc3NhZ2UuX3VwZGF0ZU1lbnRpb25lZChfdGhpczMuaWQpO1xuICAgICAgICAgIGlmIChpbnRlcm5hbChfdGhpczMpLmxhc3RQYXRjaFRpbWUgPCBwYXRjaFRpbWUpIHtcbiAgICAgICAgICAgIGludGVybmFsKF90aGlzMykubGFzdFBhdGNoVGltZSA9IHBhdGNoVGltZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gdXBkYXRlIGNvbnZlcnNhdGlvbiBsYXN0TWVzc2FnZVxuICAgICAgICAgIGlmIChjb252ZXJzYXRpb24ubGFzdE1lc3NhZ2UgJiYgY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlLmlkID09PSBtaWQpIHtcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5sYXN0TWVzc2FnZSA9IG1lc3NhZ2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlY2FsbCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDmtojmga/ooqvmkqTlm55cbiAgICAgICAgICAgICAqIEBldmVudCBJTUNsaWVudCNNRVNTQUdFX1JFQ0FMTFxuICAgICAgICAgICAgICogQHBhcmFtIHtBVk1lc3NhZ2V9IG1lc3NhZ2Ug6KKr5pKk5Zue55qE5raI5oGvXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NvbnZlcnNhdGlvbkJhc2V9IGNvbnZlcnNhdGlvbiDmtojmga/miYDlnKjnmoTkvJror51cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgX3RoaXMzLmVtaXQoTUVTU0FHRV9SRUNBTEwkMSwgbWVzc2FnZSwgY29udmVyc2F0aW9uKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5raI5oGv6KKr5pKk5ZueXG4gICAgICAgICAgICAgKiBAZXZlbnQgQ29udmVyc2F0aW9uQmFzZSNNRVNTQUdFX1JFQ0FMTFxuICAgICAgICAgICAgICogQHBhcmFtIHtBVk1lc3NhZ2V9IG1lc3NhZ2Ug6KKr5pKk5Zue55qE5raI5oGvXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5lbWl0KE1FU1NBR0VfUkVDQUxMJDEsIG1lc3NhZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOa2iOaBr+iiq+S/ruaUuVxuICAgICAgICAgICAgICogQGV2ZW50IElNQ2xpZW50I01FU1NBR0VfVVBEQVRFXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FWTWVzc2FnZX0gbWVzc2FnZSDooqvkv67mlLnnmoTmtojmga9cbiAgICAgICAgICAgICAqIEBwYXJhbSB7Q29udmVyc2F0aW9uQmFzZX0gY29udmVyc2F0aW9uIOa2iOaBr+aJgOWcqOeahOS8muivnVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfdGhpczMuZW1pdChNRVNTQUdFX1VQREFURSQxLCBtZXNzYWdlLCBjb252ZXJzYXRpb24pO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiDmtojmga/ooqvkv67mlLlcbiAgICAgICAgICAgICAqIEBldmVudCBDb252ZXJzYXRpb25CYXNlI01FU1NBR0VfVVBEQVRFXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FWTWVzc2FnZX0gbWVzc2FnZSDooqvkv67mlLnnmoTmtojmga9cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29udmVyc2F0aW9uLmVtaXQoTUVTU0FHRV9VUERBVEUkMSwgbWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfTtcblxuICBJTUNsaWVudC5wcm90b3R5cGUuX2Rpc3BhdGNoQ29udk1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWY4ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KG1lc3NhZ2UpIHtcbiAgICAgIHZhciBjb252TWVzc2FnZSwgX21lc3NhZ2UkY29udk1lc3NhZ2UsIGluaXRCeSwgbSwgaW5mbywgYXR0ciwgY29udmVyc2F0aW9uLCBwYXlsb2FkLCBfcGF5bG9hZCwgX3BheWxvYWQyLCBfcGF5bG9hZDMsIF9wYXlsb2FkNCwgX3BheWxvYWQ1LCBfcGF5bG9hZDYsIF9wYXlsb2FkNywgX3BheWxvYWQ4LCBfcGF5bG9hZDksIF9wYXlsb2FkMTAsIF9wYXlsb2FkMTEsIHBpZCwgcm9sZSwgX2ludGVybmFsLCBtZW1iZXJJbmZvTWFwLCBtZW1iZXJJbmZvLCBfcGF5bG9hZDEyLCBhdHRyaWJ1dGVzLCBfcGF5bG9hZDEzO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGNvbnZNZXNzYWdlID0gbWVzc2FnZS5jb252TWVzc2FnZSwgX21lc3NhZ2UkY29udk1lc3NhZ2UgPSBtZXNzYWdlLmNvbnZNZXNzYWdlLCBpbml0QnkgPSBfbWVzc2FnZSRjb252TWVzc2FnZS5pbml0QnksIG0gPSBfbWVzc2FnZSRjb252TWVzc2FnZS5tLCBpbmZvID0gX21lc3NhZ2UkY29udk1lc3NhZ2UuaW5mbywgYXR0ciA9IF9tZXNzYWdlJGNvbnZNZXNzYWdlLmF0dHI7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29udmVyc2F0aW9uKGNvbnZNZXNzYWdlLmNpZCk7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY29udmVyc2F0aW9uID0gX2NvbnRleHQ0LnNlbnQ7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC50MCA9IG1lc3NhZ2Uub3A7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gX2NvbnRleHQ0LnQwID09PSBPcFR5cGUuam9pbmVkID8gNyA6IF9jb250ZXh0NC50MCA9PT0gT3BUeXBlLmxlZnQgPyAxMiA6IF9jb250ZXh0NC50MCA9PT0gT3BUeXBlLm1lbWJlcnNfam9pbmVkID8gMTcgOiBfY29udGV4dDQudDAgPT09IE9wVHlwZS5tZW1iZXJzX2xlZnQgPyAyMiA6IF9jb250ZXh0NC50MCA9PT0gT3BUeXBlLm1lbWJlcnNfYmxvY2tlZCA/IDI3IDogX2NvbnRleHQ0LnQwID09PSBPcFR5cGUubWVtYmVyc191bmJsb2NrZWQgPyAzMSA6IF9jb250ZXh0NC50MCA9PT0gT3BUeXBlLmJsb2NrZWQgPyAzNSA6IF9jb250ZXh0NC50MCA9PT0gT3BUeXBlLnVuYmxvY2tlZCA/IDM5IDogX2NvbnRleHQ0LnQwID09PSBPcFR5cGUubWVtYmVyc19zaHV0dXBlZCA/IDQzIDogX2NvbnRleHQ0LnQwID09PSBPcFR5cGUubWVtYmVyc191bnNodXR1cGVkID8gNDcgOiBfY29udGV4dDQudDAgPT09IE9wVHlwZS5zaHV0dXBlZCA/IDUxIDogX2NvbnRleHQ0LnQwID09PSBPcFR5cGUudW5zaHV0dXBlZCA/IDU1IDogX2NvbnRleHQ0LnQwID09PSBPcFR5cGUubWVtYmVyX2luZm9fY2hhbmdlZCA/IDU5IDogX2NvbnRleHQ0LnQwID09PSBPcFR5cGUudXBkYXRlZCA/IDcxIDogNzc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGlmICghY29udmVyc2F0aW9uLnRyYW5zaWVudCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5tZW1iZXJzID0gdW5pb24oY29udmVyc2F0aW9uLm1lbWJlcnMsIFt0aGlzLmlkXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBpbnZpdGVkQnk6IGluaXRCeVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICog5b2T5YmN55So5oi36KKr5re75Yqg6Iez5p+Q5Liq5a+56K+dXG4gICAgICAgICAgICAgICAqIEBldmVudCBJTUNsaWVudCNJTlZJVEVEXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXlsb2FkLmludml0ZWRCeSDpgoDor7fogIUgaWRcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtDb252ZXJzYXRpb25CYXNlfSBjb252ZXJzYXRpb25cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgdGhpcy5lbWl0KElOVklURUQkMSwgcGF5bG9hZCwgY29udmVyc2F0aW9uKTtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIOW9k+WJjeeUqOaIt+iiq+a3u+WKoOiHs+W9k+WJjeWvueivnVxuICAgICAgICAgICAgICAgKiBAZXZlbnQgQ29udmVyc2F0aW9uQmFzZSNJTlZJVEVEXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXlsb2FkLmludml0ZWRCeSDor6Xnp7vpmaTmk43kvZznmoTlj5HotbfogIUgaWRcbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5lbWl0KElOVklURUQkMSwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCdyZXR1cm4nKTtcblxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgaWYgKCFjb252ZXJzYXRpb24udHJhbnNpZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgY29udmVyc2F0aW9uLm1lbWJlcnMgPSBkaWZmZXJlbmNlKGNvbnZlcnNhdGlvbi5tZW1iZXJzLCBbdGhpcy5pZF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9wYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIGtpY2tlZEJ5OiBpbml0QnlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIOW9k+WJjeeUqOaIt+iiq+S7juafkOS4quWvueivneS4reenu+mZpFxuICAgICAgICAgICAgICAgKiBAZXZlbnQgSU1DbGllbnQjS0lDS0VEXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXlsb2FkLmtpY2tlZEJ5IOivpeenu+mZpOaTjeS9nOeahOWPkei1t+iAhSBpZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge0NvbnZlcnNhdGlvbkJhc2V9IGNvbnZlcnNhdGlvblxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICB0aGlzLmVtaXQoS0lDS0VEJDEsIF9wYXlsb2FkLCBjb252ZXJzYXRpb24pO1xuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICog5b2T5YmN55So5oi36KKr5LuO5b2T5YmN5a+56K+d5Lit56e76ZmkXG4gICAgICAgICAgICAgICAqIEBldmVudCBDb252ZXJzYXRpb25CYXNlI0tJQ0tFRFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF5bG9hZC5raWNrZWRCeSDor6Xnp7vpmaTmk43kvZznmoTlj5HotbfogIUgaWRcbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5lbWl0KEtJQ0tFRCQxLCBfcGF5bG9hZCk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCdyZXR1cm4nKTtcblxuICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgaWYgKCFjb252ZXJzYXRpb24udHJhbnNpZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgY29udmVyc2F0aW9uLm1lbWJlcnMgPSB1bmlvbihjb252ZXJzYXRpb24ubWVtYmVycywgY29udk1lc3NhZ2UubSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3BheWxvYWQyID0ge1xuICAgICAgICAgICAgICAgIGludml0ZWRCeTogaW5pdEJ5LFxuICAgICAgICAgICAgICAgIG1lbWJlcnM6IG1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIOacieeUqOaIt+iiq+a3u+WKoOiHs+afkOS4quWvueivnVxuICAgICAgICAgICAgICAgKiBAZXZlbnQgSU1DbGllbnQjTUVNQkVSU19KT0lORURcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gcGF5bG9hZC5tZW1iZXJzIOiiq+a3u+WKoOeahOeUqOaItyBpZCDliJfooahcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBheWxvYWQuaW52aXRlZEJ5IOmCgOivt+iAhSBpZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge0NvbnZlcnNhdGlvbkJhc2V9IGNvbnZlcnNhdGlvblxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICB0aGlzLmVtaXQoTUVNQkVSU19KT0lORUQkMSwgX3BheWxvYWQyLCBjb252ZXJzYXRpb24pO1xuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICog5pyJ5oiQ5ZGY6KKr5re75Yqg6Iez5b2T5YmN5a+56K+dXG4gICAgICAgICAgICAgICAqIEBldmVudCBDb252ZXJzYXRpb25CYXNlI01FTUJFUlNfSk9JTkVEXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHBheWxvYWQubWVtYmVycyDooqvmt7vliqDnmoTmiJDlkZggaWQg5YiX6KGoXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXlsb2FkLmludml0ZWRCeSDpgoDor7fogIUgaWRcbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5lbWl0KE1FTUJFUlNfSk9JTkVEJDEsIF9wYXlsb2FkMik7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCdyZXR1cm4nKTtcblxuICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgaWYgKCFjb252ZXJzYXRpb24udHJhbnNpZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgY29udmVyc2F0aW9uLm1lbWJlcnMgPSBkaWZmZXJlbmNlKGNvbnZlcnNhdGlvbi5tZW1iZXJzLCBjb252TWVzc2FnZS5tKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfcGF5bG9hZDMgPSB7XG4gICAgICAgICAgICAgICAga2lja2VkQnk6IGluaXRCeSxcbiAgICAgICAgICAgICAgICBtZW1iZXJzOiBtXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiDmnInmiJDlkZjooqvku47mn5DkuKrlr7nor53kuK3np7vpmaRcbiAgICAgICAgICAgICAgICogQGV2ZW50IElNQ2xpZW50I01FTUJFUlNfTEVGVFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXlsb2FkLm1lbWJlcnMg6KKr56e76Zmk55qE5oiQ5ZGYIGlkIOWIl+ihqFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF5bG9hZC5raWNrZWRCeSDor6Xnp7vpmaTmk43kvZznmoTlj5HotbfogIUgaWRcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtDb252ZXJzYXRpb25CYXNlfSBjb252ZXJzYXRpb25cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgdGhpcy5lbWl0KE1FTUJFUlNfTEVGVCQxLCBfcGF5bG9hZDMsIGNvbnZlcnNhdGlvbik7XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiDmnInmiJDlkZjooqvku47lvZPliY3lr7nor53kuK3np7vpmaRcbiAgICAgICAgICAgICAgICogQGV2ZW50IENvbnZlcnNhdGlvbkJhc2UjTUVNQkVSU19MRUZUXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHBheWxvYWQubWVtYmVycyDooqvnp7vpmaTnmoTmiJDlkZggaWQg5YiX6KGoXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXlsb2FkLmtpY2tlZEJ5IOivpeenu+mZpOaTjeS9nOeahOWPkei1t+iAhSBpZFxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgY29udmVyc2F0aW9uLmVtaXQoTUVNQkVSU19MRUZUJDEsIF9wYXlsb2FkMyk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCdyZXR1cm4nKTtcblxuICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgX3BheWxvYWQ0ID0ge1xuICAgICAgICAgICAgICAgIGJsb2NrZWRCeTogaW5pdEJ5LFxuICAgICAgICAgICAgICAgIG1lbWJlcnM6IG1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIOacieaIkOWRmOiiq+WKoOWFpeafkOS4quWvueivneeahOm7keWQjeWNlVxuICAgICAgICAgICAgICAgKiBAZXZlbnQgSU1DbGllbnQjTUVNQkVSU19CTE9DS0VEXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHBheWxvYWQubWVtYmVycyDmiJDlkZggaWQg5YiX6KGoXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXlsb2FkLmJsb2NrZWRCeSDor6Xmk43kvZznmoTlj5HotbfogIUgaWRcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtDb252ZXJzYXRpb25CYXNlfSBjb252ZXJzYXRpb25cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgdGhpcy5lbWl0KE1FTUJFUlNfQkxPQ0tFRCQxLCBfcGF5bG9hZDQsIGNvbnZlcnNhdGlvbik7XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiDmnInmiJDlkZjooqvliqDlhaXlvZPliY3lr7nor53nmoTpu5HlkI3ljZVcbiAgICAgICAgICAgICAgICogQGV2ZW50IENvbnZlcnNhdGlvbkJhc2UjTUVNQkVSU19CTE9DS0VEXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nW119IHBheWxvYWQubWVtYmVycyDmiJDlkZggaWQg5YiX6KGoXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXlsb2FkLmJsb2NrZWRCeSDor6Xmk43kvZznmoTlj5HotbfogIUgaWRcbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5lbWl0KE1FTUJFUlNfQkxPQ0tFRCQxLCBfcGF5bG9hZDQpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdCgncmV0dXJuJyk7XG5cbiAgICAgICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgICAgIF9wYXlsb2FkNSA9IHtcbiAgICAgICAgICAgICAgICB1bmJsb2NrZWRCeTogaW5pdEJ5LFxuICAgICAgICAgICAgICAgIG1lbWJlcnM6IG1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIOacieaIkOWRmOiiq+enu+WHuuafkOS4quWvueivneeahOm7keWQjeWNlVxuICAgICAgICAgICAgICAgKiBAZXZlbnQgSU1DbGllbnQjTUVNQkVSU19VTkJMT0NLRURcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gcGF5bG9hZC5tZW1iZXJzIOaIkOWRmCBpZCDliJfooahcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBheWxvYWQudW5ibG9ja2VkQnkg6K+l5pON5L2c55qE5Y+R6LW36ICFIGlkXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7Q29udmVyc2F0aW9uQmFzZX0gY29udmVyc2F0aW9uXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgIHRoaXMuZW1pdChNRU1CRVJTX1VOQkxPQ0tFRCQxLCBfcGF5bG9hZDUsIGNvbnZlcnNhdGlvbik7XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiDmnInmiJDlkZjooqvnp7vlh7rlvZPliY3lr7nor53nmoTpu5HlkI3ljZVcbiAgICAgICAgICAgICAgICogQGV2ZW50IENvbnZlcnNhdGlvbkJhc2UjTUVNQkVSU19VTkJMT0NLRURcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gcGF5bG9hZC5tZW1iZXJzIOaIkOWRmCBpZCDliJfooahcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBheWxvYWQudW5ibG9ja2VkQnkg6K+l5pON5L2c55qE5Y+R6LW36ICFIGlkXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBjb252ZXJzYXRpb24uZW1pdChNRU1CRVJTX1VOQkxPQ0tFRCQxLCBfcGF5bG9hZDUpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdCgncmV0dXJuJyk7XG5cbiAgICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICAgIF9wYXlsb2FkNiA9IHtcbiAgICAgICAgICAgICAgICBibG9ja2VkQnk6IGluaXRCeVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICog5b2T5YmN55So5oi36KKr5Yqg5YWl5p+Q5Liq5a+56K+d55qE6buR5ZCN5Y2VXG4gICAgICAgICAgICAgICAqIEBldmVudCBJTUNsaWVudCNCTE9DS0VEXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXlsb2FkYmxvY2tlZEJ5IOivpeaTjeS9nOeahOWPkei1t+iAhSBpZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge0NvbnZlcnNhdGlvbkJhc2V9IGNvbnZlcnNhdGlvblxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICB0aGlzLmVtaXQoQkxPQ0tFRCQxLCBfcGF5bG9hZDYsIGNvbnZlcnNhdGlvbik7XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiDlvZPliY3nlKjmiLfooqvliqDlhaXlvZPliY3lr7nor53nmoTpu5HlkI3ljZVcbiAgICAgICAgICAgICAgICogQGV2ZW50IENvbnZlcnNhdGlvbkJhc2UjQkxPQ0tFRFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF5bG9hZC5ibG9ja2VkQnkg6K+l5pON5L2c55qE5Y+R6LW36ICFIGlkXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBjb252ZXJzYXRpb24uZW1pdChCTE9DS0VEJDEsIF9wYXlsb2FkNik7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCdyZXR1cm4nKTtcblxuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgX3BheWxvYWQ3ID0ge1xuICAgICAgICAgICAgICAgIHVuYmxvY2tlZEJ5OiBpbml0QnlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIOW9k+WJjeeUqOaIt+iiq+enu+WHuuafkOS4quWvueivneeahOm7keWQjeWNlVxuICAgICAgICAgICAgICAgKiBAZXZlbnQgSU1DbGllbnQjVU5CTE9DS0VEXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXlsb2FkLnVuYmxvY2tlZEJ5IOivpeaTjeS9nOeahOWPkei1t+iAhSBpZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge0NvbnZlcnNhdGlvbkJhc2V9IGNvbnZlcnNhdGlvblxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICB0aGlzLmVtaXQoVU5CTE9DS0VEJDEsIF9wYXlsb2FkNywgY29udmVyc2F0aW9uKTtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIOW9k+WJjeeUqOaIt+iiq+enu+WHuuW9k+WJjeWvueivneeahOm7keWQjeWNlVxuICAgICAgICAgICAgICAgKiBAZXZlbnQgQ29udmVyc2F0aW9uQmFzZSNVTkJMT0NLRURcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBheWxvYWQudW5ibG9ja2VkQnkg6K+l5pON5L2c55qE5Y+R6LW36ICFIGlkXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBjb252ZXJzYXRpb24uZW1pdChVTkJMT0NLRUQkMSwgX3BheWxvYWQ3KTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoJ3JldHVybicpO1xuXG4gICAgICAgICAgICBjYXNlIDQzOlxuICAgICAgICAgICAgICBfcGF5bG9hZDggPSB7XG4gICAgICAgICAgICAgICAgbXV0ZWRCeTogaW5pdEJ5LFxuICAgICAgICAgICAgICAgIG1lbWJlcnM6IG1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIOacieaIkOWRmOWcqOafkOS4quWvueivneS4reiiq+emgeiogFxuICAgICAgICAgICAgICAgKiBAZXZlbnQgSU1DbGllbnQjTUVNQkVSU19NVVRFRFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXlsb2FkLm1lbWJlcnMg5oiQ5ZGYIGlkIOWIl+ihqFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF5bG9hZC5tdXRlZEJ5IOivpeaTjeS9nOeahOWPkei1t+iAhSBpZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge0NvbnZlcnNhdGlvbkJhc2V9IGNvbnZlcnNhdGlvblxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICB0aGlzLmVtaXQoTUVNQkVSU19NVVRFRCQxLCBfcGF5bG9hZDgsIGNvbnZlcnNhdGlvbik7XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiDmnInmiJDlkZjlnKjlvZPliY3lr7nor53kuK3ooqvnpoHoqIBcbiAgICAgICAgICAgICAgICogQGV2ZW50IENvbnZlcnNhdGlvbkJhc2UjTUVNQkVSU19NVVRFRFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXlsb2FkLm1lbWJlcnMg5oiQ5ZGYIGlkIOWIl+ihqFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF5bG9hZC5tdXRlZEJ5IOivpeaTjeS9nOeahOWPkei1t+iAhSBpZFxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgY29udmVyc2F0aW9uLmVtaXQoTUVNQkVSU19NVVRFRCQxLCBfcGF5bG9hZDgpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdCgncmV0dXJuJyk7XG5cbiAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgIF9wYXlsb2FkOSA9IHtcbiAgICAgICAgICAgICAgICB1bm11dGVkQnk6IGluaXRCeSxcbiAgICAgICAgICAgICAgICBtZW1iZXJzOiBtXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiDmnInmiJDlkZjlnKjmn5DkuKrlr7nor53kuK3ooqvop6PpmaTnpoHoqIBcbiAgICAgICAgICAgICAgICogQGV2ZW50IElNQ2xpZW50I01FTUJFUlNfVU5NVVRFRFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXlsb2FkLm1lbWJlcnMg5oiQ5ZGYIGlkIOWIl+ihqFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF5bG9hZC51bm11dGVkQnkg6K+l5pON5L2c55qE5Y+R6LW36ICFIGlkXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7Q29udmVyc2F0aW9uQmFzZX0gY29udmVyc2F0aW9uXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgIHRoaXMuZW1pdChNRU1CRVJTX1VOTVVURUQkMSwgX3BheWxvYWQ5LCBjb252ZXJzYXRpb24pO1xuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICog5pyJ5oiQ5ZGY5Zyo5b2T5YmN5a+56K+d5Lit6KKr6Kej6Zmk56aB6KiAXG4gICAgICAgICAgICAgICAqIEBldmVudCBDb252ZXJzYXRpb25CYXNlI01FTUJFUlNfVU5NVVRFRFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXlsb2FkLm1lbWJlcnMg5oiQ5ZGYIGlkIOWIl+ihqFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF5bG9hZC51bm11dGVkQnkg6K+l5pON5L2c55qE5Y+R6LW36ICFIGlkXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBjb252ZXJzYXRpb24uZW1pdChNRU1CRVJTX1VOTVVURUQkMSwgX3BheWxvYWQ5KTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoJ3JldHVybicpO1xuXG4gICAgICAgICAgICBjYXNlIDUxOlxuICAgICAgICAgICAgICBfcGF5bG9hZDEwID0ge1xuICAgICAgICAgICAgICAgIG11dGVkQnk6IGluaXRCeVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICog5pyJ5oiQ5ZGY5Zyo5p+Q5Liq5a+56K+d5Lit6KKr56aB6KiAXG4gICAgICAgICAgICAgICAqIEBldmVudCBJTUNsaWVudCNNVVRFRFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF5bG9hZC5tdXRlZEJ5IOivpeaTjeS9nOeahOWPkei1t+iAhSBpZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge0NvbnZlcnNhdGlvbkJhc2V9IGNvbnZlcnNhdGlvblxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICB0aGlzLmVtaXQoTVVURUQkMSwgX3BheWxvYWQxMCwgY29udmVyc2F0aW9uKTtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIOacieaIkOWRmOWcqOW9k+WJjeWvueivneS4reiiq+emgeiogFxuICAgICAgICAgICAgICAgKiBAZXZlbnQgQ29udmVyc2F0aW9uQmFzZSNNVVRFRFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF5bG9hZC5tdXRlZEJ5IOivpeaTjeS9nOeahOWPkei1t+iAhSBpZFxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgY29udmVyc2F0aW9uLmVtaXQoTVVURUQkMSwgX3BheWxvYWQxMCk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCdyZXR1cm4nKTtcblxuICAgICAgICAgICAgY2FzZSA1NTpcbiAgICAgICAgICAgICAgX3BheWxvYWQxMSA9IHtcbiAgICAgICAgICAgICAgICB1bm11dGVkQnk6IGluaXRCeVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICog5pyJ5oiQ5ZGY5Zyo5p+Q5Liq5a+56K+d5Lit6KKr6Kej6Zmk56aB6KiAXG4gICAgICAgICAgICAgICAqIEBldmVudCBJTUNsaWVudCNVTk1VVEVEXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXlsb2FkLnVubXV0ZWRCeSDor6Xmk43kvZznmoTlj5HotbfogIUgaWRcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtDb252ZXJzYXRpb25CYXNlfSBjb252ZXJzYXRpb25cbiAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgdGhpcy5lbWl0KFVOTVVURUQkMSwgX3BheWxvYWQxMSwgY29udmVyc2F0aW9uKTtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIOacieaIkOWRmOWcqOW9k+WJjeWvueivneS4reiiq+ino+mZpOemgeiogFxuICAgICAgICAgICAgICAgKiBAZXZlbnQgQ29udmVyc2F0aW9uQmFzZSNVTk1VVEVEXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXlsb2FkLnVubXV0ZWRCeSDor6Xmk43kvZznmoTlj5HotbfogIUgaWRcbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5lbWl0KFVOTVVURUQkMSwgX3BheWxvYWQxMSk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCdyZXR1cm4nKTtcblxuICAgICAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgICAgICAgcGlkID0gaW5mby5waWQsIHJvbGUgPSBpbmZvLnJvbGU7XG4gICAgICAgICAgICAgIF9pbnRlcm5hbCA9IGludGVybmFsKGNvbnZlcnNhdGlvbiksIG1lbWJlckluZm9NYXAgPSBfaW50ZXJuYWwubWVtYmVySW5mb01hcDtcbiAgICAgICAgICAgICAgLy8g5aaC5p6c5LiN5a2Y5Zyo57yT5a2Y77yM5LiU5LiN5pivIHJvbGUg55qE5pu05paw77yM5YiZ5LiN6YCa55+lXG5cbiAgICAgICAgICAgICAgaWYgKCEoIW1lbWJlckluZm9NYXAgJiYgIXJvbGUpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA2MztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCdyZXR1cm4nKTtcblxuICAgICAgICAgICAgY2FzZSA2MzpcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA2NTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnNhdGlvbi5nZXRNZW1iZXJJbmZvKHBpZCk7XG5cbiAgICAgICAgICAgIGNhc2UgNjU6XG4gICAgICAgICAgICAgIG1lbWJlckluZm8gPSBfY29udGV4dDQuc2VudDtcblxuICAgICAgICAgICAgICBpbnRlcm5hbChtZW1iZXJJbmZvKS5yb2xlID0gcm9sZTtcbiAgICAgICAgICAgICAgX3BheWxvYWQxMiA9IHtcbiAgICAgICAgICAgICAgICBtZW1iZXI6IHBpZCxcbiAgICAgICAgICAgICAgICBtZW1iZXJJbmZvOiBtZW1iZXJJbmZvLFxuICAgICAgICAgICAgICAgIHVwZGF0ZWRCeTogaW5pdEJ5XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiDmnInmiJDlkZjnmoTlr7nor53kv6Hmga/ooqvmm7TmlrBcbiAgICAgICAgICAgICAgICogQGV2ZW50IElNQ2xpZW50I01FTUJFUl9JTkZPX1VQREFURURcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmdbXX0gcGF5bG9hZC5tZW1iZXIg6KKr5pu05paw5a+56K+d5L+h5oGv55qE5oiQ5ZGYIGlkXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7Q29udmVyc2F0aW9uTXVtYmVySW5mb30gcGF5bG9hZC5tZW1iZXJJbmZvIOiiq+abtOaWsOeahOaIkOWRmOWvueivneS/oeaBr1xuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF5bG9hZC51cGRhdGVkQnkg6K+l5pON5L2c55qE5Y+R6LW36ICFIGlkXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7Q29udmVyc2F0aW9uQmFzZX0gY29udmVyc2F0aW9uXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgIHRoaXMuZW1pdChNRU1CRVJfSU5GT19VUERBVEVEJDEsIF9wYXlsb2FkMTIsIGNvbnZlcnNhdGlvbik7XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiDmnInmiJDlkZjnmoTlr7nor53kv6Hmga/ooqvmm7TmlrBcbiAgICAgICAgICAgICAgICogQGV2ZW50IENvbnZlcnNhdGlvbkJhc2UjTUVNQkVSX0lORk9fVVBEQVRFRFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXlsb2FkLm1lbWJlciDooqvmm7TmlrDlr7nor53kv6Hmga/nmoTmiJDlkZggaWRcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtDb252ZXJzYXRpb25NdW1iZXJJbmZvfSBwYXlsb2FkLm1lbWJlckluZm8g6KKr5pu05paw55qE5oiQ5ZGY5a+56K+d5L+h5oGvXG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXlsb2FkLnVwZGF0ZWRCeSDor6Xmk43kvZznmoTlj5HotbfogIUgaWRcbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5lbWl0KE1FTUJFUl9JTkZPX1VQREFURUQkMSwgX3BheWxvYWQxMik7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCdyZXR1cm4nKTtcblxuICAgICAgICAgICAgY2FzZSA3MTpcbiAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IGRlY29kZShKU09OLnBhcnNlKGF0dHIuZGF0YSkpO1xuXG4gICAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5fdXBkYXRlU2VydmVyQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgX3BheWxvYWQxMyA9IHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIHVwZGF0ZWRCeTogaW5pdEJ5XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiDor6Xlr7nor53kv6Hmga/ooqvmm7TmlrBcbiAgICAgICAgICAgICAgICogQGV2ZW50IElNQ2xpZW50I0NPTlZFUlNBVElPTl9JTkZPX1VQREFURURcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQuYXR0cmlidXRlcyDooqvmm7TmlrDnmoTlsZ7mgKdcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBheWxvYWQudXBkYXRlZEJ5IOivpeaTjeS9nOeahOWPkei1t+iAhSBpZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge0NvbnZlcnNhdGlvbkJhc2V9IGNvbnZlcnNhdGlvblxuICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICB0aGlzLmVtaXQoQ09OVkVSU0FUSU9OX0lORk9fVVBEQVRFRCQxLCBfcGF5bG9hZDEzLCBjb252ZXJzYXRpb24pO1xuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICog5pyJ5a+56K+d5L+h5oGv6KKr5pu05pawXG4gICAgICAgICAgICAgICAqIEBldmVudCBDb252ZXJzYXRpb25CYXNlI0lORk9fVVBEQVRFRFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZC5hdHRyaWJ1dGVzIOiiq+abtOaWsOeahOWxnuaAp1xuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF5bG9hZC51cGRhdGVkQnkg6K+l5pON5L2c55qE5Y+R6LW36ICFIGlkXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBjb252ZXJzYXRpb24uZW1pdChJTkZPX1VQREFURUQkMSwgX3BheWxvYWQxMyk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KCdyZXR1cm4nKTtcblxuICAgICAgICAgICAgY2FzZSA3NzpcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KFVOSEFORExFRF9NRVNTQUdFJDEsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBjb252ZXJzYXRpb24gY29tbWFuZCcpO1xuXG4gICAgICAgICAgICBjYXNlIDc5OlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gX2Rpc3BhdGNoQ29udk1lc3NhZ2UoX3g1KSB7XG4gICAgICByZXR1cm4gX3JlZjguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2Rpc3BhdGNoQ29udk1lc3NhZ2U7XG4gIH0oKTtcblxuICBJTUNsaWVudC5wcm90b3R5cGUuX2Rpc3BhdGNoRGlyZWN0TWVzc2FnZSA9IGZ1bmN0aW9uIF9kaXNwYXRjaERpcmVjdE1lc3NhZ2Uob3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgZGlyZWN0TWVzc2FnZSA9IG9yaWdpbmFsTWVzc2FnZS5kaXJlY3RNZXNzYWdlLFxuICAgICAgICBfb3JpZ2luYWxNZXNzYWdlJGRpcmUgPSBvcmlnaW5hbE1lc3NhZ2UuZGlyZWN0TWVzc2FnZSxcbiAgICAgICAgaWQgPSBfb3JpZ2luYWxNZXNzYWdlJGRpcmUuaWQsXG4gICAgICAgIGNpZCA9IF9vcmlnaW5hbE1lc3NhZ2UkZGlyZS5jaWQsXG4gICAgICAgIGZyb21QZWVySWQgPSBfb3JpZ2luYWxNZXNzYWdlJGRpcmUuZnJvbVBlZXJJZCxcbiAgICAgICAgdGltZXN0YW1wID0gX29yaWdpbmFsTWVzc2FnZSRkaXJlLnRpbWVzdGFtcCxcbiAgICAgICAgdHJhbnNpZW50ID0gX29yaWdpbmFsTWVzc2FnZSRkaXJlLnRyYW5zaWVudCxcbiAgICAgICAgcGF0Y2hUaW1lc3RhbXAgPSBfb3JpZ2luYWxNZXNzYWdlJGRpcmUucGF0Y2hUaW1lc3RhbXAsXG4gICAgICAgIG1lbnRpb25QaWRzID0gX29yaWdpbmFsTWVzc2FnZSRkaXJlLm1lbnRpb25QaWRzLFxuICAgICAgICBtZW50aW9uQWxsID0gX29yaWdpbmFsTWVzc2FnZSRkaXJlLm1lbnRpb25BbGwsXG4gICAgICAgIGJpbmFyeU1zZyA9IF9vcmlnaW5hbE1lc3NhZ2UkZGlyZS5iaW5hcnlNc2csXG4gICAgICAgIG1zZyA9IF9vcmlnaW5hbE1lc3NhZ2UkZGlyZS5tc2c7XG5cbiAgICB2YXIgY29udGVudCA9IGJpbmFyeU1zZyA/IGJpbmFyeU1zZy50b0FycmF5QnVmZmVyKCkgOiBtc2c7XG4gICAgcmV0dXJuIF9Qcm9taXNlLmFsbChbdGhpcy5nZXRDb252ZXJzYXRpb24oZGlyZWN0TWVzc2FnZS5jaWQpLCB0aGlzLl9tZXNzYWdlUGFyc2VyLnBhcnNlKGNvbnRlbnQpXSkudGhlbihmdW5jdGlvbiAoX3JlZjkpIHtcbiAgICAgIHZhciBfcmVmMTAgPSBfc2xpY2VkVG9BcnJheShfcmVmOSwgMiksXG4gICAgICAgICAgY29udmVyc2F0aW9uID0gX3JlZjEwWzBdLFxuICAgICAgICAgIG1lc3NhZ2UgPSBfcmVmMTBbMV07XG5cbiAgICAgIC8vIGRlbGV0ZWQgY29udmVyc2F0aW9uXG4gICAgICBpZiAoIWNvbnZlcnNhdGlvbikgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciBtZXNzYWdlUHJvcHMgPSB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgY2lkOiBjaWQsXG4gICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICB1cGRhdGVkQXQ6IHBhdGNoVGltZXN0YW1wLFxuICAgICAgICBmcm9tOiBmcm9tUGVlcklkLFxuICAgICAgICBtZW50aW9uTGlzdDogbWVudGlvblBpZHMsXG4gICAgICAgIG1lbnRpb25lZEFsbDogbWVudGlvbkFsbFxuICAgICAgfTtcbiAgICAgIF9PYmplY3QkYXNzaWduKG1lc3NhZ2UsIG1lc3NhZ2VQcm9wcyk7XG4gICAgICBtZXNzYWdlLl91cGRhdGVNZW50aW9uZWQoX3RoaXM0LmlkKTtcbiAgICAgIG1lc3NhZ2UuX3NldFN0YXR1cyhNZXNzYWdlU3RhdHVzLlNFTlQpO1xuICAgICAgLy8gZmlsdGVyIG91dGdvaW5nIG1lc3NhZ2Ugc2VudCBmcm9tIGFub3RoZXIgZGV2aWNlXG4gICAgICBpZiAobWVzc2FnZS5mcm9tICE9PSBfdGhpczQuaWQpIHtcbiAgICAgICAgaWYgKCEodHJhbnNpZW50IHx8IGNvbnZlcnNhdGlvbi50cmFuc2llbnQpKSB7XG4gICAgICAgICAgX3RoaXM0Ll9zZW5kQWNrKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3RoaXM0Ll9kaXNwYXRjaFBhcnNlZE1lc3NhZ2UobWVzc2FnZSwgY29udmVyc2F0aW9uKTtcbiAgICB9KTtcbiAgfTtcblxuICBJTUNsaWVudC5wcm90b3R5cGUuX2Rpc3BhdGNoUGFyc2VkTWVzc2FnZSA9IGZ1bmN0aW9uIF9kaXNwYXRjaFBhcnNlZE1lc3NhZ2UobWVzc2FnZSwgY29udmVyc2F0aW9uKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAvLyBiZWZvcmVNZXNzYWdlRGlzcGF0Y2ggaG9va1xuICAgIHJldHVybiBhcHBseURpc3BhdGNoZXIodGhpcy5fcGx1Z2lucy5iZWZvcmVNZXNzYWdlRGlzcGF0Y2gsIFttZXNzYWdlLCBjb252ZXJzYXRpb25dKS50aGVuKGZ1bmN0aW9uIChzaG91bGREaXNwYXRjaCkge1xuICAgICAgaWYgKHNob3VsZERpc3BhdGNoID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlID0gbWVzc2FnZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlQXQgPSBtZXNzYWdlLnRpbWVzdGFtcDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgLy8gZmlsdGVyIG91dGdvaW5nIG1lc3NhZ2Ugc2VudCBmcm9tIGFub3RoZXIgZGV2aWNlXG4gICAgICBpZiAobWVzc2FnZS5mcm9tICE9PSBfdGhpczUuaWQpIHtcbiAgICAgICAgY29udmVyc2F0aW9uLnVucmVhZE1lc3NhZ2VzQ291bnQgKz0gMTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBpZiAobWVzc2FnZS5tZW50aW9uZWQpIGNvbnZlcnNhdGlvbi5fc2V0VW5yZWFkTWVzc2FnZXNNZW50aW9uZWQodHJ1ZSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIOW9k+WJjeeUqOaIt+aUtuWIsOa2iOaBr1xuICAgICAgICogQGV2ZW50IElNQ2xpZW50I01FU1NBR0VcbiAgICAgICAqIEBwYXJhbSB7TWVzc2FnZX0gbWVzc2FnZVxuICAgICAgICogQHBhcmFtIHtDb252ZXJzYXRpb25CYXNlfSBjb252ZXJzYXRpb24g5pS25Yiw5raI5oGv55qE5a+56K+dXG4gICAgICAgKi9cbiAgICAgIF90aGlzNS5lbWl0KE1FU1NBR0UkMiwgbWVzc2FnZSwgY29udmVyc2F0aW9uKTtcbiAgICAgIC8qKlxuICAgICAgICog5b2T5YmN5a+56K+d5pS25Yiw5raI5oGvXG4gICAgICAgKiBAZXZlbnQgQ29udmVyc2F0aW9uQmFzZSNNRVNTQUdFXG4gICAgICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1lc3NhZ2VcbiAgICAgICAqL1xuICAgICAgY29udmVyc2F0aW9uLmVtaXQoTUVTU0FHRSQyLCBtZXNzYWdlKTtcbiAgICB9KTtcbiAgfTtcblxuICBJTUNsaWVudC5wcm90b3R5cGUuX3NlbmRBY2sgPSBmdW5jdGlvbiBfc2VuZEFjayhtZXNzYWdlKSB7XG4gICAgdGhpcy5fZGVidWcoJ3NlbmQgYWNrIGZvciAlTycsIG1lc3NhZ2UpO1xuICAgIHZhciBjaWQgPSBtZXNzYWdlLmNpZDtcblxuICAgIGlmICghY2lkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgY2lkJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fYWNrTWVzc2FnZUJ1ZmZlcltjaWRdKSB7XG4gICAgICB0aGlzLl9hY2tNZXNzYWdlQnVmZmVyW2NpZF0gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5fYWNrTWVzc2FnZUJ1ZmZlcltjaWRdLnB1c2gobWVzc2FnZSk7XG4gICAgcmV0dXJuIHRoaXMuX2RvU2VuZEFjaygpO1xuICB9O1xuXG4gIC8vIGpzZG9jLWlnbm9yZS1zdGFydFxuXG5cbiAgLy8ganNkb2MtaWdub3JlLWVuZFxuICBJTUNsaWVudC5wcm90b3R5cGUuX2RvU2VuZEFjayA9IGZ1bmN0aW9uIF9kb1NlbmRBY2soKSB7XG4gICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAvLyBpZiBub3QgY29ubmVjdGVkLCBqdXN0IHNraXAgZXZlcnl0aGluZ1xuICAgIGlmICghdGhpcy5fY29ubmVjdGlvbi5pcygnY29ubmVjdGVkJykpIHJldHVybjtcbiAgICB0aGlzLl9kZWJ1ZygnZG8gc2VuZCBhY2sgJU8nLCB0aGlzLl9hY2tNZXNzYWdlQnVmZmVyKTtcbiAgICBfUHJvbWlzZS5hbGwoX09iamVjdCRrZXlzKHRoaXMuX2Fja01lc3NhZ2VCdWZmZXIpLm1hcChmdW5jdGlvbiAoY2lkKSB7XG4gICAgICB2YXIgY29udkFja01lc3NhZ2VzID0gX3RoaXM2Ll9hY2tNZXNzYWdlQnVmZmVyW2NpZF07XG4gICAgICB2YXIgdGltZXN0YW1wcyA9IGNvbnZBY2tNZXNzYWdlcy5tYXAoZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UudGltZXN0YW1wO1xuICAgICAgfSk7XG4gICAgICB2YXIgY29tbWFuZCA9IG5ldyBHZW5lcmljQ29tbWFuZCh7XG4gICAgICAgIGNtZDogJ2FjaycsXG4gICAgICAgIHBlZXJJZDogX3RoaXM2LmlkLFxuICAgICAgICBhY2tNZXNzYWdlOiBuZXcgQWNrQ29tbWFuZCh7XG4gICAgICAgICAgY2lkOiBjaWQsXG4gICAgICAgICAgZnJvbXRzOiBNYXRoLm1pbi5hcHBseShudWxsLCB0aW1lc3RhbXBzKSxcbiAgICAgICAgICB0b3RzOiBNYXRoLm1heC5hcHBseShudWxsLCB0aW1lc3RhbXBzKVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBkZWxldGUgX3RoaXM2Ll9hY2tNZXNzYWdlQnVmZmVyW2NpZF07XG4gICAgICByZXR1cm4gX3RoaXM2Ll9zZW5kKGNvbW1hbmQsIGZhbHNlKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IkJDEpIHtcbiAgICAgICAgX3RoaXM2Ll9kZWJ1Zygnc2VuZCBhY2sgZmFpbGVkOiAlTycsIGVycm9yJCQxKTtcbiAgICAgICAgX3RoaXM2Ll9hY2tNZXNzYWdlQnVmZmVyW2NpZF0gPSBjb252QWNrTWVzc2FnZXM7XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH07XG5cbiAgSU1DbGllbnQucHJvdG90eXBlLl9vbWl0UGVlcklkID0gZnVuY3Rpb24gX29taXRQZWVySWQodmFsdWUpIHtcbiAgICBpbnRlcm5hbCh0aGlzKS5wZWVySWRPbWl0dGFibGUgPSB2YWx1ZTtcbiAgfTtcblxuICBJTUNsaWVudC5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbiBfc2VuZChjbWQpIHtcbiAgICB2YXIgX2Nvbm5lY3Rpb247XG5cbiAgICB2YXIgY29tbWFuZCA9IGNtZDtcbiAgICBpZiAoIWludGVybmFsKHRoaXMpLnBlZXJJZE9taXR0YWJsZSAmJiB0aGlzLmlkKSB7XG4gICAgICBjb21tYW5kLnBlZXJJZCA9IHRoaXMuaWQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjMgPiAxID8gX2xlbjMgLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKF9jb25uZWN0aW9uID0gdGhpcy5fY29ubmVjdGlvbikuc2VuZC5hcHBseShfY29ubmVjdGlvbiwgW2NvbW1hbmRdLmNvbmNhdChhcmdzKSk7XG4gIH07XG5cbiAgSU1DbGllbnQucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmMTEgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoYXBwSWQsIHRhZywgZGV2aWNlSWQpIHtcbiAgICAgIHZhciBpc1JlY29ubmVjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgICAgIHZhciBfaW50ZXJuYWwyLCBsYXN0VW5yZWFkTm90aWZUaW1lLCBsYXN0UGF0Y2hUaW1lLCBjb21tYW5kLCBzaWduYXR1cmVSZXN1bHQsIHNlc3Npb25Ub2tlbiwgcmVzQ29tbWFuZCwgX3Jlc0NvbW1hbmQsIHBlZXJJZCwgc2Vzc2lvbk1lc3NhZ2UsIF9yZXNDb21tYW5kJHNlc3Npb25NZSwgdG9rZW4sIHRva2VuVFRMLCBjb2RlO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdvcGVuIHNlc3Npb24nKTtcbiAgICAgICAgICAgICAgX2ludGVybmFsMiA9IGludGVybmFsKHRoaXMpLCBsYXN0VW5yZWFkTm90aWZUaW1lID0gX2ludGVybmFsMi5sYXN0VW5yZWFkTm90aWZUaW1lLCBsYXN0UGF0Y2hUaW1lID0gX2ludGVybmFsMi5sYXN0UGF0Y2hUaW1lO1xuICAgICAgICAgICAgICBjb21tYW5kID0gbmV3IEdlbmVyaWNDb21tYW5kKHtcbiAgICAgICAgICAgICAgICBjbWQ6ICdzZXNzaW9uJyxcbiAgICAgICAgICAgICAgICBvcDogJ29wZW4nLFxuICAgICAgICAgICAgICAgIGFwcElkOiBhcHBJZCxcbiAgICAgICAgICAgICAgICBwZWVySWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbk1lc3NhZ2U6IG5ldyBTZXNzaW9uQ29tbWFuZCh7XG4gICAgICAgICAgICAgICAgICB1YTogJ2pzLycgKyB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgcjogaXNSZWNvbm5lY3QsXG4gICAgICAgICAgICAgICAgICBsYXN0VW5yZWFkTm90aWZUaW1lOiBsYXN0VW5yZWFkTm90aWZUaW1lLFxuICAgICAgICAgICAgICAgICAgbGFzdFBhdGNoVGltZTogbGFzdFBhdGNoVGltZSxcbiAgICAgICAgICAgICAgICAgIGNvbmZpZ0JpdG1hcDogY29uZmlnQml0bWFwXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKGlzUmVjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9PYmplY3QkYXNzaWduKGNvbW1hbmQuc2Vzc2lvbk1lc3NhZ2UsIHRyaW0kMSh7XG4gICAgICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgICAgICAgICAgZGV2aWNlSWQ6IGRldmljZUlkXG4gICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaWduYXR1cmVGYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgcmV0dXJuIHJ1blNpZ25hdHVyZUZhY3RvcnkodGhpcy5vcHRpb25zLnNpZ25hdHVyZUZhY3RvcnksIFt0aGlzLl9pZGVudGl0eV0pO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHNpZ25hdHVyZVJlc3VsdCA9IF9jb250ZXh0NS5zZW50O1xuXG4gICAgICAgICAgICAgIF9PYmplY3QkYXNzaWduKGNvbW1hbmQuc2Vzc2lvbk1lc3NhZ2UsIGtleVJlbWFwKHtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICdzJyxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6ICd0JyxcbiAgICAgICAgICAgICAgICBub25jZTogJ24nXG4gICAgICAgICAgICAgIH0sIHNpZ25hdHVyZVJlc3VsdCkpO1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDE2O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Nlc3Npb25NYW5hZ2VyLmdldFNlc3Npb25Ub2tlbih7XG4gICAgICAgICAgICAgICAgYXV0b1JlZnJlc2g6IGZhbHNlXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBzZXNzaW9uVG9rZW4gPSBfY29udGV4dDUuc2VudDtcblxuICAgICAgICAgICAgICBpZiAoc2Vzc2lvblRva2VuICYmIHNlc3Npb25Ub2tlbiAhPT0gRXhwaXJhYmxlLkVYUElSRUQpIHtcbiAgICAgICAgICAgICAgICBfT2JqZWN0JGFzc2lnbihjb21tYW5kLnNlc3Npb25NZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgICBzdDogc2Vzc2lvblRva2VuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgcmVzQ29tbWFuZCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAxNztcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAyMDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmQoY29tbWFuZCk7XG5cbiAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgIHJlc0NvbW1hbmQgPSBfY29udGV4dDUuc2VudDtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgIF9jb250ZXh0NS5wcmV2ID0gMjM7XG4gICAgICAgICAgICAgIF9jb250ZXh0NS50MCA9IF9jb250ZXh0NVsnY2F0Y2gnXSgxNyk7XG5cbiAgICAgICAgICAgICAgaWYgKCEoX2NvbnRleHQ1LnQwLmNvZGUgPT09IEVycm9yQ29kZS5TRVNTSU9OX1RPS0VOX0VYUElSRUQpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAzMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0aGlzLl9zZXNzaW9uTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2Vzc2lvbiBleHBpcmF0aW9uJyk7XG5cbiAgICAgICAgICAgIGNhc2UgMjg6XG4gICAgICAgICAgICAgIGRlYnVnJDEwKCdTZXNzaW9uIHRva2VuIGV4cGlyZWQsIHJlb3BlbmluZycpO1xuICAgICAgICAgICAgICB0aGlzLl9zZXNzaW9uTWFuYWdlci5yZXZva2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoJ3JldHVybicsIHRoaXMuX29wZW4oYXBwSWQsIHRhZywgZGV2aWNlSWQsIGlzUmVjb25uZWN0KSk7XG5cbiAgICAgICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgICAgIHRocm93IF9jb250ZXh0NS50MDtcblxuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgX3Jlc0NvbW1hbmQgPSByZXNDb21tYW5kLCBwZWVySWQgPSBfcmVzQ29tbWFuZC5wZWVySWQsIHNlc3Npb25NZXNzYWdlID0gX3Jlc0NvbW1hbmQuc2Vzc2lvbk1lc3NhZ2UsIF9yZXNDb21tYW5kJHNlc3Npb25NZSA9IF9yZXNDb21tYW5kLnNlc3Npb25NZXNzYWdlLCB0b2tlbiA9IF9yZXNDb21tYW5kJHNlc3Npb25NZS5zdCwgdG9rZW5UVEwgPSBfcmVzQ29tbWFuZCRzZXNzaW9uTWUuc3RUdGwsIGNvZGUgPSBfcmVzQ29tbWFuZCRzZXNzaW9uTWUuY29kZTtcblxuICAgICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDM1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IkMShzZXNzaW9uTWVzc2FnZSk7XG5cbiAgICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICAgIGlmIChwZWVySWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gcGVlcklkO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faWRlbnRpdHkpIHRoaXMuX2lkZW50aXR5ID0gcGVlcklkO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc2Vzc2lvbk1hbmFnZXIgPSB0aGlzLl9zZXNzaW9uTWFuYWdlciB8fCB0aGlzLl9jcmVhdGVTZXNzaW9uTWFuYWdlcigpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5fc2Vzc2lvbk1hbmFnZXIuc2V0U2Vzc2lvblRva2VuKHRva2VuLCB0b2tlblRUTCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbCh0aGlzKS5sYXN0Tm90aWZpY2F0aW9uVGltZSkge1xuICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IGF3YWl0IGZvciBpdCBhcyB0aGlzIGlzIGZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICB0aGlzLl9zeW5jTm90aWZpY2F0aW9ucyhpbnRlcm5hbCh0aGlzKS5sYXN0Tm90aWZpY2F0aW9uVGltZSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yJCQxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oJ1N5bmNpbmcgbm90aWZpY2F0aW9ucyBmYWlsZWQ6JywgZXJyb3IkJDEpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIFNldCB0aW1lc3RhbXAgdG8gbm93IGZvciBuZXh0IHJlY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgaW50ZXJuYWwodGhpcykubGFzdE5vdGlmaWNhdGlvblRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VuZXhwZWN0ZWQgc2Vzc2lvbiBvcGVuZWQgd2l0aG91dCBwZWVySWQuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoJ3JldHVybicsIHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWU1LCB0aGlzLCBbWzE3LCAyM11dKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBfb3BlbihfeDcsIF94OCwgX3g5KSB7XG4gICAgICByZXR1cm4gX3JlZjExLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9vcGVuO1xuICB9KCk7XG5cbiAgSU1DbGllbnQucHJvdG90eXBlLl9zeW5jTm90aWZpY2F0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjEyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KHRpbWVzdGFtcCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHZhciBfcmVmMTMsIGhhc01vcmUsIG5vdGlmaWNhdGlvbnM7XG5cbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2JChfY29udGV4dDYpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hOb3RpZmljYXRpb25zKHRpbWVzdGFtcCk7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgX3JlZjEzID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICAgIGhhc01vcmUgPSBfcmVmMTMuaGFzTW9yZTtcbiAgICAgICAgICAgICAgbm90aWZpY2F0aW9ucyA9IF9yZWYxMy5ub3RpZmljYXRpb25zO1xuXG4gICAgICAgICAgICAgIG5vdGlmaWNhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAobm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNtZCA9IG5vdGlmaWNhdGlvbi5jbWQsXG4gICAgICAgICAgICAgICAgICAgIG9wID0gbm90aWZpY2F0aW9uLm9wLFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJUcyA9IG5vdGlmaWNhdGlvbi5zZXJ2ZXJUcyxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub3RpZmljYXRpb24sIFsnY21kJywgJ29wJywgJ3NlcnZlclRzJ10pO1xuXG4gICAgICAgICAgICAgICAgX3RoaXM3Ll9kaXNwYXRjaENvbW1hbmQoX2RlZmluZVByb3BlcnR5KHtcbiAgICAgICAgICAgICAgICAgIGNtZDogQ29tbWFuZFR5cGVbY21kXSxcbiAgICAgICAgICAgICAgICAgIG9wOiBPcFR5cGVbb3BdLFxuICAgICAgICAgICAgICAgICAgc2VydmVyVHM6IHNlcnZlclRzXG4gICAgICAgICAgICAgICAgfSwgY21kICsgJ01lc3NhZ2UnLCBwYXlsb2FkKSk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmICghaGFzTW9yZSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KCdyZXR1cm4nLCB0aGlzLl9zeW5jTm90aWZpY2F0aW9ucyhpbnRlcm5hbCh0aGlzKS5sYXN0Tm90aWZpY2F0aW9uVGltZSkpO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KCdyZXR1cm4nLCB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWU2LCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBfc3luY05vdGlmaWNhdGlvbnMoX3gxMCkge1xuICAgICAgcmV0dXJuIF9yZWYxMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfc3luY05vdGlmaWNhdGlvbnM7XG4gIH0oKTtcblxuICBJTUNsaWVudC5wcm90b3R5cGUuX2ZldGNoTm90aWZpY2F0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjE0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KHRpbWVzdGFtcCkge1xuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LmFicnVwdCgncmV0dXJuJywgdGhpcy5fcmVxdWVzdFdpdGhTZXNzaW9uVG9rZW4oe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgcGF0aDogJy9ydG0vbm90aWZpY2F0aW9ucycsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0X3RzOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25fdHlwZTogJ3Blcm1hbmVudCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlNywgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gX2ZldGNoTm90aWZpY2F0aW9ucyhfeDExKSB7XG4gICAgICByZXR1cm4gX3JlZjE0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9mZXRjaE5vdGlmaWNhdGlvbnM7XG4gIH0oKTtcblxuICBJTUNsaWVudC5wcm90b3R5cGUuX2NyZWF0ZVNlc3Npb25NYW5hZ2VyID0gZnVuY3Rpb24gX2NyZWF0ZVNlc3Npb25NYW5hZ2VyKCkge1xuICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgZGVidWckMTAoJ2NyZWF0ZSBTZXNzaW9uTWFuYWdlcicpO1xuICAgIHJldHVybiBuZXcgU2Vzc2lvbk1hbmFnZXIoe1xuICAgICAgb25CZWZvcmVHZXRTZXNzaW9uVG9rZW46IHRoaXMuX2Nvbm5lY3Rpb24uY2hlY2tDb25uZWN0aW9uQXZhaWxhYmlsaXR5LmJpbmQodGhpcy5fY29ubmVjdGlvbiksXG4gICAgICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoKG1hbmFnZXIsIGV4cGlyZWRTZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIG1hbmFnZXIuc2V0U2Vzc2lvblRva2VuQXN5bmMoX1Byb21pc2UucmVzb2x2ZShuZXcgR2VuZXJpY0NvbW1hbmQoe1xuICAgICAgICAgIGNtZDogJ3Nlc3Npb24nLFxuICAgICAgICAgIG9wOiAncmVmcmVzaCcsXG4gICAgICAgICAgc2Vzc2lvbk1lc3NhZ2U6IG5ldyBTZXNzaW9uQ29tbWFuZCh7XG4gICAgICAgICAgICB1YTogJ2pzLycgKyB2ZXJzaW9uLFxuICAgICAgICAgICAgc3Q6IGV4cGlyZWRTZXNzaW9uVG9rZW5cbiAgICAgICAgICB9KVxuICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9yZWYxNSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlOChjb21tYW5kKSB7XG4gICAgICAgICAgICB2YXIgc2lnbmF0dXJlUmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzOC5vcHRpb25zLnNpZ25hdHVyZUZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydW5TaWduYXR1cmVGYWN0b3J5KF90aGlzOC5vcHRpb25zLnNpZ25hdHVyZUZhY3RvcnksIFtfdGhpczguX2lkZW50aXR5XSk7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlUmVzdWx0ID0gX2NvbnRleHQ4LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgX09iamVjdCRhc3NpZ24oY29tbWFuZC5zZXNzaW9uTWVzc2FnZSwga2V5UmVtYXAoe1xuICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogJ3MnLFxuICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogJ3QnLFxuICAgICAgICAgICAgICAgICAgICAgIG5vbmNlOiAnbidcbiAgICAgICAgICAgICAgICAgICAgfSwgc2lnbmF0dXJlUmVzdWx0KSk7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoJ3JldHVybicsIGNvbW1hbmQpO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWU4LCBfdGhpczgpO1xuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gxMikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWYxNS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0oKSkudGhlbihfdGhpczguX3NlbmQuYmluZChfdGhpczgpKS50aGVuKGZ1bmN0aW9uIChfcmVmMTYpIHtcbiAgICAgICAgICB2YXIgX3JlZjE2JHNlc3Npb25NZXNzYWdlID0gX3JlZjE2LnNlc3Npb25NZXNzYWdlLFxuICAgICAgICAgICAgICB0b2tlbiA9IF9yZWYxNiRzZXNzaW9uTWVzc2FnZS5zdCxcbiAgICAgICAgICAgICAgdHRsID0gX3JlZjE2JHNlc3Npb25NZXNzYWdlLnN0VHRsO1xuICAgICAgICAgIHJldHVybiBbdG9rZW4sIHR0bF07XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBJTUNsaWVudC5wcm90b3R5cGUuX3JlcXVlc3RXaXRoU2Vzc2lvblRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmMTggPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkoX3JlZjE3KSB7XG4gICAgICB2YXIgaGVhZGVycyA9IF9yZWYxNy5oZWFkZXJzLFxuICAgICAgICAgIHF1ZXJ5ID0gX3JlZjE3LnF1ZXJ5LFxuICAgICAgICAgIHBhcmFtcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMTcsIFsnaGVhZGVycycsICdxdWVyeSddKTtcblxuICAgICAgdmFyIHNlc3Npb25Ub2tlbjtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbk1hbmFnZXIuZ2V0U2Vzc2lvblRva2VuKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgc2Vzc2lvblRva2VuID0gX2NvbnRleHQ5LnNlbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuYWJydXB0KCdyZXR1cm4nLCB0aGlzLl9yZXF1ZXN0KF9leHRlbmRzJDEoe1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IF9leHRlbmRzJDEoe1xuICAgICAgICAgICAgICAgICAgJ1gtTEMtSU0tU2Vzc2lvbi1Ub2tlbic6IHNlc3Npb25Ub2tlblxuICAgICAgICAgICAgICAgIH0sIGhlYWRlcnMpLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBfZXh0ZW5kcyQxKHtcbiAgICAgICAgICAgICAgICAgIGNsaWVudF9pZDogdGhpcy5pZFxuICAgICAgICAgICAgICAgIH0sIHF1ZXJ5KVxuICAgICAgICAgICAgICB9LCBwYXJhbXMpKSk7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTksIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIF9yZXF1ZXN0V2l0aFNlc3Npb25Ub2tlbihfeDEzKSB7XG4gICAgICByZXR1cm4gX3JlZjE4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXF1ZXN0V2l0aFNlc3Npb25Ub2tlbjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiDlhbPpl63lrqLmiLfnq69cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG5cblxuICBJTUNsaWVudC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYxOSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMTAoKSB7XG4gICAgICB2YXIgX2VlLCBjb21tYW5kO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAkKF9jb250ZXh0MTApIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTAucHJldiA9IF9jb250ZXh0MTAubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnY2xvc2Ugc2Vzc2lvbicpO1xuICAgICAgICAgICAgICBfZWUgPSBpbnRlcm5hbCh0aGlzKS5fZXZlbnRlbWl0dGVyO1xuXG4gICAgICAgICAgICAgIF9lZS5lbWl0KCdiZWZvcmVjbG9zZScpO1xuXG4gICAgICAgICAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvbi5pcygnY29ubmVjdGVkJykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29tbWFuZCA9IG5ldyBHZW5lcmljQ29tbWFuZCh7XG4gICAgICAgICAgICAgICAgY21kOiAnc2Vzc2lvbicsXG4gICAgICAgICAgICAgICAgb3A6ICdjbG9zZSdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDc7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kKGNvbW1hbmQpO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9lZS5lbWl0KCdjbG9zZScpO1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoQ0xPU0UkMSwge1xuICAgICAgICAgICAgICAgIGNvZGU6IDBcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUxMCwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICByZXR1cm4gX3JlZjE5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb3NlO1xuICB9KCk7XG4gIC8qKlxuICAgKiDojrflj5YgY2xpZW50IOWIl+ihqOS4reWcqOe6v+eahCBjbGllbnTvvIzmr4/mrKHmn6Xor6LmnIDlpJogMjAg5LiqIGNsaWVudElk77yM6LaF5Ye66YOo5YiG5Lya6KKr5b+955WlXG4gICAqIEBwYXJhbSAge1N0cmluZ1tdfSBjbGllbnRJZHMg6KaB5p+l6K+i55qEIGNsaWVudCBpZHNcbiAgICogQHJldHVybiB7UHJpbXNlLjxTdHJpbmdbXT59IOWcqOe6v+eahCBjbGllbnQgaWRzXG4gICAqL1xuXG5cbiAgSU1DbGllbnQucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYyMCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMTEoY2xpZW50SWRzKSB7XG4gICAgICB2YXIgY29tbWFuZCwgcmVzQ29tbWFuZDtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMSQoX2NvbnRleHQxMSkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdwaW5nJyk7XG5cbiAgICAgICAgICAgICAgaWYgKGNsaWVudElkcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NsaWVudElkcyAnICsgY2xpZW50SWRzICsgJyBpcyBub3QgYW4gQXJyYXknKTtcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBpZiAoY2xpZW50SWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5hYnJ1cHQoJ3JldHVybicsIF9Qcm9taXNlLnJlc29sdmUoW10pKTtcblxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjb21tYW5kID0gbmV3IEdlbmVyaWNDb21tYW5kKHtcbiAgICAgICAgICAgICAgICBjbWQ6ICdzZXNzaW9uJyxcbiAgICAgICAgICAgICAgICBvcDogJ3F1ZXJ5JyxcbiAgICAgICAgICAgICAgICBzZXNzaW9uTWVzc2FnZTogbmV3IFNlc3Npb25Db21tYW5kKHtcbiAgICAgICAgICAgICAgICAgIHNlc3Npb25QZWVySWRzOiBjbGllbnRJZHNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmQoY29tbWFuZCk7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgcmVzQ29tbWFuZCA9IF9jb250ZXh0MTEuc2VudDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuYWJydXB0KCdyZXR1cm4nLCByZXNDb21tYW5kLnNlc3Npb25NZXNzYWdlLm9ubGluZVNlc3Npb25QZWVySWRzKTtcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUxMSwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gcGluZyhfeDE0KSB7XG4gICAgICByZXR1cm4gX3JlZjIwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBpbmc7XG4gIH0oKTtcblxuICAvKipcbiAgICog6I635Y+W5p+Q5Liq54m55a6a55qE5a+56K+dXG4gICAqIEBwYXJhbSAge1N0cmluZ30gaWQg5a+56K+dIGlk77yM5a+55bqUIF9Db252ZXJzYXRpb24g6KGo5Lit55qEIG9iamVjdElkXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtub0NhY2hlPWZhbHNlXSDlvLrliLbkuI3ku47nvJPlrZjkuK3ojrflj5ZcbiAgICogQHJldHVybiB7UHJvbWlzZS48Q29udmVyc2F0aW9uQmFzZT59IOWmguaenCBpZCDlr7nlupTnmoTlr7nor53kuI3lrZjlnKjliJnov5Tlm54gbnVsbFxuICAgKi9cblxuXG4gIElNQ2xpZW50LnByb3RvdHlwZS5nZXRDb252ZXJzYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYyMSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMTIoaWQpIHtcbiAgICAgIHZhciBub0NhY2hlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBjYWNoZWRDb252ZXJzYXRpb247XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMTIkKF9jb250ZXh0MTIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoISh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGlkICsgJyBpcyBub3QgYSBTdHJpbmcnKTtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBpZiAobm9DYWNoZSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYWNoZWRDb252ZXJzYXRpb24gPSB0aGlzLl9jb252ZXJzYXRpb25DYWNoZS5nZXQoaWQpO1xuXG4gICAgICAgICAgICAgIGlmICghY2FjaGVkQ29udmVyc2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmFicnVwdCgncmV0dXJuJywgY2FjaGVkQ29udmVyc2F0aW9uKTtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBpZiAoIWlzVGVtcG9yYXJ5Q29udmVyc2F0cmlvbklkKGlkKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRlbXBvcmFyeUNvbnZlcnNhdGlvbnMoW2lkXSk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQxMi50MCA9IF9jb250ZXh0MTIuc2VudFswXTtcblxuICAgICAgICAgICAgICBpZiAoX2NvbnRleHQxMi50MCkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTIubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQxMi50MCA9IG51bGw7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmFicnVwdCgncmV0dXJuJywgX2NvbnRleHQxMi50MCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmFicnVwdCgncmV0dXJuJywgdGhpcy5nZXRRdWVyeSgpLmVxdWFsVG8oJ29iamVjdElkJywgaWQpLmZpbmQoKS50aGVuKGZ1bmN0aW9uIChjb252ZXJzYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnNhdGlvbnNbMF0gfHwgbnVsbDtcbiAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTEyLCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBnZXRDb252ZXJzYXRpb24oX3gxNikge1xuICAgICAgcmV0dXJuIF9yZWYyMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRDb252ZXJzYXRpb247XG4gIH0oKTtcblxuICAvKipcbiAgICog6YCa6L+HIGlkIOaJuemHj+iOt+WPluafkOS4queJueWumueahOWvueivnVxuICAgKiBAc2luY2UgMy40LjBcbiAgICogQHBhcmFtICB7U3RyaW5nW119IGlkcyDlr7nor50gaWQg5YiX6KGo77yM5a+55bqUIF9Db252ZXJzYXRpb24g6KGo5Lit55qEIG9iamVjdElkXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtub0NhY2hlPWZhbHNlXSDlvLrliLbkuI3ku47nvJPlrZjkuK3ojrflj5ZcbiAgICogQHJldHVybiB7UHJvbWlzZS48Q29udmVyc2F0aW9uQmFzZVtdPn0g5aaC5p6cIGlkIOWvueW6lOeahOWvueivneS4jeWtmOWcqOWImei/lOWbniBudWxsXG4gICAqL1xuXG5cbiAgSU1DbGllbnQucHJvdG90eXBlLmdldENvbnZlcnNhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYyMiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMTMoaWRzKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcblxuICAgICAgdmFyIG5vQ2FjaGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIHJlbW90ZUNvbnZlcnNhdGlvbklkcywgcmVtb3RlVGVtcG9yYXJ5Q29udmVyc2F0aW9uSWRzLCBxdWVyeSwgcmVtb3RlVGVtcG9yYXJ5Q29udmVyc2F0aW9uc1Byb21pc2U7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMTMkKF9jb250ZXh0MTMpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTMucHJldiA9IF9jb250ZXh0MTMubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZW1vdGVDb252ZXJzYXRpb25JZHMgPSBub0NhY2hlID8gaWRzIDogaWRzLmZpbHRlcihmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM5Ll9jb252ZXJzYXRpb25DYWNoZS5nZXQoaWQpID09PSBudWxsO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAoIXJlbW90ZUNvbnZlcnNhdGlvbklkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmVtb3RlVGVtcG9yYXJ5Q29udmVyc2F0aW9uSWRzID0gcmVtb3ZlXzEocmVtb3RlQ29udmVyc2F0aW9uSWRzLCBpc1RlbXBvcmFyeUNvbnZlcnNhdHJpb25JZCk7XG4gICAgICAgICAgICAgIHF1ZXJ5ID0gW107XG5cbiAgICAgICAgICAgICAgaWYgKHJlbW90ZUNvbnZlcnNhdGlvbklkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBxdWVyeS5wdXNoKHRoaXMuZ2V0UXVlcnkoKS5jb250YWluZWRJbignb2JqZWN0SWQnLCByZW1vdGVDb252ZXJzYXRpb25JZHMpLmxpbWl0KDk5OSkuZmluZCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVtb3RlVGVtcG9yYXJ5Q29udmVyc2F0aW9uSWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlbW90ZVRlbXBvcmFyeUNvbnZlcnNhdGlvbnNQcm9taXNlID0gcmVtb3RlVGVtcG9yYXJ5Q29udmVyc2F0aW9uSWRzLm1hcCh0aGlzLl9nZXRUZW1wb3JhcnlDb252ZXJzYXRpb25zLmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAgICAgcXVlcnkucHVzaC5hcHBseShxdWVyeSwgX3RvQ29uc3VtYWJsZUFycmF5KHJlbW90ZVRlbXBvcmFyeUNvbnZlcnNhdGlvbnNQcm9taXNlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gODtcbiAgICAgICAgICAgICAgcmV0dXJuIF9Qcm9taXNlLmFsbChxdWVyeSk7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuYWJydXB0KCdyZXR1cm4nLCBpZHMubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczkuX2NvbnZlcnNhdGlvbkNhY2hlLmdldChpZCk7XG4gICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTEzLCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBnZXRDb252ZXJzYXRpb25zKF94MTgpIHtcbiAgICAgIHJldHVybiBfcmVmMjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0Q29udmVyc2F0aW9ucztcbiAgfSgpO1xuXG4gIElNQ2xpZW50LnByb3RvdHlwZS5fZ2V0VGVtcG9yYXJ5Q29udmVyc2F0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjIzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNChpZHMpIHtcbiAgICAgIHZhciBjb21tYW5kLCByZXNDb21tYW5kO1xuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE0JChfY29udGV4dDE0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDE0LnByZXYgPSBfY29udGV4dDE0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY29tbWFuZCA9IG5ldyBHZW5lcmljQ29tbWFuZCh7XG4gICAgICAgICAgICAgICAgY21kOiAnY29udicsXG4gICAgICAgICAgICAgICAgb3A6ICdxdWVyeScsXG4gICAgICAgICAgICAgICAgY29udk1lc3NhZ2U6IG5ldyBDb252Q29tbWFuZCh7XG4gICAgICAgICAgICAgICAgICB0ZW1wQ29udklkczogaWRzXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kKGNvbW1hbmQpO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHJlc0NvbW1hbmQgPSBfY29udGV4dDE0LnNlbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE0LmFicnVwdCgncmV0dXJuJywgdGhpcy5faGFuZGxlUXVlcnlSZXN1bHRzKHJlc0NvbW1hbmQpKTtcblxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTE0LCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBfZ2V0VGVtcG9yYXJ5Q29udmVyc2F0aW9ucyhfeDE5KSB7XG4gICAgICByZXR1cm4gX3JlZjIzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXRUZW1wb3JhcnlDb252ZXJzYXRpb25zO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIOaehOmAoOS4gOS4qiBDb252ZXJzYXRpb25RdWVyeSDmnaXmn6Xor6Llr7nor51cbiAgICogQHJldHVybiB7Q29udmVyc2F0aW9uUXVlcnkuPFBlcnNpc3RlbnRDb252ZXJzYXRpb24+fVxuICAgKi9cblxuXG4gIElNQ2xpZW50LnByb3RvdHlwZS5nZXRRdWVyeSA9IGZ1bmN0aW9uIGdldFF1ZXJ5KCkge1xuICAgIHJldHVybiBuZXcgQ29udmVyc2F0aW9uUXVlcnkodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIOaehOmAoOS4gOS4qiBDb252ZXJzYXRpb25RdWVyeSDmnaXmn6Xor6LogYrlpKnlrqRcbiAgICogQHJldHVybiB7Q29udmVyc2F0aW9uUXVlcnkuPENoYXRSb29tPn1cbiAgICovXG5cblxuICBJTUNsaWVudC5wcm90b3R5cGUuZ2V0Q2hhdFJvb21RdWVyeSA9IGZ1bmN0aW9uIGdldENoYXRSb29tUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UXVlcnkoKS5lcXVhbFRvKCd0cicsIHRydWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiDmnoTpgKDkuIDkuKogQ29udmVyc2F0aW9uUXVlcnkg5p2l5p+l6K+i5pyN5Yqh5Y+3XG4gICAqIEByZXR1cm4ge0NvbnZlcnNhdGlvblF1ZXJ5LjxTZXJ2aWNlQ29udmVyc2F0aW9uPn1cbiAgICovXG5cblxuICBJTUNsaWVudC5wcm90b3R5cGUuZ2V0U2VydmljZUNvbnZlcnNhdGlvblF1ZXJ5ID0gZnVuY3Rpb24gZ2V0U2VydmljZUNvbnZlcnNhdGlvblF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLmdldFF1ZXJ5KCkuZXF1YWxUbygnc3lzJywgdHJ1ZSk7XG4gIH07XG5cbiAgSU1DbGllbnQucHJvdG90eXBlLl9leGVjdXRlUXVlcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYyNCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMTUocXVlcnkpIHtcbiAgICAgIHZhciBxdWVyeUpTT04sIGNvbW1hbmQsIHJlc0NvbW1hbmQ7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMTUkKF9jb250ZXh0MTUpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTUucHJldiA9IF9jb250ZXh0MTUubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBxdWVyeUpTT04gPSBxdWVyeS50b0pTT04oKTtcblxuICAgICAgICAgICAgICBxdWVyeUpTT04ud2hlcmUgPSBuZXcgSnNvbk9iamVjdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGRhdGE6IF9KU09OJHN0cmluZ2lmeShlbmNvZGUkMShxdWVyeUpTT04ud2hlcmUpKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29tbWFuZCA9IG5ldyBHZW5lcmljQ29tbWFuZCh7XG4gICAgICAgICAgICAgICAgY21kOiAnY29udicsXG4gICAgICAgICAgICAgICAgb3A6ICdxdWVyeScsXG4gICAgICAgICAgICAgICAgY29udk1lc3NhZ2U6IG5ldyBDb252Q29tbWFuZChxdWVyeUpTT04pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBfY29udGV4dDE1Lm5leHQgPSA1O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VuZChjb21tYW5kKTtcblxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICByZXNDb21tYW5kID0gX2NvbnRleHQxNS5zZW50O1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNS5hYnJ1cHQoJ3JldHVybicsIHRoaXMuX2hhbmRsZVF1ZXJ5UmVzdWx0cyhyZXNDb21tYW5kKSk7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE1LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUxNSwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gX2V4ZWN1dGVRdWVyeShfeDIwKSB7XG4gICAgICByZXR1cm4gX3JlZjI0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9leGVjdXRlUXVlcnk7XG4gIH0oKTtcblxuICBJTUNsaWVudC5wcm90b3R5cGUuX2hhbmRsZVF1ZXJ5UmVzdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjI1ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNihyZXNDb21tYW5kKSB7XG4gICAgICB2YXIgY29udmVyc2F0aW9ucywgY29tbWFuZFN0cmluZztcbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNiQoX2NvbnRleHQxNikge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNi5wcmV2ID0gX2NvbnRleHQxNi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGNvbnZlcnNhdGlvbnMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTYucHJldiA9IDE7XG5cbiAgICAgICAgICAgICAgY29udmVyc2F0aW9ucyA9IGRlY29kZShKU09OLnBhcnNlKHJlc0NvbW1hbmQuY29udk1lc3NhZ2UucmVzdWx0cy5kYXRhKSk7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTYubmV4dCA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTYucHJldiA9IDU7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTYudDAgPSBfY29udGV4dDE2WydjYXRjaCddKDEpO1xuICAgICAgICAgICAgICBjb21tYW5kU3RyaW5nID0gX0pTT04kc3RyaW5naWZ5KHRyaW0kMShyZXNDb21tYW5kKSk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyc2UgcXVlcnkgcmVzdWx0IGZhaWxlZDogJyArIF9jb250ZXh0MTYudDAubWVzc2FnZSArICcuIENvbW1hbmQ6ICcgKyBjb21tYW5kU3RyaW5nKTtcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBfY29udGV4dDE2Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9Qcm9taXNlLmFsbChjb252ZXJzYXRpb25zLm1hcCh0aGlzLl9wYXJzZUNvbnZlcnNhdGlvbkZyb21SYXdEYXRhLmJpbmQodGhpcykpKTtcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgY29udmVyc2F0aW9ucyA9IF9jb250ZXh0MTYuc2VudDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTYuYWJydXB0KCdyZXR1cm4nLCBjb252ZXJzYXRpb25zLm1hcCh0aGlzLl91cHNlcnRDb252ZXJzYXRpb25Ub0NhY2hlLmJpbmQodGhpcykpKTtcblxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE2LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUxNiwgdGhpcywgW1sxLCA1XV0pO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIF9oYW5kbGVRdWVyeVJlc3VsdHMoX3gyMSkge1xuICAgICAgcmV0dXJuIF9yZWYyNS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfaGFuZGxlUXVlcnlSZXN1bHRzO1xuICB9KCk7XG5cbiAgSU1DbGllbnQucHJvdG90eXBlLl91cHNlcnRDb252ZXJzYXRpb25Ub0NhY2hlID0gZnVuY3Rpb24gX3Vwc2VydENvbnZlcnNhdGlvblRvQ2FjaGUoZmV0Y2hlZENvbnZlcnNhdGlvbikge1xuICAgIHZhciBjb252ZXJzYXRpb24gPSB0aGlzLl9jb252ZXJzYXRpb25DYWNoZS5nZXQoZmV0Y2hlZENvbnZlcnNhdGlvbi5pZCk7XG4gICAgaWYgKCFjb252ZXJzYXRpb24pIHtcbiAgICAgIGNvbnZlcnNhdGlvbiA9IGZldGNoZWRDb252ZXJzYXRpb247XG4gICAgICB0aGlzLl9kZWJ1Zygnbm8gbWF0Y2gsIHNldCBjYWNoZScpO1xuICAgICAgdGhpcy5fY29udmVyc2F0aW9uQ2FjaGUuc2V0KGZldGNoZWRDb252ZXJzYXRpb24uaWQsIGZldGNoZWRDb252ZXJzYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kZWJ1ZygndXBkYXRlIGNhY2hlZCBjb252ZXJzYXRpb24nKTtcbiAgICAgIFsnY3JlYXRvcicsICdjcmVhdGVkQXQnLCAndXBkYXRlZEF0JywgJ2xhc3RNZXNzYWdlQXQnLCAnbGFzdE1lc3NhZ2UnLCAnbXV0ZWRNZW1iZXJzJywgJ21lbWJlcnMnLCAnX2F0dHJpYnV0ZXMnLCAndHJhbnNpZW50JywgJ211dGVkJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGZldGNoZWRDb252ZXJzYXRpb25ba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIGNvbnZlcnNhdGlvbltrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIGlmIChjb252ZXJzYXRpb24uX3Jlc2V0KSBjb252ZXJzYXRpb24uX3Jlc2V0KCk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJzYXRpb247XG4gIH07XG5cbiAgLyoqXG4gICAqIOWPjeW6j+WIl+WMlua2iOaBr++8jOS4jiB7QGxpbmsgTWVzc2FnZSN0b0Z1bGxKU09OfSDnm7jlr7njgIJcbiAgICogQHBhcmFtIHtPYmplY3R9XG4gICAqIEByZXR1cm4ge0FWTWVzc2FnZX0g6Kej5p6Q5ZCO55qE5raI5oGvXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKi9cblxuXG4gIElNQ2xpZW50LnByb3RvdHlwZS5wYXJzZU1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYyNyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMTcoX3JlZjI2KSB7XG4gICAgICB2YXIgZGF0YSA9IF9yZWYyNi5kYXRhLFxuICAgICAgICAgIF9yZWYyNiRiaW4gPSBfcmVmMjYuYmluLFxuICAgICAgICAgIGJpbiA9IF9yZWYyNiRiaW4gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3JlZjI2JGJpbixcbiAgICAgICAgICBwcm9wZXJ0aWVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyNiwgWydkYXRhJywgJ2JpbiddKTtcblxuICAgICAgdmFyIGNvbnRlbnQsIG1lc3NhZ2U7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMTckKF9jb250ZXh0MTcpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTcucHJldiA9IF9jb250ZXh0MTcubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBjb250ZW50ID0gYmluID8gYmFzZTY0QXJyYXlidWZmZXJfMihkYXRhKSA6IGRhdGE7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTcubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlUGFyc2VyLnBhcnNlKGNvbnRlbnQpO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBfY29udGV4dDE3LnNlbnQ7XG5cbiAgICAgICAgICAgICAgX09iamVjdCRhc3NpZ24obWVzc2FnZSwgcHJvcGVydGllcyk7XG4gICAgICAgICAgICAgIG1lc3NhZ2UuX3VwZGF0ZU1lbnRpb25lZCh0aGlzLmlkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTcuYWJydXB0KCdyZXR1cm4nLCBtZXNzYWdlKTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTcuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTE3LCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1lc3NhZ2UoX3gyMikge1xuICAgICAgcmV0dXJuIF9yZWYyNy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZU1lc3NhZ2U7XG4gIH0oKTtcblxuICAvKipcbiAgICog5Y+N5bqP5YiX5YyW5a+56K+d77yM5LiOIHtAbGluayBDb252ZXJzYXRpb24jdG9GdWxsSlNPTn0g55u45a+544CCXG4gICAqIEBwYXJhbSB7T2JqZWN0fVxuICAgKiBAcmV0dXJuIHtDb252ZXJzYXRpb25CYXNlfSDop6PmnpDlkI7nmoTlr7nor51cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqL1xuXG5cbiAgSU1DbGllbnQucHJvdG90eXBlLnBhcnNlQ29udmVyc2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmMjkgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE4KF9yZWYyOCkge1xuICAgICAgdmFyIGlkID0gX3JlZjI4LmlkLFxuICAgICAgICAgIGxhc3RNZXNzYWdlQXQgPSBfcmVmMjgubGFzdE1lc3NhZ2VBdCxcbiAgICAgICAgICBsYXN0TWVzc2FnZSA9IF9yZWYyOC5sYXN0TWVzc2FnZSxcbiAgICAgICAgICBsYXN0RGVsaXZlcmVkQXQgPSBfcmVmMjgubGFzdERlbGl2ZXJlZEF0LFxuICAgICAgICAgIGxhc3RSZWFkQXQgPSBfcmVmMjgubGFzdFJlYWRBdCxcbiAgICAgICAgICB1bnJlYWRNZXNzYWdlc0NvdW50ID0gX3JlZjI4LnVucmVhZE1lc3NhZ2VzQ291bnQsXG4gICAgICAgICAgbWVtYmVycyA9IF9yZWYyOC5tZW1iZXJzLFxuICAgICAgICAgIG1lbnRpb25lZCA9IF9yZWYyOC5tZW50aW9uZWQsXG4gICAgICAgICAgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMjgsIFsnaWQnLCAnbGFzdE1lc3NhZ2VBdCcsICdsYXN0TWVzc2FnZScsICdsYXN0RGVsaXZlcmVkQXQnLCAnbGFzdFJlYWRBdCcsICd1bnJlYWRNZXNzYWdlc0NvdW50JywgJ21lbWJlcnMnLCAnbWVudGlvbmVkJ10pO1xuXG4gICAgICB2YXIgY29udmVyc2F0aW9uRGF0YSwgdHJhbnNpZW50LCBzeXN0ZW0sIGV4cGlyZWRBdDtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxOCQoX2NvbnRleHQxOCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxOC5wcmV2ID0gX2NvbnRleHQxOC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGNvbnZlcnNhdGlvbkRhdGEgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlQXQ6IGxhc3RNZXNzYWdlQXQsXG4gICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2U6IGxhc3RNZXNzYWdlLFxuICAgICAgICAgICAgICAgIGxhc3REZWxpdmVyZWRBdDogbGFzdERlbGl2ZXJlZEF0LFxuICAgICAgICAgICAgICAgIGxhc3RSZWFkQXQ6IGxhc3RSZWFkQXQsXG4gICAgICAgICAgICAgICAgdW5yZWFkTWVzc2FnZXNDb3VudDogdW5yZWFkTWVzc2FnZXNDb3VudCxcbiAgICAgICAgICAgICAgICBtZW1iZXJzOiBtZW1iZXJzLFxuICAgICAgICAgICAgICAgIG1lbnRpb25lZDogbWVudGlvbmVkXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaWYgKCFsYXN0TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTgubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dDE4Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU1lc3NhZ2UobGFzdE1lc3NhZ2UpO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNvbnZlcnNhdGlvbkRhdGEubGFzdE1lc3NhZ2UgPSBfY29udGV4dDE4LnNlbnQ7XG5cbiAgICAgICAgICAgICAgY29udmVyc2F0aW9uRGF0YS5sYXN0TWVzc2FnZS5fc2V0U3RhdHVzKE1lc3NhZ2VTdGF0dXMuU0VOVCk7XG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgdHJhbnNpZW50ID0gcHJvcGVydGllcy50cmFuc2llbnQsIHN5c3RlbSA9IHByb3BlcnRpZXMuc3lzdGVtLCBleHBpcmVkQXQgPSBwcm9wZXJ0aWVzLmV4cGlyZWRBdDtcblxuICAgICAgICAgICAgICBpZiAoIXRyYW5zaWVudCkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTgubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOC5hYnJ1cHQoJ3JldHVybicsIG5ldyBDaGF0Um9vbShjb252ZXJzYXRpb25EYXRhLCBwcm9wZXJ0aWVzLCB0aGlzKSk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgaWYgKCFzeXN0ZW0pIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE4Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE4LmFicnVwdCgncmV0dXJuJywgbmV3IFNlcnZpY2VDb252ZXJzYXRpb24oY29udmVyc2F0aW9uRGF0YSwgcHJvcGVydGllcywgdGhpcykpO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBpZiAoIShleHBpcmVkQXQgfHwgaXNUZW1wb3JhcnlDb252ZXJzYXRyaW9uSWQoaWQpKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTgubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTguYWJydXB0KCdyZXR1cm4nLCBuZXcgVGVtcG9yYXJ5Q29udmVyc2F0aW9uKGNvbnZlcnNhdGlvbkRhdGEsIHsgZXhwaXJlZEF0OiBleHBpcmVkQXQgfSwgdGhpcykpO1xuXG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOC5hYnJ1cHQoJ3JldHVybicsIG5ldyBDb252ZXJzYXRpb24oY29udmVyc2F0aW9uRGF0YSwgcHJvcGVydGllcywgdGhpcykpO1xuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTguc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTE4LCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbnZlcnNhdGlvbihfeDIzKSB7XG4gICAgICByZXR1cm4gX3JlZjI5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlQ29udmVyc2F0aW9uO1xuICB9KCk7XG5cbiAgSU1DbGllbnQucHJvdG90eXBlLl9wYXJzZUNvbnZlcnNhdGlvbkZyb21SYXdEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmMzAgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE5KHJhd0RhdGEpIHtcbiAgICAgIHZhciBkYXRhLCB0dGw7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMTkkKF9jb250ZXh0MTkpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTkucHJldiA9IF9jb250ZXh0MTkubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBkYXRhID0ga2V5UmVtYXAoe1xuICAgICAgICAgICAgICAgIG9iamVjdElkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGxtOiAnbGFzdE1lc3NhZ2VBdCcsXG4gICAgICAgICAgICAgICAgbTogJ21lbWJlcnMnLFxuICAgICAgICAgICAgICAgIHRyOiAndHJhbnNpZW50JyxcbiAgICAgICAgICAgICAgICBzeXM6ICdzeXN0ZW0nLFxuICAgICAgICAgICAgICAgIGM6ICdjcmVhdG9yJyxcbiAgICAgICAgICAgICAgICBtdTogJ211dGVkTWVtYmVycydcbiAgICAgICAgICAgICAgfSwgcmF3RGF0YSk7XG5cbiAgICAgICAgICAgICAgaWYgKGRhdGEubXNnKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5sYXN0TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEubXNnLFxuICAgICAgICAgICAgICAgICAgYmluOiBkYXRhLmJpbixcbiAgICAgICAgICAgICAgICAgIGZyb206IGRhdGEubXNnX2Zyb20sXG4gICAgICAgICAgICAgICAgICBpZDogZGF0YS5tc2dfbWlkLFxuICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBkYXRhLm1zZ190aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IGRhdGEucGF0Y2hfdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5sYXN0TWVzc2FnZUZyb207XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGEubGFzdE1lc3NhZ2VJZDtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5sYXN0TWVzc2FnZVRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5sYXN0TWVzc2FnZVBhdGNoVGltZXN0YW1wO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHR0bCA9IGRhdGEudHRsO1xuXG4gICAgICAgICAgICAgIGlmICh0dGwpIGRhdGEuZXhwaXJlZEF0ID0gRGF0ZS5ub3coKSArIHR0bCAqIDEwMDA7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE5LmFicnVwdCgncmV0dXJuJywgdGhpcy5wYXJzZUNvbnZlcnNhdGlvbihkYXRhKSk7XG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE5LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUxOSwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gX3BhcnNlQ29udmVyc2F0aW9uRnJvbVJhd0RhdGEoX3gyNCkge1xuICAgICAgcmV0dXJuIF9yZWYzMC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcGFyc2VDb252ZXJzYXRpb25Gcm9tUmF3RGF0YTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiDliJvlu7rkuIDkuKrlr7nor51cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMg6Zmk5LqG5LiL5YiX5a2X5q615aSW55qE5YW25LuW5a2X5q615bCG6KKr6KeG5Li65a+56K+d55qE6Ieq5a6a5LmJ5bGe5oCnXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IG9wdGlvbnMubWVtYmVycyDlr7nor53nmoTliJ3lp4vmiJDlkZjliJfooajvvIzpu5jorqTljIXlkKvlvZPliY0gY2xpZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5uYW1lXSDlr7nor53nmoTlkI3lrZdcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51bmlxdWU9ZmFsc2VdIOWUr+S4gOWvueivne+8jOW9k+WFtuS4uiB0cnVlIOaXtu+8jOWmguaenOW9k+WJjeW3sue7j+acieebuOWQjOaIkOWRmOeahOWvueivneWtmOWcqOWImei/lOWbnuivpeWvueivne+8jOWQpuWImeS8muWIm+W7uuaWsOeahOWvueivnVxuICAgKiBAcmV0dXJuIHtQcm9taXNlLjxDb252ZXJzYXRpb24+fVxuICAgKi9cblxuXG4gIElNQ2xpZW50LnByb3RvdHlwZS5jcmVhdGVDb252ZXJzYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYzMiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMjAoKSB7XG4gICAgICB2YXIgX3JlZjMxID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgdmFyIG0gPSBfcmVmMzEubWVtYmVycyxcbiAgICAgICAgICBuYW1lJCQxID0gX3JlZjMxLm5hbWUsXG4gICAgICAgICAgdHJhbnNpZW50ID0gX3JlZjMxLnRyYW5zaWVudCxcbiAgICAgICAgICB1bmlxdWUgPSBfcmVmMzEudW5pcXVlLFxuICAgICAgICAgIHRlbXBDb252ID0gX3JlZjMxLl90ZW1wQ29udixcbiAgICAgICAgICB0ZW1wQ29udlRUTCA9IF9yZWYzMS5fdGVtcENvbnZUVEwsXG4gICAgICAgICAgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMzEsIFsnbWVtYmVycycsICduYW1lJywgJ3RyYW5zaWVudCcsICd1bmlxdWUnLCAnX3RlbXBDb252JywgJ190ZW1wQ29udlRUTCddKTtcblxuICAgICAgdmFyIG1lbWJlcnMsIGF0dHIsIHN0YXJ0Q29tbWFuZEpzb24sIGNvbW1hbmQsIF9wYXJhbXMsIHNpZ25hdHVyZVJlc3VsdCwgX3JlZjMzLCBfcmVmMzMkY29udk1lc3NhZ2UsIGNpZCwgY2RhdGUsIHR0bCwgZGF0YSwgY29udmVyc2F0aW9uO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMjAkKF9jb250ZXh0MjApIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjAucHJldiA9IF9jb250ZXh0MjAubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAodHJhbnNpZW50IHx8IEFycmF5LmlzQXJyYXkobSkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIwLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29udmVyc2F0aW9uIG1lbWJlcnMgJyArIG0gKyAnIGlzIG5vdCBhbiBhcnJheScpO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIG1lbWJlcnMgPSBuZXcgX1NldChtKTtcblxuICAgICAgICAgICAgICBtZW1iZXJzLmFkZCh0aGlzLmlkKTtcbiAgICAgICAgICAgICAgbWVtYmVycyA9IF9BcnJheSRmcm9tKG1lbWJlcnMpLnNvcnQoKTtcbiAgICAgICAgICAgICAgYXR0ciA9IHByb3BlcnRpZXMgfHwge307XG5cbiAgICAgICAgICAgICAgaWYgKCFuYW1lJCQxKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyMC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoISh0eXBlb2YgbmFtZSQkMSAhPT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyMC5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvbnZlcnNhdGlvbiBuYW1lICcgKyBuYW1lJCQxICsgJyBpcyBub3QgYSBzdHJpbmcnKTtcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBhdHRyLm5hbWUgPSBuYW1lJCQxO1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBhdHRyID0gbmV3IEpzb25PYmplY3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBfSlNPTiRzdHJpbmdpZnkoZW5jb2RlJDEoYXR0cikpXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHN0YXJ0Q29tbWFuZEpzb24gPSB7XG4gICAgICAgICAgICAgICAgbTogbWVtYmVycyxcbiAgICAgICAgICAgICAgICBhdHRyOiBhdHRyLFxuICAgICAgICAgICAgICAgIHRyYW5zaWVudDogdHJhbnNpZW50LFxuICAgICAgICAgICAgICAgIHVuaXF1ZTogdW5pcXVlLFxuICAgICAgICAgICAgICAgIHRlbXBDb252OiB0ZW1wQ29udixcbiAgICAgICAgICAgICAgICB0ZW1wQ29udlRUTDogdGVtcENvbnZUVExcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY29tbWFuZCA9IG5ldyBHZW5lcmljQ29tbWFuZCh7XG4gICAgICAgICAgICAgICAgY21kOiAnY29udicsXG4gICAgICAgICAgICAgICAgb3A6ICdzdGFydCcsXG4gICAgICAgICAgICAgICAgY29udk1lc3NhZ2U6IG5ldyBDb252Q29tbWFuZChzdGFydENvbW1hbmRKc29uKVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5jb252ZXJzYXRpb25TaWduYXR1cmVGYWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyMC5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfcGFyYW1zID0gW251bGwsIHRoaXMuX2lkZW50aXR5LCBtZW1iZXJzLCAnY3JlYXRlJ107XG4gICAgICAgICAgICAgIF9jb250ZXh0MjAubmV4dCA9IDE3O1xuICAgICAgICAgICAgICByZXR1cm4gcnVuU2lnbmF0dXJlRmFjdG9yeSh0aGlzLm9wdGlvbnMuY29udmVyc2F0aW9uU2lnbmF0dXJlRmFjdG9yeSwgX3BhcmFtcyk7XG5cbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgIHNpZ25hdHVyZVJlc3VsdCA9IF9jb250ZXh0MjAuc2VudDtcblxuICAgICAgICAgICAgICBfT2JqZWN0JGFzc2lnbihjb21tYW5kLmNvbnZNZXNzYWdlLCBrZXlSZW1hcCh7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiAncycsXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiAndCcsXG4gICAgICAgICAgICAgICAgbm9uY2U6ICduJ1xuICAgICAgICAgICAgICB9LCBzaWduYXR1cmVSZXN1bHQpKTtcblxuICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQyMC5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kKGNvbW1hbmQpO1xuXG4gICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICBfcmVmMzMgPSBfY29udGV4dDIwLnNlbnQ7XG4gICAgICAgICAgICAgIF9yZWYzMyRjb252TWVzc2FnZSA9IF9yZWYzMy5jb252TWVzc2FnZTtcbiAgICAgICAgICAgICAgY2lkID0gX3JlZjMzJGNvbnZNZXNzYWdlLmNpZDtcbiAgICAgICAgICAgICAgY2RhdGUgPSBfcmVmMzMkY29udk1lc3NhZ2UuY2RhdGU7XG4gICAgICAgICAgICAgIHR0bCA9IF9yZWYzMyRjb252TWVzc2FnZS50ZW1wQ29udlRUTDtcbiAgICAgICAgICAgICAgZGF0YSA9IF9leHRlbmRzJDEoe1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUkJDEsXG4gICAgICAgICAgICAgICAgdHJhbnNpZW50OiB0cmFuc2llbnQsXG4gICAgICAgICAgICAgICAgdW5pcXVlOiB1bmlxdWUsXG4gICAgICAgICAgICAgICAgaWQ6IGNpZCxcbiAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IGNkYXRlLFxuICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogY2RhdGUsXG4gICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VBdDogbnVsbCxcbiAgICAgICAgICAgICAgICBjcmVhdG9yOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIG1lbWJlcnM6IHRyYW5zaWVudCA/IFtdIDogbWVtYmVyc1xuICAgICAgICAgICAgICB9LCBwcm9wZXJ0aWVzKTtcblxuICAgICAgICAgICAgICBpZiAodHRsKSBkYXRhLmV4cGlyZWRBdCA9IERhdGUubm93KCkgKyB0dGwgKiAxMDAwO1xuICAgICAgICAgICAgICBfY29udGV4dDIwLm5leHQgPSAzMDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb252ZXJzYXRpb24oZGF0YSk7XG5cbiAgICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICAgIGNvbnZlcnNhdGlvbiA9IF9jb250ZXh0MjAuc2VudDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjAuYWJydXB0KCdyZXR1cm4nLCB0aGlzLl91cHNlcnRDb252ZXJzYXRpb25Ub0NhY2hlKGNvbnZlcnNhdGlvbikpO1xuXG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjAuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTIwLCB0aGlzKTtcbiAgICB9KSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDb252ZXJzYXRpb24oKSB7XG4gICAgICByZXR1cm4gX3JlZjMyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNvbnZlcnNhdGlvbjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiDliJvlu7rkuIDkuKrogYrlpKnlrqRcbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIOmZpOS6huS4i+WIl+Wtl+auteWklueahOWFtuS7luWtl+auteWwhuiiq+inhuS4uuWvueivneeahOiHquWumuS5ieWxnuaAp1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubmFtZV0g5a+56K+d55qE5ZCN5a2XXG4gICAqIEByZXR1cm4ge1Byb21pc2UuPENoYXRSb29tPn1cbiAgICovXG5cblxuICBJTUNsaWVudC5wcm90b3R5cGUuY3JlYXRlQ2hhdFJvb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYzNCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMjEocGFyYW0pIHtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvci53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyMSQoX2NvbnRleHQyMSkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyMS5wcmV2ID0gX2NvbnRleHQyMS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIxLmFicnVwdCgncmV0dXJuJywgdGhpcy5jcmVhdGVDb252ZXJzYXRpb24oX2V4dGVuZHMkMSh7fSwgcGFyYW0sIHtcbiAgICAgICAgICAgICAgICB0cmFuc2llbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbWVtYmVyczogbnVsbCxcbiAgICAgICAgICAgICAgICB1bmlxdWU6IGZhbHNlXG4gICAgICAgICAgICAgIH0pKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIxLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUyMSwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2hhdFJvb20oX3gyNikge1xuICAgICAgcmV0dXJuIF9yZWYzNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGF0Um9vbTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiDliJvlu7rkuIDkuKrkuLTml7blr7nor51cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IG9wdGlvbnMubWVtYmVycyDlr7nor53nmoTliJ3lp4vmiJDlkZjliJfooajvvIzpu5jorqTljIXlkKvlvZPliY0gY2xpZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50dGxdIOWvueivneWtmOWcqOaXtumXtO+8jOWNleS9jeS4uuenku+8jOacgOWkp+WAvOS4jum7mOiupOWAvOWdh+S4uiA4NjQwMO+8iOS4gOWkqe+8ie+8jOi/h+acn+WQjuivpeWvueivneS4jeWGjeWPr+eUqOOAglxuICAgKiBAcmV0dXJuIHtQcm9taXNlLjxUZW1wb3JhcnlDb252ZXJzYXRpb24+fVxuICAgKi9cblxuXG4gIElNQ2xpZW50LnByb3RvdHlwZS5jcmVhdGVUZW1wb3JhcnlDb252ZXJzYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYzNiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3IubWFyayhmdW5jdGlvbiBfY2FsbGVlMjIoX3JlZjM1KSB7XG4gICAgICB2YXIgX3RlbXBDb252VFRMID0gX3JlZjM1LnR0bCxcbiAgICAgICAgICBwYXJhbSA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMzUsIFsndHRsJ10pO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMjIkKF9jb250ZXh0MjIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MjIucHJldiA9IF9jb250ZXh0MjIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMi5hYnJ1cHQoJ3JldHVybicsIHRoaXMuY3JlYXRlQ29udmVyc2F0aW9uKF9leHRlbmRzJDEoe30sIHBhcmFtLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNpZW50OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB1bmlxdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIF90ZW1wQ29udjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBfdGVtcENvbnZUVEw6IF90ZW1wQ29udlRUTFxuICAgICAgICAgICAgICB9KSkpO1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlMjIsIHRoaXMpO1xuICAgIH0pKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRlbXBvcmFyeUNvbnZlcnNhdGlvbihfeDI3KSB7XG4gICAgICByZXR1cm4gX3JlZjM2LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZVRlbXBvcmFyeUNvbnZlcnNhdGlvbjtcbiAgfSgpO1xuXG4gIC8vIGpzZG9jLWlnbm9yZS1zdGFydFxuXG5cbiAgLy8ganNkb2MtaWdub3JlLWVuZFxuICBJTUNsaWVudC5wcm90b3R5cGUuX2RvU2VuZFJlYWQgPSBmdW5jdGlvbiBfZG9TZW5kUmVhZCgpIHtcbiAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICAvLyBpZiBub3QgY29ubmVjdGVkLCBqdXN0IHNraXAgZXZlcnl0aGluZ1xuICAgIGlmICghdGhpcy5fY29ubmVjdGlvbi5pcygnY29ubmVjdGVkJykpIHJldHVybjtcbiAgICB2YXIgYnVmZmVyID0gaW50ZXJuYWwodGhpcykucmVhZENvbnZlcnNhdGlvbnNCdWZmZXI7XG4gICAgdmFyIGNvbnZlcnNhdGlvbnMgPSBfQXJyYXkkZnJvbShidWZmZXIpO1xuICAgIGlmICghY29udmVyc2F0aW9ucy5sZW5ndGgpIHJldHVybjtcbiAgICB2YXIgaWRzID0gY29udmVyc2F0aW9ucy5tYXAoZnVuY3Rpb24gKGNvbnZlcnNhdGlvbikge1xuICAgICAgaWYgKCEoY29udmVyc2F0aW9uIGluc3RhbmNlb2YgQ29udmVyc2F0aW9uQmFzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb252ZXJzYXRpb24gKyAnIGlzIG5vdCBhIENvbnZlcnNhdGlvbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnZlcnNhdGlvbi5pZDtcbiAgICB9KTtcbiAgICB0aGlzLl9kZWJ1ZygnbWFyayBbJyArIGlkcyArICddIGFzIHJlYWQnKTtcbiAgICBidWZmZXIuY2xlYXIoKTtcbiAgICB0aGlzLl9zZW5kUmVhZENvbW1hbmQoY29udmVyc2F0aW9ucykuY2F0Y2goZnVuY3Rpb24gKGVycm9yJCQxKSB7XG4gICAgICBfdGhpczEwLl9kZWJ1Zygnc2VuZCByZWFkIGZhaWxlZDogJU8nLCBlcnJvciQkMSk7XG4gICAgICBjb252ZXJzYXRpb25zLmZvckVhY2goYnVmZmVyLmFkZC5iaW5kKGJ1ZmZlcikpO1xuICAgIH0pO1xuICB9O1xuXG4gIElNQ2xpZW50LnByb3RvdHlwZS5fc2VuZFJlYWRDb21tYW5kID0gZnVuY3Rpb24gX3NlbmRSZWFkQ29tbWFuZChjb252ZXJzYXRpb25zKSB7XG4gICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuX3NlbmQobmV3IEdlbmVyaWNDb21tYW5kKHtcbiAgICAgIGNtZDogJ3JlYWQnLFxuICAgICAgcmVhZE1lc3NhZ2U6IG5ldyBSZWFkQ29tbWFuZCh7XG4gICAgICAgIGNvbnZzOiBjb252ZXJzYXRpb25zLm1hcChmdW5jdGlvbiAoY29udmVyc2F0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWFkVHVwbGUoe1xuICAgICAgICAgICAgY2lkOiBjb252ZXJzYXRpb24uaWQsXG4gICAgICAgICAgICBtaWQ6IGNvbnZlcnNhdGlvbi5sYXN0TWVzc2FnZSAmJiBjb252ZXJzYXRpb24ubGFzdE1lc3NhZ2UuZnJvbSAhPT0gX3RoaXMxMS5pZCA/IGNvbnZlcnNhdGlvbi5sYXN0TWVzc2FnZS5pZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogKGNvbnZlcnNhdGlvbi5sYXN0TWVzc2FnZUF0IHx8IG5ldyBEYXRlKCkpLmdldFRpbWUoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KSwgZmFsc2UpO1xuICB9O1xuXG4gIHJldHVybiBJTUNsaWVudDtcbn0oZXZlbnRlbWl0dGVyMyksIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IkMShfY2xhc3MkMy5wcm90b3R5cGUsICdfZG9TZW5kQWNrJywgW19kZWMkMl0sIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9jbGFzcyQzLnByb3RvdHlwZSwgJ19kb1NlbmRBY2snKSwgX2NsYXNzJDMucHJvdG90eXBlKSwgX2FwcGx5RGVjb3JhdGVkRGVzY3JpcHRvciQxKF9jbGFzcyQzLnByb3RvdHlwZSwgJ19kb1NlbmRSZWFkJywgW19kZWMyXSwgX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX2NsYXNzJDMucHJvdG90eXBlLCAnX2RvU2VuZFJlYWQnKSwgX2NsYXNzJDMucHJvdG90eXBlKSwgX2NsYXNzJDMpO1xuXG52YXIgUkVDT05ORUNUX0VSUk9SID0gJ3JlY29ubmVjdGVycm9yJztcblxudmFyIENvcmVFdmVudCA9IE9iamVjdC5mcmVlemUoe1xuXHRSRUNPTk5FQ1RfRVJST1I6IFJFQ09OTkVDVF9FUlJPUixcblx0RElTQ09OTkVDVDogRElTQ09OTkVDVCxcblx0UkVDT05ORUNUOiBSRUNPTk5FQ1QsXG5cdFJFVFJZOiBSRVRSWSxcblx0U0NIRURVTEU6IFNDSEVEVUxFLFxuXHRPRkZMSU5FOiBPRkZMSU5FLFxuXHRPTkxJTkU6IE9OTElORVxufSk7XG5cbnZhciBfY2xhc3MkNDtcbi8vIGpzZG9jLWlnbm9yZS1zdGFydFxuXG4vLyBqc2RvYy1pZ25vcmUtZW5kXG52YXIgQmluYXJ5TWVzc2FnZSA9IElFMTBDb21wYXRpYmxlKF9jbGFzcyQ0ID0gZnVuY3Rpb24gKF9NZXNzYWdlKSB7XG4gIF9pbmhlcml0cyhCaW5hcnlNZXNzYWdlLCBfTWVzc2FnZSk7XG5cbiAgLyoqXG4gICAqIOS6jOi/m+WItua2iOaBr1xuICAgKiBAZXh0ZW5kcyBNZXNzYWdlXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlclxuICAgKiBAc2luY2UgNC4wLjBcbiAgICovXG4gIGZ1bmN0aW9uIEJpbmFyeU1lc3NhZ2UoYnVmZmVyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJpbmFyeU1lc3NhZ2UpO1xuXG4gICAgaWYgKCEoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGJ1ZmZlciArICcgaXMgbm90IGFuIEFycmF5QnVmZmVyJyk7XG4gICAgfVxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfTWVzc2FnZS5jYWxsKHRoaXMsIGJ1ZmZlcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIEFycmF5QnVmZmVyXG4gICAqL1xuXG5cbiAgQmluYXJ5TWVzc2FnZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbiAgfTtcblxuICBCaW5hcnlNZXNzYWdlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIF9leHRlbmRzJDEoe30sIF9NZXNzYWdlLnByb3RvdHlwZS5fdG9KU09OLmNhbGwodGhpcyksIHtcbiAgICAgIGRhdGE6IGJhc2U2NEFycmF5YnVmZmVyXzEodGhpcy5jb250ZW50KVxuICAgIH0pO1xuICB9O1xuXG4gIEJpbmFyeU1lc3NhZ2UucHJvdG90eXBlLnRvRnVsbEpTT04gPSBmdW5jdGlvbiB0b0Z1bGxKU09OKCkge1xuICAgIHJldHVybiBfZXh0ZW5kcyQxKHt9LCBfTWVzc2FnZS5wcm90b3R5cGUudG9GdWxsSlNPTi5jYWxsKHRoaXMpLCB7XG4gICAgICBiaW46IHRydWUsXG4gICAgICBkYXRhOiBiYXNlNjRBcnJheWJ1ZmZlcl8xKHRoaXMuY29udGVudClcbiAgICB9KTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoQmluYXJ5TWVzc2FnZSwgW3tcbiAgICBrZXk6ICdidWZmZXInLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGJ1ZmZlcikge1xuICAgICAgdGhpcy5jb250ZW50ID0gYnVmZmVyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCaW5hcnlNZXNzYWdlO1xufShNZXNzYWdlKSkgfHwgX2NsYXNzJDQ7XG5cbnZhciBfZGVjJDMsIF9jbGFzcyQ1O1xuXG4vLyBqc2RvYy1pZ25vcmUtc3RhcnRcblxuLy8ganNkb2MtaWdub3JlLWVuZFxudmFyIFRleHRNZXNzYWdlID0gKF9kZWMkMyA9IG1lc3NhZ2VUeXBlKC0xKSwgX2RlYyQzKF9jbGFzcyQ1ID0gSUUxMENvbXBhdGlibGUoX2NsYXNzJDUgPSBmdW5jdGlvbiAoX1R5cGVkTWVzc2FnZSkge1xuICBfaW5oZXJpdHMoVGV4dE1lc3NhZ2UsIF9UeXBlZE1lc3NhZ2UpO1xuXG4gIC8qKlxuICAgKiDmlofnsbvnsbvlnovmtojmga9cbiAgICogQGV4dGVuZHMgVHlwZWRNZXNzYWdlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW3RleHQ9JyddXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gdGV4dCDkuI3mmK8gU3RyaW5nIOexu+Wei1xuICAgKi9cbiAgZnVuY3Rpb24gVGV4dE1lc3NhZ2UoKSB7XG4gICAgdmFyIHRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcnO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRNZXNzYWdlKTtcblxuICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IodGV4dCArICcgaXMgbm90IGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1R5cGVkTWVzc2FnZS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLnNldFRleHQodGV4dCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFRleHRNZXNzYWdlO1xufShUeXBlZE1lc3NhZ2UpKSB8fCBfY2xhc3MkNSkgfHwgX2NsYXNzJDUpO1xuXG52YXIgX2NsYXNzJDY7XG5cbmZ1bmN0aW9uIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IkMih0YXJnZXQsIHByb3BlcnR5LCBkZWNvcmF0b3JzLCBkZXNjcmlwdG9yLCBjb250ZXh0KSB7XG4gIHZhciBkZXNjID0ge307XG4gIE9iamVjdFsna2UnICsgJ3lzJ10oZGVzY3JpcHRvcikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgZGVzY1trZXldID0gZGVzY3JpcHRvcltrZXldO1xuICB9KTtcbiAgZGVzYy5lbnVtZXJhYmxlID0gISFkZXNjLmVudW1lcmFibGU7XG4gIGRlc2MuY29uZmlndXJhYmxlID0gISFkZXNjLmNvbmZpZ3VyYWJsZTtcblxuICBpZiAoJ3ZhbHVlJyBpbiBkZXNjIHx8IGRlc2MuaW5pdGlhbGl6ZXIpIHtcbiAgICBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcbiAgfVxuXG4gIGRlc2MgPSBkZWNvcmF0b3JzLnNsaWNlKCkucmV2ZXJzZSgpLnJlZHVjZShmdW5jdGlvbiAoZGVzYywgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5LCBkZXNjKSB8fCBkZXNjO1xuICB9LCBkZXNjKTtcblxuICBpZiAoY29udGV4dCAmJiBkZXNjLmluaXRpYWxpemVyICE9PSB2b2lkIDApIHtcbiAgICBkZXNjLnZhbHVlID0gZGVzYy5pbml0aWFsaXplciA/IGRlc2MuaW5pdGlhbGl6ZXIuY2FsbChjb250ZXh0KSA6IHZvaWQgMDtcbiAgICBkZXNjLmluaXRpYWxpemVyID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKGRlc2MuaW5pdGlhbGl6ZXIgPT09IHZvaWQgMCkge1xuICAgIE9iamVjdFsnZGVmaW5lJyArICdQcm9wZXJ0eSddKHRhcmdldCwgcHJvcGVydHksIGRlc2MpO1xuICAgIGRlc2MgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGRlc2M7XG59XG5cbnZhciBkZWJ1ZyQxMSA9IGJyb3dzZXIoJ0xDOk1lc3NhZ2VQYXJzZXInKTtcblxudmFyIHRyeVBhcnNlSnNvbiA9IGZ1bmN0aW9uIHRyeVBhcnNlSnNvbih0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICB2YXIgZm4gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uIHdyYXBwZXIocGFyYW0pIHtcbiAgICB2YXIgY29udGVudCA9IHZvaWQgMDtcbiAgICBpZiAodHlwZW9mIHBhcmFtICE9PSAnc3RyaW5nJykge1xuICAgICAgY29udGVudCA9IHBhcmFtO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb250ZW50ID0gSlNPTi5wYXJzZShwYXJhbSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb250ZW50ID0gcGFyYW07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGNvbnRlbnQpO1xuICB9O1xufTtcblxudmFyIGFwcGx5UGx1Z2lucyA9IGZ1bmN0aW9uIGFwcGx5UGx1Z2lucyh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICB2YXIgZm4gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uIHdyYXBwZXIoanNvbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gX1Byb21pc2UucmVzb2x2ZShqc29uKS50aGVuKGFwcGx5TWlkZGxld2FyZXModGhpcy5fcGx1Z2lucy5iZWZvcmVNZXNzYWdlUGFyc2UpKS50aGVuKGZ1bmN0aW9uIChkZWNvcmF0ZWRKc29uKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbChfdGhpcywgZGVjb3JhdGVkSnNvbik7XG4gICAgfSkudGhlbihhcHBseU1pZGRsZXdhcmVzKHRoaXMuX3BsdWdpbnMuYWZ0ZXJNZXNzYWdlUGFyc2UpKTtcbiAgfTtcbn07XG5cbnZhciBNZXNzYWdlUGFyc2VyID0gKF9jbGFzcyQ2ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNZXNzYWdlUGFyc2VyKCkge1xuICAgIHZhciBwbHVnaW5zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZXNzYWdlUGFyc2VyKTtcblxuICAgIHRoaXMuX3BsdWdpbnMgPSBwbHVnaW5zO1xuICAgIHRoaXMuX21lc3NhZ2VDbGFzc2VzID0gW107XG4gIH1cblxuICBNZXNzYWdlUGFyc2VyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKG1lc3NhZ2VDbGFzcykge1xuICAgIGlmIChtZXNzYWdlQ2xhc3MgJiYgbWVzc2FnZUNsYXNzLnBhcnNlICYmIG1lc3NhZ2VDbGFzcy5wcm90b3R5cGUgJiYgbWVzc2FnZUNsYXNzLnByb3RvdHlwZS5nZXRQYXlsb2FkKSB7XG4gICAgICB0aGlzLl9tZXNzYWdlQ2xhc3Nlcy51bnNoaWZ0KG1lc3NhZ2VDbGFzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWVzc2FnZUNsYXNzJyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGpzZG9jLWlnbm9yZS1zdGFydFxuXG5cbiAgLy8ganNkb2MtaWdub3JlLWVuZFxuICBNZXNzYWdlUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGNvbnRlbnQpIHtcbiAgICBkZWJ1ZyQxMSgncGFyc2luZyBtZXNzYWdlOiAlTycsIGNvbnRlbnQpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2dldEl0ZXJhdG9yKHRoaXMuX21lc3NhZ2VDbGFzc2VzKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICB2YXIgS2xhc3MgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICB2YXIgY29udGVudENvcHkgPSBpc1BsYWluT2JqZWN0XzEoY29udGVudCkgPyBfT2JqZWN0JGFzc2lnbih7fSwgY29udGVudCkgOiBjb250ZW50O1xuICAgICAgICB2YXIgdmFsaWQgPSB2b2lkIDA7XG4gICAgICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFsaWQgPSBLbGFzcy52YWxpZGF0ZShjb250ZW50Q29weSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBLbGFzcy5wYXJzZShjb250ZW50Q29weSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigncGFyc2luZyBhIHZhbGlkIG1lc3NhZ2UgY29udGVudCBlcnJvcicsIHtcbiAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICBLbGFzczogS2xhc3MsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRDb3B5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyQxMSgncGFyc2UgcmVzdWx0OiAlTycsIHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignTm8gTWVzc2FnZSBDbGFzcyBtYXRjaGVkJyk7XG4gIH07XG5cbiAgcmV0dXJuIE1lc3NhZ2VQYXJzZXI7XG59KCksIF9hcHBseURlY29yYXRlZERlc2NyaXB0b3IkMihfY2xhc3MkNi5wcm90b3R5cGUsICdwYXJzZScsIFt0cnlQYXJzZUpzb24sIGFwcGx5UGx1Z2luc10sIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9jbGFzcyQ2LnByb3RvdHlwZSwgJ3BhcnNlJyksIF9jbGFzcyQ2LnByb3RvdHlwZSksIF9jbGFzcyQ2KTtcblxudmFyIF90aGlzID0gdW5kZWZpbmVkO1xuXG52YXIgZGVidWckMTIgPSBicm93c2VyKCdMQzpJTVBsdWdpbicpO1xuXG4vKipcbiAqIOa2iOaBr+S8mOWFiOe6p+aemuS4vlxuICogQGVudW0ge051bWJlcn1cbiAqIEBzaW5jZSAzLjMuMFxuICovXG52YXIgTWVzc2FnZVByaW9yaXR5ID0ge1xuICAvKiog6auYICovXG4gIEhJR0g6IDEsXG4gIC8qKiDmma7pgJogKi9cbiAgTk9STUFMOiAyLFxuICAvKiog5L2OICovXG4gIExPVzogM1xufTtcbl9PYmplY3QkZnJlZXplKE1lc3NhZ2VQcmlvcml0eSk7XG5cbi8qKlxuICog5Li6IENvbnZlcnNhdGlvbiDlrprkuYnkuIDkuKrmlrDlsZ7mgKdcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIOWxnuaAp+WQjVxuICogQHBhcmFtIHtPYmplY3R9IFtkZXNjcmlwdG9yXSDlsZ7mgKfnmoTmj4/ov7DnrKbvvIzlj4Lop4Ege0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IjRGVzY3JpcHRpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yI0Rlc2NyaXB0aW9uIC0gTUROfe+8jOm7mOiupOS4uuivpeWxnuaAp+WQjeWvueW6lOeahCBDb252ZXJzYXRpb24g6Ieq5a6a5LmJ5bGe5oCn55qEIGdldHRlci9zZXR0ZXJcbiAqIEByZXR1cm5zIHZvaWRcbiAqIEBleGFtcGxlXG4gKlxuICogY29udmVyc2F0aW9uLmdldCgndHlwZScpO1xuICogY29udmVyc2F0aW9uLnNldCgndHlwZScsIDEpO1xuICpcbiAqIC8vIGVxdWFscyB0b1xuICogZGVmaW5lQ29udmVyc2F0aW9uUHJvcGVydHkoJ3R5cGUnKTtcbiAqIGNvbnZlcnNhdGlvbi50eXBlO1xuICogY29udmVyc2F0aW9uLnR5cGUgPSAxO1xuICovXG52YXIgZGVmaW5lQ29udmVyc2F0aW9uUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVDb252ZXJzYXRpb25Qcm9wZXJ0eShwcm9wKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQocHJvcCk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5zZXQocHJvcCwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBfT2JqZWN0JGRlZmluZVByb3BlcnR5KENvbnZlcnNhdGlvbi5wcm90b3R5cGUsIHByb3AsIGRlc2NyaXB0b3IpO1xufTtcblxudmFyIG9uUmVhbHRpbWVDcmVhdGUgPSBmdW5jdGlvbiBvblJlYWx0aW1lQ3JlYXRlKHJlYWx0aW1lKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gIHZhciBkZXZpY2VJZCA9IHY0XzEoKTtcbiAgcmVhbHRpbWUuX0lNQ2xpZW50cyA9IHt9O1xuICByZWFsdGltZS5fSU1DbGllbnRzQ3JlYXRpb25Db3VudCA9IDA7XG4gIHZhciBtZXNzYWdlUGFyc2VyID0gbmV3IE1lc3NhZ2VQYXJzZXIocmVhbHRpbWUuX3BsdWdpbnMpO1xuICByZWFsdGltZS5fbWVzc2FnZVBhcnNlciA9IG1lc3NhZ2VQYXJzZXI7XG5cbiAgdmFyIHNpZ25BVlVzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSh1c2VyKSB7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdCgncmV0dXJuJywgcmVhbHRpbWUuX3JlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIHBhdGg6ICcvcnRtL3NpZ24nLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgIHNlc3Npb25fdG9rZW46IHVzZXIuZ2V0U2Vzc2lvblRva2VuKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUsIF90aGlzKTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gc2lnbkFWVXNlcihfeDIpIHtcbiAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiDms6jlhozmtojmga/nsbtcbiAgICpcbiAgICog5Zyo5o6l5pS25raI5oGv44CB5p+l6K+i5raI5oGv5pe277yM5Lya5oyJ54Wn5raI5oGv57G75rOo5YaM6aG65bqP55qE6YCG5bqP5L6d5qyh5bCd6K+V6Kej5p6Q5raI5oGv5YaF5a65XG4gICAqXG4gICAqIEBtZW1iZXJvZiBSZWFsdGltZVxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtICB7RnVuY3Rpb24gfCBGdW5jdGlvbltdfSBtZXNzYWdlQ2xhc3Mg5raI5oGv57G777yM6ZyA6KaB5a6e546wIHtAbGluayBBVk1lc3NhZ2V9IOaOpeWPo++8jFxuICAgKiDlu7rorq7nu6fmib/oh6oge0BsaW5rIFR5cGVkTWVzc2FnZX1cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSDlpoLmnpwgbWVzc2FnZUNsYXNzIOayoeacieWunueOsCB7QGxpbmsgQVZNZXNzYWdlfSDmjqXlj6PliJnmipvlh7rlvILluLhcbiAgICovXG4gIHZhciByZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKG1lc3NhZ2VDbGFzcykge1xuICAgIHJldHVybiBlbnN1cmVBcnJheShtZXNzYWdlQ2xhc3MpLm1hcChtZXNzYWdlUGFyc2VyLnJlZ2lzdGVyLmJpbmQobWVzc2FnZVBhcnNlcikpO1xuICB9O1xuICByZWdpc3RlcihlbnN1cmVBcnJheShyZWFsdGltZS5fcGx1Z2lucy5tZXNzYWdlQ2xhc3NlcykpO1xuICAvKipcbiAgICog5Yib5bu65LiA5Liq5Y2z5pe26YCa6K6v5a6i5oi356uv77yM5aSa5qyh5Yib5bu655u45ZCMIGlkIOeahOWuouaIt+err+S8mui/lOWbnuWQjOS4gOS4quWunuS+i1xuICAgKiBAbWVtYmVyb2YgUmVhbHRpbWVcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSAge1N0cmluZ3xBVi5Vc2VyfSBbaWRlbnRpdHldIOWuouaIt+erryBpZGVudGl0ee+8jOWmguaenOS4jeaMh+WumuivpeWPguaVsO+8jOacjeWKoeerr+S8mumaj+acuueUn+aIkOS4gOS4quWtl+espuS4suS9nOS4uiBpZGVudGl0ee+8jFxuICAgKiDlpoLmnpzkvKDlhaXkuIDkuKrlt7LnmbvlvZXnmoQgQVYuVXNlcu+8jOWImeS8muS9v+eUqOivpeeUqOaIt+eahCBpZCDkvZzkuLrlrqLmiLfnq68gaWRlbnRpdHkg55m75b2V44CCXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb3B0aW9ucy5zaWduYXR1cmVGYWN0b3J5XSBvcGVuIHNlc3Npb24g5pe255qE562+5ZCN5pa55rOVIC8vIFRPRE8gbmVlZCBkZXRhaWxzXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb3B0aW9ucy5jb252ZXJzYXRpb25TaWduYXR1cmVGYWN0b3J5XSDlr7nor53liJvlu7rjgIHlop7lh4/miJDlkZjmk43kvZzml7bnmoTnrb7lkI3mlrnms5VcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLmJsYWNrbGlzdFNpZ25hdHVyZUZhY3RvcnldIOm7keWQjeWNleaTjeS9nOaXtueahOetvuWQjeaWueazlVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtvcHRpb25zLnRhZ10g5a6i5oi356uv57G75Z6L5qCH6K6w77yM5Lul5pSv5oyB5Y2V54K555m75b2V5Yqf6IO9XG4gICAqIEBwYXJhbSAge1N0cmluZ30gW29wdGlvbnMuaXNSZWNvbm5lY3Q9ZmFsc2VdIOWNleeCueeZu+W9leaXtuagh+iusOivpeasoeeZu+W9leaYr+S4jeaYr+W6lOeUqOWQr+WKqOaXtuiHquWKqOmHjeaWsOeZu+W9lVxuICAgKiBAcmV0dXJuIHtQcm9taXNlLjxJTUNsaWVudD59XG4gICAqL1xuICB2YXIgY3JlYXRlSU1DbGllbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvci5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGlkZW50aXR5KSB7XG4gICAgICB2YXIgX3JlYWx0aW1lJF9vcGVuJHRoZW47XG5cbiAgICAgIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgIHZhciB0YWcgPSBfcmVmMi50YWcsXG4gICAgICAgICAgaXNSZWNvbm5lY3QgPSBfcmVmMi5pc1JlY29ubmVjdCxcbiAgICAgICAgICBjbGllbnRPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBbJ3RhZycsICdpc1JlY29ubmVjdCddKTtcblxuICAgICAgdmFyIGxhZ2VjeVRhZyA9IGFyZ3VtZW50c1syXTtcblxuICAgICAgdmFyIGlkLCBidWlsZGluT3B0aW9ucywgc2Vzc2lvblRva2VuLCBfdGFnLCBwcm9taXNlO1xuXG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3Iud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGlkID0gdm9pZCAwO1xuICAgICAgICAgICAgICBidWlsZGluT3B0aW9ucyA9IHt9O1xuXG4gICAgICAgICAgICAgIGlmICghaWRlbnRpdHkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIGlkZW50aXR5ID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZCA9IGlkZW50aXR5O1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE2O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBpZiAoIShpZGVudGl0eS5pZCAmJiBpZGVudGl0eS5nZXRTZXNzaW9uVG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlkID0gaWRlbnRpdHkuaWQ7XG4gICAgICAgICAgICAgIHNlc3Npb25Ub2tlbiA9IGlkZW50aXR5LmdldFNlc3Npb25Ub2tlbigpO1xuXG4gICAgICAgICAgICAgIGlmIChzZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2VyIG11c3QgYmUgYXV0aGVudGljYXRlZCcpO1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBidWlsZGluT3B0aW9ucy5zaWduYXR1cmVGYWN0b3J5ID0gc2lnbkFWVXNlcjtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lkZW50aXR5IG11c3QgYmUgYSBTdHJpbmcgb3IgYW4gQVYuVXNlcicpO1xuXG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICBpZiAoIShyZWFsdGltZS5fSU1DbGllbnRzW2lkXSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdCgncmV0dXJuJywgcmVhbHRpbWUuX0lNQ2xpZW50c1tpZF0pO1xuXG4gICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICBpZiAobGFnZWN5VGFnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdERVBSRUNBVElPTiBjcmVhdGVJTUNsaWVudCB0YWcgcGFyYW06IFVzZSBvcHRpb25zLnRhZyBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF90YWcgPSB0YWcgfHwgbGFnZWN5VGFnO1xuICAgICAgICAgICAgICBwcm9taXNlID0gKF9yZWFsdGltZSRfb3BlbiR0aGVuID0gcmVhbHRpbWUuX29wZW4oKS50aGVuKGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsaWVudCA9IG5ldyBJTUNsaWVudChpZCwgX2V4dGVuZHMkMSh7fSwgYnVpbGRpbk9wdGlvbnMsIGNsaWVudE9wdGlvbnMpLCB7XG4gICAgICAgICAgICAgICAgICBfY29ubmVjdGlvbjogY29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICAgIF9yZXF1ZXN0OiByZWFsdGltZS5fcmVxdWVzdC5iaW5kKHJlYWx0aW1lKSxcbiAgICAgICAgICAgICAgICAgIF9tZXNzYWdlUGFyc2VyOiBtZXNzYWdlUGFyc2VyLFxuICAgICAgICAgICAgICAgICAgX3BsdWdpbnM6IHJlYWx0aW1lLl9wbHVnaW5zLFxuICAgICAgICAgICAgICAgICAgX2lkZW50aXR5OiBpZGVudGl0eVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ub24oUkVDT05ORUNULCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50Ll9vcGVuKHJlYWx0aW1lLl9vcHRpb25zLmFwcElkLCBfdGFnLCBkZXZpY2VJZCwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICog5a6i5oi356uv6L+e5o6l5oGi5aSN5q2j5bi477yM6K+l5LqL5Lu26YCa5bi45ZyoIHtAbGluayBSZWFsdGltZSNldmVudDpSRUNPTk5FQ1R9IOS5i+WQjuWPkeeUn1xuICAgICAgICAgICAgICAgICAgICogQGV2ZW50IElNQ2xpZW50I1JFQ09OTkVDVFxuICAgICAgICAgICAgICAgICAgICogQHNlZSBSZWFsdGltZSNldmVudDpSRUNPTk5FQ1RcbiAgICAgICAgICAgICAgICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAqIOWuouaIt+err+mHjeaWsOeZu+W9leWPkeeUn+mUmeivr++8iOe9kee7nOi/nuaOpeW3suaBouWkje+8jOS9humHjeaWsOeZu+W9lemUmeivr++8iVxuICAgICAgICAgICAgICAgICAgICogQGV2ZW50IElNQ2xpZW50I1JFQ09OTkVDVF9FUlJPUlxuICAgICAgICAgICAgICAgICAgICogQHNpbmNlIDMuMi4wXG4gICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5lbWl0KFJFQ09OTkVDVCk7XG4gICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5lbWl0KFJFQ09OTkVDVF9FUlJPUiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWwoY2xpZW50KS5fZXZlbnRlbWl0dGVyLm9uKCdiZWZvcmVjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZWFsdGltZS5fSU1DbGllbnRzW2NsaWVudC5pZF07XG4gICAgICAgICAgICAgICAgICBpZiAocmVhbHRpbWUuX2ZpcnN0SU1DbGllbnQgPT09IGNsaWVudCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVhbHRpbWUuX2ZpcnN0SU1DbGllbnQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgcmVhbHRpbWUpO1xuICAgICAgICAgICAgICAgIGludGVybmFsKGNsaWVudCkuX2V2ZW50ZW1pdHRlci5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZWFsdGltZS5fZGVyZWdpc3RlcihjbGllbnQpO1xuICAgICAgICAgICAgICAgIH0sIHJlYWx0aW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50Ll9vcGVuKHJlYWx0aW1lLl9vcHRpb25zLmFwcElkLCBfdGFnLCBkZXZpY2VJZCwgaXNSZWNvbm5lY3QpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmVhbHRpbWUuX0lNQ2xpZW50c1tjbGllbnQuaWRdID0gY2xpZW50O1xuICAgICAgICAgICAgICAgICAgcmVhbHRpbWUuX0lNQ2xpZW50c0NyZWF0aW9uQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgIGlmIChyZWFsdGltZS5fSU1DbGllbnRzQ3JlYXRpb25Db3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQuX29taXRQZWVySWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlYWx0aW1lLl9maXJzdElNQ2xpZW50ID0gY2xpZW50O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZWFsdGltZS5fSU1DbGllbnRzQ3JlYXRpb25Db3VudCA+IDEgJiYgcmVhbHRpbWUuX2ZpcnN0SU1DbGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhbHRpbWUuX2ZpcnN0SU1DbGllbnQuX29taXRQZWVySWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVhbHRpbWUuX3JlZ2lzdGVyKGNsaWVudCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlYWx0aW1lLl9JTUNsaWVudHNbY2xpZW50LmlkXTtcbiAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KSkudGhlbi5hcHBseShfcmVhbHRpbWUkX29wZW4kdGhlbiwgX3RvQ29uc3VtYWJsZUFycmF5KGZpbmFsaXplKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZWFsdGltZS5fZGVyZWdpc3RlclBlbmRpbmcocHJvbWlzZSk7XG4gICAgICAgICAgICAgIH0pKSk7XG5cbiAgICAgICAgICAgICAgaWYgKGlkZW50aXR5KSB7XG4gICAgICAgICAgICAgICAgcmVhbHRpbWUuX0lNQ2xpZW50c1tpZF0gPSBwcm9taXNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlYWx0aW1lLl9yZWdpc3RlclBlbmRpbmcocHJvbWlzZSk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KCdyZXR1cm4nLCBwcm9taXNlKTtcblxuICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTIsIF90aGlzKTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlSU1DbGllbnQoX3g0KSB7XG4gICAgICByZXR1cm4gX3JlZjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KCk7XG4gIF9PYmplY3QkYXNzaWduKHJlYWx0aW1lLCB7XG4gICAgcmVnaXN0ZXI6IHJlZ2lzdGVyLFxuICAgIGNyZWF0ZUlNQ2xpZW50OiBjcmVhdGVJTUNsaWVudFxuICB9KTtcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xufTtcblxudmFyIGJlZm9yZUNvbW1hbmREaXNwYXRjaCA9IGZ1bmN0aW9uIGJlZm9yZUNvbW1hbmREaXNwYXRjaChjb21tYW5kLCByZWFsdGltZSkge1xuICB2YXIgaXNJTUNvbW1hbmQgPSBjb21tYW5kLnNlcnZpY2UgPT09IG51bGwgfHwgY29tbWFuZC5zZXJ2aWNlID09PSAyO1xuICBpZiAoIWlzSU1Db21tYW5kKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIHRhcmdldENsaWVudCA9IGNvbW1hbmQucGVlcklkID8gcmVhbHRpbWUuX0lNQ2xpZW50c1tjb21tYW5kLnBlZXJJZF0gOiByZWFsdGltZS5fZmlyc3RJTUNsaWVudDtcbiAgaWYgKHRhcmdldENsaWVudCkge1xuICAgIF9Qcm9taXNlLnJlc29sdmUodGFyZ2V0Q2xpZW50KS50aGVuKGZ1bmN0aW9uIChjbGllbnQpIHtcbiAgICAgIHJldHVybiBjbGllbnQuX2Rpc3BhdGNoQ29tbWFuZChjb21tYW5kKTtcbiAgICB9KS5jYXRjaChkZWJ1ZyQxMik7XG4gIH0gZWxzZSB7XG4gICAgZGVidWckMTIoJ1tXQVJOXSBVbmV4cGVjdGVkIG1lc3NhZ2UgcmVjZWl2ZWQgd2l0aG91dCBhbnkgbGl2ZSBjbGllbnQgbWF0Y2g6ICVPJywgdHJpbSQxKGNvbW1hbmQpKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgSU1QbHVnaW4gPSB7XG4gIG5hbWU6ICdsZWFuY2xvdWQtcmVhbHRpbWUtcGx1Z2luLWltJyxcbiAgb25SZWFsdGltZUNyZWF0ZTogb25SZWFsdGltZUNyZWF0ZSxcbiAgYmVmb3JlQ29tbWFuZERpc3BhdGNoOiBiZWZvcmVDb21tYW5kRGlzcGF0Y2gsXG4gIG1lc3NhZ2VDbGFzc2VzOiBbTWVzc2FnZSwgQmluYXJ5TWVzc2FnZSwgUmVjYWxsZWRNZXNzYWdlLCBUZXh0TWVzc2FnZV1cbn07XG5cblJlYWx0aW1lLmRlZmluZUNvbnZlcnNhdGlvblByb3BlcnR5ID0gZGVmaW5lQ29udmVyc2F0aW9uUHJvcGVydHk7XG5SZWFsdGltZS5fX3ByZVJlZ2lzdGVyZWRQbHVnaW5zID0gW0lNUGx1Z2luXTtcblxudmFyIEV2ZW50JDEgPSBfZXh0ZW5kcyQxKHt9LCBDb3JlRXZlbnQsIEV2ZW50KTtcblxuZXhwb3J0cy5FdmVudCA9IEV2ZW50JDE7XG5leHBvcnRzLkVycm9yQ29kZSA9IEVycm9yQ29kZTtcbmV4cG9ydHMuUHJvdG9jYWxzID0gbWVzc2FnZTtcbmV4cG9ydHMuUHJvbWlzZSA9IF9Qcm9taXNlO1xuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBldmVudGVtaXR0ZXIzO1xuZXhwb3J0cy5SZWFsdGltZSA9IFJlYWx0aW1lO1xuZXhwb3J0cy5NZXNzYWdlID0gTWVzc2FnZTtcbmV4cG9ydHMuQmluYXJ5TWVzc2FnZSA9IEJpbmFyeU1lc3NhZ2U7XG5leHBvcnRzLlR5cGVkTWVzc2FnZSA9IFR5cGVkTWVzc2FnZTtcbmV4cG9ydHMuVGV4dE1lc3NhZ2UgPSBUZXh0TWVzc2FnZTtcbmV4cG9ydHMuUmVjYWxsZWRNZXNzYWdlID0gUmVjYWxsZWRNZXNzYWdlO1xuZXhwb3J0cy5NZXNzYWdlUHJpb3JpdHkgPSBNZXNzYWdlUHJpb3JpdHk7XG5leHBvcnRzLk1lc3NhZ2VTdGF0dXMgPSBNZXNzYWdlU3RhdHVzO1xuZXhwb3J0cy5NZXNzYWdlUXVlcnlEaXJlY3Rpb24gPSBNZXNzYWdlUXVlcnlEaXJlY3Rpb247XG5leHBvcnRzLmRlZmluZUNvbnZlcnNhdGlvblByb3BlcnR5ID0gZGVmaW5lQ29udmVyc2F0aW9uUHJvcGVydHk7XG5leHBvcnRzLklNUGx1Z2luID0gSU1QbHVnaW47XG5leHBvcnRzLm1lc3NhZ2VUeXBlID0gbWVzc2FnZVR5cGU7XG5leHBvcnRzLm1lc3NhZ2VGaWVsZCA9IG1lc3NhZ2VGaWVsZDtcbmV4cG9ydHMuSUUxMENvbXBhdGlibGUgPSBJRTEwQ29tcGF0aWJsZTtcbmV4cG9ydHMuQ29udmVyc2F0aW9uTWVtYmVyUm9sZSA9IENvbnZlcnNhdGlvbk1lbWJlclJvbGU7XG5leHBvcnRzLkNvbnZlcnNhdGlvbiA9IENvbnZlcnNhdGlvbjtcbmV4cG9ydHMuQ2hhdFJvb20gPSBDaGF0Um9vbTtcbmV4cG9ydHMuU2VydmljZUNvbnZlcnNhdGlvbiA9IFNlcnZpY2VDb252ZXJzYXRpb247XG5leHBvcnRzLlRlbXBvcmFyeUNvbnZlcnNhdGlvbiA9IFRlbXBvcmFyeUNvbnZlcnNhdGlvbjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWx0aW1lLmJyb3dzZXIuanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/leancloud-realtime/dist/realtime.browser.js\n");

/***/ }),

/***/ "./node_modules/leancloud-storage/dist/av-min.js":
/*!*******************************************************!*\
  !*** ./node_modules/leancloud-storage/dist/av-min.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {!function(t,e){ true?module.exports=e():undefined}(\"undefined\"!=typeof self?self:this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var n={};return e.m=t,e.c=n,e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,\"a\",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p=\"\",e(e.s=14)}([function(t,e,n){(function(t,n){var r,i;!function(){var s=\"object\"==typeof self&&self.self===self&&self||\"object\"==typeof t&&t.global===t&&t||this||{},o=s._,a=Array.prototype,u=Object.prototype,c=\"undefined\"!=typeof Symbol?Symbol.prototype:null,l=a.push,h=a.slice,f=u.toString,d=u.hasOwnProperty,p=Array.isArray,_=Object.keys,v=Object.create,y=function(){},m=function(t){return t instanceof m?t:this instanceof m?void(this._wrapped=t):new m(t)};void 0===e||e.nodeType?s._=m:(void 0!==n&&!n.nodeType&&n.exports&&(e=n.exports=m),e._=m),m.VERSION=\"1.9.1\";var g,b=function(t,e,n){if(void 0===e)return t;switch(null==n?3:n){case 1:return function(n){return t.call(e,n)};case 3:return function(n,r,i){return t.call(e,n,r,i)};case 4:return function(n,r,i,s){return t.call(e,n,r,i,s)}}return function(){return t.apply(e,arguments)}},w=function(t,e,n){return m.iteratee!==g?m.iteratee(t,e):null==t?m.identity:m.isFunction(t)?b(t,e,n):m.isObject(t)&&!m.isArray(t)?m.matcher(t):m.property(t)};m.iteratee=g=function(t,e){return w(t,e,1/0)};var O=function(t,e){return e=null==e?t.length-1:+e,function(){for(var n=Math.max(arguments.length-e,0),r=Array(n),i=0;i<n;i++)r[i]=arguments[i+e];switch(e){case 0:return t.call(this,r);case 1:return t.call(this,arguments[0],r);case 2:return t.call(this,arguments[0],arguments[1],r)}var s=Array(e+1);for(i=0;i<e;i++)s[i]=arguments[i];return s[e]=r,t.apply(this,s)}},A=function(t){if(!m.isObject(t))return{};if(v)return v(t);y.prototype=t;var e=new y;return y.prototype=null,e},S=function(t){return function(e){return null==e?void 0:e[t]}},C=function(t,e){return null!=t&&d.call(t,e)},E=function(t,e){for(var n=e.length,r=0;r<n;r++){if(null==t)return;t=t[e[r]]}return n?t:void 0},T=Math.pow(2,53)-1,N=S(\"length\"),j=function(t){var e=N(t);return\"number\"==typeof e&&e>=0&&e<=T};m.each=m.forEach=function(t,e,n){e=b(e,n);var r,i;if(j(t))for(r=0,i=t.length;r<i;r++)e(t[r],r,t);else{var s=m.keys(t);for(r=0,i=s.length;r<i;r++)e(t[s[r]],s[r],t)}return t},m.map=m.collect=function(t,e,n){e=w(e,n);for(var r=!j(t)&&m.keys(t),i=(r||t).length,s=Array(i),o=0;o<i;o++){var a=r?r[o]:o;s[o]=e(t[a],a,t)}return s};var x=function(t){var e=function(e,n,r,i){var s=!j(e)&&m.keys(e),o=(s||e).length,a=t>0?0:o-1;for(i||(r=e[s?s[a]:a],a+=t);a>=0&&a<o;a+=t){var u=s?s[a]:a;r=n(r,e[u],u,e)}return r};return function(t,n,r,i){var s=arguments.length>=3;return e(t,b(n,i,4),r,s)}};m.reduce=m.foldl=m.inject=x(1),m.reduceRight=m.foldr=x(-1),m.find=m.detect=function(t,e,n){var r=j(t)?m.findIndex:m.findKey,i=r(t,e,n);if(void 0!==i&&-1!==i)return t[i]},m.filter=m.select=function(t,e,n){var r=[];return e=w(e,n),m.each(t,function(t,n,i){e(t,n,i)&&r.push(t)}),r},m.reject=function(t,e,n){return m.filter(t,m.negate(w(e)),n)},m.every=m.all=function(t,e,n){e=w(e,n);for(var r=!j(t)&&m.keys(t),i=(r||t).length,s=0;s<i;s++){var o=r?r[s]:s;if(!e(t[o],o,t))return!1}return!0},m.some=m.any=function(t,e,n){e=w(e,n);for(var r=!j(t)&&m.keys(t),i=(r||t).length,s=0;s<i;s++){var o=r?r[s]:s;if(e(t[o],o,t))return!0}return!1},m.contains=m.includes=m.include=function(t,e,n,r){return j(t)||(t=m.values(t)),(\"number\"!=typeof n||r)&&(n=0),m.indexOf(t,e,n)>=0},m.invoke=O(function(t,e,n){var r,i;return m.isFunction(e)?i=e:m.isArray(e)&&(r=e.slice(0,-1),e=e[e.length-1]),m.map(t,function(t){var s=i;if(!s){if(r&&r.length&&(t=E(t,r)),null==t)return;s=t[e]}return null==s?s:s.apply(t,n)})}),m.pluck=function(t,e){return m.map(t,m.property(e))},m.where=function(t,e){return m.filter(t,m.matcher(e))},m.findWhere=function(t,e){return m.find(t,m.matcher(e))},m.max=function(t,e,n){var r,i,s=-1/0,o=-1/0;if(null==e||\"number\"==typeof e&&\"object\"!=typeof t[0]&&null!=t){t=j(t)?t:m.values(t);for(var a=0,u=t.length;a<u;a++)null!=(r=t[a])&&r>s&&(s=r)}else e=w(e,n),m.each(t,function(t,n,r){((i=e(t,n,r))>o||i===-1/0&&s===-1/0)&&(s=t,o=i)});return s},m.min=function(t,e,n){var r,i,s=1/0,o=1/0;if(null==e||\"number\"==typeof e&&\"object\"!=typeof t[0]&&null!=t){t=j(t)?t:m.values(t);for(var a=0,u=t.length;a<u;a++)null!=(r=t[a])&&r<s&&(s=r)}else e=w(e,n),m.each(t,function(t,n,r){((i=e(t,n,r))<o||i===1/0&&s===1/0)&&(s=t,o=i)});return s},m.shuffle=function(t){return m.sample(t,1/0)},m.sample=function(t,e,n){if(null==e||n)return j(t)||(t=m.values(t)),t[m.random(t.length-1)];var r=j(t)?m.clone(t):m.values(t),i=N(r);e=Math.max(Math.min(e,i),0);for(var s=i-1,o=0;o<e;o++){var a=m.random(o,s),u=r[o];r[o]=r[a],r[a]=u}return r.slice(0,e)},m.sortBy=function(t,e,n){var r=0;return e=w(e,n),m.pluck(m.map(t,function(t,n,i){return{value:t,index:r++,criteria:e(t,n,i)}}).sort(function(t,e){var n=t.criteria,r=e.criteria;if(n!==r){if(n>r||void 0===n)return 1;if(n<r||void 0===r)return-1}return t.index-e.index}),\"value\")};var U=function(t,e){return function(n,r,i){var s=e?[[],[]]:{};return r=w(r,i),m.each(n,function(e,i){var o=r(e,i,n);t(s,e,o)}),s}};m.groupBy=U(function(t,e,n){C(t,n)?t[n].push(e):t[n]=[e]}),m.indexBy=U(function(t,e,n){t[n]=e}),m.countBy=U(function(t,e,n){C(t,n)?t[n]++:t[n]=1});var k=/[^\\ud800-\\udfff]|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff]/g;m.toArray=function(t){return t?m.isArray(t)?h.call(t):m.isString(t)?t.match(k):j(t)?m.map(t,m.identity):m.values(t):[]},m.size=function(t){return null==t?0:j(t)?t.length:m.keys(t).length},m.partition=U(function(t,e,n){t[n?0:1].push(e)},!0),m.first=m.head=m.take=function(t,e,n){return null==t||t.length<1?null==e?void 0:[]:null==e||n?t[0]:m.initial(t,t.length-e)},m.initial=function(t,e,n){return h.call(t,0,Math.max(0,t.length-(null==e||n?1:e)))},m.last=function(t,e,n){return null==t||t.length<1?null==e?void 0:[]:null==e||n?t[t.length-1]:m.rest(t,Math.max(0,t.length-e))},m.rest=m.tail=m.drop=function(t,e,n){return h.call(t,null==e||n?1:e)},m.compact=function(t){return m.filter(t,Boolean)};var I=function(t,e,n,r){r=r||[];for(var i=r.length,s=0,o=N(t);s<o;s++){var a=t[s];if(j(a)&&(m.isArray(a)||m.isArguments(a)))if(e)for(var u=0,c=a.length;u<c;)r[i++]=a[u++];else I(a,e,n,r),i=r.length;else n||(r[i++]=a)}return r};m.flatten=function(t,e){return I(t,e,!1)},m.without=O(function(t,e){return m.difference(t,e)}),m.uniq=m.unique=function(t,e,n,r){m.isBoolean(e)||(r=n,n=e,e=!1),null!=n&&(n=w(n,r));for(var i=[],s=[],o=0,a=N(t);o<a;o++){var u=t[o],c=n?n(u,o,t):u;e&&!n?(o&&s===c||i.push(u),s=c):n?m.contains(s,c)||(s.push(c),i.push(u)):m.contains(i,u)||i.push(u)}return i},m.union=O(function(t){return m.uniq(I(t,!0,!0))}),m.intersection=function(t){for(var e=[],n=arguments.length,r=0,i=N(t);r<i;r++){var s=t[r];if(!m.contains(e,s)){var o;for(o=1;o<n&&m.contains(arguments[o],s);o++);o===n&&e.push(s)}}return e},m.difference=O(function(t,e){return e=I(e,!0,!0),m.filter(t,function(t){return!m.contains(e,t)})}),m.unzip=function(t){for(var e=t&&m.max(t,N).length||0,n=Array(e),r=0;r<e;r++)n[r]=m.pluck(t,r);return n},m.zip=O(m.unzip),m.object=function(t,e){for(var n={},r=0,i=N(t);r<i;r++)e?n[t[r]]=e[r]:n[t[r][0]]=t[r][1];return n};var R=function(t){return function(e,n,r){n=w(n,r);for(var i=N(e),s=t>0?0:i-1;s>=0&&s<i;s+=t)if(n(e[s],s,e))return s;return-1}};m.findIndex=R(1),m.findLastIndex=R(-1),m.sortedIndex=function(t,e,n,r){n=w(n,r,1);for(var i=n(e),s=0,o=N(t);s<o;){var a=Math.floor((s+o)/2);n(t[a])<i?s=a+1:o=a}return s};var P=function(t,e,n){return function(r,i,s){var o=0,a=N(r);if(\"number\"==typeof s)t>0?o=s>=0?s:Math.max(s+a,o):a=s>=0?Math.min(s+1,a):s+a+1;else if(n&&s&&a)return s=n(r,i),r[s]===i?s:-1;if(i!==i)return s=e(h.call(r,o,a),m.isNaN),s>=0?s+o:-1;for(s=t>0?o:a-1;s>=0&&s<a;s+=t)if(r[s]===i)return s;return-1}};m.indexOf=P(1,m.findIndex,m.sortedIndex),m.lastIndexOf=P(-1,m.findLastIndex),m.range=function(t,e,n){null==e&&(e=t||0,t=0),n||(n=e<t?-1:1);for(var r=Math.max(Math.ceil((e-t)/n),0),i=Array(r),s=0;s<r;s++,t+=n)i[s]=t;return i},m.chunk=function(t,e){if(null==e||e<1)return[];for(var n=[],r=0,i=t.length;r<i;)n.push(h.call(t,r,r+=e));return n};var D=function(t,e,n,r,i){if(!(r instanceof e))return t.apply(n,i);var s=A(t.prototype),o=t.apply(s,i);return m.isObject(o)?o:s};m.bind=O(function(t,e,n){if(!m.isFunction(t))throw new TypeError(\"Bind must be called on a function\");var r=O(function(i){return D(t,r,e,this,n.concat(i))});return r}),m.partial=O(function(t,e){var n=m.partial.placeholder,r=function(){for(var i=0,s=e.length,o=Array(s),a=0;a<s;a++)o[a]=e[a]===n?arguments[i++]:e[a];for(;i<arguments.length;)o.push(arguments[i++]);return D(t,r,this,this,o)};return r}),m.partial.placeholder=m,m.bindAll=O(function(t,e){e=I(e,!1,!1);var n=e.length;if(n<1)throw new Error(\"bindAll must be passed function names\");for(;n--;){var r=e[n];t[r]=m.bind(t[r],t)}}),m.memoize=function(t,e){var n=function(r){var i=n.cache,s=\"\"+(e?e.apply(this,arguments):r);return C(i,s)||(i[s]=t.apply(this,arguments)),i[s]};return n.cache={},n},m.delay=O(function(t,e,n){return setTimeout(function(){return t.apply(null,n)},e)}),m.defer=m.partial(m.delay,m,1),m.throttle=function(t,e,n){var r,i,s,o,a=0;n||(n={});var u=function(){a=!1===n.leading?0:m.now(),r=null,o=t.apply(i,s),r||(i=s=null)},c=function(){var c=m.now();a||!1!==n.leading||(a=c);var l=e-(c-a);return i=this,s=arguments,l<=0||l>e?(r&&(clearTimeout(r),r=null),a=c,o=t.apply(i,s),r||(i=s=null)):r||!1===n.trailing||(r=setTimeout(u,l)),o};return c.cancel=function(){clearTimeout(r),a=0,r=i=s=null},c},m.debounce=function(t,e,n){var r,i,s=function(e,n){r=null,n&&(i=t.apply(e,n))},o=O(function(o){if(r&&clearTimeout(r),n){var a=!r;r=setTimeout(s,e),a&&(i=t.apply(this,o))}else r=m.delay(s,e,this,o);return i});return o.cancel=function(){clearTimeout(r),r=null},o},m.wrap=function(t,e){return m.partial(e,t)},m.negate=function(t){return function(){return!t.apply(this,arguments)}},m.compose=function(){var t=arguments,e=t.length-1;return function(){for(var n=e,r=t[e].apply(this,arguments);n--;)r=t[n].call(this,r);return r}},m.after=function(t,e){return function(){if(--t<1)return e.apply(this,arguments)}},m.before=function(t,e){var n;return function(){return--t>0&&(n=e.apply(this,arguments)),t<=1&&(e=null),n}},m.once=m.partial(m.before,2),m.restArguments=O;var L=!{toString:null}.propertyIsEnumerable(\"toString\"),F=[\"valueOf\",\"isPrototypeOf\",\"toString\",\"propertyIsEnumerable\",\"hasOwnProperty\",\"toLocaleString\"],q=function(t,e){var n=F.length,r=t.constructor,i=m.isFunction(r)&&r.prototype||u,s=\"constructor\";for(C(t,s)&&!m.contains(e,s)&&e.push(s);n--;)(s=F[n])in t&&t[s]!==i[s]&&!m.contains(e,s)&&e.push(s)};m.keys=function(t){if(!m.isObject(t))return[];if(_)return _(t);var e=[];for(var n in t)C(t,n)&&e.push(n);return L&&q(t,e),e},m.allKeys=function(t){if(!m.isObject(t))return[];var e=[];for(var n in t)e.push(n);return L&&q(t,e),e},m.values=function(t){for(var e=m.keys(t),n=e.length,r=Array(n),i=0;i<n;i++)r[i]=t[e[i]];return r},m.mapObject=function(t,e,n){e=w(e,n);for(var r=m.keys(t),i=r.length,s={},o=0;o<i;o++){var a=r[o];s[a]=e(t[a],a,t)}return s},m.pairs=function(t){for(var e=m.keys(t),n=e.length,r=Array(n),i=0;i<n;i++)r[i]=[e[i],t[e[i]]];return r},m.invert=function(t){for(var e={},n=m.keys(t),r=0,i=n.length;r<i;r++)e[t[n[r]]]=n[r];return e},m.functions=m.methods=function(t){var e=[];for(var n in t)m.isFunction(t[n])&&e.push(n);return e.sort()};var M=function(t,e){return function(n){var r=arguments.length;if(e&&(n=Object(n)),r<2||null==n)return n;for(var i=1;i<r;i++)for(var s=arguments[i],o=t(s),a=o.length,u=0;u<a;u++){var c=o[u];e&&void 0!==n[c]||(n[c]=s[c])}return n}};m.extend=M(m.allKeys),m.extendOwn=m.assign=M(m.keys),m.findKey=function(t,e,n){e=w(e,n);for(var r,i=m.keys(t),s=0,o=i.length;s<o;s++)if(r=i[s],e(t[r],r,t))return r};var B=function(t,e,n){return e in n};m.pick=O(function(t,e){var n={},r=e[0];if(null==t)return n;m.isFunction(r)?(e.length>1&&(r=b(r,e[1])),e=m.allKeys(t)):(r=B,e=I(e,!1,!1),t=Object(t));for(var i=0,s=e.length;i<s;i++){var o=e[i],a=t[o];r(a,o,t)&&(n[o]=a)}return n}),m.omit=O(function(t,e){var n,r=e[0];return m.isFunction(r)?(r=m.negate(r),e.length>1&&(n=e[1])):(e=m.map(I(e,!1,!1),String),r=function(t,n){return!m.contains(e,n)}),m.pick(t,r,n)}),m.defaults=M(m.allKeys,!0),m.create=function(t,e){var n=A(t);return e&&m.extendOwn(n,e),n},m.clone=function(t){return m.isObject(t)?m.isArray(t)?t.slice():m.extend({},t):t},m.tap=function(t,e){return e(t),t},m.isMatch=function(t,e){var n=m.keys(e),r=n.length;if(null==t)return!r;for(var i=Object(t),s=0;s<r;s++){var o=n[s];if(e[o]!==i[o]||!(o in i))return!1}return!0};var J,W;J=function(t,e,n,r){if(t===e)return 0!==t||1/t==1/e;if(null==t||null==e)return!1;if(t!==t)return e!==e;var i=typeof t;return(\"function\"===i||\"object\"===i||\"object\"==typeof e)&&W(t,e,n,r)},W=function(t,e,n,r){t instanceof m&&(t=t._wrapped),e instanceof m&&(e=e._wrapped);var i=f.call(t);if(i!==f.call(e))return!1;switch(i){case\"[object RegExp]\":case\"[object String]\":return\"\"+t==\"\"+e;case\"[object Number]\":return+t!=+t?+e!=+e:0==+t?1/+t==1/e:+t==+e;case\"[object Date]\":case\"[object Boolean]\":return+t==+e;case\"[object Symbol]\":return c.valueOf.call(t)===c.valueOf.call(e)}var s=\"[object Array]\"===i;if(!s){if(\"object\"!=typeof t||\"object\"!=typeof e)return!1;var o=t.constructor,a=e.constructor;if(o!==a&&!(m.isFunction(o)&&o instanceof o&&m.isFunction(a)&&a instanceof a)&&\"constructor\"in t&&\"constructor\"in e)return!1}n=n||[],r=r||[];for(var u=n.length;u--;)if(n[u]===t)return r[u]===e;if(n.push(t),r.push(e),s){if((u=t.length)!==e.length)return!1;for(;u--;)if(!J(t[u],e[u],n,r))return!1}else{var l,h=m.keys(t);if(u=h.length,m.keys(e).length!==u)return!1;for(;u--;)if(l=h[u],!C(e,l)||!J(t[l],e[l],n,r))return!1}return n.pop(),r.pop(),!0},m.isEqual=function(t,e){return J(t,e)},m.isEmpty=function(t){return null==t||(j(t)&&(m.isArray(t)||m.isString(t)||m.isArguments(t))?0===t.length:0===m.keys(t).length)},m.isElement=function(t){return!(!t||1!==t.nodeType)},m.isArray=p||function(t){return\"[object Array]\"===f.call(t)},m.isObject=function(t){var e=typeof t;return\"function\"===e||\"object\"===e&&!!t},m.each([\"Arguments\",\"Function\",\"String\",\"Number\",\"Date\",\"RegExp\",\"Error\",\"Symbol\",\"Map\",\"WeakMap\",\"Set\",\"WeakSet\"],function(t){m[\"is\"+t]=function(e){return f.call(e)===\"[object \"+t+\"]\"}}),m.isArguments(arguments)||(m.isArguments=function(t){return C(t,\"callee\")});var Q=s.document&&s.document.childNodes;\"function\"!=typeof/./&&\"object\"!=typeof Int8Array&&\"function\"!=typeof Q&&(m.isFunction=function(t){return\"function\"==typeof t||!1}),m.isFinite=function(t){return!m.isSymbol(t)&&isFinite(t)&&!isNaN(parseFloat(t))},m.isNaN=function(t){return m.isNumber(t)&&isNaN(t)},m.isBoolean=function(t){return!0===t||!1===t||\"[object Boolean]\"===f.call(t)},m.isNull=function(t){return null===t},m.isUndefined=function(t){return void 0===t},m.has=function(t,e){if(!m.isArray(e))return C(t,e);for(var n=e.length,r=0;r<n;r++){var i=e[r];if(null==t||!d.call(t,i))return!1;t=t[i]}return!!n},m.noConflict=function(){return s._=o,this},m.identity=function(t){return t},m.constant=function(t){return function(){return t}},m.noop=function(){},m.property=function(t){return m.isArray(t)?function(e){return E(e,t)}:S(t)},m.propertyOf=function(t){return null==t?function(){}:function(e){return m.isArray(e)?E(t,e):t[e]}},m.matcher=m.matches=function(t){return t=m.extendOwn({},t),function(e){return m.isMatch(e,t)}},m.times=function(t,e,n){var r=Array(Math.max(0,t));e=b(e,n,1);for(var i=0;i<t;i++)r[i]=e(i);return r},m.random=function(t,e){return null==e&&(e=t,t=0),t+Math.floor(Math.random()*(e-t+1))},m.now=Date.now||function(){return(new Date).getTime()};var V={\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\",'\"':\"&quot;\",\"'\":\"&#x27;\",\"`\":\"&#x60;\"},K=m.invert(V),z=function(t){var e=function(e){return t[e]},n=\"(?:\"+m.keys(t).join(\"|\")+\")\",r=RegExp(n),i=RegExp(n,\"g\");return function(t){return t=null==t?\"\":\"\"+t,r.test(t)?t.replace(i,e):t}};m.escape=z(V),m.unescape=z(K),m.result=function(t,e,n){m.isArray(e)||(e=[e]);var r=e.length;if(!r)return m.isFunction(n)?n.call(t):n;for(var i=0;i<r;i++){var s=null==t?void 0:t[e[i]];void 0===s&&(s=n,i=r),t=m.isFunction(s)?s.call(t):s}return t};var G=0;m.uniqueId=function(t){var e=++G+\"\";return t?t+e:e},m.templateSettings={evaluate:/<%([\\s\\S]+?)%>/g,interpolate:/<%=([\\s\\S]+?)%>/g,escape:/<%-([\\s\\S]+?)%>/g};var H=/(.)^/,$={\"'\":\"'\",\"\\\\\":\"\\\\\",\"\\r\":\"r\",\"\\n\":\"n\",\"\\u2028\":\"u2028\",\"\\u2029\":\"u2029\"},X=/\\\\|'|\\r|\\n|\\u2028|\\u2029/g,Y=function(t){return\"\\\\\"+$[t]};m.template=function(t,e,n){!e&&n&&(e=n),e=m.defaults({},e,m.templateSettings);var r=RegExp([(e.escape||H).source,(e.interpolate||H).source,(e.evaluate||H).source].join(\"|\")+\"|$\",\"g\"),i=0,s=\"__p+='\";t.replace(r,function(e,n,r,o,a){return s+=t.slice(i,a).replace(X,Y),i=a+e.length,n?s+=\"'+\\n((__t=(\"+n+\"))==null?'':_.escape(__t))+\\n'\":r?s+=\"'+\\n((__t=(\"+r+\"))==null?'':__t)+\\n'\":o&&(s+=\"';\\n\"+o+\"\\n__p+='\"),e}),s+=\"';\\n\",e.variable||(s=\"with(obj||{}){\\n\"+s+\"}\\n\"),s=\"var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\\n\"+s+\"return __p;\\n\";var o;try{o=new Function(e.variable||\"obj\",\"_\",s)}catch(t){throw t.source=s,t}var a=function(t){return o.call(this,t,m)};return a.source=\"function(\"+(e.variable||\"obj\")+\"){\\n\"+s+\"}\",a},m.chain=function(t){var e=m(t);return e._chain=!0,e};var Z=function(t,e){return t._chain?m(e).chain():e};m.mixin=function(t){return m.each(m.functions(t),function(e){var n=m[e]=t[e];m.prototype[e]=function(){var t=[this._wrapped];return l.apply(t,arguments),Z(this,n.apply(m,t))}}),m},m.mixin(m),m.each([\"pop\",\"push\",\"reverse\",\"shift\",\"sort\",\"splice\",\"unshift\"],function(t){var e=a[t];m.prototype[t]=function(){var n=this._wrapped;return e.apply(n,arguments),\"shift\"!==t&&\"splice\"!==t||0!==n.length||delete n[0],Z(this,n)}}),m.each([\"concat\",\"join\",\"slice\"],function(t){var e=a[t];m.prototype[t]=function(){return Z(this,e.apply(this._wrapped,arguments))}}),m.prototype.value=function(){return this._wrapped},m.prototype.valueOf=m.prototype.toJSON=m.prototype.value,m.prototype.toString=function(){return String(this._wrapped)},r=[],void 0!==(i=function(){return m}.apply(e,r))&&(n.exports=i)}()}).call(e,n(7),n(16)(t))},function(t,e,n){\"use strict\";var r=(n(0),n(26).Promise);r._continueWhile=function(t,e){return t()?e().then(function(){return r._continueWhile(t,e)}):r.resolve()},t.exports=r},function(t,e,n){\"use strict\";var r=n(0),i=n(41),s=n(0),o=s.extend,a=n(1),u=n(5),c=n(3),l=c.getSessionToken,h=c.ajax,f=function(t,e){var n=(new Date).getTime(),r=i(n+t);return e?r+\",\"+n+\",master\":r+\",\"+n},d=function(t,e){e?t[\"X-LC-Sign\"]=f(u.applicationKey):t[\"X-LC-Key\"]=u.applicationKey},p=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments[1],n={\"X-LC-Id\":u.applicationId,\"Content-Type\":\"application/json;charset=UTF-8\"},r=!1;return\"boolean\"==typeof t.useMasterKey?r=t.useMasterKey:\"boolean\"==typeof u._config.useMasterKey&&(r=u._config.useMasterKey),r?u.masterKey?e?n[\"X-LC-Sign\"]=f(u.masterKey,!0):n[\"X-LC-Key\"]=u.masterKey+\",master\":(console.warn(\"masterKey is not set, fall back to use appKey\"),d(n,e)):d(n,e),u.hookKey&&(n[\"X-LC-Hook-Key\"]=u.hookKey),null!==u._config.production&&(n[\"X-LC-Prod\"]=String(u._config.production)),n[\"X-LC-UA\"]=u._sharedConfig.userAgent,a.resolve().then(function(){var e=l(t);if(e)n[\"X-LC-Session\"]=e;else if(!u._config.disableCurrentUser)return u.User.currentAsync().then(function(t){return t&&t._sessionToken&&(n[\"X-LC-Session\"]=t._sessionToken),n});return n})},_=function(t){var e=t.service,n=void 0===e?\"api\":e,r=t.version,i=void 0===r?\"1.1\":r,s=t.path,o=u._config.serverURLs[n];if(!o)throw new Error(\"undefined server URL for \"+n);return\"/\"!==o.charAt(o.length-1)&&(o+=\"/\"),o+=i,s&&(o+=s),o},v=function(t){var e=t.service,n=t.version,i=t.method,s=t.path,o=t.query,a=t.data,c=t.authOptions,l=t.signKey,f=void 0===l||l;if(!u.applicationId||!u.applicationKey&&!u.masterKey)throw new Error(\"Not initialized\");u._appRouter.refresh();var d=u._config.requestTimeout,v=_({service:e,path:s,version:n});return p(c,f).then(function(t){return h({method:i,url:v,query:o,data:a,headers:t,timeout:d}).catch(function(t){var e={code:t.code||-1,error:t.message||t.responseText};if(t.response&&t.response.code)e=t.response;else if(t.responseText)try{e=JSON.parse(t.responseText)}catch(t){}e.rawMessage=e.rawMessage||e.error,u._sharedConfig.keepErrorRawMessage||(e.error+=\" [\"+(t.statusCode||\"N/A\")+\" \"+i+\" \"+v+\"]\");var n=new Error(e.error);throw delete e.error,r.extend(n,e)})})},y=function(t,e,n,r,i,s,a){var u=\"\";if(t&&(u+=\"/\"+t),e&&(u+=\"/\"+e),n&&(u+=\"/\"+n),i&&i._fetchWhenSave)throw new Error(\"_fetchWhenSave should be in the query\");if(i&&i._where)throw new Error(\"_where should be in the query\");return r&&\"get\"===r.toLowerCase()&&(a=o({},a,i),i=null),v({method:r,path:u,query:a,data:i,authOptions:s})};u.request=v,t.exports={_request:y,request:v}},function(t,e,n){\"use strict\";function r(t){var e=new RegExp(\"^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})T([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})(.([0-9]+))?Z$\"),n=e.exec(t);if(!n)return null;var r=n[1]||0,i=(n[2]||1)-1,s=n[3]||0,o=n[4]||0,a=n[5]||0,u=n[6]||0,c=n[8]||0;return new Date(Date.UTC(r,i,s,o,a,u,c))}var i=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t},s=n(0),o=n(8),a=n(6),u=a(\"leancloud:request\"),c=a(\"leancloud:request:error\"),l=n(1),h=0,f=function(t){var e=t.method,n=t.url,r=t.query,s=t.data,f=t.headers,d=void 0===f?{}:f,p=t.onprogress,_=t.timeout,v=h++;u(\"request(%d) %s %s %o %o %o\",v,e,n,r,s,d);var y={};if(r)for(var m in r)\"object\"===i(r[m])?y[m]=JSON.stringify(r[m]):y[m]=r[m];return new l(function(t,i){var l=o(e,n).set(d).query(y).send(s);p&&l.on(\"progress\",p),_&&l.timeout(_),l.end(function(o,l){return o?(l&&(a.enabled(\"leancloud:request\")||c(\"request(%d) %s %s %o %o %o\",v,e,n,r,s,d),c(\"response(%d) %d %O %o\",v,l.status,l.body||l.text,l.header),o.statusCode=l.status,o.responseText=l.text,o.response=l.body),i(o)):(u(\"response(%d) %d %O %o\",v,l.status,l.body||l.text,l.header),t(l.body))})})},d=function(t){return s.isNull(t)||s.isUndefined(t)},p=function(t){return s.isArray(t)?t:void 0===t||null===t?[]:[t]},_=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=t.keys,n=t.include,r=t.includeACL,i={};return e&&(i.keys=p(e).join(\",\")),n&&(i.include=p(n).join(\",\")),r&&(i.returnACL=r),i},v=function(t){return t.sessionToken?t.sessionToken:t.user&&\"function\"==typeof t.user.getSessionToken?t.user.getSessionToken():void 0},y=function(t){return function(e){return t(e),e}},m=function(){},g=function(t,e,n){var r;return r=e&&e.hasOwnProperty(\"constructor\")?e.constructor:function(){t.apply(this,arguments)},s.extend(r,t),m.prototype=t.prototype,r.prototype=new m,e&&s.extend(r.prototype,e),n&&s.extend(r,n),r.prototype.constructor=r,r.__super__=t.prototype,r},b=function(t,e,n){var r=e.split(\".\"),i=r.pop(),s=t;return r.forEach(function(t){void 0===s[t]&&(s[t]={}),s=s[t]}),s[i]=n,t},w=function(t,e){for(var n=e.split(\".\"),r=n[0],i=n.pop(),s=t,o=0;o<n.length;o++)if(void 0===(s=s[n[o]]))return[void 0,void 0,i];return[s[i],s,i,r]},O=function(t){return s.isObject(t)&&Object.getPrototypeOf(t)===Object.prototype};t.exports={ajax:f,isNullOrUndefined:d,ensureArray:p,transformFetchOptions:_,getSessionToken:v,tap:y,inherits:g,parseDate:r,setValue:b,findValue:w,isPlainObject:O}},function(t,e,n){\"use strict\";function r(t,e){var n=new Error(e);return n.code=t,n}n(0).extend(r,{OTHER_CAUSE:-1,INTERNAL_SERVER_ERROR:1,CONNECTION_FAILED:100,OBJECT_NOT_FOUND:101,INVALID_QUERY:102,INVALID_CLASS_NAME:103,MISSING_OBJECT_ID:104,INVALID_KEY_NAME:105,INVALID_POINTER:106,INVALID_JSON:107,COMMAND_UNAVAILABLE:108,NOT_INITIALIZED:109,INCORRECT_TYPE:111,INVALID_CHANNEL_NAME:112,PUSH_MISCONFIGURED:115,OBJECT_TOO_LARGE:116,OPERATION_FORBIDDEN:119,CACHE_MISS:120,INVALID_NESTED_KEY:121,INVALID_FILE_NAME:122,INVALID_ACL:123,TIMEOUT:124,INVALID_EMAIL_ADDRESS:125,MISSING_CONTENT_TYPE:126,MISSING_CONTENT_LENGTH:127,INVALID_CONTENT_LENGTH:128,FILE_TOO_LARGE:129,FILE_SAVE_ERROR:130,FILE_DELETE_ERROR:153,DUPLICATE_VALUE:137,INVALID_ROLE_NAME:139,EXCEEDED_QUOTA:140,SCRIPT_FAILED:141,VALIDATION_ERROR:142,INVALID_IMAGE_DATA:150,UNSAVED_FILE_ERROR:151,INVALID_PUSH_TIME_ERROR:152,USERNAME_MISSING:200,PASSWORD_MISSING:201,USERNAME_TAKEN:202,EMAIL_TAKEN:203,EMAIL_MISSING:204,EMAIL_NOT_FOUND:205,SESSION_MISSING:206,MUST_CREATE_USER_THROUGH_SIGNUP:207,ACCOUNT_ALREADY_LINKED:208,LINKED_ID_MISSING:250,INVALID_LINKED_SESSION:251,UNSUPPORTED_SERVICE:252,X_DOMAIN_REQUEST:602}),t.exports=r},function(t,e,n){\"use strict\";(function(e){var r=n(0),i=n(17),s=n(3),o=s.inherits,a=s.parseDate,u=e.AV||{};u._config={serverURLs:{},useMasterKey:!1,production:null,realtime:null,requestTimeout:null},u._sharedConfig={userAgent:i,liveQueryRealtime:null},u._getAVPath=function(t){if(!u.applicationId)throw new Error(\"You need to call AV.initialize before using AV.\");if(t||(t=\"\"),!r.isString(t))throw new Error(\"Tried to get a localStorage path that wasn't a String.\");return\"/\"===t[0]&&(t=t.substring(1)),\"AV/\"+u.applicationId+\"/\"+t};var c=function(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)},l=function(){return\"\"+c()+c()+\"-\"+c()+\"-\"+c()+\"-\"+c()+\"-\"+c()+c()+c()};u._installationId=null,u._getInstallationId=function(){if(u._installationId)return u.Promise.resolve(u._installationId);var t=u._getAVPath(\"installationId\");return u.localStorage.getItemAsync(t).then(function(e){return u._installationId=e,u._installationId?e:(u._installationId=e=l(),u.localStorage.setItemAsync(t,e).then(function(){return e}))})},u._subscriptionId=null,u._refreshSubscriptionId=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:u._getAVPath(\"subscriptionId\"),e=u._subscriptionId=l();return u.localStorage.setItemAsync(t,e).then(function(){return e})},u._getSubscriptionId=function(){if(u._subscriptionId)return u.Promise.resolve(u._subscriptionId);var t=u._getAVPath(\"subscriptionId\");return u.localStorage.getItemAsync(t).then(function(e){return u._subscriptionId=e,u._subscriptionId||(e=u._refreshSubscriptionId(t)),e})},u._parseDate=a,u._extend=function(t,e){var n=o(this,t,e);return n.extend=this.extend,n},u._encode=function(t,e,n){var i=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];if(t instanceof u.Object){if(n)throw new Error(\"AV.Objects not allowed here\");return e&&!r.include(e,t)&&t._hasData?t._toFullJSON(e.concat(t),i):t._toPointer()}if(t instanceof u.ACL)return t.toJSON();if(r.isDate(t))return i?{__type:\"Date\",iso:t.toJSON()}:t.toJSON();if(t instanceof u.GeoPoint)return t.toJSON();if(r.isArray(t))return r.map(t,function(t){return u._encode(t,e,n,i)});if(r.isRegExp(t))return t.source;if(t instanceof u.Relation)return t.toJSON();if(t instanceof u.Op)return t.toJSON();if(t instanceof u.File){if(!t.url()&&!t.id)throw new Error(\"Tried to save an object containing an unsaved file.\");return t._toFullJSON(e,i)}return r.isObject(t)?r.mapObject(t,function(t,r){return u._encode(t,e,n,i)}):t},u._decode=function(t,e){if(!r.isObject(t)||r.isDate(t))return t;if(r.isArray(t))return r.map(t,function(t){return u._decode(t)});if(t instanceof u.Object)return t;if(t instanceof u.File)return t;if(t instanceof u.Op)return t;if(t instanceof u.GeoPoint)return t;if(t instanceof u.ACL)return t;if(\"ACL\"===e)return new u.ACL(t);if(t.__op)return u.Op._decode(t);var n;if(\"Pointer\"===t.__type){n=t.className;var i=u.Object._create(n);if(Object.keys(t).length>3){var s=r.clone(t);delete s.__type,delete s.className,i._finishFetch(s,!0)}else i._finishFetch({objectId:t.objectId},!1);return i}if(\"Object\"===t.__type){n=t.className;var o=r.clone(t);delete o.__type,delete o.className;var a=u.Object._create(n);return a._finishFetch(o,!0),a}if(\"Date\"===t.__type)return u._parseDate(t.iso);if(\"GeoPoint\"===t.__type)return new u.GeoPoint({latitude:t.latitude,longitude:t.longitude});if(\"Relation\"===t.__type){if(!e)throw new Error(\"key missing decoding a Relation\");var c=new u.Relation(null,e);return c.targetClassName=t.className,c}if(\"File\"===t.__type){var l=new u.File(t.name),h=r.clone(t);return delete h.__type,l._finishFetch(h),l}return r.mapObject(t,u._decode)},u.parseJSON=u._decode,u._encodeObjectOrArray=function(t){var e=function(t){return t&&t._toFullJSON&&(t=t._toFullJSON([])),r.mapObject(t,function(t){return u._encode(t,[])})};return r.isArray(t)?t.map(function(t){return e(t)}):e(t)},u._arrayEach=r.each,u._traverse=function(t,e,n){if(t instanceof u.Object){if(n=n||[],r.indexOf(n,t)>=0)return;return n.push(t),u._traverse(t.attributes,e,n),e(t)}return t instanceof u.Relation||t instanceof u.File?e(t):r.isArray(t)?(r.each(t,function(r,i){var s=u._traverse(r,e,n);s&&(t[i]=s)}),e(t)):r.isObject(t)?(u._each(t,function(r,i){var s=u._traverse(r,e,n);s&&(t[i]=s)}),e(t)):e(t)},u._objectEach=u._each=function(t,e){r.isObject(t)?r.each(r.keys(t),function(n){e(t[n],n)}):r.each(t,e)},t.exports=u}).call(e,n(7))},function(t,e,n){function r(){return!(\"undefined\"==typeof window||!window.process||\"renderer\"!==window.process.type)||(\"undefined\"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/))&&(\"undefined\"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||\"undefined\"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||\"undefined\"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)&&parseInt(RegExp.$1,10)>=31||\"undefined\"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/))}function i(t){var n=this.useColors;if(t[0]=(n?\"%c\":\"\")+this.namespace+(n?\" %c\":\" \")+t[0]+(n?\"%c \":\" \")+\"+\"+e.humanize(this.diff),n){var r=\"color: \"+this.color;t.splice(1,0,r,\"color: inherit\");var i=0,s=0;t[0].replace(/%[a-zA-Z%]/g,function(t){\"%%\"!==t&&(i++,\"%c\"===t&&(s=i))}),t.splice(s,0,r)}}function s(){return\"object\"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function o(t){try{null==t?e.storage.removeItem(\"debug\"):e.storage.debug=t}catch(t){}}function a(){var t;try{t=e.storage.debug}catch(t){}return!t&&\"undefined\"!=typeof process&&\"env\"in process&&(t=process.env.DEBUG),t}e=t.exports=n(24),e.log=s,e.formatArgs=i,e.save=o,e.load=a,e.useColors=r,e.storage=\"undefined\"!=typeof chrome&&void 0!==chrome.storage?chrome.storage.local:function(){try{return window.localStorage}catch(t){}}(),e.colors=[\"#0000CC\",\"#0000FF\",\"#0033CC\",\"#0033FF\",\"#0066CC\",\"#0066FF\",\"#0099CC\",\"#0099FF\",\"#00CC00\",\"#00CC33\",\"#00CC66\",\"#00CC99\",\"#00CCCC\",\"#00CCFF\",\"#3300CC\",\"#3300FF\",\"#3333CC\",\"#3333FF\",\"#3366CC\",\"#3366FF\",\"#3399CC\",\"#3399FF\",\"#33CC00\",\"#33CC33\",\"#33CC66\",\"#33CC99\",\"#33CCCC\",\"#33CCFF\",\"#6600CC\",\"#6600FF\",\"#6633CC\",\"#6633FF\",\"#66CC00\",\"#66CC33\",\"#9900CC\",\"#9900FF\",\"#9933CC\",\"#9933FF\",\"#99CC00\",\"#99CC33\",\"#CC0000\",\"#CC0033\",\"#CC0066\",\"#CC0099\",\"#CC00CC\",\"#CC00FF\",\"#CC3300\",\"#CC3333\",\"#CC3366\",\"#CC3399\",\"#CC33CC\",\"#CC33FF\",\"#CC6600\",\"#CC6633\",\"#CC9900\",\"#CC9933\",\"#CCCC00\",\"#CCCC33\",\"#FF0000\",\"#FF0033\",\"#FF0066\",\"#FF0099\",\"#FF00CC\",\"#FF00FF\",\"#FF3300\",\"#FF3333\",\"#FF3366\",\"#FF3399\",\"#FF33CC\",\"#FF33FF\",\"#FF6600\",\"#FF6633\",\"#FF9900\",\"#FF9933\",\"#FFCC00\",\"#FFCC33\"],e.formatters.j=function(t){try{return JSON.stringify(t)}catch(t){return\"[UnexpectedJSONParseError]: \"+t.message}},e.enable(a())},function(t,e){var n;n=function(){return this}();try{n=n||Function(\"return this\")()||(0,eval)(\"this\")}catch(t){\"object\"==typeof window&&(n=window)}t.exports=n},function(t,e,n){function r(){}function i(t){if(!_(t))return t;var e=[];for(var n in t)s(e,n,t[n]);return e.join(\"&\")}function s(t,e,n){if(null!=n)if(Array.isArray(n))n.forEach(function(n){s(t,e,n)});else if(_(n))for(var r in n)s(t,e+\"[\"+r+\"]\",n[r]);else t.push(encodeURIComponent(e)+\"=\"+encodeURIComponent(n));else null===n&&t.push(encodeURIComponent(e))}function o(t){for(var e,n,r={},i=t.split(\"&\"),s=0,o=i.length;s<o;++s)e=i[s],n=e.indexOf(\"=\"),-1==n?r[decodeURIComponent(e)]=\"\":r[decodeURIComponent(e.slice(0,n))]=decodeURIComponent(e.slice(n+1));return r}function a(t){for(var e,n,r,i,s=t.split(/\\r?\\n/),o={},a=0,u=s.length;a<u;++a)n=s[a],-1!==(e=n.indexOf(\":\"))&&(r=n.slice(0,e).toLowerCase(),i=g(n.slice(e+1)),o[r]=i);return o}function u(t){return/[\\/+]json($|[^-\\w])/.test(t)}function c(t){this.req=t,this.xhr=this.req.xhr,this.text=\"HEAD\"!=this.req.method&&(\"\"===this.xhr.responseType||\"text\"===this.xhr.responseType)||void 0===this.xhr.responseType?this.xhr.responseText:null,this.statusText=this.req.xhr.statusText;var e=this.xhr.status;1223===e&&(e=204),this._setStatusProperties(e),this.header=this.headers=a(this.xhr.getAllResponseHeaders()),this.header[\"content-type\"]=this.xhr.getResponseHeader(\"content-type\"),this._setHeaderProperties(this.header),null===this.text&&t._responseType?this.body=this.xhr.response:this.body=\"HEAD\"!=this.req.method?this._parseBody(this.text?this.text:this.xhr.response):null}function l(t,e){var n=this;this._query=this._query||[],this.method=t,this.url=e,this.header={},this._header={},this.on(\"end\",function(){var t=null,e=null;try{e=new c(n)}catch(e){return t=new Error(\"Parser is unable to parse the response\"),t.parse=!0,t.original=e,n.xhr?(t.rawResponse=void 0===n.xhr.responseType?n.xhr.responseText:n.xhr.response,t.status=n.xhr.status?n.xhr.status:null,t.statusCode=t.status):(t.rawResponse=null,t.status=null),n.callback(t)}n.emit(\"response\",e);var r;try{n._isResponseOK(e)||(r=new Error(e.statusText||\"Unsuccessful HTTP response\"))}catch(t){r=t}r?(r.original=t,r.response=e,r.status=e.status,n.callback(r,e)):n.callback(null,e)})}function h(t,e,n){var r=m(\"DELETE\",t);return\"function\"==typeof e&&(n=e,e=null),e&&r.send(e),n&&r.end(n),r}var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof self?f=self:(console.warn(\"Using browser-only version of superagent in non-browser environment\"),f=this);var d=n(19),p=n(20),_=n(10),v=n(21),y=n(23),m=e=t.exports=function(t,n){return\"function\"==typeof n?new e.Request(\"GET\",t).end(n):1==arguments.length?new e.Request(\"GET\",t):new e.Request(t,n)};e.Request=l,m.getXHR=function(){if(!(!f.XMLHttpRequest||f.location&&\"file:\"==f.location.protocol&&f.ActiveXObject))return new XMLHttpRequest;try{return new ActiveXObject(\"Microsoft.XMLHTTP\")}catch(t){}try{return new ActiveXObject(\"Msxml2.XMLHTTP.6.0\")}catch(t){}try{return new ActiveXObject(\"Msxml2.XMLHTTP.3.0\")}catch(t){}try{return new ActiveXObject(\"Msxml2.XMLHTTP\")}catch(t){}throw Error(\"Browser-only version of superagent could not find XHR\")};var g=\"\".trim?function(t){return t.trim()}:function(t){return t.replace(/(^\\s*|\\s*$)/g,\"\")};m.serializeObject=i,m.parseString=o,m.types={html:\"text/html\",json:\"application/json\",xml:\"text/xml\",urlencoded:\"application/x-www-form-urlencoded\",form:\"application/x-www-form-urlencoded\",\"form-data\":\"application/x-www-form-urlencoded\"},m.serialize={\"application/x-www-form-urlencoded\":i,\"application/json\":JSON.stringify},m.parse={\"application/x-www-form-urlencoded\":o,\"application/json\":JSON.parse},v(c.prototype),c.prototype._parseBody=function(t){var e=m.parse[this.type];return this.req._parser?this.req._parser(this,t):(!e&&u(this.type)&&(e=m.parse[\"application/json\"]),e&&t&&(t.length||t instanceof Object)?e(t):null)},c.prototype.toError=function(){var t=this.req,e=t.method,n=t.url,r=\"cannot \"+e+\" \"+n+\" (\"+this.status+\")\",i=new Error(r);return i.status=this.status,i.method=e,i.url=n,i},m.Response=c,d(l.prototype),p(l.prototype),l.prototype.type=function(t){return this.set(\"Content-Type\",m.types[t]||t),this},l.prototype.accept=function(t){return this.set(\"Accept\",m.types[t]||t),this},l.prototype.auth=function(t,e,n){1===arguments.length&&(e=\"\"),\"object\"==typeof e&&null!==e&&(n=e,e=\"\"),n||(n={type:\"function\"==typeof btoa?\"basic\":\"auto\"});var r=function(t){if(\"function\"==typeof btoa)return btoa(t);throw new Error(\"Cannot use basic auth, btoa is not a function\")};return this._auth(t,e,n,r)},l.prototype.query=function(t){return\"string\"!=typeof t&&(t=i(t)),t&&this._query.push(t),this},l.prototype.attach=function(t,e,n){if(e){if(this._data)throw Error(\"superagent can't mix .send() and .attach()\");this._getFormData().append(t,e,n||e.name)}return this},l.prototype._getFormData=function(){return this._formData||(this._formData=new f.FormData),this._formData},l.prototype.callback=function(t,e){if(this._shouldRetry(t,e))return this._retry();var n=this._callback;this.clearTimeout(),t&&(this._maxRetries&&(t.retries=this._retries-1),this.emit(\"error\",t)),n(t,e)},l.prototype.crossDomainError=function(){var t=new Error(\"Request has been terminated\\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.\");t.crossDomain=!0,t.status=this.status,t.method=this.method,t.url=this.url,this.callback(t)},l.prototype.buffer=l.prototype.ca=l.prototype.agent=function(){return console.warn(\"This is not supported in browser version of superagent\"),this},l.prototype.pipe=l.prototype.write=function(){throw Error(\"Streaming is not supported in browser version of superagent\")},l.prototype._isHost=function(t){return t&&\"object\"==typeof t&&!Array.isArray(t)&&\"[object Object]\"!==Object.prototype.toString.call(t)},l.prototype.end=function(t){return this._endCalled&&console.warn(\"Warning: .end() was called twice. This is not supported in superagent\"),this._endCalled=!0,this._callback=t||r,this._finalizeQueryString(),this._end()},l.prototype._end=function(){var t=this,e=this.xhr=m.getXHR(),n=this._formData||this._data;this._setTimeouts(),e.onreadystatechange=function(){var n=e.readyState;if(n>=2&&t._responseTimeoutTimer&&clearTimeout(t._responseTimeoutTimer),4==n){var r;try{r=e.status}catch(t){r=0}if(!r){if(t.timedout||t._aborted)return;return t.crossDomainError()}t.emit(\"end\")}};var r=function(e,n){n.total>0&&(n.percent=n.loaded/n.total*100),n.direction=e,t.emit(\"progress\",n)};if(this.hasListeners(\"progress\"))try{e.onprogress=r.bind(null,\"download\"),e.upload&&(e.upload.onprogress=r.bind(null,\"upload\"))}catch(t){}try{this.username&&this.password?e.open(this.method,this.url,!0,this.username,this.password):e.open(this.method,this.url,!0)}catch(t){return this.callback(t)}if(this._withCredentials&&(e.withCredentials=!0),!this._formData&&\"GET\"!=this.method&&\"HEAD\"!=this.method&&\"string\"!=typeof n&&!this._isHost(n)){var i=this._header[\"content-type\"],s=this._serializer||m.serialize[i?i.split(\";\")[0]:\"\"];!s&&u(i)&&(s=m.serialize[\"application/json\"]),s&&(n=s(n))}for(var o in this.header)null!=this.header[o]&&this.header.hasOwnProperty(o)&&e.setRequestHeader(o,this.header[o]);return this._responseType&&(e.responseType=this._responseType),this.emit(\"request\",this),e.send(void 0!==n?n:null),this},m.agent=function(){return new y},[\"GET\",\"POST\",\"OPTIONS\",\"PATCH\",\"PUT\",\"DELETE\"].forEach(function(t){y.prototype[t.toLowerCase()]=function(e,n){var r=new m.Request(t,e);return this._setDefaults(r),n&&r.end(n),r}}),y.prototype.del=y.prototype.delete,m.get=function(t,e,n){var r=m(\"GET\",t);return\"function\"==typeof e&&(n=e,e=null),e&&r.query(e),n&&r.end(n),r},m.head=function(t,e,n){var r=m(\"HEAD\",t);return\"function\"==typeof e&&(n=e,e=null),e&&r.query(e),n&&r.end(n),r},m.options=function(t,e,n){var r=m(\"OPTIONS\",t);return\"function\"==typeof e&&(n=e,e=null),e&&r.send(e),n&&r.end(n),r},m.del=h,m.delete=h,m.patch=function(t,e,n){var r=m(\"PATCH\",t);return\"function\"==typeof e&&(n=e,e=null),e&&r.send(e),n&&r.end(n),r},m.post=function(t,e,n){var r=m(\"POST\",t);return\"function\"==typeof e&&(n=e,e=null),e&&r.send(e),n&&r.end(n),r},m.put=function(t,e,n){var r=m(\"PUT\",t);return\"function\"==typeof e&&(n=e,e=null),e&&r.send(e),n&&r.end(n),r}},function(t,e,n){\"use strict\";t.exports=\"3.7.3\"},function(t,e,n){\"use strict\";function r(t){return null!==t&&\"object\"==typeof t}t.exports=r},function(t,e,n){\"use strict\";var r=n(0),i=n(1),s=n(28),o=[\"getItem\",\"setItem\",\"removeItem\",\"clear\"];s.async?r(o).each(function(t){\"function\"!=typeof s[t]&&(s[t]=function(){var e=new Error(\"Synchronous API [\"+t+\"] is not available in this runtime.\");throw e.code=\"SYNC_API_NOT_AVAILABLE\",e})}):r(o).each(function(t){\"function\"==typeof s[t]&&(s[t+\"Async\"]=function(){return i.resolve(s[t].apply(s,arguments))})}),t.exports=s},function(t,e,n){\"use strict\";var r=n(11),i=n(5),s=e.removeAsync=r.removeItemAsync.bind(r),o=function(t,e){try{t=JSON.parse(t)}catch(t){return null}if(t){return t.expiredAt&&t.expiredAt<Date.now()?s(e).then(function(){return null}):t.value}return null};e.getAsync=function(t){return t=\"AV/\"+i.applicationId+\"/\"+t,r.getItemAsync(t).then(function(e){return o(e,t)})},e.setAsync=function(t,e,n){var s={value:e};return\"number\"==typeof n&&(s.expiredAt=Date.now()+n),r.setItemAsync(\"AV/\"+i.applicationId+\"/\"+t,JSON.stringify(s))}},function(t,e){var n={utf8:{stringToBytes:function(t){return n.bin.stringToBytes(unescape(encodeURIComponent(t)))},bytesToString:function(t){return decodeURIComponent(escape(n.bin.bytesToString(t)))}},bin:{stringToBytes:function(t){for(var e=[],n=0;n<t.length;n++)e.push(255&t.charCodeAt(n));return e},bytesToString:function(t){for(var e=[],n=0;n<t.length;n++)e.push(String.fromCharCode(t[n]));return e.join(\"\")}}};t.exports=n},function(t,e,n){\"use strict\";/*!\n * LeanCloud JavaScript SDK\n * https://leancloud.cn\n *\n * Copyright 2016 LeanCloud.cn, Inc.\n * The LeanCloud JavaScript SDK is freely distributable under the MIT license.\n */\nn(15);var r=n(0),i=n(5);i._=r,i.version=n(9),i.Promise=n(1),i.localStorage=n(11),i.Cache=n(12),i.Error=n(4),n(30),n(32)(i),n(33)(i),n(34)(i),n(35)(i),n(36)(i),n(37)(i),n(45)(i),n(46)(i),n(47)(i),n(48)(i),n(49)(i),n(51)(i),n(52)(i),n(53)(i),n(54)(i),n(55)(i),n(56)(i),i.Conversation=n(57),n(58),t.exports=i},function(t,e,n){\"use strict\"},function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,\"loaded\",{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,\"id\",{enumerable:!0,get:function(){return t.i}}),t.webpackPolyfill=1),t}},function(t,e,n){\"use strict\";var r=n(9),i=[\"Browser\"].concat(n(18));t.exports=\"LeanCloud-JS-SDK/\"+r+\" (\"+i.join(\"; \")+\")\"},function(t,e,n){\"use strict\";t.exports=[]},function(t,e,n){function r(t){if(t)return i(t)}function i(t){for(var e in r.prototype)t[e]=r.prototype[e];return t}t.exports=r,r.prototype.on=r.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks[\"$\"+t]=this._callbacks[\"$\"+t]||[]).push(e),this},r.prototype.once=function(t,e){function n(){this.off(t,n),e.apply(this,arguments)}return n.fn=e,this.on(t,n),this},r.prototype.off=r.prototype.removeListener=r.prototype.removeAllListeners=r.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var n=this._callbacks[\"$\"+t];if(!n)return this;if(1==arguments.length)return delete this._callbacks[\"$\"+t],this;for(var r,i=0;i<n.length;i++)if((r=n[i])===e||r.fn===e){n.splice(i,1);break}return this},r.prototype.emit=function(t){this._callbacks=this._callbacks||{};var e=[].slice.call(arguments,1),n=this._callbacks[\"$\"+t];if(n){n=n.slice(0);for(var r=0,i=n.length;r<i;++r)n[r].apply(this,e)}return this},r.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks[\"$\"+t]||[]},r.prototype.hasListeners=function(t){return!!this.listeners(t).length}},function(t,e,n){\"use strict\";function r(t){if(t)return i(t)}function i(t){for(var e in r.prototype)t[e]=r.prototype[e];return t}var s=n(10);t.exports=r,r.prototype.clearTimeout=function(){return clearTimeout(this._timer),clearTimeout(this._responseTimeoutTimer),delete this._timer,delete this._responseTimeoutTimer,this},r.prototype.parse=function(t){return this._parser=t,this},r.prototype.responseType=function(t){return this._responseType=t,this},r.prototype.serialize=function(t){return this._serializer=t,this},r.prototype.timeout=function(t){if(!t||\"object\"!=typeof t)return this._timeout=t,this._responseTimeout=0,this;for(var e in t)switch(e){case\"deadline\":this._timeout=t.deadline;break;case\"response\":this._responseTimeout=t.response;break;default:console.warn(\"Unknown timeout option\",e)}return this},r.prototype.retry=function(t,e){return 0!==arguments.length&&!0!==t||(t=1),t<=0&&(t=0),this._maxRetries=t,this._retries=0,this._retryCallback=e,this};var o=[\"ECONNRESET\",\"ETIMEDOUT\",\"EADDRINFO\",\"ESOCKETTIMEDOUT\"];r.prototype._shouldRetry=function(t,e){if(!this._maxRetries||this._retries++>=this._maxRetries)return!1;if(this._retryCallback)try{var n=this._retryCallback(t,e);if(!0===n)return!0;if(!1===n)return!1}catch(t){console.error(t)}if(e&&e.status&&e.status>=500&&501!=e.status)return!0;if(t){if(t.code&&~o.indexOf(t.code))return!0;if(t.timeout&&\"ECONNABORTED\"==t.code)return!0;if(t.crossDomain)return!0}return!1},r.prototype._retry=function(){return this.clearTimeout(),this.req&&(this.req=null,this.req=this.request()),this._aborted=!1,this.timedout=!1,this._end()},r.prototype.then=function(t,e){if(!this._fullfilledPromise){var n=this;this._endCalled&&console.warn(\"Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises\"),this._fullfilledPromise=new Promise(function(t,e){n.end(function(n,r){n?e(n):t(r)})})}return this._fullfilledPromise.then(t,e)},r.prototype.catch=function(t){return this.then(void 0,t)},r.prototype.use=function(t){return t(this),this},r.prototype.ok=function(t){if(\"function\"!=typeof t)throw Error(\"Callback required\");return this._okCallback=t,this},r.prototype._isResponseOK=function(t){return!!t&&(this._okCallback?this._okCallback(t):t.status>=200&&t.status<300)},r.prototype.get=function(t){return this._header[t.toLowerCase()]},r.prototype.getHeader=r.prototype.get,r.prototype.set=function(t,e){if(s(t)){for(var n in t)this.set(n,t[n]);return this}return this._header[t.toLowerCase()]=e,this.header[t]=e,this},r.prototype.unset=function(t){return delete this._header[t.toLowerCase()],delete this.header[t],this},r.prototype.field=function(t,e){if(null===t||void 0===t)throw new Error(\".field(name, val) name can not be empty\");if(this._data&&console.error(\".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()\"),s(t)){for(var n in t)this.field(n,t[n]);return this}if(Array.isArray(e)){for(var r in e)this.field(t,e[r]);return this}if(null===e||void 0===e)throw new Error(\".field(name, val) val can not be empty\");return\"boolean\"==typeof e&&(e=\"\"+e),this._getFormData().append(t,e),this},r.prototype.abort=function(){return this._aborted?this:(this._aborted=!0,this.xhr&&this.xhr.abort(),this.req&&this.req.abort(),this.clearTimeout(),this.emit(\"abort\"),this)},r.prototype._auth=function(t,e,n,r){switch(n.type){case\"basic\":this.set(\"Authorization\",\"Basic \"+r(t+\":\"+e));break;case\"auto\":this.username=t,this.password=e;break;case\"bearer\":this.set(\"Authorization\",\"Bearer \"+t)}return this},r.prototype.withCredentials=function(t){return void 0==t&&(t=!0),this._withCredentials=t,this},r.prototype.redirects=function(t){return this._maxRedirects=t,this},r.prototype.maxResponseSize=function(t){if(\"number\"!=typeof t)throw TypeError(\"Invalid argument\");return this._maxResponseSize=t,this},r.prototype.toJSON=function(){return{method:this.method,url:this.url,data:this._data,headers:this._header}},r.prototype.send=function(t){var e=s(t),n=this._header[\"content-type\"];if(this._formData&&console.error(\".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()\"),e&&!this._data)Array.isArray(t)?this._data=[]:this._isHost(t)||(this._data={});else if(t&&this._data&&this._isHost(this._data))throw Error(\"Can't merge these send calls\");if(e&&s(this._data))for(var r in t)this._data[r]=t[r];else\"string\"==typeof t?(n||this.type(\"form\"),n=this._header[\"content-type\"],this._data=\"application/x-www-form-urlencoded\"==n?this._data?this._data+\"&\"+t:t:(this._data||\"\")+t):this._data=t;return!e||this._isHost(t)?this:(n||this.type(\"json\"),this)},r.prototype.sortQuery=function(t){return this._sort=void 0===t||t,this},r.prototype._finalizeQueryString=function(){var t=this._query.join(\"&\");if(t&&(this.url+=(this.url.indexOf(\"?\")>=0?\"&\":\"?\")+t),this._query.length=0,this._sort){var e=this.url.indexOf(\"?\");if(e>=0){var n=this.url.substring(e+1).split(\"&\");\"function\"==typeof this._sort?n.sort(this._sort):n.sort(),this.url=this.url.substring(0,e)+\"?\"+n.join(\"&\")}}},r.prototype._appendQueryString=function(){console.trace(\"Unsupported\")},r.prototype._timeoutError=function(t,e,n){if(!this._aborted){var r=new Error(t+e+\"ms exceeded\");r.timeout=e,r.code=\"ECONNABORTED\",r.errno=n,this.timedout=!0,this.abort(),this.callback(r)}},r.prototype._setTimeouts=function(){var t=this;this._timeout&&!this._timer&&(this._timer=setTimeout(function(){t._timeoutError(\"Timeout of \",t._timeout,\"ETIME\")},this._timeout)),this._responseTimeout&&!this._responseTimeoutTimer&&(this._responseTimeoutTimer=setTimeout(function(){t._timeoutError(\"Response timeout of \",t._responseTimeout,\"ETIMEDOUT\")},this._responseTimeout))}},function(t,e,n){\"use strict\";function r(t){if(t)return i(t)}function i(t){for(var e in r.prototype)t[e]=r.prototype[e];return t}var s=n(22);t.exports=r,r.prototype.get=function(t){return this.header[t.toLowerCase()]},r.prototype._setHeaderProperties=function(t){var e=t[\"content-type\"]||\"\";this.type=s.type(e);var n=s.params(e);for(var r in n)this[r]=n[r];this.links={};try{t.link&&(this.links=s.parseLinks(t.link))}catch(t){}},r.prototype._setStatusProperties=function(t){var e=t/100|0;this.status=this.statusCode=t,this.statusType=e,this.info=1==e,this.ok=2==e,this.redirect=3==e,this.clientError=4==e,this.serverError=5==e,this.error=(4==e||5==e)&&this.toError(),this.created=201==t,this.accepted=202==t,this.noContent=204==t,this.badRequest=400==t,this.unauthorized=401==t,this.notAcceptable=406==t,this.forbidden=403==t,this.notFound=404==t,this.unprocessableEntity=422==t}},function(t,e,n){\"use strict\";e.type=function(t){return t.split(/ *; */).shift()},e.params=function(t){return t.split(/ *; */).reduce(function(t,e){var n=e.split(/ *= */),r=n.shift(),i=n.shift();return r&&i&&(t[r]=i),t},{})},e.parseLinks=function(t){return t.split(/ *, */).reduce(function(t,e){var n=e.split(/ *; */),r=n[0].slice(1,-1);return t[n[1].split(/ *= */)[1].slice(1,-1)]=r,t},{})},e.cleanHeader=function(t,e){return delete t[\"content-type\"],delete t[\"content-length\"],delete t[\"transfer-encoding\"],delete t.host,e&&(delete t.authorization,delete t.cookie),t}},function(t,e){function n(){this._defaults=[]}[\"use\",\"on\",\"once\",\"set\",\"query\",\"type\",\"accept\",\"auth\",\"withCredentials\",\"sortQuery\",\"retry\",\"ok\",\"redirects\",\"timeout\",\"buffer\",\"serialize\",\"parse\",\"ca\",\"key\",\"pfx\",\"cert\"].forEach(function(t){n.prototype[t]=function(){return this._defaults.push({fn:t,arguments:arguments}),this}}),n.prototype._setDefaults=function(t){this._defaults.forEach(function(e){t[e.fn].apply(t,e.arguments)})},t.exports=n},function(t,e,n){function r(t){var n,r=0;for(n in t)r=(r<<5)-r+t.charCodeAt(n),r|=0;return e.colors[Math.abs(r)%e.colors.length]}function i(t){function n(){if(n.enabled){var t=n,r=+new Date,s=r-(i||r);t.diff=s,t.prev=i,t.curr=r,i=r;for(var o=new Array(arguments.length),a=0;a<o.length;a++)o[a]=arguments[a];o[0]=e.coerce(o[0]),\"string\"!=typeof o[0]&&o.unshift(\"%O\");var u=0;o[0]=o[0].replace(/%([a-zA-Z%])/g,function(n,r){if(\"%%\"===n)return n;u++;var i=e.formatters[r];if(\"function\"==typeof i){var s=o[u];n=i.call(t,s),o.splice(u,1),u--}return n}),e.formatArgs.call(t,o);(n.log||e.log||console.log.bind(console)).apply(t,o)}}var i;return n.namespace=t,n.enabled=e.enabled(t),n.useColors=e.useColors(),n.color=r(t),n.destroy=s,\"function\"==typeof e.init&&e.init(n),e.instances.push(n),n}function s(){var t=e.instances.indexOf(this);return-1!==t&&(e.instances.splice(t,1),!0)}function o(t){e.save(t),e.names=[],e.skips=[];var n,r=(\"string\"==typeof t?t:\"\").split(/[\\s,]+/),i=r.length;for(n=0;n<i;n++)r[n]&&(t=r[n].replace(/\\*/g,\".*?\"),\"-\"===t[0]?e.skips.push(new RegExp(\"^\"+t.substr(1)+\"$\")):e.names.push(new RegExp(\"^\"+t+\"$\")));for(n=0;n<e.instances.length;n++){var s=e.instances[n];s.enabled=e.enabled(s.namespace)}}function a(){e.enable(\"\")}function u(t){if(\"*\"===t[t.length-1])return!0;var n,r;for(n=0,r=e.skips.length;n<r;n++)if(e.skips[n].test(t))return!1;for(n=0,r=e.names.length;n<r;n++)if(e.names[n].test(t))return!0;return!1}function c(t){return t instanceof Error?t.stack||t.message:t}e=t.exports=i.debug=i.default=i,e.coerce=c,e.disable=a,e.enable=o,e.enabled=u,e.humanize=n(25),e.instances=[],e.names=[],e.skips=[],e.formatters={}},function(t,e){function n(t){if(t=String(t),!(t.length>100)){var e=/^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(t);if(e){var n=parseFloat(e[1]);switch((e[2]||\"ms\").toLowerCase()){case\"years\":case\"year\":case\"yrs\":case\"yr\":case\"y\":return n*l;case\"days\":case\"day\":case\"d\":return n*c;case\"hours\":case\"hour\":case\"hrs\":case\"hr\":case\"h\":return n*u;case\"minutes\":case\"minute\":case\"mins\":case\"min\":case\"m\":return n*a;case\"seconds\":case\"second\":case\"secs\":case\"sec\":case\"s\":return n*o;case\"milliseconds\":case\"millisecond\":case\"msecs\":case\"msec\":case\"ms\":return n;default:return}}}}function r(t){return t>=c?Math.round(t/c)+\"d\":t>=u?Math.round(t/u)+\"h\":t>=a?Math.round(t/a)+\"m\":t>=o?Math.round(t/o)+\"s\":t+\"ms\"}function i(t){return s(t,c,\"day\")||s(t,u,\"hour\")||s(t,a,\"minute\")||s(t,o,\"second\")||t+\" ms\"}function s(t,e,n){if(!(t<e))return t<1.5*e?Math.floor(t/e)+\" \"+n:Math.ceil(t/e)+\" \"+n+\"s\"}var o=1e3,a=60*o,u=60*a,c=24*u,l=365.25*c;t.exports=function(t,e){e=e||{};var s=typeof t;if(\"string\"===s&&t.length>0)return n(t);if(\"number\"===s&&!1===isNaN(t))return e.long?i(t):r(t);throw new Error(\"val is not a non-empty string or a valid number. val=\"+JSON.stringify(t))}},function(t,e,n){(function(e){/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.3+b33f4734\n */\n!function(e,n){t.exports=n()}(0,function(){\"use strict\";function t(t){var e=typeof t;return null!==t&&(\"object\"===e||\"function\"===e)}function r(t){return\"function\"==typeof t}function i(t){B=t}function s(t){J=t}function o(){return void 0!==M?function(){M(u)}:a()}function a(){var t=setTimeout;return function(){return t(u,1)}}function u(){for(var t=0;t<q;t+=2){(0,G[t])(G[t+1]),G[t]=void 0,G[t+1]=void 0}q=0}function c(t,e){var n=this,r=new this.constructor(h);void 0===r[$]&&j(r);var i=n._state;if(i){var s=arguments[i-1];J(function(){return E(i,r,s,n._result)})}else A(n,r,t,e);return r}function l(t){var e=this;if(t&&\"object\"==typeof t&&t.constructor===e)return t;var n=new e(h);return g(n,t),n}function h(){}function f(){return new TypeError(\"You cannot resolve a promise with itself\")}function d(){return new TypeError(\"A promises callback cannot return that same promise.\")}function p(t){try{return t.then}catch(t){return tt.error=t,tt}}function _(t,e,n,r){try{t.call(e,n,r)}catch(t){return t}}function v(t,e,n){J(function(t){var r=!1,i=_(n,e,function(n){r||(r=!0,e!==n?g(t,n):w(t,n))},function(e){r||(r=!0,O(t,e))},\"Settle: \"+(t._label||\" unknown promise\"));!r&&i&&(r=!0,O(t,i))},t)}function y(t,e){e._state===Y?w(t,e._result):e._state===Z?O(t,e._result):A(e,void 0,function(e){return g(t,e)},function(e){return O(t,e)})}function m(t,e,n){e.constructor===t.constructor&&n===c&&e.constructor.resolve===l?y(t,e):n===tt?(O(t,tt.error),tt.error=null):void 0===n?w(t,e):r(n)?v(t,e,n):w(t,e)}function g(e,n){e===n?O(e,f()):t(n)?m(e,n,p(n)):w(e,n)}function b(t){t._onerror&&t._onerror(t._result),S(t)}function w(t,e){t._state===X&&(t._result=e,t._state=Y,0!==t._subscribers.length&&J(S,t))}function O(t,e){t._state===X&&(t._state=Z,t._result=e,J(b,t))}function A(t,e,n,r){var i=t._subscribers,s=i.length;t._onerror=null,i[s]=e,i[s+Y]=n,i[s+Z]=r,0===s&&t._state&&J(S,t)}function S(t){var e=t._subscribers,n=t._state;if(0!==e.length){for(var r=void 0,i=void 0,s=t._result,o=0;o<e.length;o+=3)r=e[o],i=e[o+n],r?E(n,r,i,s):i(s);t._subscribers.length=0}}function C(t,e){try{return t(e)}catch(t){return tt.error=t,tt}}function E(t,e,n,i){var s=r(n),o=void 0,a=void 0,u=void 0,c=void 0;if(s){if(o=C(n,i),o===tt?(c=!0,a=o.error,o.error=null):u=!0,e===o)return void O(e,d())}else o=i,u=!0;e._state!==X||(s&&u?g(e,o):c?O(e,a):t===Y?w(e,o):t===Z&&O(e,o))}function T(t,e){try{e(function(e){g(t,e)},function(e){O(t,e)})}catch(e){O(t,e)}}function N(){return et++}function j(t){t[$]=et++,t._state=void 0,t._result=void 0,t._subscribers=[]}function x(){return new Error(\"Array Methods must be provided an Array\")}function U(t){return new nt(this,t).promise}function k(t){var e=this;return new e(F(t)?function(n,r){for(var i=t.length,s=0;s<i;s++)e.resolve(t[s]).then(n,r)}:function(t,e){return e(new TypeError(\"You must pass an array to race.\"))})}function I(t){var e=this,n=new e(h);return O(n,t),n}function R(){throw new TypeError(\"You must pass a resolver function as the first argument to the promise constructor\")}function P(){throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\")}function D(){var t=void 0;if(void 0!==e)t=e;else if(\"undefined\"!=typeof self)t=self;else try{t=Function(\"return this\")()}catch(t){throw new Error(\"polyfill failed because global object is unavailable in this environment\")}var n=t.Promise;if(n){var r=null;try{r=Object.prototype.toString.call(n.resolve())}catch(t){}if(\"[object Promise]\"===r&&!n.cast)return}t.Promise=rt}var L=void 0;L=Array.isArray?Array.isArray:function(t){return\"[object Array]\"===Object.prototype.toString.call(t)};var F=L,q=0,M=void 0,B=void 0,J=function(t,e){G[q]=t,G[q+1]=e,2===(q+=2)&&(B?B(u):H())},W=\"undefined\"!=typeof window?window:void 0,Q=W||{},V=Q.MutationObserver||Q.WebKitMutationObserver,K=\"undefined\"==typeof self&&\"undefined\"!=typeof process&&\"[object process]\"==={}.toString.call(process),z=\"undefined\"!=typeof Uint8ClampedArray&&\"undefined\"!=typeof importScripts&&\"undefined\"!=typeof MessageChannel,G=new Array(1e3),H=void 0;H=K?function(){return function(){return process.nextTick(u)}}():V?function(){var t=0,e=new V(u),n=document.createTextNode(\"\");return e.observe(n,{characterData:!0}),function(){n.data=t=++t%2}}():z?function(){var t=new MessageChannel;return t.port1.onmessage=u,function(){return t.port2.postMessage(0)}}():void 0===W?function(){try{var t=n(27);return M=t.runOnLoop||t.runOnContext,o()}catch(t){return a()}}():a();var $=Math.random().toString(36).substring(2),X=void 0,Y=1,Z=2,tt={error:null},et=0,nt=function(){function t(t,e){this._instanceConstructor=t,this.promise=new t(h),this.promise[$]||j(this.promise),F(e)?(this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?w(this.promise,this._result):(this.length=this.length||0,this._enumerate(e),0===this._remaining&&w(this.promise,this._result))):O(this.promise,x())}return t.prototype._enumerate=function(t){for(var e=0;this._state===X&&e<t.length;e++)this._eachEntry(t[e],e)},t.prototype._eachEntry=function(t,e){var n=this._instanceConstructor,r=n.resolve;if(r===l){var i=p(t);if(i===c&&t._state!==X)this._settledAt(t._state,e,t._result);else if(\"function\"!=typeof i)this._remaining--,this._result[e]=t;else if(n===rt){var s=new n(h);m(s,t,i),this._willSettleAt(s,e)}else this._willSettleAt(new n(function(e){return e(t)}),e)}else this._willSettleAt(r(t),e)},t.prototype._settledAt=function(t,e,n){var r=this.promise;r._state===X&&(this._remaining--,t===Z?O(r,n):this._result[e]=n),0===this._remaining&&w(r,this._result)},t.prototype._willSettleAt=function(t,e){var n=this;A(t,void 0,function(t){return n._settledAt(Y,e,t)},function(t){return n._settledAt(Z,e,t)})},t}(),rt=function(){function t(e){this[$]=N(),this._result=this._state=void 0,this._subscribers=[],h!==e&&(\"function\"!=typeof e&&R(),this instanceof t?T(this,e):P())}return t.prototype.catch=function(t){return this.then(null,t)},t.prototype.finally=function(t){var e=this,n=e.constructor;return e.then(function(e){return n.resolve(t()).then(function(){return e})},function(e){return n.resolve(t()).then(function(){throw e})})},t}();return rt.prototype.then=c,rt.all=U,rt.race=k,rt.resolve=l,rt.reject=I,rt._setScheduler=i,rt._setAsap=s,rt._asap=J,rt.polyfill=D,rt.Promise=rt,rt})}).call(e,n(7))},function(t,e){},function(t,e,n){\"use strict\";(function(e){var r=n(0),i=(n(1),{}),s=[\"getItem\",\"setItem\",\"removeItem\",\"clear\"],o=e.localStorage;try{var a=\"__storejs__\";if(o.setItem(a,a),o.getItem(a)!=a)throw new Error;o.removeItem(a)}catch(t){o=n(29)}r(s).each(function(t){i[t]=function(){return o[t].apply(o,arguments)}}),i.async=!1,t.exports=i}).call(e,n(7))},function(t,e,n){!function(e){var n={},r={};n.length=0,n.getItem=function(t){return r[t]||null},n.setItem=function(t,e){void 0===e?n.removeItem(t):(r.hasOwnProperty(t)||n.length++,r[t]=\"\"+e)},n.removeItem=function(t){r.hasOwnProperty(t)&&(delete r[t],n.length--)},n.key=function(t){return Object.keys(r)[t]||null},n.clear=function(){r={},n.length=0},t.exports=n}()},function(t,e,n){\"use strict\";function r(t,e){if(\"us\"===e)return h(\"https://us-api.leancloud.cn\");var n=void 0;switch(t.slice(-9)){case\"-9Nh9j0Va\":return n=t.slice(0,8).toLowerCase(),{push:\"https://\"+n+\".push.lncldapi.com\",stats:\"https://\"+n+\".stats.lncldapi.com\",engine:\"https://\"+n+\".engine.lncldapi.com\",api:\"https://\"+n+\".api.lncldapi.com\"};case\"-MdYXbMMI\":return h(\"https://us-api.leancloud.cn\");default:return n=t.slice(0,8).toLowerCase(),{push:\"https://\"+n+\".push.lncld.net\",stats:\"https://\"+n+\".stats.lncld.net\",engine:\"https://\"+n+\".engine.lncld.net\",api:\"https://\"+n+\".api.lncld.net\"}}}var i=n(5),s=n(31),o=n(3),a=o.isNullOrUndefined,u=n(0),c=u.extend,l=u.isObject,h=function(t){return{push:t,stats:t,engine:t,api:t}},f=!1;i.init=function(t){if(!l(t))return i.init({appId:t,appKey:arguments.length<=1?void 0:arguments[1],masterKey:arguments.length<=2?void 0:arguments[2],region:arguments.length<=3?void 0:arguments[3]});var e=t.appId,n=t.appKey,o=t.masterKey,a=(t.hookKey,t.region),u=void 0===a?\"cn\":a,d=t.serverURLs,p=t.disableCurrentUser,_=t.production,v=t.realtime;if(i.applicationId)throw new Error(\"SDK is already initialized.\");if(!e)throw new TypeError(\"appId must be a string\");if(!n)throw new TypeError(\"appKey must be a string\");o&&console.warn(\"MasterKey is not supposed to be used in browser.\"),i._config.applicationId=e,i._config.applicationKey=n,i._config.masterKey=o,void 0!==_&&(i._config.production=_),void 0!==p&&(i._config.disableCurrentUser=p),i._appRouter=new s(i);var y=f||void 0!==d||\"cn\"!==u;i._setServerURLs(c({},r(e,u),i._config.serverURLs,\"string\"==typeof d?h(d):d),y),v?i._config.realtime=v:i._sharedConfig.liveQueryRealtime&&(i._config.realtime=new i._sharedConfig.liveQueryRealtime({appId:e,appKey:n,region:u}))},i.setProduction=function(t){a(t)?i._config.production=null:i._config.production=t?1:0},i._setServerURLs=function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];\"string\"!=typeof t?c(i._config.serverURLs,t):i._config.serverURLs=h(t),e&&(i._appRouter?i._appRouter.disable():f=!0)},i.setServerURLs=function(t){return i._setServerURLs(t)},i.keepErrorRawMessage=function(t){i._sharedConfig.keepErrorRawMessage=t},i.setRequestTimeout=function(t){i._config.requestTimeout=t},i.initialize=i.init,[\"applicationId\",\"applicationKey\",\"masterKey\",\"hookKey\"].forEach(function(t){return Object.defineProperty(i,t,{get:function(){return i._config[t]},set:function(e){i._config[t]=e}})})},function(t,e,n){\"use strict\";function r(t){var e=this;this.AV=t,this.lockedUntil=0,o.getAsync(\"serverURLs\").then(function(t){if(!t)return e.lock(0);var n=t.serverURLs,r=t.lockedUntil;e.AV._setServerURLs(n,!1),e.lockedUntil=r}).catch(function(){return e.lock(0)})}var i=n(3),s=i.ajax,o=n(12);r.prototype.disable=function(){this.disabled=!0},r.prototype.lock=function(t){this.lockedUntil=Date.now()+t},r.prototype.refresh=function(){var t=this;if(!(this.disabled||Date.now()<this.lockedUntil)){this.lock(10);return s({method:\"get\",url:\"https://app-router.leancloud.cn/2/route\",query:{appId:this.AV.applicationId}}).then(function(e){if(!t.disabled){var n=e.ttl;if(!n)throw new Error(\"missing ttl\");n*=1e3;var r={push:\"https://\"+e.push_server,stats:\"https://\"+e.stats_server,engine:\"https://\"+e.engine_server,api:\"https://\"+e.api_server};return t.AV._setServerURLs(r,!1),t.lock(n),o.setAsync(\"serverURLs\",{serverURLs:r,lockedUntil:t.lockedUntil},n)}}).catch(function(e){console.warn(\"refresh server URLs failed: \"+e.message),t.lock(600)})}},t.exports=r},function(t,e,n){\"use strict\";var r=n(0);t.exports=function(t){var e=/\\s+/,n=Array.prototype.slice;t.Events={on:function(t,n,r){var i,s,o,a,u;if(!n)return this;for(t=t.split(e),i=this._callbacks||(this._callbacks={}),s=t.shift();s;)u=i[s],o=u?u.tail:{},o.next=a={},o.context=r,o.callback=n,i[s]={tail:a,next:u?u.next:o},s=t.shift();return this},off:function(t,n,i){var s,o,a,u,c,l;if(o=this._callbacks){if(!(t||n||i))return delete this._callbacks,this;for(t=t?t.split(e):r.keys(o),s=t.shift();s;)if(a=o[s],delete o[s],a&&(n||i)){for(u=a.tail,a=a.next;a!==u;)c=a.callback,l=a.context,(n&&c!==n||i&&l!==i)&&this.on(s,c,l),a=a.next;s=t.shift()}return this}},trigger:function(t){var r,i,s,o,a,u,c;if(!(s=this._callbacks))return this;for(u=s.all,t=t.split(e),c=n.call(arguments,1),r=t.shift();r;){if(i=s[r])for(o=i.tail;(i=i.next)!==o;)i.callback.apply(i.context||this,c);if(i=u)for(o=i.tail,a=[r].concat(c);(i=i.next)!==o;)i.callback.apply(i.context||this,a);r=t.shift()}return this}},t.Events.bind=t.Events.on,t.Events.unbind=t.Events.off}},function(t,e,n){\"use strict\";var r=n(0);t.exports=function(t){t.GeoPoint=function(e,n){r.isArray(e)?(t.GeoPoint._validate(e[0],e[1]),this.latitude=e[0],this.longitude=e[1]):r.isObject(e)?(t.GeoPoint._validate(e.latitude,e.longitude),this.latitude=e.latitude,this.longitude=e.longitude):r.isNumber(e)&&r.isNumber(n)?(t.GeoPoint._validate(e,n),this.latitude=e,this.longitude=n):(this.latitude=0,this.longitude=0);var i=this;this.__defineGetter__&&this.__defineSetter__&&(this._latitude=this.latitude,this._longitude=this.longitude,this.__defineGetter__(\"latitude\",function(){return i._latitude}),this.__defineGetter__(\"longitude\",function(){return i._longitude}),this.__defineSetter__(\"latitude\",function(e){t.GeoPoint._validate(e,i.longitude),i._latitude=e}),this.__defineSetter__(\"longitude\",function(e){t.GeoPoint._validate(i.latitude,e),i._longitude=e}))},t.GeoPoint._validate=function(t,e){if(t<-90)throw new Error(\"AV.GeoPoint latitude \"+t+\" < -90.0.\");if(t>90)throw new Error(\"AV.GeoPoint latitude \"+t+\" > 90.0.\");if(e<-180)throw new Error(\"AV.GeoPoint longitude \"+e+\" < -180.0.\");if(e>180)throw new Error(\"AV.GeoPoint longitude \"+e+\" > 180.0.\")},t.GeoPoint.current=function(){return new t.Promise(function(e,n){navigator.geolocation.getCurrentPosition(function(n){e(new t.GeoPoint({latitude:n.coords.latitude,longitude:n.coords.longitude}))},n)})},r.extend(t.GeoPoint.prototype,{toJSON:function(){return t.GeoPoint._validate(this.latitude,this.longitude),{__type:\"GeoPoint\",latitude:this.latitude,longitude:this.longitude}},radiansTo:function(t){var e=Math.PI/180,n=this.latitude*e,r=this.longitude*e,i=t.latitude*e,s=t.longitude*e,o=n-i,a=r-s,u=Math.sin(o/2),c=Math.sin(a/2),l=u*u+Math.cos(n)*Math.cos(i)*c*c;return l=Math.min(1,l),2*Math.asin(Math.sqrt(l))},kilometersTo:function(t){return 6371*this.radiansTo(t)},milesTo:function(t){return 3958.8*this.radiansTo(t)}})}},function(t,e,n){\"use strict\";var r=n(0);t.exports=function(t){t.ACL=function(e){var n=this;if(n.permissionsById={},r.isObject(e))if(e instanceof t.User)n.setReadAccess(e,!0),n.setWriteAccess(e,!0);else{if(r.isFunction(e))throw new Error(\"AV.ACL() called with a function.  Did you forget ()?\");t._objectEach(e,function(e,i){if(!r.isString(i))throw new Error(\"Tried to create an ACL with an invalid userId.\");n.permissionsById[i]={},t._objectEach(e,function(t,e){if(\"read\"!==e&&\"write\"!==e)throw new Error(\"Tried to create an ACL with an invalid permission type.\");if(!r.isBoolean(t))throw new Error(\"Tried to create an ACL with an invalid permission value.\");n.permissionsById[i][e]=t})})}},t.ACL.prototype.toJSON=function(){return r.clone(this.permissionsById)},t.ACL.prototype._setAccess=function(e,n,i){if(n instanceof t.User?n=n.id:n instanceof t.Role&&(n=\"role:\"+n.getName()),!r.isString(n))throw new Error(\"userId must be a string.\");if(!r.isBoolean(i))throw new Error(\"allowed must be either true or false.\");var s=this.permissionsById[n];if(!s){if(!i)return;s={},this.permissionsById[n]=s}i?this.permissionsById[n][e]=!0:(delete s[e],r.isEmpty(s)&&delete this.permissionsById[n])},t.ACL.prototype._getAccess=function(e,n){n instanceof t.User?n=n.id:n instanceof t.Role&&(n=\"role:\"+n.getName());var r=this.permissionsById[n];return!!r&&!!r[e]},t.ACL.prototype.setReadAccess=function(t,e){this._setAccess(\"read\",t,e)},t.ACL.prototype.getReadAccess=function(t){return this._getAccess(\"read\",t)},t.ACL.prototype.setWriteAccess=function(t,e){this._setAccess(\"write\",t,e)},t.ACL.prototype.getWriteAccess=function(t){return this._getAccess(\"write\",t)},t.ACL.prototype.setPublicReadAccess=function(t){this.setReadAccess(\"*\",t)},t.ACL.prototype.getPublicReadAccess=function(){return this.getReadAccess(\"*\")},t.ACL.prototype.setPublicWriteAccess=function(t){this.setWriteAccess(\"*\",t)},t.ACL.prototype.getPublicWriteAccess=function(){return this.getWriteAccess(\"*\")},t.ACL.prototype.getRoleReadAccess=function(e){if(e instanceof t.Role&&(e=e.getName()),r.isString(e))return this.getReadAccess(\"role:\"+e);throw new Error(\"role must be a AV.Role or a String\")},t.ACL.prototype.getRoleWriteAccess=function(e){if(e instanceof t.Role&&(e=e.getName()),r.isString(e))return this.getWriteAccess(\"role:\"+e);throw new Error(\"role must be a AV.Role or a String\")},t.ACL.prototype.setRoleReadAccess=function(e,n){if(e instanceof t.Role&&(e=e.getName()),r.isString(e))return void this.setReadAccess(\"role:\"+e,n);throw new Error(\"role must be a AV.Role or a String\")},t.ACL.prototype.setRoleWriteAccess=function(e,n){if(e instanceof t.Role&&(e=e.getName()),r.isString(e))return void this.setWriteAccess(\"role:\"+e,n);throw new Error(\"role must be a AV.Role or a String\")}}},function(t,e,n){\"use strict\";var r=n(0);t.exports=function(t){t.Op=function(){this._initialize.apply(this,arguments)},r.extend(t.Op.prototype,{_initialize:function(){}}),r.extend(t.Op,{_extend:t._extend,_opDecoderMap:{},_registerDecoder:function(e,n){t.Op._opDecoderMap[e]=n},_decode:function(e){var n=t.Op._opDecoderMap[e.__op];return n?n(e):void 0}}),t.Op._registerDecoder(\"Batch\",function(e){var n=null;return t._arrayEach(e.ops,function(e){e=t.Op._decode(e),n=e._mergeWithPrevious(n)}),n}),t.Op.Set=t.Op._extend({_initialize:function(t){this._value=t},value:function(){return this._value},toJSON:function(){return t._encode(this.value())},_mergeWithPrevious:function(t){return this},_estimate:function(t){return this.value()}}),t.Op._UNSET={},t.Op.Unset=t.Op._extend({toJSON:function(){return{__op:\"Delete\"}},_mergeWithPrevious:function(t){return this},_estimate:function(e){return t.Op._UNSET}}),t.Op._registerDecoder(\"Delete\",function(e){return new t.Op.Unset}),t.Op.Increment=t.Op._extend({_initialize:function(t){this._amount=t},amount:function(){return this._amount},toJSON:function(){return{__op:\"Increment\",amount:this._amount}},_mergeWithPrevious:function(e){if(e){if(e instanceof t.Op.Unset)return new t.Op.Set(this.amount());if(e instanceof t.Op.Set)return new t.Op.Set(e.value()+this.amount());if(e instanceof t.Op.Increment)return new t.Op.Increment(this.amount()+e.amount());throw new Error(\"Op is invalid after previous op.\")}return this},_estimate:function(t){return t?t+this.amount():this.amount()}}),t.Op._registerDecoder(\"Increment\",function(e){return new t.Op.Increment(e.amount)}),t.Op.BitAnd=t.Op._extend({_initialize:function(t){this._value=t},value:function(){return this._value},toJSON:function(){return{__op:\"BitAnd\",value:this.value()}},_mergeWithPrevious:function(e){if(e){if(e instanceof t.Op.Unset)return new t.Op.Set(0);if(e instanceof t.Op.Set)return new t.Op.Set(e.value()&this.value());throw new Error(\"Op is invalid after previous op.\")}return this},_estimate:function(t){return t&this.value()}}),t.Op._registerDecoder(\"BitAnd\",function(e){return new t.Op.BitAnd(e.value)}),t.Op.BitOr=t.Op._extend({_initialize:function(t){this._value=t},value:function(){return this._value},toJSON:function(){return{__op:\"BitOr\",value:this.value()}},_mergeWithPrevious:function(e){if(e){if(e instanceof t.Op.Unset)return new t.Op.Set(this.value());if(e instanceof t.Op.Set)return new t.Op.Set(e.value()|this.value());throw new Error(\"Op is invalid after previous op.\")}return this},_estimate:function(t){return t|this.value()}}),t.Op._registerDecoder(\"BitOr\",function(e){return new t.Op.BitOr(e.value)}),t.Op.BitXor=t.Op._extend({_initialize:function(t){this._value=t},value:function(){return this._value},toJSON:function(){return{__op:\"BitXor\",value:this.value()}},_mergeWithPrevious:function(e){if(e){if(e instanceof t.Op.Unset)return new t.Op.Set(this.value());if(e instanceof t.Op.Set)return new t.Op.Set(e.value()^this.value());throw new Error(\"Op is invalid after previous op.\")}return this},_estimate:function(t){return t^this.value()}}),t.Op._registerDecoder(\"BitXor\",function(e){return new t.Op.BitXor(e.value)}),t.Op.Add=t.Op._extend({_initialize:function(t){this._objects=t},objects:function(){return this._objects},toJSON:function(){return{__op:\"Add\",objects:t._encode(this.objects())}},_mergeWithPrevious:function(e){if(e){if(e instanceof t.Op.Unset)return new t.Op.Set(this.objects());if(e instanceof t.Op.Set)return new t.Op.Set(this._estimate(e.value()));if(e instanceof t.Op.Add)return new t.Op.Add(e.objects().concat(this.objects()));throw new Error(\"Op is invalid after previous op.\")}return this},_estimate:function(t){return t?t.concat(this.objects()):r.clone(this.objects())}}),t.Op._registerDecoder(\"Add\",function(e){return new t.Op.Add(t._decode(e.objects))}),t.Op.AddUnique=t.Op._extend({_initialize:function(t){this._objects=r.uniq(t)},objects:function(){return this._objects},toJSON:function(){return{__op:\"AddUnique\",objects:t._encode(this.objects())}},_mergeWithPrevious:function(e){if(e){if(e instanceof t.Op.Unset)return new t.Op.Set(this.objects());if(e instanceof t.Op.Set)return new t.Op.Set(this._estimate(e.value()));if(e instanceof t.Op.AddUnique)return new t.Op.AddUnique(this._estimate(e.objects()));throw new Error(\"Op is invalid after previous op.\")}return this},_estimate:function(e){if(e){var n=r.clone(e);return t._arrayEach(this.objects(),function(e){if(e instanceof t.Object&&e.id){var i=r.find(n,function(n){return n instanceof t.Object&&n.id===e.id});if(i){var s=r.indexOf(n,i);n[s]=e}else n.push(e)}else r.contains(n,e)||n.push(e)}),n}return r.clone(this.objects())}}),t.Op._registerDecoder(\"AddUnique\",function(e){return new t.Op.AddUnique(t._decode(e.objects))}),t.Op.Remove=t.Op._extend({_initialize:function(t){this._objects=r.uniq(t)},objects:function(){return this._objects},toJSON:function(){return{__op:\"Remove\",objects:t._encode(this.objects())}},_mergeWithPrevious:function(e){if(e){if(e instanceof t.Op.Unset)return e;if(e instanceof t.Op.Set)return new t.Op.Set(this._estimate(e.value()));if(e instanceof t.Op.Remove)return new t.Op.Remove(r.union(e.objects(),this.objects()));throw new Error(\"Op is invalid after previous op.\")}return this},_estimate:function(e){if(e){var n=r.difference(e,this.objects());return t._arrayEach(this.objects(),function(e){e instanceof t.Object&&e.id&&(n=r.reject(n,function(n){return n instanceof t.Object&&n.id===e.id}))}),n}return[]}}),t.Op._registerDecoder(\"Remove\",function(e){return new t.Op.Remove(t._decode(e.objects))}),t.Op.Relation=t.Op._extend({_initialize:function(e,n){this._targetClassName=null;var i=this,s=function(e){if(e instanceof t.Object){if(!e.id)throw new Error(\"You can't add an unsaved AV.Object to a relation.\");if(i._targetClassName||(i._targetClassName=e.className),i._targetClassName!==e.className)throw new Error(\"Tried to create a AV.Relation with 2 different types: \"+i._targetClassName+\" and \"+e.className+\".\");return e.id}return e};this.relationsToAdd=r.uniq(r.map(e,s)),this.relationsToRemove=r.uniq(r.map(n,s))},added:function(){var e=this;return r.map(this.relationsToAdd,function(n){var r=t.Object._create(e._targetClassName);return r.id=n,r})},removed:function(){var e=this;return r.map(this.relationsToRemove,function(n){var r=t.Object._create(e._targetClassName);return r.id=n,r})},toJSON:function(){var t=null,e=null,n=this,i=function(t){return{__type:\"Pointer\",className:n._targetClassName,objectId:t}},s=null;return this.relationsToAdd.length>0&&(s=r.map(this.relationsToAdd,i),t={__op:\"AddRelation\",objects:s}),this.relationsToRemove.length>0&&(s=r.map(this.relationsToRemove,i),e={__op:\"RemoveRelation\",objects:s}),t&&e?{__op:\"Batch\",ops:[t,e]}:t||e||{}},_mergeWithPrevious:function(e){if(e){if(e instanceof t.Op.Unset)throw new Error(\"You can't modify a relation after deleting it.\");if(e instanceof t.Op.Relation){if(e._targetClassName&&e._targetClassName!==this._targetClassName)throw new Error(\"Related object must be of class \"+e._targetClassName+\", but \"+this._targetClassName+\" was passed in.\");var n=r.union(r.difference(e.relationsToAdd,this.relationsToRemove),this.relationsToAdd),i=r.union(r.difference(e.relationsToRemove,this.relationsToAdd),this.relationsToRemove),s=new t.Op.Relation(n,i);return s._targetClassName=this._targetClassName,s}throw new Error(\"Op is invalid after previous op.\")}return this},_estimate:function(e,n,r){if(e){if(e instanceof t.Relation){if(this._targetClassName)if(e.targetClassName){if(e.targetClassName!==this._targetClassName)throw new Error(\"Related object must be a \"+e.targetClassName+\", but a \"+this._targetClassName+\" was passed in.\")}else e.targetClassName=this._targetClassName;return e}throw new Error(\"Op is invalid after previous op.\")}new t.Relation(n,r).targetClassName=this._targetClassName}}),t.Op._registerDecoder(\"AddRelation\",function(e){return new t.Op.Relation(t._decode(e.objects),[])}),t.Op._registerDecoder(\"RemoveRelation\",function(e){return new t.Op.Relation([],t._decode(e.objects))})}},function(t,e,n){\"use strict\";var r=n(0);t.exports=function(t){t.Relation=function(t,e){if(!r.isString(e))throw new TypeError(\"key must be a string\");this.parent=t,this.key=e,this.targetClassName=null},t.Relation.reverseQuery=function(e,n,r){var i=new t.Query(e);return i.equalTo(n,r._toPointer()),i},r.extend(t.Relation.prototype,{_ensureParentAndKey:function(t,e){if(this.parent=this.parent||t,this.key=this.key||e,this.parent!==t)throw new Error(\"Internal Error. Relation retrieved from two different Objects.\");if(this.key!==e)throw new Error(\"Internal Error. Relation retrieved from two different keys.\")},add:function(e){r.isArray(e)||(e=[e]);var n=new t.Op.Relation(e,[]);this.parent.set(this.key,n),this.targetClassName=n._targetClassName},remove:function(e){r.isArray(e)||(e=[e]);var n=new t.Op.Relation([],e);this.parent.set(this.key,n),this.targetClassName=n._targetClassName},toJSON:function(){return{__type:\"Relation\",className:this.targetClassName}},query:function(){var e,n;return this.targetClassName?(e=t.Object._getSubclass(this.targetClassName),n=new t.Query(e)):(e=t.Object._getSubclass(this.parent.className),n=new t.Query(e),n._extraOptions.redirectClassNameForKey=this.key),n._addCondition(\"$relatedTo\",\"object\",this.parent._toPointer()),n._addCondition(\"$relatedTo\",\"key\",this.key),n}})}},function(t,e,n){\"use strict\";var r=n(0),i=n(38),s=n(39),o=n(40),a=n(4),u=n(2)._request,c=n(1),l=n(3),h=l.tap,f=l.transformFetchOptions,d=n(6)(\"leancloud:file\"),p=n(44);t.exports=function(t){var e=function(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)},n=function(t){return r.isString(t)?t.match(/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/)[4]:\"\"},l=function(t){if(t<26)return String.fromCharCode(65+t);if(t<52)return String.fromCharCode(t-26+97);if(t<62)return String.fromCharCode(t-52+48);if(62===t)return\"+\";if(63===t)return\"/\";throw new Error(\"Tried to encode large digit \"+t+\" in base64.\")},_=function(t){var e=[];return e.length=Math.ceil(t.length/3),r.times(e.length,function(n){var r=t[3*n],i=t[3*n+1]||0,s=t[3*n+2]||0,o=3*n+1<t.length,a=3*n+2<t.length;e[n]=[l(r>>2&63),l(r<<4&48|i>>4&15),o?l(i<<2&60|s>>6&3):\"=\",a?l(63&s):\"=\"].join(\"\")}),e.join(\"\")};t.File=function(e,i,s){if(this.attributes={name:e,url:\"\",metaData:{},base64:\"\"},r.isString(i))throw new TypeError(\"Creating an AV.File from a String is not yet supported.\");r.isArray(i)&&(this.attributes.metaData.size=i.length,i={base64:_(i)}),this._extName=\"\",this._data=i,this._uploadHeaders={},\"undefined\"!=typeof Blob&&i instanceof Blob&&(i.size&&(this.attributes.metaData.size=i.size),i.name&&(this._extName=n(i.name)));var o=void 0;if(i&&i.owner)o=i.owner;else if(!t._config.disableCurrentUser)try{o=t.User.current()}catch(t){if(\"SYNC_API_NOT_AVAILABLE\"!==t.code)throw t}this.attributes.metaData.owner=o?o.id:\"unknown\",this.set(\"mime_type\",s)},t.File.withURL=function(e,n,r,i){if(!e||!n)throw new Error(\"Please provide file name and url\");var s=new t.File(e,null,i);if(r)for(var o in r)s.attributes.metaData[o]||(s.attributes.metaData[o]=r[o]);return s.attributes.url=n,s.attributes.metaData.__source=\"external\",s},t.File.createWithoutData=function(e){var n=new t.File;return n.id=e,n},r.extend(t.File.prototype,{className:\"_File\",_toFullJSON:function(e){var n=this,i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],s=r.clone(this.attributes);return t._objectEach(s,function(n,r){s[r]=t._encode(n,e,void 0,i)}),t._objectEach(this._operations,function(t,e){s[e]=t}),r.has(this,\"id\")&&(s.objectId=this.id),r([\"createdAt\",\"updatedAt\"]).each(function(t){if(r.has(n,t)){var e=n[t];s[t]=r.isDate(e)?e.toJSON():e}}),i&&(s.__type=\"File\"),s},toFullJSON:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return this._toFullJSON(t)},toJSON:function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[this];return this._toFullJSON(n,!1)},_toPointer:function(){return{__type:\"Pointer\",className:this.className,objectId:this.id}},getACL:function(){return this._acl},setACL:function(e){if(!(e instanceof t.ACL))return new a(a.OTHER_CAUSE,\"ACL must be a AV.ACL.\");this._acl=e},name:function(){return this.get(\"name\")},url:function(){return this.get(\"url\")},get:function(t){switch(t){case\"objectId\":return this.id;case\"url\":case\"name\":case\"mime_type\":case\"metaData\":case\"createdAt\":case\"updatedAt\":return this.attributes[t];default:return this.attributes.metaData[t]}},set:function(){for(var t=this,e=function(e,n){switch(e){case\"name\":case\"url\":case\"mime_type\":case\"base64\":case\"metaData\":t.attributes[e]=n;break;default:t.attributes.metaData[e]=n}},n=arguments.length,r=Array(n),i=0;i<n;i++)r[i]=arguments[i];switch(r.length){case 1:for(var s in r[0])e(s,r[0][s]);break;case 2:e(r[0],r[1])}},setUploadHeader:function(t,e){return this._uploadHeaders[t]=e,this},metaData:function(t,e){return t&&e?(this.attributes.metaData[t]=e,this):t&&!e?this.attributes.metaData[t]:this.attributes.metaData},thumbnailURL:function(t,e,n,r,i){var s=this.attributes.url;if(!s)throw new Error(\"Invalid url.\");if(!t||!e||t<=0||e<=0)throw new Error(\"Invalid width or height value.\");if(n=n||100,r=r||!0,n<=0||n>100)throw new Error(\"Invalid quality value.\");return i=i||\"png\",s+\"?imageView/\"+(r?2:1)+\"/w/\"+t+\"/h/\"+e+\"/q/\"+n+\"/format/\"+i},size:function(){return this.metaData().size},ownerId:function(){return this.metaData().owner},destroy:function(t){return this.id?u(\"files\",null,this.id,\"DELETE\",null,t):c.reject(new Error(\"The file id does not eixst.\"))},_fileToken:function(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"fileTokens\",i=this.attributes.name,s=n(i);!s&&this._extName&&(i+=this._extName,s=this._extName);var o=e()+e()+e()+e()+e()+s,a={key:o,name:i,ACL:this._acl,mime_type:t,metaData:this.attributes.metaData};return this._qiniu_key=o,u(r,null,null,\"POST\",a)},save:function(t){var e=this;if(this.id)throw new Error(\"File already saved. If you want to manipulate a file, use AV.Query to get it.\");if(!this._previousSave)if(this._data){var n=this.get(\"mime_type\");this._previousSave=this._fileToken(n).then(function(r){return r.mime_type&&(n=r.mime_type,e.set(\"mime_type\",n)),e._token=r.token,c.resolve().then(function(){var t=e._data;if(t&&t.base64)return p(t.base64,n);if(t&&t.blob)return!t.blob.type&&n&&(t.blob.type=n),t.blob.name||(t.blob.name=e.get(\"name\")),t.blob;if(\"undefined\"!=typeof Blob&&t instanceof Blob)return t;throw new TypeError(\"malformed file data\")}).then(function(n){switch(r.provider){case\"s3\":return o(r,n,e,t);case\"qcloud\":return i(r,n,e,t);case\"qiniu\":default:return s(r,n,e,t)}}).then(h(function(){return e._callback(!0)}),function(t){throw e._callback(!1),t})})}else if(this.attributes.url&&\"external\"===this.attributes.metaData.__source){var r={name:this.attributes.name,ACL:this._acl,metaData:this.attributes.metaData,mime_type:this.mimeType,url:this.attributes.url};this._previousSave=u(\"files\",this.attributes.name,null,\"post\",r).then(function(t){return e.attributes.name=t.name,e.attributes.url=t.url,e.id=t.objectId,t.size&&(e.attributes.metaData.size=t.size),e})}return this._previousSave},_callback:function(t){u(\"fileCallback\",null,null,\"post\",{token:this._token,result:t}).catch(d),delete this._token,delete this._data},fetch:function(t,e){return u(\"files\",null,this.id,\"GET\",f(t),e).then(this._finishFetch.bind(this))},_finishFetch:function(e){var n=t.Object.prototype.parse(e);return n.attributes={name:n.name,url:n.url,mime_type:n.mime_type,bucket:n.bucket},n.attributes.metaData=n.metaData||{},n.id=n.objectId,delete n.objectId,delete n.metaData,delete n.url,delete n.name,delete n.mime_type,delete n.bucket,r.extend(this,n),this}})}},function(t,e,n){\"use strict\";var r=n(8),i=n(6)(\"cos\"),s=n(1);t.exports=function(t,e,n){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};n.attributes.url=t.url,n._bucket=t.bucket,n.id=t.objectId;var a=t.upload_url+\"?sign=\"+encodeURIComponent(t.token);return new s(function(t,s){var u=r(\"POST\",a).set(n._uploadHeaders).attach(\"fileContent\",e,n.attributes.name).field(\"op\",\"upload\");o.onprogress&&u.on(\"progress\",o.onprogress),u.end(function(e,r){if(r&&i(r.status,r.body,r.text),e)return r&&(e.statusCode=r.status,e.responseText=r.text,e.response=r.body),s(e);t(n)})})}},function(t,e,n){\"use strict\";var r=n(8),i=n(1),s=n(6)(\"qiniu\");t.exports=function(t,e,n){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};n.attributes.url=t.url,n._bucket=t.bucket,n.id=t.objectId;var a=t.token,u=t.upload_url||\"https://upload.qiniup.com\";return new i(function(t,i){var c=r(\"POST\",u).set(n._uploadHeaders).attach(\"file\",e,n.attributes.name).field(\"name\",n.attributes.name).field(\"key\",n._qiniu_key).field(\"token\",a);o.onprogress&&c.on(\"progress\",o.onprogress),c.end(function(e,r){if(r&&s(r.status,r.body,r.text),e)return r&&(e.statusCode=r.status,e.responseText=r.text,e.response=r.body),i(e);t(n)})})}},function(t,e,n){\"use strict\";var r=n(8),i=n(1),s=function(t,e){return e&&(t.statusCode=e.status,t.responseText=e.text,t.response=e.body),t};t.exports=function(t,e,n){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.attributes.url=t.url,n._bucket=t.bucket,n.id=t.objectId,new i(function(i,a){var u=r(\"PUT\",t.upload_url).set(Object.assign({\"Content-Type\":n.get(\"mime_type\"),\"Cache-Control\":\"public, max-age=31536000\"},n._uploadHeaders));o.onprogress&&u.on(\"progress\",o.onprogress),u.on(\"response\",function(t){if(t.ok)return i(n);a(s(t.error,t))}),u.on(\"error\",function(t,e){return a(s(t,e))}),u.send(e).end()})}},function(t,e,n){!function(){var e=n(42),r=n(13).utf8,i=n(43),s=n(13).bin,o=function(t,n){t.constructor==String?t=n&&\"binary\"===n.encoding?s.stringToBytes(t):r.stringToBytes(t):i(t)?t=Array.prototype.slice.call(t,0):Array.isArray(t)||(t=t.toString());for(var a=e.bytesToWords(t),u=8*t.length,c=1732584193,l=-271733879,h=-1732584194,f=271733878,d=0;d<a.length;d++)a[d]=16711935&(a[d]<<8|a[d]>>>24)|4278255360&(a[d]<<24|a[d]>>>8);a[u>>>5]|=128<<u%32,a[14+(u+64>>>9<<4)]=u;for(var p=o._ff,_=o._gg,v=o._hh,y=o._ii,d=0;d<a.length;d+=16){var m=c,g=l,b=h,w=f;c=p(c,l,h,f,a[d+0],7,-680876936),f=p(f,c,l,h,a[d+1],12,-389564586),h=p(h,f,c,l,a[d+2],17,606105819),l=p(l,h,f,c,a[d+3],22,-1044525330),c=p(c,l,h,f,a[d+4],7,-176418897),f=p(f,c,l,h,a[d+5],12,1200080426),h=p(h,f,c,l,a[d+6],17,-1473231341),l=p(l,h,f,c,a[d+7],22,-45705983),c=p(c,l,h,f,a[d+8],7,1770035416),f=p(f,c,l,h,a[d+9],12,-1958414417),h=p(h,f,c,l,a[d+10],17,-42063),l=p(l,h,f,c,a[d+11],22,-1990404162),c=p(c,l,h,f,a[d+12],7,1804603682),f=p(f,c,l,h,a[d+13],12,-40341101),h=p(h,f,c,l,a[d+14],17,-1502002290),l=p(l,h,f,c,a[d+15],22,1236535329),c=_(c,l,h,f,a[d+1],5,-165796510),f=_(f,c,l,h,a[d+6],9,-1069501632),h=_(h,f,c,l,a[d+11],14,643717713),l=_(l,h,f,c,a[d+0],20,-373897302),c=_(c,l,h,f,a[d+5],5,-701558691),f=_(f,c,l,h,a[d+10],9,38016083),h=_(h,f,c,l,a[d+15],14,-660478335),l=_(l,h,f,c,a[d+4],20,-405537848),c=_(c,l,h,f,a[d+9],5,568446438),f=_(f,c,l,h,a[d+14],9,-1019803690),h=_(h,f,c,l,a[d+3],14,-187363961),l=_(l,h,f,c,a[d+8],20,1163531501),c=_(c,l,h,f,a[d+13],5,-1444681467),f=_(f,c,l,h,a[d+2],9,-51403784),h=_(h,f,c,l,a[d+7],14,1735328473),l=_(l,h,f,c,a[d+12],20,-1926607734),c=v(c,l,h,f,a[d+5],4,-378558),f=v(f,c,l,h,a[d+8],11,-2022574463),h=v(h,f,c,l,a[d+11],16,1839030562),l=v(l,h,f,c,a[d+14],23,-35309556),c=v(c,l,h,f,a[d+1],4,-1530992060),f=v(f,c,l,h,a[d+4],11,1272893353),h=v(h,f,c,l,a[d+7],16,-155497632),l=v(l,h,f,c,a[d+10],23,-1094730640),c=v(c,l,h,f,a[d+13],4,681279174),f=v(f,c,l,h,a[d+0],11,-358537222),h=v(h,f,c,l,a[d+3],16,-722521979),l=v(l,h,f,c,a[d+6],23,76029189),c=v(c,l,h,f,a[d+9],4,-640364487),f=v(f,c,l,h,a[d+12],11,-421815835),h=v(h,f,c,l,a[d+15],16,530742520),l=v(l,h,f,c,a[d+2],23,-995338651),c=y(c,l,h,f,a[d+0],6,-198630844),f=y(f,c,l,h,a[d+7],10,1126891415),h=y(h,f,c,l,a[d+14],15,-1416354905),l=y(l,h,f,c,a[d+5],21,-57434055),c=y(c,l,h,f,a[d+12],6,1700485571),f=y(f,c,l,h,a[d+3],10,-1894986606),h=y(h,f,c,l,a[d+10],15,-1051523),l=y(l,h,f,c,a[d+1],21,-2054922799),c=y(c,l,h,f,a[d+8],6,1873313359),f=y(f,c,l,h,a[d+15],10,-30611744),h=y(h,f,c,l,a[d+6],15,-1560198380),l=y(l,h,f,c,a[d+13],21,1309151649),c=y(c,l,h,f,a[d+4],6,-145523070),f=y(f,c,l,h,a[d+11],10,-1120210379),h=y(h,f,c,l,a[d+2],15,718787259),l=y(l,h,f,c,a[d+9],21,-343485551),c=c+m>>>0,l=l+g>>>0,h=h+b>>>0,f=f+w>>>0}return e.endian([c,l,h,f])};o._ff=function(t,e,n,r,i,s,o){var a=t+(e&n|~e&r)+(i>>>0)+o;return(a<<s|a>>>32-s)+e},o._gg=function(t,e,n,r,i,s,o){var a=t+(e&r|n&~r)+(i>>>0)+o;return(a<<s|a>>>32-s)+e},o._hh=function(t,e,n,r,i,s,o){var a=t+(e^n^r)+(i>>>0)+o;return(a<<s|a>>>32-s)+e},o._ii=function(t,e,n,r,i,s,o){var a=t+(n^(e|~r))+(i>>>0)+o;return(a<<s|a>>>32-s)+e},o._blocksize=16,o._digestsize=16,t.exports=function(t,n){if(void 0===t||null===t)throw new Error(\"Illegal argument \"+t);var r=e.wordsToBytes(o(t,n));return n&&n.asBytes?r:n&&n.asString?s.bytesToString(r):e.bytesToHex(r)}}()},function(t,e){!function(){var e=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",n={rotl:function(t,e){return t<<e|t>>>32-e},rotr:function(t,e){return t<<32-e|t>>>e},endian:function(t){if(t.constructor==Number)return 16711935&n.rotl(t,8)|4278255360&n.rotl(t,24);for(var e=0;e<t.length;e++)t[e]=n.endian(t[e]);return t},randomBytes:function(t){for(var e=[];t>0;t--)e.push(Math.floor(256*Math.random()));return e},bytesToWords:function(t){for(var e=[],n=0,r=0;n<t.length;n++,r+=8)e[r>>>5]|=t[n]<<24-r%32;return e},wordsToBytes:function(t){for(var e=[],n=0;n<32*t.length;n+=8)e.push(t[n>>>5]>>>24-n%32&255);return e},bytesToHex:function(t){for(var e=[],n=0;n<t.length;n++)e.push((t[n]>>>4).toString(16)),e.push((15&t[n]).toString(16));return e.join(\"\")},hexToBytes:function(t){for(var e=[],n=0;n<t.length;n+=2)e.push(parseInt(t.substr(n,2),16));return e},bytesToBase64:function(t){for(var n=[],r=0;r<t.length;r+=3)for(var i=t[r]<<16|t[r+1]<<8|t[r+2],s=0;s<4;s++)8*r+6*s<=8*t.length?n.push(e.charAt(i>>>6*(3-s)&63)):n.push(\"=\");return n.join(\"\")},base64ToBytes:function(t){t=t.replace(/[^A-Z0-9+\\/]/gi,\"\");for(var n=[],r=0,i=0;r<t.length;i=++r%4)0!=i&&n.push((e.indexOf(t.charAt(r-1))&Math.pow(2,-2*i+8)-1)<<2*i|e.indexOf(t.charAt(r))>>>6-2*i);return n}};t.exports=n}()},function(t,e){function n(t){return!!t.constructor&&\"function\"==typeof t.constructor.isBuffer&&t.constructor.isBuffer(t)}function r(t){return\"function\"==typeof t.readFloatLE&&\"function\"==typeof t.slice&&n(t.slice(0,0))}/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\nt.exports=function(t){return null!=t&&(n(t)||r(t)||!!t._isBuffer)}},function(t,e,n){\"use strict\";var r=function(t,e){var n;t.indexOf(\"base64\")<0?n=atob(t):t.split(\",\")[0].indexOf(\"base64\")>=0?(e=e||t.split(\",\")[0].split(\":\")[1].split(\";\")[0],n=atob(t.split(\",\")[1])):n=unescape(t.split(\",\")[1]);for(var r=new Uint8Array(n.length),i=0;i<n.length;i++)r[i]=n.charCodeAt(i);return new Blob([r],{type:e})};t.exports=r},function(t,e,n){\"use strict\";function r(t,e){return t&&t[e]?s.isFunction(t[e])?t[e]():t[e]:null}var i=function(){function t(t,e){var n=[],r=!0,i=!1,s=void 0;try{for(var o,a=t[Symbol.iterator]();!(r=(o=a.next()).done)&&(n.push(o.value),!e||n.length!==e);r=!0);}catch(t){i=!0,s=t}finally{try{!r&&a.return&&a.return()}finally{if(i)throw s}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}}(),s=n(0),o=n(4),a=n(2),u=a._request,c=n(3),l=c.isNullOrUndefined,h=c.ensureArray,f=c.transformFetchOptions,d=c.setValue,p=c.findValue,_=c.isPlainObject,v=function t(e){return s.isArray(e)?e.map(t):_(e)?s.mapObject(e,t):s.isObject(e)&&e._toPointer?e._toPointer():e},y=[\"objectId\",\"createdAt\",\"updatedAt\"],m=function(t){if(-1!==y.indexOf(t))throw new Error(\"key[\"+t+\"] is reserved\")},g=function(t){var e=s.find(t,function(t){return t instanceof Error});if(!e)return t;var n=new o(e.code,e.message);throw n.results=t,n};t.exports=function(t){t.Object=function(e,n){if(s.isString(e))return t.Object._create.apply(this,arguments);e=e||{},n&&n.parse&&(e=this.parse(e),e=this._mergeMagicFields(e));var i=r(this,\"defaults\");i&&(e=s.extend({},i,e)),n&&n.collection&&(this.collection=n.collection),this._serverData={},this._opSetQueue=[{}],this._flags={},this.attributes={},this._hashedJSON={},this._escapedAttributes={},this.cid=s.uniqueId(\"c\"),this.changed={},this._silent={},this._pending={},this.set(e,{silent:!0}),this.changed={},this._silent={},this._pending={},this._hasData=!0,this._previousAttributes=s.clone(this.attributes),this.initialize.apply(this,arguments)},t.Object.saveAll=function(e,n){return t.Object._deepSaveAsync(e,null,n)},t.Object.fetchAll=function(e,n){return t.Promise.resolve().then(function(){return u(\"batch\",null,null,\"POST\",{requests:s.map(e,function(t){if(!t.className)throw new Error(\"object must have className to fetch\");if(!t.id)throw new Error(\"object must have id to fetch\");if(t.dirty())throw new Error(\"object is modified but not saved\");return{method:\"GET\",path:\"/1.1/classes/\"+t.className+\"/\"+t.id}})},n)}).then(function(t){var n=s.map(e,function(e,n){if(t[n].success){var r=e.parse(t[n].success);return e._cleanupUnsetKeys(r),e._finishFetch(r),e}return null===t[n].success?new o(o.OBJECT_NOT_FOUND,\"Object not found.\"):new o(t[n].error.code,t[n].error.error)});return g(n)})},s.extend(t.Object.prototype,t.Events,{_fetchWhenSave:!1,initialize:function(){},fetchWhenSave:function(t){if(console.warn(\"AV.Object#fetchWhenSave is deprecated, use AV.Object#save with options.fetchWhenSave instead.\"),!s.isBoolean(t))throw new Error(\"Expect boolean value for fetchWhenSave\");this._fetchWhenSave=t},getObjectId:function(){return this.id},getCreatedAt:function(){return this.createdAt||this.get(\"createdAt\")},getUpdatedAt:function(){return this.updatedAt||this.get(\"updatedAt\")},toJSON:function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return this._toFullJSON(n,!1)},toFullJSON:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return this._toFullJSON(t)},_toFullJSON:function(e){var n=this,r=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=s.clone(this.attributes);if(s.isArray(e))var o=e.concat(this);return t._objectEach(i,function(e,n){i[n]=t._encode(e,o,void 0,r)}),t._objectEach(this._operations,function(t,e){i[e]=t}),s.has(this,\"id\")&&(i.objectId=this.id),s([\"createdAt\",\"updatedAt\"]).each(function(t){if(s.has(n,t)){var e=n[t];i[t]=s.isDate(e)?e.toJSON():e}}),r&&(i.__type=\"Object\",s.isArray(e)&&e.length&&(i.__type=\"Pointer\"),i.className=this.className),i},_refreshCache:function(){var e=this;e._refreshingCache||(e._refreshingCache=!0,t._objectEach(this.attributes,function(n,r){n instanceof t.Object?n._refreshCache():s.isObject(n)&&e._resetCacheForKey(r)&&e.set(r,new t.Op.Set(n),{silent:!0})}),delete e._refreshingCache)},dirty:function(t){this._refreshCache();var e=s.last(this._opSetQueue);return t?!!e[t]:!this.id||s.keys(e).length>0},_toPointer:function(){return{__type:\"Pointer\",className:this.className,objectId:this.id}},get:function(t){switch(t){case\"objectId\":return this.id;case\"createdAt\":case\"updatedAt\":return this[t];default:return this.attributes[t]}},relation:function(e){var n=this.get(e);if(n){if(!(n instanceof t.Relation))throw new Error(\"Called relation() on non-relation field \"+e);return n._ensureParentAndKey(this,e),n}return new t.Relation(this,e)},escape:function(t){var e=this._escapedAttributes[t];if(e)return e;var n,r=this.attributes[t];return n=l(r)?\"\":s.escape(r.toString()),this._escapedAttributes[t]=n,n},has:function(t){return!l(this.attributes[t])},_mergeMagicFields:function(e){var n=this,r=[\"objectId\",\"createdAt\",\"updatedAt\"];return t._arrayEach(r,function(r){e[r]&&(\"objectId\"===r?n.id=e[r]:\"createdAt\"!==r&&\"updatedAt\"!==r||s.isDate(e[r])?n[r]=e[r]:n[r]=t._parseDate(e[r]),delete e[r])}),e},_startSave:function(){this._opSetQueue.push({})},_cancelSave:function(){var e=s.first(this._opSetQueue);this._opSetQueue=s.rest(this._opSetQueue);var n=s.first(this._opSetQueue);t._objectEach(e,function(t,r){var i=e[r],s=n[r];i&&s?n[r]=s._mergeWithPrevious(i):i&&(n[r]=i)}),this._saving=this._saving-1},_finishSave:function(e){var n={};t._traverse(this.attributes,function(e){e instanceof t.Object&&e.id&&e._hasData&&(n[e.id]=e)});var r=s.first(this._opSetQueue);this._opSetQueue=s.rest(this._opSetQueue),this._applyOpSet(r,this._serverData),this._mergeMagicFields(e);var i=this;t._objectEach(e,function(e,r){i._serverData[r]=t._decode(e,r);var s=t._traverse(i._serverData[r],function(e){if(e instanceof t.Object&&n[e.id])return n[e.id]});s&&(i._serverData[r]=s)}),this._rebuildAllEstimatedData();var o=this._opSetQueue.map(s.clone);this._refreshCache(),this._opSetQueue=o,this._saving=this._saving-1},_finishFetch:function(e,n){this._opSetQueue=[{}],this._mergeMagicFields(e);var r=this;t._objectEach(e,function(e,n){r._serverData[n]=t._decode(e,n)}),this._rebuildAllEstimatedData(),this._refreshCache(),this._opSetQueue=[{}],this._hasData=n},_applyOpSet:function(e,n){var r=this;t._objectEach(e,function(e,s){var o=p(n,s),a=i(o,3),u=a[0],c=a[1],l=a[2];d(n,s,e._estimate(u,r,s)),c&&c[l]===t.Op._UNSET&&delete c[l]})},_resetCacheForKey:function(e){var n=this.attributes[e];if(s.isObject(n)&&!(n instanceof t.Object)&&!(n instanceof t.File)){var r=JSON.stringify(v(n));if(this._hashedJSON[e]!==r){var i=!!this._hashedJSON[e];return this._hashedJSON[e]=r,i}}return!1},_rebuildEstimatedDataForKey:function(e){var n=this;delete this.attributes[e],this._serverData[e]&&(this.attributes[e]=this._serverData[e]),t._arrayEach(this._opSetQueue,function(r){var s=r[e];if(s){var o=p(n.attributes,e),a=i(o,4),u=a[0],c=a[1],l=a[2],h=a[3];d(n.attributes,e,s._estimate(u,n,e)),c&&c[l]===t.Op._UNSET&&delete c[l],n._resetCacheForKey(h)}})},_rebuildAllEstimatedData:function(){var e=this,n=s.clone(this.attributes);this.attributes=s.clone(this._serverData),t._arrayEach(this._opSetQueue,function(n){e._applyOpSet(n,e.attributes),t._objectEach(n,function(t,n){e._resetCacheForKey(n)})}),t._objectEach(n,function(t,n){e.attributes[n]!==t&&e.trigger(\"change:\"+n,e,e.attributes[n],{})}),t._objectEach(this.attributes,function(t,r){s.has(n,r)||e.trigger(\"change:\"+r,e,t,{})})},set:function(e,n,r){var i;if(s.isObject(e)||l(e)?(i=s.mapObject(e,function(e,n){return m(n),t._decode(e,n)}),r=n):(i={},m(e),i[e]=t._decode(n,e)),r=r||{},!i)return this;i instanceof t.Object&&(i=i.attributes),r.unset&&t._objectEach(i,function(e,n){i[n]=new t.Op.Unset});var o=s.clone(i),a=this;t._objectEach(o,function(e,n){e instanceof t.Op&&(o[n]=e._estimate(a.attributes[n],a,n),o[n]===t.Op._UNSET&&delete o[n])}),this._validate(i,r),r.changes={};var u=this._escapedAttributes;this._previousAttributes;return t._arrayEach(s.keys(i),function(e){var n=i[e];n instanceof t.Relation&&(n.parent=a),n instanceof t.Op||(n=new t.Op.Set(n));var o=!0;n instanceof t.Op.Set&&s.isEqual(a.attributes[e],n.value)&&(o=!1),o&&(delete u[e],r.silent?a._silent[e]=!0:r.changes[e]=!0);var c=s.last(a._opSetQueue);c[e]=n._mergeWithPrevious(c[e]),a._rebuildEstimatedDataForKey(e),o?(a.changed[e]=a.attributes[e],r.silent||(a._pending[e]=!0)):(delete a.changed[e],delete a._pending[e])}),r.silent||this.change(r),this},unset:function(t,e){return e=e||{},e.unset=!0,this.set(t,null,e)},increment:function(e,n){return(s.isUndefined(n)||s.isNull(n))&&(n=1),this.set(e,new t.Op.Increment(n))},add:function(e,n){return this.set(e,new t.Op.Add(h(n)))},addUnique:function(e,n){return this.set(e,new t.Op.AddUnique(h(n)))},remove:function(e,n){return this.set(e,new t.Op.Remove(h(n)))},bitAnd:function(e,n){return this.set(e,new t.Op.BitAnd(n))},bitOr:function(e,n){return this.set(e,new t.Op.BitOr(n))},bitXor:function(e,n){return this.set(e,new t.Op.BitXor(n))},op:function(t){return s.last(this._opSetQueue)[t]},clear:function(t){t=t||{},t.unset=!0;var e=s.extend(this.attributes,this._operations);return this.set(e,t)},_getSaveJSON:function(){var e=s.clone(s.first(this._opSetQueue));return t._objectEach(e,function(t,n){e[n]=t.toJSON()}),e},_canBeSerialized:function(){return t.Object._canBeSerializedAsValue(this.attributes)},fetch:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments[1],n=this;return u(\"classes\",this.className,this.id,\"GET\",f(t),e).then(function(e){var r=n.parse(e);return t.keys||n._cleanupUnsetKeys(r),n._finishFetch(r,!0),n})},_cleanupUnsetKeys:function(e){var n=this;t._objectEach(this._serverData,function(t,r){void 0===e[r]&&delete n._serverData[r]})},save:function(e,n,r){var i,o,a;s.isObject(e)||l(e)?(i=e,a=n):(i={},i[e]=n,a=r),a=s.clone(a)||{},a.wait&&(o=s.clone(this.attributes));var c=s.clone(a)||{};c.wait&&(c.silent=!0),i&&this.set(i,c);var h=this,f=[],d=[];return t.Object._findUnsavedChildren(h,f,d),f.length+d.length>1?t.Object._deepSaveAsync(this,h,a):(this._startSave(),this._saving=(this._saving||0)+1,this._allPreviousSaves=this._allPreviousSaves||t.Promise.resolve(),this._allPreviousSaves=this._allPreviousSaves.catch(function(t){}).then(function(){var t=h.id?\"PUT\":\"POST\",e=h._getSaveJSON(),n={};if((h._fetchWhenSave||a.fetchWhenSave)&&(n.new=\"true\"),a._failOnNotExist&&(n.failOnNotExist=\"true\"),a.query){var r;if(\"function\"==typeof a.query.toJSON&&(r=a.query.toJSON())&&(n.where=r.where),!n.where){throw new Error(\"options.query is not an AV.Query\")}}s.extend(e,h._flags);var l=\"classes\",f=h.className;\"_User\"!==h.className||h.id||(l=\"users\",f=null);var d=a._makeRequest||u,p=d(l,f,h.id,t,e,a,n);return p=p.then(function(t){var e=h.parse(t);return a.wait&&(e=s.extend(i||{},e)),h._finishSave(e),a.wait&&h.set(o,c),h},function(t){throw h._cancelSave(),t})}),this._allPreviousSaves)},destroy:function(t){t=t||{};var e=this,n=function(){e.trigger(\"destroy\",e,e.collection,t)};return this.id?(t.wait||n(),u(\"classes\",this.className,this.id,\"DELETE\",this._flags,t).then(function(){return t.wait&&n(),e})):n()},parse:function(e){var n=s.clone(e);return s([\"createdAt\",\"updatedAt\"]).each(function(e){n[e]&&(n[e]=t._parseDate(n[e]))}),n.createdAt&&!n.updatedAt&&(n.updatedAt=n.createdAt),n},clone:function(){return new this.constructor(this.attributes)},isNew:function(){return!this.id},change:function(e){e=e||{};var n=this._changing;this._changing=!0;var r=this;t._objectEach(this._silent,function(t){r._pending[t]=!0});var i=s.extend({},e.changes,this._silent);if(this._silent={},t._objectEach(i,function(t,n){r.trigger(\"change:\"+n,r,r.get(n),e)}),n)return this;for(var o=function(t,e){r._pending[e]||r._silent[e]||delete r.changed[e]};!s.isEmpty(this._pending);)this._pending={},this.trigger(\"change\",this,e),t._objectEach(this.changed,o),r._previousAttributes=s.clone(this.attributes);return this._changing=!1,this},hasChanged:function(t){return arguments.length?this.changed&&s.has(this.changed,t):!s.isEmpty(this.changed)},changedAttributes:function(e){if(!e)return!!this.hasChanged()&&s.clone(this.changed);var n={},r=this._previousAttributes;return t._objectEach(e,function(t,e){s.isEqual(r[e],t)||(n[e]=t)}),n},previous:function(t){return arguments.length&&this._previousAttributes?this._previousAttributes[t]:null},previousAttributes:function(){return s.clone(this._previousAttributes)},isValid:function(){try{this.validate(this.attributes)}catch(t){return!1}return!0},validate:function(e){if(s.has(e,\"ACL\")&&!(e.ACL instanceof t.ACL))throw new o(o.OTHER_CAUSE,\"ACL must be a AV.ACL.\")},_validate:function(t,e){!e.silent&&this.validate&&(t=s.extend({},this.attributes,t),this.validate(t))},getACL:function(){return this.get(\"ACL\")},setACL:function(t,e){return this.set(\"ACL\",t,e)},disableBeforeHook:function(){this.ignoreHook(\"beforeSave\"),this.ignoreHook(\"beforeUpdate\"),this.ignoreHook(\"beforeDelete\")},disableAfterHook:function(){this.ignoreHook(\"afterSave\"),this.ignoreHook(\"afterUpdate\"),this.ignoreHook(\"afterDelete\")},ignoreHook:function(e){s.contains([\"beforeSave\",\"afterSave\",\"beforeUpdate\",\"afterUpdate\",\"beforeDelete\",\"afterDelete\"],e)||console.trace(\"Unsupported hookName: \"+e),t.hookKey||console.trace(\"ignoreHook required hookKey\"),this._flags.__ignore_hooks||(this._flags.__ignore_hooks=[]),this._flags.__ignore_hooks.push(e)}}),t.Object.createWithoutData=function(e,n,r){var i=new t.Object(e);return i.id=n,i._hasData=r,i},t.Object.destroyAll=function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!e||0===e.length)return t.Promise.resolve();var r=s.groupBy(e,function(t){return JSON.stringify({className:t.className,flags:t._flags})}),i={requests:s.map(r,function(t){var e=s.map(t,\"id\").join(\",\");return{method:\"DELETE\",path:\"/1.1/classes/\"+t[0].className+\"/\"+e,body:t[0]._flags}})};return u(\"batch\",null,null,\"POST\",i,n).then(function(t){var e=s.find(t,function(t){return!t.success});if(e)throw new o(e.error.code,e.error.error)})},t.Object._getSubclass=function(e){if(!s.isString(e))throw new Error(\"AV.Object._getSubclass requires a string argument.\");var n=t.Object._classMap[e];return n||(n=t.Object.extend(e),t.Object._classMap[e]=n),n},t.Object._create=function(e,n,r){return new(t.Object._getSubclass(e))(n,r)},t.Object._classMap={},t.Object._extend=t._extend,t.Object.new=function(e,n){return new t.Object(e,n)},t.Object.extend=function(e,n,r){if(!s.isString(e)){if(e&&s.has(e,\"className\"))return t.Object.extend(e.className,e,n);throw new Error(\"AV.Object.extend's first argument should be the className.\")}\"User\"===e&&(e=\"_User\");var i=null;if(s.has(t.Object._classMap,e)){var o=t.Object._classMap[e];if(!n&&!r)return o;i=o._extend(n,r)}else n=n||{},n._className=e,i=this._extend(n,r);return i.extend=function(n){if(s.isString(n)||n&&s.has(n,\"className\"))return t.Object.extend.apply(i,arguments);var r=[e].concat(s.toArray(arguments));return t.Object.extend.apply(i,r)},Object.defineProperty(i,\"query\",Object.getOwnPropertyDescriptor(t.Object,\"query\")),i.new=function(t,e){return new i(t,e)},t.Object._classMap[e]=i,i},Object.defineProperty(t.Object.prototype,\"className\",{get:function(){var t=this._className||this.constructor._LCClassName||this.constructor.name;return\"User\"===t?\"_User\":t}}),t.Object.register=function(e,n){if(!(e.prototype instanceof t.Object))throw new Error(\"registered class is not a subclass of AV.Object\");var r=n||e.name;if(!r.length)throw new Error(\"registered class must be named\");n&&(e._LCClassName=n),t.Object._classMap[r]=e},Object.defineProperty(t.Object,\"query\",{get:function(){return new t.Query(this.prototype.className)}}),t.Object._findUnsavedChildren=function(e,n,r){t._traverse(e,function(e){return e instanceof t.Object?void(e.dirty()&&n.push(e)):e instanceof t.File?void(e.id||r.push(e)):void 0})},t.Object._canBeSerializedAsValue=function(e){var n=!0;return e instanceof t.Object||e instanceof t.File?n=!!e.id:s.isArray(e)?t._arrayEach(e,function(e){t.Object._canBeSerializedAsValue(e)||(n=!1)}):s.isObject(e)&&t._objectEach(e,function(e){t.Object._canBeSerializedAsValue(e)||(n=!1)}),n},t.Object._deepSaveAsync=function(e,n,r){var i=[],a=[];t.Object._findUnsavedChildren(e,i,a);var c=t.Promise.resolve();s.each(a,function(t){c=c.then(function(){return t.save()})});var l=s.uniq(i),h=s.uniq(l);return c.then(function(){return t.Promise._continueWhile(function(){return h.length>0},function(){var e=[],n=[];if(t._arrayEach(h,function(t){if(e.length>20)return void n.push(t);t._canBeSerialized()?e.push(t):n.push(t)}),h=n,0===e.length)return t.Promise.reject(new o(o.OTHER_CAUSE,\"Tried to save a batch with a cycle.\"));var i=t.Promise.resolve(s.map(e,function(e){return e._allPreviousSaves||t.Promise.resolve()})),a=i.then(function(){return u(\"batch\",null,null,\"POST\",{requests:s.map(e,function(t){var e=t.id?\"PUT\":\"POST\",n=t._getSaveJSON();s.extend(n,t._flags);var r=t.className,i=\"/classes/\"+r;\"_User\"!==t.className||t.id||(i=\"/users\");var i=\"/1.1\"+i;return t.id&&(i=i+\"/\"+t.id),t._startSave(),{method:e,path:i,body:n}})},r).then(function(t){var n=s.map(e,function(e,n){return t[n].success?(e._finishSave(e.parse(t[n].success)),e):(e._cancelSave(),new o(t[n].error.code,t[n].error.error))});return g(n)})});return t._arrayEach(e,function(t){t._allPreviousSaves=a}),a})}).then(function(){return e})}}},function(t,e,n){\"use strict\";var r=n(0),i=n(4);t.exports=function(t){t.Role=t.Object.extend(\"_Role\",{constructor:function(e,n){if(r.isString(e)?(t.Object.prototype.constructor.call(this,null,null),this.setName(e)):t.Object.prototype.constructor.call(this,e,n),n){if(!(n instanceof t.ACL))throw new TypeError(\"acl must be an instance of AV.ACL\");this.setACL(n)}},getName:function(){return this.get(\"name\")},setName:function(t,e){return this.set(\"name\",t,e)},getUsers:function(){return this.relation(\"users\")},getRoles:function(){return this.relation(\"roles\")},validate:function(e,n){if(\"name\"in e&&e.name!==this.getName()){var s=e.name;if(this.id&&this.id!==e.objectId)return new i(i.OTHER_CAUSE,\"A role's name can only be set before it has been saved.\");if(!r.isString(s))return new i(i.OTHER_CAUSE,\"A role's name must be a String.\");if(!/^[0-9a-zA-Z\\-_ ]+$/.test(s))return new i(i.OTHER_CAUSE,\"A role's name can only contain alphanumeric characters, _, -, and spaces.\")}return!!t.Object.prototype.validate&&t.Object.prototype.validate.call(this,e,n)}})}},function(t,e,n){\"use strict\";function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var i=n(0),s=n(4),o=n(2),a=o._request,u=o.request,c=n(1),l=function(){if(\"undefined\"==typeof wx||\"function\"!=typeof wx.login)throw new Error(\"Weapp Login is only available in Weapp\");return new c(function(t,e){wx.login({success:function(n){var r=n.code,i=n.errMsg;r?t(r):e(new Error(i))},fail:function(){return e(new Error(\"wx.login 失败\"))}})})},h=function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=n.unionIdPlatform,o=void 0===r?\"weixin\":r,a=n.asMainAccount,u=void 0!==a&&a;if(\"string\"!=typeof e)throw new s(s.OTHER_CAUSE,\"unionId is not a string\");if(\"string\"!=typeof o)throw new s(s.OTHER_CAUSE,\"unionIdPlatform is not a string\");return i.extend({},t,{platform:o,unionid:e,main_account:Boolean(u)})};t.exports=function(t){t.User=t.Object.extend(\"_User\",{_isCurrentUser:!1,_mergeMagicFields:function(e){return e.sessionToken&&(this._sessionToken=e.sessionToken,delete e.sessionToken),t.User.__super__._mergeMagicFields.call(this,e)},_cleanupAuthData:function(){if(this.isCurrent()){var e=this.get(\"authData\");e&&t._objectEach(this.get(\"authData\"),function(t,n){e[n]||delete e[n]})}},_synchronizeAllAuthData:function(){if(this.get(\"authData\")){var e=this;t._objectEach(this.get(\"authData\"),function(t,n){e._synchronizeAuthData(n)})}},_synchronizeAuthData:function(e){if(this.isCurrent()){var n;i.isString(e)?(n=e,e=t.User._authProviders[n]):n=e.getAuthType();var r=this.get(\"authData\");if(r&&e){e.restoreAuthentication(r[n])||this.dissociateAuthData(e)}}},_handleSaveResult:function(e){return e&&!t._config.disableCurrentUser&&(this._isCurrentUser=!0),this._cleanupAuthData(),this._synchronizeAllAuthData(),delete this._serverData.password,this._rebuildEstimatedDataForKey(\"password\"),this._refreshCache(),!e&&!this.isCurrent()||t._config.disableCurrentUser?c.resolve():c.resolve(t.User._saveCurrentUser(this))},_linkWith:function(e,n){var s,o=this,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},u=a.failOnNotExist,c=void 0!==u&&u;return i.isString(e)?(s=e,e=t.User._authProviders[e]):s=e.getAuthType(),n?this.save({authData:r({},s,n)},{fetchWhenSave:!!this.get(\"authData\"),_failOnNotExist:c}).then(function(t){return t._handleSaveResult(!0).then(function(){return t})}):e.authenticate().then(function(t){return o._linkWith(e,t)})},associateWithAuthData:function(t,e){return this._linkWith(e,t)},associateWithAuthDataAndUnionId:function(t,e,n,r){return this._linkWith(e,h(t,n,r))},linkWithWeapp:function(){var t=this;return l().then(function(e){return t._linkWith(\"lc_weapp\",{code:e})})},dissociateAuthData:function(t){return this.unset(\"authData.\"+t),this.save().then(function(t){return t._handleSaveResult(!0).then(function(){return t})})},_unlinkFrom:function(t){return console.warn(\"DEPRECATED: User#_unlinkFrom 已废弃，请使用 User#dissociateAuthData 代替\"),this.dissociateAuthData(t)},_isLinked:function(t){var e;return e=i.isString(t)?t:t.getAuthType(),!!(this.get(\"authData\")||{})[e]},logOut:function(){this._logOutWithAll(),this._isCurrentUser=!1},_logOutWithAll:function(){if(this.get(\"authData\")){var e=this;t._objectEach(this.get(\"authData\"),function(t,n){e._logOutWith(n)})}},_logOutWith:function(e){this.isCurrent()&&(i.isString(e)&&(e=t.User._authProviders[e]),e&&e.deauthenticate&&e.deauthenticate())},signUp:function(t,e){var n=t&&t.username||this.get(\"username\");if(!n||\"\"===n)throw new s(s.OTHER_CAUSE,\"Cannot sign up user with an empty name.\");var r=t&&t.password||this.get(\"password\");if(!r||\"\"===r)throw new s(s.OTHER_CAUSE,\"Cannot sign up user with an empty password.\");return this.save(t,e).then(function(t){return t._handleSaveResult(!0).then(function(){return t})})},signUpOrlogInWithMobilePhone:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=t&&t.mobilePhoneNumber||this.get(\"mobilePhoneNumber\");if(!n||\"\"===n)throw new s(s.OTHER_CAUSE,\"Cannot sign up or login user by mobilePhoneNumber with an empty mobilePhoneNumber.\");var r=t&&t.smsCode||this.get(\"smsCode\");if(!r||\"\"===r)throw new s(s.OTHER_CAUSE,\"Cannot sign up or login user by mobilePhoneNumber  with an empty smsCode.\");return e._makeRequest=function(t,e,n,r,i){return a(\"usersByMobilePhone\",null,null,\"POST\",i)},this.save(t,e).then(function(t){return delete t.attributes.smsCode,delete t._serverData.smsCode,t._handleSaveResult(!0).then(function(){return t})})},loginWithAuthData:function(t,e,n){return this._linkWith(e,t,n)},loginWithAuthDataAndUnionId:function(t,e,n,r){return this.loginWithAuthData(h(t,n,r),e,r)},loginWithWeapp:function(t){var e=this;return l().then(function(n){return e.loginWithAuthData({code:n},\"lc_weapp\",t)})},logIn:function(){var t=this;return a(\"login\",null,null,\"POST\",this.toJSON()).then(function(e){var n=t.parse(e);return t._finishFetch(n),t._handleSaveResult(!0).then(function(){return n.smsCode||delete t.attributes.smsCode,t})})},save:function(e,n,r){var s,o;return i.isObject(e)||i.isNull(e)||i.isUndefined(e)?(s=e,o=n):(s={},s[e]=n,o=r),o=o||{},t.Object.prototype.save.call(this,s,o).then(function(t){return t._handleSaveResult(!1).then(function(){return t})})},follow:function(e,n){if(!this.id)throw new Error(\"Please signin.\");var r=void 0,s=void 0;e.user?(r=e.user,s=e.attributes):r=e;var o=i.isString(r)?r:r.id;if(!o)throw new Error(\"Invalid target user.\");var u=\"users/\"+this.id+\"/friendship/\"+o;return a(u,null,null,\"POST\",t._encode(s),n)},unfollow:function(t,e){if(!this.id)throw new Error(\"Please signin.\");var n=void 0;n=t.user?t.user:t;var r=i.isString(n)?n:n.id;if(!r)throw new Error(\"Invalid target user.\");var s=\"users/\"+this.id+\"/friendship/\"+r;return a(s,null,null,\"DELETE\",null,e)},followerQuery:function(){return t.User.followerQuery(this.id)},followeeQuery:function(){return t.User.followeeQuery(this.id)},fetch:function(e,n){return t.Object.prototype.fetch.call(this,e,n).then(function(t){return t._handleSaveResult(!1).then(function(){return t})})},updatePassword:function(t,e,n){var r=\"users/\"+this.id+\"/updatePassword\";return a(r,null,null,\"PUT\",{old_password:t,new_password:e},n)},isCurrent:function(){return this._isCurrentUser},getUsername:function(){return this.get(\"username\")},getMobilePhoneNumber:function(){return this.get(\"mobilePhoneNumber\")},setMobilePhoneNumber:function(t,e){return this.set(\"mobilePhoneNumber\",t,e)},setUsername:function(t,e){return this.set(\"username\",t,e)},setPassword:function(t,e){return this.set(\"password\",t,e)},getEmail:function(){return this.get(\"email\")},setEmail:function(t,e){return this.set(\"email\",t,e)},authenticated:function(){return console.warn(\"DEPRECATED: 如果要判断当前用户的登录状态是否有效，请使用 currentUser.isAuthenticated().then()，如果要判断该用户是否是当前登录用户，请使用 user.id === currentUser.id。\"),!!this._sessionToken&&!t._config.disableCurrentUser&&t.User.current()&&t.User.current().id===this.id},isAuthenticated:function(){var e=this;return c.resolve().then(function(){return!!e._sessionToken&&t.User._fetchUserBySessionToken(e._sessionToken).then(function(){return!0},function(t){if(211===t.code)return!1;throw t})})},getSessionToken:function(){return this._sessionToken},refreshSessionToken:function(t){var e=this;return a(\"users/\"+this.id+\"/refreshSessionToken\",null,null,\"PUT\",null,t).then(function(t){return e._finishFetch(t),e._handleSaveResult(!0).then(function(){return e})})},getRoles:function(e){return t.Relation.reverseQuery(\"_Role\",\"users\",this).find(e)}},{_currentUser:null,_currentUserMatchesDisk:!1,_CURRENT_USER_KEY:\"currentUser\",_authProviders:{},signUp:function(e,n,r,i){return r=r||{},r.username=e,r.password=n,t.Object._create(\"_User\").signUp(r,i)},logIn:function(e,n){var r=t.Object._create(\"_User\");return r._finishFetch({username:e,password:n}),r.logIn()},become:function(t){return this._fetchUserBySessionToken(t).then(function(t){return t._handleSaveResult(!0).then(function(){return t})})},_fetchUserBySessionToken:function(e){var n=t.Object._create(\"_User\");return u({method:\"GET\",path:\"/users/me\",authOptions:{sessionToken:e}}).then(function(t){var e=n.parse(t);return n._finishFetch(e),n})},logInWithMobilePhoneSmsCode:function(e,n){var r=t.Object._create(\"_User\");return r._finishFetch({mobilePhoneNumber:e,smsCode:n}),r.logIn()},signUpOrlogInWithMobilePhone:function(e,n,r,i){return r=r||{},r.mobilePhoneNumber=e,r.smsCode=n,t.Object._create(\"_User\").signUpOrlogInWithMobilePhone(r,i)},logInWithMobilePhone:function(e,n){var r=t.Object._create(\"_User\");return r._finishFetch({mobilePhoneNumber:e,password:n}),r.logIn()},loginWithAuthData:function(e,n,r){return t.User._logInWith(n,e,r)},signUpOrlogInWithAuthData:function(){return console.warn(\"DEPRECATED: User.signUpOrlogInWithAuthData 已废弃，请使用 User#loginWithAuthData 代替\"),this.loginWithAuthData.apply(this,arguments)},loginWithAuthDataAndUnionId:function(t,e,n,r){return this.loginWithAuthData(h(t,n,r),e,r)},signUpOrlogInWithAuthDataAndUnionId:function(){return console.warn(\"DEPRECATED: User.signUpOrlogInWithAuthDataAndUnionId 已废弃，请使用 User#loginWithAuthDataAndUnionId 代替\"),this.loginWithAuthDataAndUnionId.apply(this,arguments)},loginWithWeapp:function(t){var e=this;return l().then(function(n){return e.loginWithAuthData({code:n},\"lc_weapp\",t)})},associateWithAuthData:function(t,e,n){return console.warn(\"DEPRECATED: User.associateWithAuthData 已废弃，请使用 User#associateWithAuthData 代替\"),t._linkWith(e,n)},logOut:function(){return t._config.disableCurrentUser?(console.warn(\"AV.User.current() was disabled in multi-user environment, call logOut() from user object instead https://leancloud.cn/docs/leanengine-node-sdk-upgrade-1.html\"),c.resolve(null)):(null!==t.User._currentUser&&(t.User._currentUser._logOutWithAll(),t.User._currentUser._isCurrentUser=!1),t.User._currentUserMatchesDisk=!0,t.User._currentUser=null,t.localStorage.removeItemAsync(t._getAVPath(t.User._CURRENT_USER_KEY)).then(function(){return t._refreshSubscriptionId()}))},followerQuery:function(e){if(!e||!i.isString(e))throw new Error(\"Invalid user object id.\");var n=new t.FriendShipQuery(\"_Follower\");return n._friendshipTag=\"follower\",n.equalTo(\"user\",t.Object.createWithoutData(\"_User\",e)),n},followeeQuery:function(e){if(!e||!i.isString(e))throw new Error(\"Invalid user object id.\");var n=new t.FriendShipQuery(\"_Followee\");return n._friendshipTag=\"followee\",n.equalTo(\"user\",t.Object.createWithoutData(\"_User\",e)),n},requestPasswordReset:function(t){return a(\"requestPasswordReset\",null,null,\"POST\",{email:t})},requestEmailVerify:function(t){return a(\"requestEmailVerify\",null,null,\"POST\",{email:t})},requestMobilePhoneVerify:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n={mobilePhoneNumber:t};return e.validateToken&&(n.validate_token=e.validateToken),a(\"requestMobilePhoneVerify\",null,null,\"POST\",n,e)},requestPasswordResetBySmsCode:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n={mobilePhoneNumber:t};return e.validateToken&&(n.validate_token=e.validateToken),a(\"requestPasswordResetBySmsCode\",null,null,\"POST\",n,e)},resetPasswordBySmsCode:function(t,e){return a(\"resetPasswordBySmsCode\",null,t,\"PUT\",{password:e})},verifyMobilePhone:function(t){return a(\"verifyMobilePhone\",null,t,\"POST\",null)},requestLoginSmsCode:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n={mobilePhoneNumber:t};return e.validateToken&&(n.validate_token=e.validateToken),a(\"requestLoginSmsCode\",null,null,\"POST\",n,e)},currentAsync:function(){return t._config.disableCurrentUser?(console.warn(\"AV.User.currentAsync() was disabled in multi-user environment, access user from request instead https://leancloud.cn/docs/leanengine-node-sdk-upgrade-1.html\"),c.resolve(null)):t.User._currentUser?c.resolve(t.User._currentUser):t.User._currentUserMatchesDisk?c.resolve(t.User._currentUser):t.localStorage.getItemAsync(t._getAVPath(t.User._CURRENT_USER_KEY)).then(function(e){if(!e)return null;t.User._currentUserMatchesDisk=!0,t.User._currentUser=t.Object._create(\"_User\"),t.User._currentUser._isCurrentUser=!0;var n=JSON.parse(e);return t.User._currentUser.id=n._id,delete n._id,t.User._currentUser._sessionToken=n._sessionToken,delete n._sessionToken,t.User._currentUser._finishFetch(n),t.User._currentUser._synchronizeAllAuthData(),t.User._currentUser._refreshCache(),t.User._currentUser._opSetQueue=[{}],t.User._currentUser})},current:function(){if(t._config.disableCurrentUser)return console.warn(\"AV.User.current() was disabled in multi-user environment, access user from request instead https://leancloud.cn/docs/leanengine-node-sdk-upgrade-1.html\"),null;if(t.User._currentUser)return t.User._currentUser;if(t.User._currentUserMatchesDisk)return t.User._currentUser;t.User._currentUserMatchesDisk=!0;var e=t.localStorage.getItem(t._getAVPath(t.User._CURRENT_USER_KEY));if(!e)return null;t.User._currentUser=t.Object._create(\"_User\"),t.User._currentUser._isCurrentUser=!0;var n=JSON.parse(e);return t.User._currentUser.id=n._id,delete n._id,t.User._currentUser._sessionToken=n._sessionToken,delete n._sessionToken,t.User._currentUser._finishFetch(n),t.User._currentUser._synchronizeAllAuthData(),t.User._currentUser._refreshCache(),t.User._currentUser._opSetQueue=[{}],t.User._currentUser},_saveCurrentUser:function(e){var n;return n=t.User._currentUser!==e?t.User.logOut():c.resolve(),n.then(function(){e._isCurrentUser=!0,t.User._currentUser=e;var n=e._toFullJSON();return n._id=e.id,n._sessionToken=e._sessionToken,t.localStorage.setItemAsync(t._getAVPath(t.User._CURRENT_USER_KEY),JSON.stringify(n)).then(function(){return t.User._currentUserMatchesDisk=!0,t._refreshSubscriptionId()})})},_registerAuthenticationProvider:function(e){t.User._authProviders[e.getAuthType()]=e,!t._config.disableCurrentUser&&t.User.current()&&t.User.current()._synchronizeAuthData(e.getAuthType())},_logInWith:function(e,n,r){return t.Object._create(\"_User\")._linkWith(e,n,r)}})}},function(t,e,n){\"use strict\";var r=n(0),i=n(6)(\"leancloud:query\"),s=n(1),o=n(4),a=n(2),u=a._request,c=a.request,l=n(3),h=l.ensureArray,f=l.transformFetchOptions,d=function(t,e){if(void 0===t)throw new Error(e)};t.exports=function(t){t.Query=function(e){r.isString(e)&&(e=t.Object._getSubclass(e)),this.objectClass=e,this.className=e.prototype.className,this._where={},this._include=[],this._select=[],this._limit=-1,this._skip=0,this._extraOptions={}},t.Query.or=function(){var e=r.toArray(arguments),n=null;t._arrayEach(e,function(t){if(r.isNull(n)&&(n=t.className),n!==t.className)throw new Error(\"All queries must be for the same class\")});var i=new t.Query(n);return i._orQuery(e),i},t.Query.and=function(){var e=r.toArray(arguments),n=null;t._arrayEach(e,function(t){if(r.isNull(n)&&(n=t.className),n!==t.className)throw new Error(\"All queries must be for the same class\")});var i=new t.Query(n);return i._andQuery(e),i},t.Query.doCloudQuery=function(e,n,i){var s={cql:e};return r.isArray(n)?s.pvalues=n:i=n,u(\"cloudQuery\",null,null,\"GET\",s,i).then(function(e){var n=new t.Query(e.className);return{results:r.map(e.results,function(t){var r=n._newObject(e);return r._finishFetch&&r._finishFetch(n._processResult(t),!0),r}),count:e.count,className:e.className}})},t.Query._extend=t._extend,r.extend(t.Query.prototype,{_processResult:function(t){return t},get:function(t,e){if(!t){throw new o(o.OBJECT_NOT_FOUND,\"Object not found.\")}var n=this._newObject();n.id=t;var i=this.toJSON(),s={};return i.keys&&(s.keys=i.keys),i.include&&(s.include=i.include),i.includeACL&&(s.includeACL=i.includeACL),u(\"classes\",this.className,t,\"GET\",f(s),e).then(function(t){if(r.isEmpty(t))throw new o(o.OBJECT_NOT_FOUND,\"Object not found.\");return n._finishFetch(n.parse(t),!0),n})},toJSON:function(){var e={where:this._where};return this._include.length>0&&(e.include=this._include.join(\",\")),this._select.length>0&&(e.keys=this._select.join(\",\")),void 0!==this._includeACL&&(e.returnACL=this._includeACL),this._limit>=0&&(e.limit=this._limit),this._skip>0&&(e.skip=this._skip),void 0!==this._order&&(e.order=this._order),t._objectEach(this._extraOptions,function(t,n){e[n]=t}),e},_newObject:function(e){return e&&e.className?new t.Object(e.className):new this.objectClass},_createRequest:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.toJSON(),e=arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:\"/classes/\"+this.className;if(encodeURIComponent(JSON.stringify(t)).length>2e3){return c({path:\"/batch\",method:\"POST\",data:{requests:[{method:\"GET\",path:\"/1.1\"+n,params:t}]},authOptions:e}).then(function(t){var e=t[0];if(e.success)return e.success;var n=new Error(e.error.error||\"Unknown batch error\");throw n.code=e.error.code,n})}return c({method:\"GET\",path:n,query:t,authOptions:e})},_parseResponse:function(t){var e=this;return r.map(t.results,function(n){var r=e._newObject(t);return r._finishFetch&&r._finishFetch(e._processResult(n),!0),r})},find:function(t){return this._createRequest(void 0,t).then(this._parseResponse.bind(this))},scan:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=e.orderedBy,o=e.batchSize,a=arguments[1],c=this.toJSON();i(\"scan %O\",c),c.order&&(console.warn(\"The order of the query is ignored for Query#scan. Checkout the orderedBy option of Query#scan.\"),delete c.order),c.skip&&(console.warn(\"The skip option of the query is ignored for Query#scan.\"),delete c.skip),c.limit&&(console.warn(\"The limit option of the query is ignored for Query#scan.\"),delete c.limit),n&&(c.scan_key=n),o&&(c.limit=o);var l=s.resolve([]),h=void 0,f=!1;return{next:function(){return l=l.then(function(e){return f?[]:e.length>1?e:h||0===e.length?u(\"scan/classes\",t.className,null,\"GET\",h?r.extend({},c,{cursor:h}):c,a).then(function(e){return h=e.cursor,t._parseResponse(e)}).then(function(t){return t.length||(f=!0),e.concat(t)}):(f=!0,e)}),l.then(function(t){return t.shift()}).then(function(t){return{value:t,done:f}})}}},destroyAll:function(e){return this.find(e).then(function(n){return t.Object.destroyAll(n,e)})},count:function(t){var e=this.toJSON();return e.limit=0,e.count=1,this._createRequest(e,t).then(function(t){return t.count})},first:function(t){var e=this,n=this.toJSON();return n.limit=1,this._createRequest(n,t).then(function(t){return r.map(t.results,function(t){var n=e._newObject();return n._finishFetch&&n._finishFetch(e._processResult(t),!0),n})[0]})},skip:function(t){return d(t,\"undefined is not a valid skip value\"),this._skip=t,this},limit:function(t){return d(t,\"undefined is not a valid limit value\"),this._limit=t,this},equalTo:function(e,n){return d(e,\"undefined is not a valid key\"),d(n,\"undefined is not a valid value\"),this._where[e]=t._encode(n),this},_addCondition:function(e,n,r){return d(e,\"undefined is not a valid condition key\"),d(n,\"undefined is not a valid condition\"),d(r,\"undefined is not a valid condition value\"),this._where[e]||(this._where[e]={}),this._where[e][n]=t._encode(r),this},sizeEqualTo:function(t,e){return this._addCondition(t,\"$size\",e),this},notEqualTo:function(t,e){return this._addCondition(t,\"$ne\",e),this},lessThan:function(t,e){return this._addCondition(t,\"$lt\",e),this},greaterThan:function(t,e){return this._addCondition(t,\"$gt\",e),this},lessThanOrEqualTo:function(t,e){return this._addCondition(t,\"$lte\",e),this},greaterThanOrEqualTo:function(t,e){return this._addCondition(t,\"$gte\",e),this},containedIn:function(t,e){return this._addCondition(t,\"$in\",e),this},notContainedIn:function(t,e){return this._addCondition(t,\"$nin\",e),this},containsAll:function(t,e){return this._addCondition(t,\"$all\",e),this},exists:function(t){return this._addCondition(t,\"$exists\",!0),this},doesNotExist:function(t){return this._addCondition(t,\"$exists\",!1),this},matches:function(t,e,n){return this._addCondition(t,\"$regex\",e),n||(n=\"\"),e.ignoreCase&&(n+=\"i\"),e.multiline&&(n+=\"m\"),n&&n.length&&this._addCondition(t,\"$options\",n),this},matchesQuery:function(t,e){var n=e.toJSON();return n.className=e.className,this._addCondition(t,\"$inQuery\",n),this},doesNotMatchQuery:function(t,e){var n=e.toJSON();return n.className=e.className,this._addCondition(t,\"$notInQuery\",n),this},matchesKeyInQuery:function(t,e,n){var r=n.toJSON();return r.className=n.className,this._addCondition(t,\"$select\",{key:e,query:r}),this},doesNotMatchKeyInQuery:function(t,e,n){var r=n.toJSON();return r.className=n.className,this._addCondition(t,\"$dontSelect\",{key:e,query:r}),this},_orQuery:function(t){var e=r.map(t,function(t){return t.toJSON().where});return this._where.$or=e,this},_andQuery:function(t){var e=r.map(t,function(t){return t.toJSON().where});return this._where.$and=e,this},_quote:function(t){return\"\\\\Q\"+t.replace(\"\\\\E\",\"\\\\E\\\\\\\\E\\\\Q\")+\"\\\\E\"},contains:function(t,e){return this._addCondition(t,\"$regex\",this._quote(e)),this},startsWith:function(t,e){return this._addCondition(t,\"$regex\",\"^\"+this._quote(e)),this},endsWith:function(t,e){return this._addCondition(t,\"$regex\",this._quote(e)+\"$\"),this},ascending:function(t){return d(t,\"undefined is not a valid key\"),this._order=t,this},addAscending:function(t){return d(t,\"undefined is not a valid key\"),this._order?this._order+=\",\"+t:this._order=t,this},descending:function(t){return d(t,\"undefined is not a valid key\"),this._order=\"-\"+t,this},addDescending:function(t){return d(t,\"undefined is not a valid key\"),this._order?this._order+=\",-\"+t:this._order=\"-\"+t,this},near:function(e,n){return n instanceof t.GeoPoint||(n=new t.GeoPoint(n)),this._addCondition(e,\"$nearSphere\",n),this},withinRadians:function(t,e,n){return this.near(t,e),this._addCondition(t,\"$maxDistance\",n),this},withinMiles:function(t,e,n){return this.withinRadians(t,e,n/3958.8)},withinKilometers:function(t,e,n){return this.withinRadians(t,e,n/6371)},withinGeoBox:function(e,n,r){return n instanceof t.GeoPoint||(n=new t.GeoPoint(n)),r instanceof t.GeoPoint||(r=new t.GeoPoint(r)),this._addCondition(e,\"$within\",{$box:[n,r]}),this},include:function(t){var e=this;return d(t,\"undefined is not a valid key\"),r(arguments).forEach(function(t){e._include=e._include.concat(h(t))}),this},includeACL:function(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return this._includeACL=t,this},select:function(t){var e=this;return d(t,\"undefined is not a valid key\"),r(arguments).forEach(function(t){e._select=e._select.concat(h(t))}),this},each:function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(this._order||this._skip||this._limit>=0){var i=new Error(\"Cannot iterate on a query with sort, skip, or limit.\");return t.Promise.reject(i)}var s=new t.Query(this.objectClass);s._limit=n.batchSize||100,s._where=r.clone(this._where),s._include=r.clone(this._include),s.ascending(\"objectId\");var o=!1;return t.Promise._continueWhile(function(){return!o},function(){return s.find(n).then(function(n){var i=t.Promise.resolve();return r.each(n,function(t){i=i.then(function(){return e(t)})}),i.then(function(){n.length>=s._limit?s.greaterThan(\"objectId\",n[n.length-1].id):o=!0})})})},subscribe:function(e){return t.LiveQuery.init(this,e)}}),t.FriendShipQuery=t.Query._extend({_objectClass:t.User,_newObject:function(){return new t.User},_processResult:function(t){if(t&&t[this._friendshipTag]){var e=t[this._friendshipTag];return\"Pointer\"===e.__type&&\"_User\"===e.className&&(delete e.__type,delete e.className),e}return null}})}},function(t,e,n){\"use strict\";var r=n(0),i=n(50),s=n(1),o=n(3),a=o.inherits,u=n(2),c=u.request,l=function(t,e){return c({method:\"POST\",path:\"/LiveQuery/subscribe\",data:{query:t,id:e}})};t.exports=function(t){t.LiveQuery=a(i,{constructor:function(t,e,n,r){var s=this;i.apply(this),this.id=t,this._client=e,this._client.register(this),this._queryJSON=n,this._subscriptionId=r,this._onMessage=this._dispatch.bind(this),this._onReconnect=function(){l(s._queryJSON,s._subscriptionId).catch(function(t){return console.error(\"LiveQuery resubscribe error: \"+t.message)})},e.on(\"message\",this._onMessage),e.on(\"reconnect\",this._onReconnect)},_dispatch:function(e){var n=this;e.forEach(function(e){var i=e.op,s=e.object,o=e.query_id,a=e.updatedKeys;if(o===n.id){var u=t.parseJSON(r.extend({__type:\"_File\"===s.className?\"File\":\"Object\"},s));a?n.emit(i,u,a):n.emit(i,u)}})},unsubscribe:function(){var t=this._client;return t.off(\"message\",this._onMessage),t.off(\"reconnect\",this._onReconnect),t.deregister(this),c({method:\"POST\",path:\"/LiveQuery/unsubscribe\",data:{id:t.id,query_id:this.id}})}},{init:function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=n.subscriptionId,i=void 0===r?t._getSubscriptionId():r;if(!t._config.realtime)throw new Error(\"LiveQuery not supported. Please use the LiveQuery bundle. https://url.leanapp.cn/enable-live-query\");if(!(e instanceof t.Query))throw new TypeError(\"LiveQuery must be inited with a Query\");return s.resolve(i).then(function(n){return t._config.realtime.createLiveQueryClient(n).then(function(r){var i=e.toJSON(),s=i.where,o=i.keys,a=i.returnACL,u={where:s,keys:o,returnACL:a,className:e.className},c=l(u,n).then(function(e){var i=e.query_id;return new t.LiveQuery(i,r,u,n)}).finally(function(){r.deregister(c)});return r.register(c),c})})}})}},function(t,e,n){\"use strict\";function r(){}function i(t,e,n){this.fn=t,this.context=e,this.once=n||!1}function s(){this._events=new r,this._eventsCount=0}var o=Object.prototype.hasOwnProperty,a=\"~\";Object.create&&(r.prototype=Object.create(null),(new r).__proto__||(a=!1)),s.prototype.eventNames=function(){var t,e,n=[];if(0===this._eventsCount)return n;for(e in t=this._events)o.call(t,e)&&n.push(a?e.slice(1):e);return Object.getOwnPropertySymbols?n.concat(Object.getOwnPropertySymbols(t)):n},s.prototype.listeners=function(t,e){var n=a?a+t:t,r=this._events[n];if(e)return!!r;if(!r)return[];if(r.fn)return[r.fn];for(var i=0,s=r.length,o=new Array(s);i<s;i++)o[i]=r[i].fn;return o},s.prototype.emit=function(t,e,n,r,i,s){var o=a?a+t:t;if(!this._events[o])return!1;var u,c,l=this._events[o],h=arguments.length;if(l.fn){switch(l.once&&this.removeListener(t,l.fn,void 0,!0),h){case 1:return l.fn.call(l.context),!0;case 2:return l.fn.call(l.context,e),!0;case 3:return l.fn.call(l.context,e,n),!0;case 4:return l.fn.call(l.context,e,n,r),!0;case 5:return l.fn.call(l.context,e,n,r,i),!0;case 6:return l.fn.call(l.context,e,n,r,i,s),!0}for(c=1,u=new Array(h-1);c<h;c++)u[c-1]=arguments[c];l.fn.apply(l.context,u)}else{var f,d=l.length;for(c=0;c<d;c++)switch(l[c].once&&this.removeListener(t,l[c].fn,void 0,!0),h){case 1:l[c].fn.call(l[c].context);break;case 2:l[c].fn.call(l[c].context,e);break;case 3:l[c].fn.call(l[c].context,e,n);break;case 4:l[c].fn.call(l[c].context,e,n,r);break;default:if(!u)for(f=1,u=new Array(h-1);f<h;f++)u[f-1]=arguments[f];l[c].fn.apply(l[c].context,u)}}return!0},s.prototype.on=function(t,e,n){var r=new i(e,n||this),s=a?a+t:t;return this._events[s]?this._events[s].fn?this._events[s]=[this._events[s],r]:this._events[s].push(r):(this._events[s]=r,this._eventsCount++),this},s.prototype.once=function(t,e,n){var r=new i(e,n||this,!0),s=a?a+t:t;return this._events[s]?this._events[s].fn?this._events[s]=[this._events[s],r]:this._events[s].push(r):(this._events[s]=r,this._eventsCount++),this},s.prototype.removeListener=function(t,e,n,i){var s=a?a+t:t;if(!this._events[s])return this;if(!e)return 0==--this._eventsCount?this._events=new r:delete this._events[s],this;var o=this._events[s];if(o.fn)o.fn!==e||i&&!o.once||n&&o.context!==n||(0==--this._eventsCount?this._events=new r:delete this._events[s]);else{for(var u=0,c=[],l=o.length;u<l;u++)(o[u].fn!==e||i&&!o[u].once||n&&o[u].context!==n)&&c.push(o[u]);c.length?this._events[s]=1===c.length?c[0]:c:0==--this._eventsCount?this._events=new r:delete this._events[s]}return this},s.prototype.removeAllListeners=function(t){var e;return t?(e=a?a+t:t,this._events[e]&&(0==--this._eventsCount?this._events=new r:delete this._events[e])):(this._events=new r,this._eventsCount=0),this},s.prototype.off=s.prototype.removeListener,s.prototype.addListener=s.prototype.on,s.prototype.setMaxListeners=function(){return this},s.prefixed=a,s.EventEmitter=s,t.exports=s},function(t,e,n){\"use strict\";var r=n(0),i=n(3),s=i.tap;t.exports=function(t){t.Captcha=function(t,e){this._options=t,this._authOptions=e,this.url=void 0,this.captchaToken=void 0,this.validateToken=void 0},t.Captcha.prototype.refresh=function(){var e=this;return t.Cloud._requestCaptcha(this._options,this._authOptions).then(function(t){var n=t.captchaToken,i=t.url;return r.extend(e,{captchaToken:n,url:i}),i})},t.Captcha.prototype.verify=function(e){var n=this;return t.Cloud.verifyCaptcha(e,this.captchaToken).then(s(function(t){return n.validateToken=t}))},t.Captcha.prototype.bind=function(t,e){var n=this,r=t.textInput,i=t.image,s=t.verifyButton,o=e.success,a=e.error;if(\"string\"==typeof r&&!(r=document.getElementById(r)))throw new Error(\"textInput with id \"+r+\" not found\");if(\"string\"==typeof i&&!(i=document.getElementById(i)))throw new Error(\"image with id \"+i+\" not found\");if(\"string\"==typeof s&&!(s=document.getElementById(s)))throw new Error(\"verifyButton with id \"+s+\" not found\");this.__refresh=function(){return n.refresh().then(function(t){i.src=t,r&&(r.value=\"\",r.focus())}).catch(function(t){return console.warn(\"refresh captcha fail: \"+t.message)})},i&&(this.__image=i,i.src=this.url,i.addEventListener(\"click\",this.__refresh)),this.__verify=function(){var t=r.value;n.verify(t).catch(function(t){throw n.__refresh(),t}).then(o,a).catch(function(t){return console.warn(\"verify captcha fail: \"+t.message)})},r&&s&&(this.__verifyButton=s,s.addEventListener(\"click\",this.__verify))},t.Captcha.prototype.unbind=function(){this.__image&&this.__image.removeEventListener(\"click\",this.__refresh),this.__verifyButton&&this.__verifyButton.removeEventListener(\"click\",this.__verify)},t.Captcha.request=function(e,n){var r=new t.Captcha(e,n);return r.refresh().then(function(){return r})}}},function(t,e,n){\"use strict\";var r=n(0),i=n(2),s=i._request,o=i.request,a=n(1);t.exports=function(t){t.Cloud=t.Cloud||{},r.extend(t.Cloud,{run:function(e,n,r){return o({service:\"engine\",method:\"POST\",path:\"/functions/\"+e,data:t._encode(n,null,!0),authOptions:r}).then(function(e){return t._decode(e).result})},rpc:function(e,n,i){return r.isArray(n)?a.reject(new Error(\"Can't pass Array as the param of rpc function in JavaScript SDK.\")):o({service:\"engine\",method:\"POST\",path:\"/call/\"+e,data:t._encodeObjectOrArray(n),authOptions:i}).then(function(e){return t._decode(e).result})},getServerDate:function(){return s(\"date\",null,null,\"GET\").then(function(e){return t._decode(e)})},requestSmsCode:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(r.isString(t)&&(t={mobilePhoneNumber:t}),!t.mobilePhoneNumber)throw new Error(\"Missing mobilePhoneNumber.\");return e.validateToken&&(t=r.extend({},t,{validate_token:e.validateToken})),s(\"requestSmsCode\",null,null,\"POST\",t,e)},verifySmsCode:function(t,e){if(!t)throw new Error(\"Missing sms code.\");var n={};return r.isString(e)&&(n.mobilePhoneNumber=e),s(\"verifySmsCode\",t,null,\"POST\",n)},_requestCaptcha:function(t,e){return s(\"requestCaptcha\",null,null,\"GET\",t,e).then(function(t){var e=t.captcha_url;return{captchaToken:t.captcha_token,url:e}})},requestCaptcha:t.Captcha.request,verifyCaptcha:function(t,e){return s(\"verifyCaptcha\",null,null,\"POST\",{captcha_code:t,captcha_token:e}).then(function(t){return t.validate_token})}})}},function(t,e,n){\"use strict\";var r=n(2).request;t.exports=function(t){t.Installation=t.Object.extend(\"_Installation\"),t.Push=t.Push||{},t.Push.send=function(t,e){if(t.where&&(t.where=t.where.toJSON().where),t.where&&t.cql)throw new Error(\"Both where and cql can't be set\");if(t.push_time&&(t.push_time=t.push_time.toJSON()),t.expiration_time&&(t.expiration_time=t.expiration_time.toJSON()),t.expiration_time&&t.expiration_time_interval)throw new Error(\"Both expiration_time and expiration_time_interval can't be set\");return r({service:\"push\",method:\"POST\",path:\"/push\",data:t,authOptions:e})}}},function(t,e,n){\"use strict\";var r=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t},i=n(0),s=n(1),o=n(2)._request,a=n(3),u=a.getSessionToken;t.exports=function(t){var e=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return u(e)?t.User._fetchUserBySessionToken(u(e)):t.User.currentAsync()},n=function(n){return e(n).then(function(e){return t.Object.createWithoutData(\"_User\",e.id)._toPointer()})};t.Status=function(t,e){return this.data={},this.inboxType=\"default\",this.query=null,t&&\"object\"===(void 0===t?\"undefined\":r(t))?this.data=t:(t&&(this.data.image=t),e&&(this.data.message=e)),this},i.extend(t.Status.prototype,{get:function(t){return this.data[t]},set:function(t,e){return this.data[t]=e,this},destroy:function(e){return this.id?o(\"statuses\",null,this.id,\"DELETE\",e):t.Promise.reject(new Error(\"The status id is not exists.\"))},toObject:function(){return this.id?t.Object.createWithoutData(\"_Status\",this.id):null},_getDataJSON:function(){var e=i.clone(this.data);return t._encode(e)},send:function(){var e=this,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!u(r)&&!t.User.current())throw new Error(\"Please signin an user.\");return this.query?n(r).then(function(t){var n=e.query.toJSON();n.className=e.query.className;var i={};return i.query=n,e.data=e.data||{},e.data.source=e.data.source||t,i.data=e._getDataJSON(),i.inboxType=e.inboxType||\"default\",o(\"statuses\",null,null,\"POST\",i,r)}).then(function(n){return e.id=n.objectId,e.createdAt=t._parseDate(n.createdAt),e}):t.Status.sendStatusToFollowers(this,r)},_finishFetch:function(e){this.id=e.objectId,this.createdAt=t._parseDate(e.createdAt),this.updatedAt=t._parseDate(e.updatedAt),this.messageId=e.messageId,delete e.messageId,delete e.objectId,delete e.createdAt,delete e.updatedAt,this.data=t._decode(e)}}),t.Status.sendStatusToFollowers=function(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!u(r)&&!t.User.current())throw new Error(\"Please signin an user.\");return n(r).then(function(n){var i={};i.className=\"_Follower\",i.keys=\"follower\",i.where={user:n};var s={};return s.query=i,e.data=e.data||{},e.data.source=e.data.source||n,s.data=e._getDataJSON(),s.inboxType=e.inboxType||\"default\",o(\"statuses\",null,null,\"POST\",s,r).then(function(n){return e.id=n.objectId,e.createdAt=t._parseDate(n.createdAt),e})})},t.Status.sendPrivateStatus=function(e,r){var s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!u(s)&&!t.User.current())throw new Error(\"Please signin an user.\");if(!r)throw new Error(\"Invalid target user.\");var a=i.isString(r)?r:r.id;if(!a)throw new Error(\"Invalid target user.\");return n(s).then(function(n){var r={};r.className=\"_User\",r.where={objectId:a};var i={};return i.query=r,e.data=e.data||{},e.data.source=e.data.source||n,i.data=e._getDataJSON(),i.inboxType=\"private\",e.inboxType=\"private\",o(\"statuses\",null,null,\"POST\",i,s).then(function(n){return e.id=n.objectId,e.createdAt=t._parseDate(n.createdAt),e})})},t.Status.countUnreadStatuses=function(n){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"default\",a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(i.isString(r)||(a=r),!u(a)&&null==n&&!t.User.current())throw new Error(\"Please signin an user or pass the owner objectId.\");return s.resolve(n||e(a)).then(function(e){var n={};return n.inboxType=t._encode(r),n.owner=t._encode(e),o(\"subscribe/statuses/count\",null,null,\"GET\",n,a)})},t.Status.resetUnreadCount=function(n){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"default\",a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(i.isString(r)||(a=r),!u(a)&&null==n&&!t.User.current())throw new Error(\"Please signin an user or pass the owner objectId.\");return s.resolve(n||e(a)).then(function(e){var n={};return n.inboxType=t._encode(r),n.owner=t._encode(e),o(\"subscribe/statuses/resetUnreadCount\",null,null,\"POST\",n,a)})},t.Status.statusQuery=function(e){var n=new t.Query(\"_Status\");return e&&n.equalTo(\"source\",e),n},t.InboxQuery=t.Query._extend({_objectClass:t.Status,_sinceId:0,_maxId:0,_inboxType:\"default\",_owner:null,_newObject:function(){return new t.Status},_createRequest:function(e,n){return t.InboxQuery.__super__._createRequest.call(this,e,n,\"/subscribe/statuses\")},sinceId:function(t){return this._sinceId=t,this},maxId:function(t){return this._maxId=t,this},owner:function(t){return this._owner=t,this},inboxType:function(t){return this._inboxType=t,this},toJSON:function(){var e=t.InboxQuery.__super__.toJSON.call(this);return e.owner=t._encode(this._owner),e.inboxType=t._encode(this._inboxType),e.sinceId=t._encode(this._sinceId),e.maxId=t._encode(this._maxId),e}}),t.Status.inboxQuery=function(e,n){var r=new t.InboxQuery(t.Status);return e&&(r._owner=e),n&&(r._inboxType=n),r}}},function(t,e,n){\"use strict\";var r=n(0),i=n(2)._request;t.exports=function(t){t.SearchSortBuilder=function(){this._sortFields=[]},r.extend(t.SearchSortBuilder.prototype,{_addField:function(t,e,n,r){var i={};return i[t]={order:e||\"asc\",mode:n||\"avg\",missing:\"_\"+(r||\"last\")},this._sortFields.push(i),this},ascending:function(t,e,n){return this._addField(t,\"asc\",e,n)},descending:function(t,e,n){return this._addField(t,\"desc\",e,n)},whereNear:function(t,e,n){n=n||{};var r={},i={lat:e.latitude,lon:e.longitude},s={order:n.order||\"asc\",mode:n.mode||\"avg\",unit:n.unit||\"km\"};return s[t]=i,r._geo_distance=s,this._sortFields.push(r),this},build:function(){return JSON.stringify(t._encode(this._sortFields))}}),t.SearchQuery=t.Query._extend({_sid:null,_hits:0,_queryString:null,_highlights:null,_sortBuilder:null,_createRequest:function(t,e){return i(\"search/select\",null,null,\"GET\",t||this.toJSON(),e)},sid:function(t){return this._sid=t,this},queryString:function(t){return this._queryString=t,this},highlights:function(t){var e;return e=t&&r.isString(t)?arguments:t,this._highlights=e,this},sortBy:function(t){return this._sortBuilder=t,this},hits:function(){return this._hits||(this._hits=0),this._hits},_processResult:function(t){return delete t.className,delete t._app_url,delete t._deeplink,t},hasMore:function(){return!this._hitEnd},reset:function(){this._hitEnd=!1,this._sid=null,this._hits=0},find:function(){var t=this;return this._createRequest().then(function(e){return e.sid?(t._oldSid=t._sid,t._sid=e.sid):(t._sid=null,t._hitEnd=!0),t._hits=e.hits||0,r.map(e.results,function(n){n.className&&(e.className=n.className);var r=t._newObject(e);return r.appURL=n._app_url,r._finishFetch(t._processResult(n),!0),r})})},toJSON:function(){var e=t.SearchQuery.__super__.toJSON.call(this);if(delete e.where,this.className&&(e.clazz=this.className),this._sid&&(e.sid=this._sid),!this._queryString)throw new Error(\"Please set query string.\");if(e.q=this._queryString,this._highlights&&(e.highlights=this._highlights.join(\",\")),this._sortBuilder&&e.order)throw new Error(\"sort and order can not be set at same time.\");return this._sortBuilder&&(e.sort=this._sortBuilder.build()),e}})}},function(t,e,n){\"use strict\";var r=n(0),i=n(4),s=n(2),o=s.request;t.exports=function(t){t.Insight=t.Insight||{},r.extend(t.Insight,{startJob:function(e,n){if(!e||!e.sql)throw new Error(\"Please provide the sql to run the job.\");var r={jobConfig:e,appId:t.applicationId};return o({path:\"/bigquery/jobs\",method:\"POST\",data:t._encode(r,null,!0),authOptions:n,signKey:!1}).then(function(e){return t._decode(e).id})},on:function(t,e){}}),t.Insight.JobQuery=function(t,e){if(!t)throw new Error(\"Please provide the job id.\");this.id=t,this.className=e,this._skip=0,this._limit=100},r.extend(t.Insight.JobQuery.prototype,{skip:function(t){return this._skip=t,this},limit:function(t){return this._limit=t,this},find:function(e){var n={skip:this._skip,limit:this._limit};return o({path:\"/bigquery/jobs/\"+this.id,method:\"GET\",query:n,authOptions:e,signKey:!1}).then(function(e){return e.error?t.Promise.reject(new i(e.code,e.error)):t.Promise.resolve(e)})}})}},function(t,e,n){\"use strict\";var r=n(0),i=n(2),s=i._request,o=n(5),a=function(t){return\"function\"==typeof t.toJSON?t.toJSON():\"string\"!=typeof t?JSON.stringify(t):t};t.exports=o.Object.extend(\"_Conversation\",{constructor:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};o.Object.prototype.constructor.call(this,null,null),this.set(\"name\",t),void 0!==e.isSystem&&this.set(\"sys\",!!e.isSystem),void 0!==e.isTransient&&this.set(\"tr\",!!e.isTransient)},getCreator:function(){return this.get(\"c\")},getLastMessageAt:function(){return this.get(\"lm\")},getMembers:function(){return this.get(\"m\")},addMember:function(t){return this.add(\"m\",t)},getMutedMembers:function(){return this.get(\"mu\")},getName:function(){return this.get(\"name\")},isTransient:function(){return this.get(\"tr\")},isSystem:function(){return this.get(\"sys\")},send:function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i={from_peer:t,conv_id:this.id,transient:!1,message:a(e)};return void 0!==n.toClients&&(i.to_peers=n.toClients),void 0!==n.transient&&(i.transient=!!n.transient),void 0!==n.pushData&&(i.push_data=n.pushData),s(\"rtm\",\"messages\",null,\"POST\",i,r)},broadcast:function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o={from_peer:t,conv_id:this.id,message:a(e)};if(void 0!==n.pushData&&(o.push=n.pushData),void 0!==n.validTill){var u=n.validTill;r.isDate(u)&&(u=u.getTime()),n.valid_till=u}return s(\"rtm\",\"broadcast\",null,\"POST\",o,i)}})},function(t,e,n){\"use strict\";function r(t){var e=t.name,n=t.value,r=t.version;this.name=e,this.value=n,this.version=r}var i=n(0),s=n(1),o=n(2),a=o.request,u=n(3),c=u.ensureArray,l=u.parseDate,h=n(5);h.LeaderboardVersionChangeInterval={NEVER:\"never\",HOUR:\"hour\",DAY:\"day\",WEEK:\"week\",MONTH:\"month\"},h.LeaderboardOrder={ASCENDING:\"ascending\",DESCENDING:\"descending\"},h.LeaderboardUpdateStrategy={BETTER:\"better\",LAST:\"last\"};var f=function(t){var e=h._decode(t);return new r({name:e.statisticName,value:e.statisticValue,version:e.version})};h.Leaderboard=function(t){this.statisticName=t,this.order=void 0,this.updateStrategy=void 0,this.versionChangeInterval=void 0,this.version=void 0,this.nextResetAt=void 0,this.createdAt=void 0};var d=h.Leaderboard;h.Leaderboard.createWithoutData=function(t){return new d(t)},h.Leaderboard.createLeaderboard=function(t,e){var n=t.statisticName,r=t.order,i=t.versionChangeInterval,s=t.updateStrategy;return a({method:\"POST\",path:\"/leaderboard/leaderboards\",data:{statisticName:n,order:r,versionChangeInterval:i,updateStrategy:s},authOptions:e}).then(function(t){return new d(n)._finishFetch(t)})},h.Leaderboard.getLeaderboard=function(t,e){return d.createWithoutData(t).fetch(e)},h.Leaderboard.getStatistics=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=e.statisticNames,r=arguments[2];return s.resolve().then(function(){if(!t||!t.id)throw new Error(\"user must be an AV.User\");return a({method:\"GET\",path:\"/leaderboard/users/\"+t.id+\"/statistics\",query:{statistics:n?c(n).join(\",\"):void 0},authOptions:r}).then(function(t){return t.results.map(f)})})},h.Leaderboard.updateStatistics=function(t,e,n){return s.resolve().then(function(){if(!t||!t.id)throw new Error(\"user must be an AV.User\");var r=i.map(e,function(t,e){return{statisticName:e,statisticValue:t}});return a({method:\"POST\",path:\"/leaderboard/users/\"+t.id+\"/statistics\",data:r,authOptions:n}).then(function(t){return t.results.map(f)})})},i.extend(d.prototype,{_finishFetch:function(t){var e=this;return i.forEach(t,function(t,n){\"updatedAt\"!==n&&\"objectId\"!==n&&(\"expiredAt\"===n&&(n=\"nextResetAt\"),\"createdAt\"===n&&(t=l(t)),t&&\"Date\"===t.__type&&(t=l(t.iso)),e[n]=t)}),this},fetch:function(t){var e=this;return a({method:\"GET\",path:\"/leaderboard/leaderboards/\"+this.statisticName,authOptions:t}).then(function(t){return e._finishFetch(t)})},_getResults:function(t,e,n){var r=t.skip,i=t.limit,s=t.selectUserKeys,o=t.includeStatistics;return a({method:\"GET\",path:\"/leaderboard/leaderboards/\"+this.statisticName+\"/ranks\"+(n?\"/self\":\"\"),query:{skip:r,limit:i,includeUser:s?c(s).join(\",\"):void 0,includeStatistics:o?c(o).join(\",\"):void 0},authOptions:e}).then(function(t){return t.results.map(function(t){var e=h._decode(t),n=e.user,r=e.statisticValue,i=e.rank,s=e.statistics;return{user:n,value:r,rank:i,includedStatistics:(void 0===s?[]:s).map(f)}})})},getResults:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=t.skip,n=t.limit,r=t.selectUserKeys,i=t.includeStatistics,s=arguments[1];return this._getResults({skip:e,limit:n,selectUserKeys:r,includeStatistics:i},s)},getResultsAroundUser:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=t.limit,n=t.selectUserKeys,r=t.includeStatistics,i=arguments[1];return this._getResults({limit:e,selectUserKeys:n,includeStatistics:r},i,!0)},_update:function(t,e){var n=this;return a({method:\"PUT\",path:\"/leaderboard/leaderboards/\"+this.statisticName,data:t,authOptions:e}).then(function(t){return n._finishFetch(t)})},updateVersionChangeInterval:function(t,e){return this._update({versionChangeInterval:t},e)},updateUpdateStrategy:function(t,e){return this._update({updateStrategy:t},e)},reset:function(t){var e=this;return a({method:\"PUT\",path:\"/leaderboard/leaderboards/\"+this.statisticName+\"/incrementVersion\",authOptions:t}).then(function(t){return e._finishFetch(t)})},destroy:function(t){return h.request({method:\"DELETE\",path:\"/leaderboard/leaderboards/\"+this.statisticName,authOptions:t}).then(function(){})}})}])});\n//# sourceMappingURL=av-min.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGVhbmNsb3VkLXN0b3JhZ2UvZGlzdC9hdi1taW4uanM/MDYzMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw4REFBZSxtQ0FBeUssK0NBQStDLG1CQUFtQixjQUFjLDRCQUE0QixZQUFZLHFCQUFxQiwyREFBMkQsU0FBUyx1Q0FBdUMscUNBQXFDLG9DQUFvQyxFQUFFLGlCQUFpQixpQ0FBaUMsaUJBQWlCLFlBQVksVUFBVSxzQkFBc0IsbUJBQW1CLGlEQUFpRCxrQkFBa0Isa0JBQWtCLGVBQWUsUUFBUSxZQUFZLGtHQUFrRyw4TUFBOE0sZUFBZSwwRUFBMEUsMkdBQTJHLHdCQUF3Qix1QkFBdUIsb0JBQW9CLDBCQUEwQixvQkFBb0IsOEJBQThCLHdCQUF3QixnQ0FBZ0MsMEJBQTBCLGtCQUFrQiw2QkFBNkIsbUJBQW1CLDJJQUEySSwyQkFBMkIsbUJBQW1CLG9CQUFvQiwwQ0FBMEMsd0RBQXdELElBQUksd0JBQXdCLFVBQVUsNkJBQTZCLDBDQUEwQyx1REFBdUQsaUJBQWlCLFFBQVEsSUFBSSxzQkFBc0IsK0JBQStCLGVBQWUsMkJBQTJCLGlCQUFpQixjQUFjLFlBQVksMEJBQTBCLGVBQWUsbUJBQW1CLDRCQUE0QixpQkFBaUIsNEJBQTRCLGlCQUFpQix1QkFBdUIsSUFBSSxLQUFLLGtCQUFrQixVQUFVLGtCQUFrQixnREFBZ0QsV0FBVyxzQ0FBc0MsaUNBQWlDLFNBQVMsUUFBUSwyQkFBMkIsSUFBSSxnQkFBZ0IsS0FBSyxnQkFBZ0IsbUJBQW1CLElBQUksc0JBQXNCLFNBQVMsaUNBQWlDLFNBQVMsMERBQTBELElBQUksS0FBSyxlQUFlLGlCQUFpQixVQUFVLGtCQUFrQix3QkFBd0IsbURBQW1ELDRCQUE0QixVQUFVLE1BQU0sZUFBZSxnQkFBZ0IsVUFBVSx5QkFBeUIsMEJBQTBCLDJCQUEyQiwyRkFBMkYsNENBQTRDLGtDQUFrQyxtQ0FBbUMsU0FBUyx5Q0FBeUMsb0JBQW9CLElBQUksMEJBQTBC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QkFBMEIsdUtBQXVLLG9CQUFvQiw0Q0FBNEMsZ0JBQWdCLCtDQUErQyw2RUFBNkUsVUFBVSxxREFBcUQsaUVBQWlFLGVBQWUsbUJBQW1CLGdDQUFnQyxFQUFFLDRDQUE0Qyx1Q0FBdUMseUNBQXlDLCtEQUErRCxtQ0FBbUMsbUNBQW1DLHdEQUF3RCxVQUFVLGtFQUFrRSxtQ0FBbUMsZUFBZSxtQkFBbUIsd0JBQXdCLEVBQUUsRUFBRSxnREFBZ0QsbUNBQW1DLHdEQUF3RCw0QkFBNEIsT0FBTyxrQ0FBa0MsRUFBRSxVQUFVLGlGQUFpRixtQkFBbUIsd0JBQXdCLEVBQUUsRUFBRSx1QkFBdUIseUJBQXlCLFdBQVcsaUNBQWlDLDBJQUEwSSxPQUFPLG1CQUFtQixXQUFXLFVBQVUsZ0ZBQWdGLG1CQUFtQix5QkFBeUIsRUFBRSw2QkFBNkIsZ0VBQWdFLFVBQVUsaUdBQWlHLDZGQUE2RixlQUFlLG1CQUFtQixpQ0FBaUMsdUVBQXVFLE9BQU8sbUVBQW1FLEVBQUUsRUFBRSx1QkFBdUIsK0RBQStELDRFQUE0RSx5QkFBeUIsb0RBQW9ELElBQUksaUNBQWlDLCtEQUErRCxtRUFBbUUseUJBQXlCLDZDQUE2QyxPQUFPLHVCQUF1QixXQUFXLFVBQVUsdUZBQXVGLG1CQUFtQix5QkFBeUIsRUFBRSwyQ0FBMkMscUJBQXFCLHdCQUF3QixJQUFJLG9DQUFvQyxxQkFBcUIsaUJBQWlCLElBQUksbUJBQW1CLFdBQVcsVUFBVSxvR0FBb0csbUJBQW1CLHlCQUF5QixFQUFFLHFCQUFxQixrQkFBa0IsbUZBQW1GLG1CQUFtQixHQUFHLEVBQUUsR0FBRztBQUNueDlELGtDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xlYW5jbG91ZC1zdG9yYWdlL2Rpc3QvYXYtbWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sZSk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5BVj1lKCk6dC5BVj1lKCl9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHIpe2lmKG5bcl0pcmV0dXJuIG5bcl0uZXhwb3J0czt2YXIgaT1uW3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gdFtyXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyxlKSxpLmw9ITAsaS5leHBvcnRzfXZhciBuPXt9O3JldHVybiBlLm09dCxlLmM9bixlLmQ9ZnVuY3Rpb24odCxuLHIpe2Uubyh0LG4pfHxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLHtjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMCxnZXQ6cn0pfSxlLm49ZnVuY3Rpb24odCl7dmFyIG49dCYmdC5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHQuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gdH07cmV0dXJuIGUuZChuLFwiYVwiLG4pLG59LGUubz1mdW5jdGlvbih0LGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKX0sZS5wPVwiXCIsZShlLnM9MTQpfShbZnVuY3Rpb24odCxlLG4peyhmdW5jdGlvbih0LG4pe3ZhciByLGk7IWZ1bmN0aW9uKCl7dmFyIHM9XCJvYmplY3RcIj09dHlwZW9mIHNlbGYmJnNlbGYuc2VsZj09PXNlbGYmJnNlbGZ8fFwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0Lmdsb2JhbD09PXQmJnR8fHRoaXN8fHt9LG89cy5fLGE9QXJyYXkucHJvdG90eXBlLHU9T2JqZWN0LnByb3RvdHlwZSxjPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2w/U3ltYm9sLnByb3RvdHlwZTpudWxsLGw9YS5wdXNoLGg9YS5zbGljZSxmPXUudG9TdHJpbmcsZD11Lmhhc093blByb3BlcnR5LHA9QXJyYXkuaXNBcnJheSxfPU9iamVjdC5rZXlzLHY9T2JqZWN0LmNyZWF0ZSx5PWZ1bmN0aW9uKCl7fSxtPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgbT90OnRoaXMgaW5zdGFuY2VvZiBtP3ZvaWQodGhpcy5fd3JhcHBlZD10KTpuZXcgbSh0KX07dm9pZCAwPT09ZXx8ZS5ub2RlVHlwZT9zLl89bToodm9pZCAwIT09biYmIW4ubm9kZVR5cGUmJm4uZXhwb3J0cyYmKGU9bi5leHBvcnRzPW0pLGUuXz1tKSxtLlZFUlNJT049XCIxLjkuMVwiO3ZhciBnLGI9ZnVuY3Rpb24odCxlLG4pe2lmKHZvaWQgMD09PWUpcmV0dXJuIHQ7c3dpdGNoKG51bGw9PW4/MzpuKXtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKG4pe3JldHVybiB0LmNhbGwoZSxuKX07Y2FzZSAzOnJldHVybiBmdW5jdGlvbihuLHIsaSl7cmV0dXJuIHQuY2FsbChlLG4scixpKX07Y2FzZSA0OnJldHVybiBmdW5jdGlvbihuLHIsaSxzKXtyZXR1cm4gdC5jYWxsKGUsbixyLGkscyl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KGUsYXJndW1lbnRzKX19LHc9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBtLml0ZXJhdGVlIT09Zz9tLml0ZXJhdGVlKHQsZSk6bnVsbD09dD9tLmlkZW50aXR5Om0uaXNGdW5jdGlvbih0KT9iKHQsZSxuKTptLmlzT2JqZWN0KHQpJiYhbS5pc0FycmF5KHQpP20ubWF0Y2hlcih0KTptLnByb3BlcnR5KHQpfTttLml0ZXJhdGVlPWc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdyh0LGUsMS8wKX07dmFyIE89ZnVuY3Rpb24odCxlKXtyZXR1cm4gZT1udWxsPT1lP3QubGVuZ3RoLTE6K2UsZnVuY3Rpb24oKXtmb3IodmFyIG49TWF0aC5tYXgoYXJndW1lbnRzLmxlbmd0aC1lLDApLHI9QXJyYXkobiksaT0wO2k8bjtpKyspcltpXT1hcmd1bWVudHNbaStlXTtzd2l0Y2goZSl7Y2FzZSAwOnJldHVybiB0LmNhbGwodGhpcyxyKTtjYXNlIDE6cmV0dXJuIHQuY2FsbCh0aGlzLGFyZ3VtZW50c1swXSxyKTtjYXNlIDI6cmV0dXJuIHQuY2FsbCh0aGlzLGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0scil9dmFyIHM9QXJyYXkoZSsxKTtmb3IoaT0wO2k8ZTtpKyspc1tpXT1hcmd1bWVudHNbaV07cmV0dXJuIHNbZV09cix0LmFwcGx5KHRoaXMscyl9fSxBPWZ1bmN0aW9uKHQpe2lmKCFtLmlzT2JqZWN0KHQpKXJldHVybnt9O2lmKHYpcmV0dXJuIHYodCk7eS5wcm90b3R5cGU9dDt2YXIgZT1uZXcgeTtyZXR1cm4geS5wcm90b3R5cGU9bnVsbCxlfSxTPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09ZT92b2lkIDA6ZVt0XX19LEM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbCE9dCYmZC5jYWxsKHQsZSl9LEU9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5sZW5ndGgscj0wO3I8bjtyKyspe2lmKG51bGw9PXQpcmV0dXJuO3Q9dFtlW3JdXX1yZXR1cm4gbj90OnZvaWQgMH0sVD1NYXRoLnBvdygyLDUzKS0xLE49UyhcImxlbmd0aFwiKSxqPWZ1bmN0aW9uKHQpe3ZhciBlPU4odCk7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGUmJmU+PTAmJmU8PVR9O20uZWFjaD1tLmZvckVhY2g9ZnVuY3Rpb24odCxlLG4pe2U9YihlLG4pO3ZhciByLGk7aWYoaih0KSlmb3Iocj0wLGk9dC5sZW5ndGg7cjxpO3IrKyllKHRbcl0scix0KTtlbHNle3ZhciBzPW0ua2V5cyh0KTtmb3Iocj0wLGk9cy5sZW5ndGg7cjxpO3IrKyllKHRbc1tyXV0sc1tyXSx0KX1yZXR1cm4gdH0sbS5tYXA9bS5jb2xsZWN0PWZ1bmN0aW9uKHQsZSxuKXtlPXcoZSxuKTtmb3IodmFyIHI9IWoodCkmJm0ua2V5cyh0KSxpPShyfHx0KS5sZW5ndGgscz1BcnJheShpKSxvPTA7bzxpO28rKyl7dmFyIGE9cj9yW29dOm87c1tvXT1lKHRbYV0sYSx0KX1yZXR1cm4gc307dmFyIHg9ZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oZSxuLHIsaSl7dmFyIHM9IWooZSkmJm0ua2V5cyhlKSxvPShzfHxlKS5sZW5ndGgsYT10PjA/MDpvLTE7Zm9yKGl8fChyPWVbcz9zW2FdOmFdLGErPXQpO2E+PTAmJmE8bzthKz10KXt2YXIgdT1zP3NbYV06YTtyPW4ocixlW3VdLHUsZSl9cmV0dXJuIHJ9O3JldHVybiBmdW5jdGlvbih0LG4scixpKXt2YXIgcz1hcmd1bWVudHMubGVuZ3RoPj0zO3JldHVybiBlKHQsYihuLGksNCkscixzKX19O20ucmVkdWNlPW0uZm9sZGw9bS5pbmplY3Q9eCgxKSxtLnJlZHVjZVJpZ2h0PW0uZm9sZHI9eCgtMSksbS5maW5kPW0uZGV0ZWN0PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1qKHQpP20uZmluZEluZGV4Om0uZmluZEtleSxpPXIodCxlLG4pO2lmKHZvaWQgMCE9PWkmJi0xIT09aSlyZXR1cm4gdFtpXX0sbS5maWx0ZXI9bS5zZWxlY3Q9ZnVuY3Rpb24odCxlLG4pe3ZhciByPVtdO3JldHVybiBlPXcoZSxuKSxtLmVhY2godCxmdW5jdGlvbih0LG4saSl7ZSh0LG4saSkmJnIucHVzaCh0KX0pLHJ9LG0ucmVqZWN0PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gbS5maWx0ZXIodCxtLm5lZ2F0ZSh3KGUpKSxuKX0sbS5ldmVyeT1tLmFsbD1mdW5jdGlvbih0LGUsbil7ZT13KGUsbik7Zm9yKHZhciByPSFqKHQpJiZtLmtleXModCksaT0ocnx8dCkubGVuZ3RoLHM9MDtzPGk7cysrKXt2YXIgbz1yP3Jbc106cztpZighZSh0W29dLG8sdCkpcmV0dXJuITF9cmV0dXJuITB9LG0uc29tZT1tLmFueT1mdW5jdGlvbih0LGUsbil7ZT13KGUsbik7Zm9yKHZhciByPSFqKHQpJiZtLmtleXModCksaT0ocnx8dCkubGVuZ3RoLHM9MDtzPGk7cysrKXt2YXIgbz1yP3Jbc106cztpZihlKHRbb10sbyx0KSlyZXR1cm4hMH1yZXR1cm4hMX0sbS5jb250YWlucz1tLmluY2x1ZGVzPW0uaW5jbHVkZT1mdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gaih0KXx8KHQ9bS52YWx1ZXModCkpLChcIm51bWJlclwiIT10eXBlb2Ygbnx8cikmJihuPTApLG0uaW5kZXhPZih0LGUsbik+PTB9LG0uaW52b2tlPU8oZnVuY3Rpb24odCxlLG4pe3ZhciByLGk7cmV0dXJuIG0uaXNGdW5jdGlvbihlKT9pPWU6bS5pc0FycmF5KGUpJiYocj1lLnNsaWNlKDAsLTEpLGU9ZVtlLmxlbmd0aC0xXSksbS5tYXAodCxmdW5jdGlvbih0KXt2YXIgcz1pO2lmKCFzKXtpZihyJiZyLmxlbmd0aCYmKHQ9RSh0LHIpKSxudWxsPT10KXJldHVybjtzPXRbZV19cmV0dXJuIG51bGw9PXM/czpzLmFwcGx5KHQsbil9KX0pLG0ucGx1Y2s9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbS5tYXAodCxtLnByb3BlcnR5KGUpKX0sbS53aGVyZT1mdW5jdGlvbih0LGUpe3JldHVybiBtLmZpbHRlcih0LG0ubWF0Y2hlcihlKSl9LG0uZmluZFdoZXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG0uZmluZCh0LG0ubWF0Y2hlcihlKSl9LG0ubWF4PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpLHM9LTEvMCxvPS0xLzA7aWYobnVsbD09ZXx8XCJudW1iZXJcIj09dHlwZW9mIGUmJlwib2JqZWN0XCIhPXR5cGVvZiB0WzBdJiZudWxsIT10KXt0PWoodCk/dDptLnZhbHVlcyh0KTtmb3IodmFyIGE9MCx1PXQubGVuZ3RoO2E8dTthKyspbnVsbCE9KHI9dFthXSkmJnI+cyYmKHM9cil9ZWxzZSBlPXcoZSxuKSxtLmVhY2godCxmdW5jdGlvbih0LG4scil7KChpPWUodCxuLHIpKT5vfHxpPT09LTEvMCYmcz09PS0xLzApJiYocz10LG89aSl9KTtyZXR1cm4gc30sbS5taW49ZnVuY3Rpb24odCxlLG4pe3ZhciByLGkscz0xLzAsbz0xLzA7aWYobnVsbD09ZXx8XCJudW1iZXJcIj09dHlwZW9mIGUmJlwib2JqZWN0XCIhPXR5cGVvZiB0WzBdJiZudWxsIT10KXt0PWoodCk/dDptLnZhbHVlcyh0KTtmb3IodmFyIGE9MCx1PXQubGVuZ3RoO2E8dTthKyspbnVsbCE9KHI9dFthXSkmJnI8cyYmKHM9cil9ZWxzZSBlPXcoZSxuKSxtLmVhY2godCxmdW5jdGlvbih0LG4scil7KChpPWUodCxuLHIpKTxvfHxpPT09MS8wJiZzPT09MS8wKSYmKHM9dCxvPWkpfSk7cmV0dXJuIHN9LG0uc2h1ZmZsZT1mdW5jdGlvbih0KXtyZXR1cm4gbS5zYW1wbGUodCwxLzApfSxtLnNhbXBsZT1mdW5jdGlvbih0LGUsbil7aWYobnVsbD09ZXx8bilyZXR1cm4gaih0KXx8KHQ9bS52YWx1ZXModCkpLHRbbS5yYW5kb20odC5sZW5ndGgtMSldO3ZhciByPWoodCk/bS5jbG9uZSh0KTptLnZhbHVlcyh0KSxpPU4ocik7ZT1NYXRoLm1heChNYXRoLm1pbihlLGkpLDApO2Zvcih2YXIgcz1pLTEsbz0wO288ZTtvKyspe3ZhciBhPW0ucmFuZG9tKG8scyksdT1yW29dO3Jbb109clthXSxyW2FdPXV9cmV0dXJuIHIuc2xpY2UoMCxlKX0sbS5zb3J0Qnk9ZnVuY3Rpb24odCxlLG4pe3ZhciByPTA7cmV0dXJuIGU9dyhlLG4pLG0ucGx1Y2sobS5tYXAodCxmdW5jdGlvbih0LG4saSl7cmV0dXJue3ZhbHVlOnQsaW5kZXg6cisrLGNyaXRlcmlhOmUodCxuLGkpfX0pLnNvcnQoZnVuY3Rpb24odCxlKXt2YXIgbj10LmNyaXRlcmlhLHI9ZS5jcml0ZXJpYTtpZihuIT09cil7aWYobj5yfHx2b2lkIDA9PT1uKXJldHVybiAxO2lmKG48cnx8dm9pZCAwPT09cilyZXR1cm4tMX1yZXR1cm4gdC5pbmRleC1lLmluZGV4fSksXCJ2YWx1ZVwiKX07dmFyIFU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZnVuY3Rpb24obixyLGkpe3ZhciBzPWU/W1tdLFtdXTp7fTtyZXR1cm4gcj13KHIsaSksbS5lYWNoKG4sZnVuY3Rpb24oZSxpKXt2YXIgbz1yKGUsaSxuKTt0KHMsZSxvKX0pLHN9fTttLmdyb3VwQnk9VShmdW5jdGlvbih0LGUsbil7Qyh0LG4pP3Rbbl0ucHVzaChlKTp0W25dPVtlXX0pLG0uaW5kZXhCeT1VKGZ1bmN0aW9uKHQsZSxuKXt0W25dPWV9KSxtLmNvdW50Qnk9VShmdW5jdGlvbih0LGUsbil7Qyh0LG4pP3Rbbl0rKzp0W25dPTF9KTt2YXIgaz0vW15cXHVkODAwLVxcdWRmZmZdfFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl18W1xcdWQ4MDAtXFx1ZGZmZl0vZzttLnRvQXJyYXk9ZnVuY3Rpb24odCl7cmV0dXJuIHQ/bS5pc0FycmF5KHQpP2guY2FsbCh0KTptLmlzU3RyaW5nKHQpP3QubWF0Y2goayk6aih0KT9tLm1hcCh0LG0uaWRlbnRpdHkpOm0udmFsdWVzKHQpOltdfSxtLnNpemU9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PXQ/MDpqKHQpP3QubGVuZ3RoOm0ua2V5cyh0KS5sZW5ndGh9LG0ucGFydGl0aW9uPVUoZnVuY3Rpb24odCxlLG4pe3Rbbj8wOjFdLnB1c2goZSl9LCEwKSxtLmZpcnN0PW0uaGVhZD1tLnRha2U9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBudWxsPT10fHx0Lmxlbmd0aDwxP251bGw9PWU/dm9pZCAwOltdOm51bGw9PWV8fG4/dFswXTptLmluaXRpYWwodCx0Lmxlbmd0aC1lKX0sbS5pbml0aWFsPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gaC5jYWxsKHQsMCxNYXRoLm1heCgwLHQubGVuZ3RoLShudWxsPT1lfHxuPzE6ZSkpKX0sbS5sYXN0PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gbnVsbD09dHx8dC5sZW5ndGg8MT9udWxsPT1lP3ZvaWQgMDpbXTpudWxsPT1lfHxuP3RbdC5sZW5ndGgtMV06bS5yZXN0KHQsTWF0aC5tYXgoMCx0Lmxlbmd0aC1lKSl9LG0ucmVzdD1tLnRhaWw9bS5kcm9wPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gaC5jYWxsKHQsbnVsbD09ZXx8bj8xOmUpfSxtLmNvbXBhY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIG0uZmlsdGVyKHQsQm9vbGVhbil9O3ZhciBJPWZ1bmN0aW9uKHQsZSxuLHIpe3I9cnx8W107Zm9yKHZhciBpPXIubGVuZ3RoLHM9MCxvPU4odCk7czxvO3MrKyl7dmFyIGE9dFtzXTtpZihqKGEpJiYobS5pc0FycmF5KGEpfHxtLmlzQXJndW1lbnRzKGEpKSlpZihlKWZvcih2YXIgdT0wLGM9YS5sZW5ndGg7dTxjOylyW2krK109YVt1KytdO2Vsc2UgSShhLGUsbixyKSxpPXIubGVuZ3RoO2Vsc2Ugbnx8KHJbaSsrXT1hKX1yZXR1cm4gcn07bS5mbGF0dGVuPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEkodCxlLCExKX0sbS53aXRob3V0PU8oZnVuY3Rpb24odCxlKXtyZXR1cm4gbS5kaWZmZXJlbmNlKHQsZSl9KSxtLnVuaXE9bS51bmlxdWU9ZnVuY3Rpb24odCxlLG4scil7bS5pc0Jvb2xlYW4oZSl8fChyPW4sbj1lLGU9ITEpLG51bGwhPW4mJihuPXcobixyKSk7Zm9yKHZhciBpPVtdLHM9W10sbz0wLGE9Tih0KTtvPGE7bysrKXt2YXIgdT10W29dLGM9bj9uKHUsbyx0KTp1O2UmJiFuPyhvJiZzPT09Y3x8aS5wdXNoKHUpLHM9Yyk6bj9tLmNvbnRhaW5zKHMsYyl8fChzLnB1c2goYyksaS5wdXNoKHUpKTptLmNvbnRhaW5zKGksdSl8fGkucHVzaCh1KX1yZXR1cm4gaX0sbS51bmlvbj1PKGZ1bmN0aW9uKHQpe3JldHVybiBtLnVuaXEoSSh0LCEwLCEwKSl9KSxtLmludGVyc2VjdGlvbj1mdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj1hcmd1bWVudHMubGVuZ3RoLHI9MCxpPU4odCk7cjxpO3IrKyl7dmFyIHM9dFtyXTtpZighbS5jb250YWlucyhlLHMpKXt2YXIgbztmb3Iobz0xO288biYmbS5jb250YWlucyhhcmd1bWVudHNbb10scyk7bysrKTtvPT09biYmZS5wdXNoKHMpfX1yZXR1cm4gZX0sbS5kaWZmZXJlbmNlPU8oZnVuY3Rpb24odCxlKXtyZXR1cm4gZT1JKGUsITAsITApLG0uZmlsdGVyKHQsZnVuY3Rpb24odCl7cmV0dXJuIW0uY29udGFpbnMoZSx0KX0pfSksbS51bnppcD1mdW5jdGlvbih0KXtmb3IodmFyIGU9dCYmbS5tYXgodCxOKS5sZW5ndGh8fDAsbj1BcnJheShlKSxyPTA7cjxlO3IrKyluW3JdPW0ucGx1Y2sodCxyKTtyZXR1cm4gbn0sbS56aXA9TyhtLnVuemlwKSxtLm9iamVjdD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj17fSxyPTAsaT1OKHQpO3I8aTtyKyspZT9uW3Rbcl1dPWVbcl06blt0W3JdWzBdXT10W3JdWzFdO3JldHVybiBufTt2YXIgUj1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxuLHIpe249dyhuLHIpO2Zvcih2YXIgaT1OKGUpLHM9dD4wPzA6aS0xO3M+PTAmJnM8aTtzKz10KWlmKG4oZVtzXSxzLGUpKXJldHVybiBzO3JldHVybi0xfX07bS5maW5kSW5kZXg9UigxKSxtLmZpbmRMYXN0SW5kZXg9UigtMSksbS5zb3J0ZWRJbmRleD1mdW5jdGlvbih0LGUsbixyKXtuPXcobixyLDEpO2Zvcih2YXIgaT1uKGUpLHM9MCxvPU4odCk7czxvOyl7dmFyIGE9TWF0aC5mbG9vcigocytvKS8yKTtuKHRbYV0pPGk/cz1hKzE6bz1hfXJldHVybiBzfTt2YXIgUD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIGZ1bmN0aW9uKHIsaSxzKXt2YXIgbz0wLGE9TihyKTtpZihcIm51bWJlclwiPT10eXBlb2Ygcyl0PjA/bz1zPj0wP3M6TWF0aC5tYXgocythLG8pOmE9cz49MD9NYXRoLm1pbihzKzEsYSk6cythKzE7ZWxzZSBpZihuJiZzJiZhKXJldHVybiBzPW4ocixpKSxyW3NdPT09aT9zOi0xO2lmKGkhPT1pKXJldHVybiBzPWUoaC5jYWxsKHIsbyxhKSxtLmlzTmFOKSxzPj0wP3MrbzotMTtmb3Iocz10PjA/bzphLTE7cz49MCYmczxhO3MrPXQpaWYocltzXT09PWkpcmV0dXJuIHM7cmV0dXJuLTF9fTttLmluZGV4T2Y9UCgxLG0uZmluZEluZGV4LG0uc29ydGVkSW5kZXgpLG0ubGFzdEluZGV4T2Y9UCgtMSxtLmZpbmRMYXN0SW5kZXgpLG0ucmFuZ2U9ZnVuY3Rpb24odCxlLG4pe251bGw9PWUmJihlPXR8fDAsdD0wKSxufHwobj1lPHQ/LTE6MSk7Zm9yKHZhciByPU1hdGgubWF4KE1hdGguY2VpbCgoZS10KS9uKSwwKSxpPUFycmF5KHIpLHM9MDtzPHI7cysrLHQrPW4paVtzXT10O3JldHVybiBpfSxtLmNodW5rPWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09ZXx8ZTwxKXJldHVybltdO2Zvcih2YXIgbj1bXSxyPTAsaT10Lmxlbmd0aDtyPGk7KW4ucHVzaChoLmNhbGwodCxyLHIrPWUpKTtyZXR1cm4gbn07dmFyIEQ9ZnVuY3Rpb24odCxlLG4scixpKXtpZighKHIgaW5zdGFuY2VvZiBlKSlyZXR1cm4gdC5hcHBseShuLGkpO3ZhciBzPUEodC5wcm90b3R5cGUpLG89dC5hcHBseShzLGkpO3JldHVybiBtLmlzT2JqZWN0KG8pP286c307bS5iaW5kPU8oZnVuY3Rpb24odCxlLG4pe2lmKCFtLmlzRnVuY3Rpb24odCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkJpbmQgbXVzdCBiZSBjYWxsZWQgb24gYSBmdW5jdGlvblwiKTt2YXIgcj1PKGZ1bmN0aW9uKGkpe3JldHVybiBEKHQscixlLHRoaXMsbi5jb25jYXQoaSkpfSk7cmV0dXJuIHJ9KSxtLnBhcnRpYWw9TyhmdW5jdGlvbih0LGUpe3ZhciBuPW0ucGFydGlhbC5wbGFjZWhvbGRlcixyPWZ1bmN0aW9uKCl7Zm9yKHZhciBpPTAscz1lLmxlbmd0aCxvPUFycmF5KHMpLGE9MDthPHM7YSsrKW9bYV09ZVthXT09PW4/YXJndW1lbnRzW2krK106ZVthXTtmb3IoO2k8YXJndW1lbnRzLmxlbmd0aDspby5wdXNoKGFyZ3VtZW50c1tpKytdKTtyZXR1cm4gRCh0LHIsdGhpcyx0aGlzLG8pfTtyZXR1cm4gcn0pLG0ucGFydGlhbC5wbGFjZWhvbGRlcj1tLG0uYmluZEFsbD1PKGZ1bmN0aW9uKHQsZSl7ZT1JKGUsITEsITEpO3ZhciBuPWUubGVuZ3RoO2lmKG48MSl0aHJvdyBuZXcgRXJyb3IoXCJiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzXCIpO2Zvcig7bi0tOyl7dmFyIHI9ZVtuXTt0W3JdPW0uYmluZCh0W3JdLHQpfX0pLG0ubWVtb2l6ZT1mdW5jdGlvbih0LGUpe3ZhciBuPWZ1bmN0aW9uKHIpe3ZhciBpPW4uY2FjaGUscz1cIlwiKyhlP2UuYXBwbHkodGhpcyxhcmd1bWVudHMpOnIpO3JldHVybiBDKGkscyl8fChpW3NdPXQuYXBwbHkodGhpcyxhcmd1bWVudHMpKSxpW3NdfTtyZXR1cm4gbi5jYWNoZT17fSxufSxtLmRlbGF5PU8oZnVuY3Rpb24odCxlLG4pe3JldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIHQuYXBwbHkobnVsbCxuKX0sZSl9KSxtLmRlZmVyPW0ucGFydGlhbChtLmRlbGF5LG0sMSksbS50aHJvdHRsZT1mdW5jdGlvbih0LGUsbil7dmFyIHIsaSxzLG8sYT0wO258fChuPXt9KTt2YXIgdT1mdW5jdGlvbigpe2E9ITE9PT1uLmxlYWRpbmc/MDptLm5vdygpLHI9bnVsbCxvPXQuYXBwbHkoaSxzKSxyfHwoaT1zPW51bGwpfSxjPWZ1bmN0aW9uKCl7dmFyIGM9bS5ub3coKTthfHwhMSE9PW4ubGVhZGluZ3x8KGE9Yyk7dmFyIGw9ZS0oYy1hKTtyZXR1cm4gaT10aGlzLHM9YXJndW1lbnRzLGw8PTB8fGw+ZT8ociYmKGNsZWFyVGltZW91dChyKSxyPW51bGwpLGE9YyxvPXQuYXBwbHkoaSxzKSxyfHwoaT1zPW51bGwpKTpyfHwhMT09PW4udHJhaWxpbmd8fChyPXNldFRpbWVvdXQodSxsKSksb307cmV0dXJuIGMuY2FuY2VsPWZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHIpLGE9MCxyPWk9cz1udWxsfSxjfSxtLmRlYm91bmNlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcixpLHM9ZnVuY3Rpb24oZSxuKXtyPW51bGwsbiYmKGk9dC5hcHBseShlLG4pKX0sbz1PKGZ1bmN0aW9uKG8pe2lmKHImJmNsZWFyVGltZW91dChyKSxuKXt2YXIgYT0hcjtyPXNldFRpbWVvdXQocyxlKSxhJiYoaT10LmFwcGx5KHRoaXMsbykpfWVsc2Ugcj1tLmRlbGF5KHMsZSx0aGlzLG8pO3JldHVybiBpfSk7cmV0dXJuIG8uY2FuY2VsPWZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHIpLHI9bnVsbH0sb30sbS53cmFwPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG0ucGFydGlhbChlLHQpfSxtLm5lZ2F0ZT1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4hdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSxtLmNvbXBvc2U9ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMsZT10Lmxlbmd0aC0xO3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgbj1lLHI9dFtlXS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7bi0tOylyPXRbbl0uY2FsbCh0aGlzLHIpO3JldHVybiByfX0sbS5hZnRlcj1mdW5jdGlvbih0LGUpe3JldHVybiBmdW5jdGlvbigpe2lmKC0tdDwxKXJldHVybiBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19LG0uYmVmb3JlPWZ1bmN0aW9uKHQsZSl7dmFyIG47cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuLS10PjAmJihuPWUuYXBwbHkodGhpcyxhcmd1bWVudHMpKSx0PD0xJiYoZT1udWxsKSxufX0sbS5vbmNlPW0ucGFydGlhbChtLmJlZm9yZSwyKSxtLnJlc3RBcmd1bWVudHM9Tzt2YXIgTD0he3RvU3RyaW5nOm51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKFwidG9TdHJpbmdcIiksRj1bXCJ2YWx1ZU9mXCIsXCJpc1Byb3RvdHlwZU9mXCIsXCJ0b1N0cmluZ1wiLFwicHJvcGVydHlJc0VudW1lcmFibGVcIixcImhhc093blByb3BlcnR5XCIsXCJ0b0xvY2FsZVN0cmluZ1wiXSxxPWZ1bmN0aW9uKHQsZSl7dmFyIG49Ri5sZW5ndGgscj10LmNvbnN0cnVjdG9yLGk9bS5pc0Z1bmN0aW9uKHIpJiZyLnByb3RvdHlwZXx8dSxzPVwiY29uc3RydWN0b3JcIjtmb3IoQyh0LHMpJiYhbS5jb250YWlucyhlLHMpJiZlLnB1c2gocyk7bi0tOykocz1GW25dKWluIHQmJnRbc10hPT1pW3NdJiYhbS5jb250YWlucyhlLHMpJiZlLnB1c2gocyl9O20ua2V5cz1mdW5jdGlvbih0KXtpZighbS5pc09iamVjdCh0KSlyZXR1cm5bXTtpZihfKXJldHVybiBfKHQpO3ZhciBlPVtdO2Zvcih2YXIgbiBpbiB0KUModCxuKSYmZS5wdXNoKG4pO3JldHVybiBMJiZxKHQsZSksZX0sbS5hbGxLZXlzPWZ1bmN0aW9uKHQpe2lmKCFtLmlzT2JqZWN0KHQpKXJldHVybltdO3ZhciBlPVtdO2Zvcih2YXIgbiBpbiB0KWUucHVzaChuKTtyZXR1cm4gTCYmcSh0LGUpLGV9LG0udmFsdWVzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1tLmtleXModCksbj1lLmxlbmd0aCxyPUFycmF5KG4pLGk9MDtpPG47aSsrKXJbaV09dFtlW2ldXTtyZXR1cm4gcn0sbS5tYXBPYmplY3Q9ZnVuY3Rpb24odCxlLG4pe2U9dyhlLG4pO2Zvcih2YXIgcj1tLmtleXModCksaT1yLmxlbmd0aCxzPXt9LG89MDtvPGk7bysrKXt2YXIgYT1yW29dO3NbYV09ZSh0W2FdLGEsdCl9cmV0dXJuIHN9LG0ucGFpcnM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW0ua2V5cyh0KSxuPWUubGVuZ3RoLHI9QXJyYXkobiksaT0wO2k8bjtpKyspcltpXT1bZVtpXSx0W2VbaV1dXTtyZXR1cm4gcn0sbS5pbnZlcnQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXt9LG49bS5rZXlzKHQpLHI9MCxpPW4ubGVuZ3RoO3I8aTtyKyspZVt0W25bcl1dXT1uW3JdO3JldHVybiBlfSxtLmZ1bmN0aW9ucz1tLm1ldGhvZHM9ZnVuY3Rpb24odCl7dmFyIGU9W107Zm9yKHZhciBuIGluIHQpbS5pc0Z1bmN0aW9uKHRbbl0pJiZlLnB1c2gobik7cmV0dXJuIGUuc29ydCgpfTt2YXIgTT1mdW5jdGlvbih0LGUpe3JldHVybiBmdW5jdGlvbihuKXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoO2lmKGUmJihuPU9iamVjdChuKSkscjwyfHxudWxsPT1uKXJldHVybiBuO2Zvcih2YXIgaT0xO2k8cjtpKyspZm9yKHZhciBzPWFyZ3VtZW50c1tpXSxvPXQocyksYT1vLmxlbmd0aCx1PTA7dTxhO3UrKyl7dmFyIGM9b1t1XTtlJiZ2b2lkIDAhPT1uW2NdfHwobltjXT1zW2NdKX1yZXR1cm4gbn19O20uZXh0ZW5kPU0obS5hbGxLZXlzKSxtLmV4dGVuZE93bj1tLmFzc2lnbj1NKG0ua2V5cyksbS5maW5kS2V5PWZ1bmN0aW9uKHQsZSxuKXtlPXcoZSxuKTtmb3IodmFyIHIsaT1tLmtleXModCkscz0wLG89aS5sZW5ndGg7czxvO3MrKylpZihyPWlbc10sZSh0W3JdLHIsdCkpcmV0dXJuIHJ9O3ZhciBCPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gZSBpbiBufTttLnBpY2s9TyhmdW5jdGlvbih0LGUpe3ZhciBuPXt9LHI9ZVswXTtpZihudWxsPT10KXJldHVybiBuO20uaXNGdW5jdGlvbihyKT8oZS5sZW5ndGg+MSYmKHI9YihyLGVbMV0pKSxlPW0uYWxsS2V5cyh0KSk6KHI9QixlPUkoZSwhMSwhMSksdD1PYmplY3QodCkpO2Zvcih2YXIgaT0wLHM9ZS5sZW5ndGg7aTxzO2krKyl7dmFyIG89ZVtpXSxhPXRbb107cihhLG8sdCkmJihuW29dPWEpfXJldHVybiBufSksbS5vbWl0PU8oZnVuY3Rpb24odCxlKXt2YXIgbixyPWVbMF07cmV0dXJuIG0uaXNGdW5jdGlvbihyKT8ocj1tLm5lZ2F0ZShyKSxlLmxlbmd0aD4xJiYobj1lWzFdKSk6KGU9bS5tYXAoSShlLCExLCExKSxTdHJpbmcpLHI9ZnVuY3Rpb24odCxuKXtyZXR1cm4hbS5jb250YWlucyhlLG4pfSksbS5waWNrKHQscixuKX0pLG0uZGVmYXVsdHM9TShtLmFsbEtleXMsITApLG0uY3JlYXRlPWZ1bmN0aW9uKHQsZSl7dmFyIG49QSh0KTtyZXR1cm4gZSYmbS5leHRlbmRPd24obixlKSxufSxtLmNsb25lPWZ1bmN0aW9uKHQpe3JldHVybiBtLmlzT2JqZWN0KHQpP20uaXNBcnJheSh0KT90LnNsaWNlKCk6bS5leHRlbmQoe30sdCk6dH0sbS50YXA9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZSh0KSx0fSxtLmlzTWF0Y2g9ZnVuY3Rpb24odCxlKXt2YXIgbj1tLmtleXMoZSkscj1uLmxlbmd0aDtpZihudWxsPT10KXJldHVybiFyO2Zvcih2YXIgaT1PYmplY3QodCkscz0wO3M8cjtzKyspe3ZhciBvPW5bc107aWYoZVtvXSE9PWlbb118fCEobyBpbiBpKSlyZXR1cm4hMX1yZXR1cm4hMH07dmFyIEosVztKPWZ1bmN0aW9uKHQsZSxuLHIpe2lmKHQ9PT1lKXJldHVybiAwIT09dHx8MS90PT0xL2U7aWYobnVsbD09dHx8bnVsbD09ZSlyZXR1cm4hMTtpZih0IT09dClyZXR1cm4gZSE9PWU7dmFyIGk9dHlwZW9mIHQ7cmV0dXJuKFwiZnVuY3Rpb25cIj09PWl8fFwib2JqZWN0XCI9PT1pfHxcIm9iamVjdFwiPT10eXBlb2YgZSkmJlcodCxlLG4scil9LFc9ZnVuY3Rpb24odCxlLG4scil7dCBpbnN0YW5jZW9mIG0mJih0PXQuX3dyYXBwZWQpLGUgaW5zdGFuY2VvZiBtJiYoZT1lLl93cmFwcGVkKTt2YXIgaT1mLmNhbGwodCk7aWYoaSE9PWYuY2FsbChlKSlyZXR1cm4hMTtzd2l0Y2goaSl7Y2FzZVwiW29iamVjdCBSZWdFeHBdXCI6Y2FzZVwiW29iamVjdCBTdHJpbmddXCI6cmV0dXJuXCJcIit0PT1cIlwiK2U7Y2FzZVwiW29iamVjdCBOdW1iZXJdXCI6cmV0dXJuK3QhPSt0PytlIT0rZTowPT0rdD8xLyt0PT0xL2U6K3Q9PStlO2Nhc2VcIltvYmplY3QgRGF0ZV1cIjpjYXNlXCJbb2JqZWN0IEJvb2xlYW5dXCI6cmV0dXJuK3Q9PStlO2Nhc2VcIltvYmplY3QgU3ltYm9sXVwiOnJldHVybiBjLnZhbHVlT2YuY2FsbCh0KT09PWMudmFsdWVPZi5jYWxsKGUpfXZhciBzPVwiW29iamVjdCBBcnJheV1cIj09PWk7aWYoIXMpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxcIm9iamVjdFwiIT10eXBlb2YgZSlyZXR1cm4hMTt2YXIgbz10LmNvbnN0cnVjdG9yLGE9ZS5jb25zdHJ1Y3RvcjtpZihvIT09YSYmIShtLmlzRnVuY3Rpb24obykmJm8gaW5zdGFuY2VvZiBvJiZtLmlzRnVuY3Rpb24oYSkmJmEgaW5zdGFuY2VvZiBhKSYmXCJjb25zdHJ1Y3RvclwiaW4gdCYmXCJjb25zdHJ1Y3RvclwiaW4gZSlyZXR1cm4hMX1uPW58fFtdLHI9cnx8W107Zm9yKHZhciB1PW4ubGVuZ3RoO3UtLTspaWYoblt1XT09PXQpcmV0dXJuIHJbdV09PT1lO2lmKG4ucHVzaCh0KSxyLnB1c2goZSkscyl7aWYoKHU9dC5sZW5ndGgpIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKDt1LS07KWlmKCFKKHRbdV0sZVt1XSxuLHIpKXJldHVybiExfWVsc2V7dmFyIGwsaD1tLmtleXModCk7aWYodT1oLmxlbmd0aCxtLmtleXMoZSkubGVuZ3RoIT09dSlyZXR1cm4hMTtmb3IoO3UtLTspaWYobD1oW3VdLCFDKGUsbCl8fCFKKHRbbF0sZVtsXSxuLHIpKXJldHVybiExfXJldHVybiBuLnBvcCgpLHIucG9wKCksITB9LG0uaXNFcXVhbD1mdW5jdGlvbih0LGUpe3JldHVybiBKKHQsZSl9LG0uaXNFbXB0eT1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09dHx8KGoodCkmJihtLmlzQXJyYXkodCl8fG0uaXNTdHJpbmcodCl8fG0uaXNBcmd1bWVudHModCkpPzA9PT10Lmxlbmd0aDowPT09bS5rZXlzKHQpLmxlbmd0aCl9LG0uaXNFbGVtZW50PWZ1bmN0aW9uKHQpe3JldHVybiEoIXR8fDEhPT10Lm5vZGVUeXBlKX0sbS5pc0FycmF5PXB8fGZ1bmN0aW9uKHQpe3JldHVyblwiW29iamVjdCBBcnJheV1cIj09PWYuY2FsbCh0KX0sbS5pc09iamVjdD1mdW5jdGlvbih0KXt2YXIgZT10eXBlb2YgdDtyZXR1cm5cImZ1bmN0aW9uXCI9PT1lfHxcIm9iamVjdFwiPT09ZSYmISF0fSxtLmVhY2goW1wiQXJndW1lbnRzXCIsXCJGdW5jdGlvblwiLFwiU3RyaW5nXCIsXCJOdW1iZXJcIixcIkRhdGVcIixcIlJlZ0V4cFwiLFwiRXJyb3JcIixcIlN5bWJvbFwiLFwiTWFwXCIsXCJXZWFrTWFwXCIsXCJTZXRcIixcIldlYWtTZXRcIl0sZnVuY3Rpb24odCl7bVtcImlzXCIrdF09ZnVuY3Rpb24oZSl7cmV0dXJuIGYuY2FsbChlKT09PVwiW29iamVjdCBcIit0K1wiXVwifX0pLG0uaXNBcmd1bWVudHMoYXJndW1lbnRzKXx8KG0uaXNBcmd1bWVudHM9ZnVuY3Rpb24odCl7cmV0dXJuIEModCxcImNhbGxlZVwiKX0pO3ZhciBRPXMuZG9jdW1lbnQmJnMuZG9jdW1lbnQuY2hpbGROb2RlcztcImZ1bmN0aW9uXCIhPXR5cGVvZi8uLyYmXCJvYmplY3RcIiE9dHlwZW9mIEludDhBcnJheSYmXCJmdW5jdGlvblwiIT10eXBlb2YgUSYmKG0uaXNGdW5jdGlvbj1mdW5jdGlvbih0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0fHwhMX0pLG0uaXNGaW5pdGU9ZnVuY3Rpb24odCl7cmV0dXJuIW0uaXNTeW1ib2wodCkmJmlzRmluaXRlKHQpJiYhaXNOYU4ocGFyc2VGbG9hdCh0KSl9LG0uaXNOYU49ZnVuY3Rpb24odCl7cmV0dXJuIG0uaXNOdW1iZXIodCkmJmlzTmFOKHQpfSxtLmlzQm9vbGVhbj1mdW5jdGlvbih0KXtyZXR1cm4hMD09PXR8fCExPT09dHx8XCJbb2JqZWN0IEJvb2xlYW5dXCI9PT1mLmNhbGwodCl9LG0uaXNOdWxsPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT09dH0sbS5pc1VuZGVmaW5lZD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dH0sbS5oYXM9ZnVuY3Rpb24odCxlKXtpZighbS5pc0FycmF5KGUpKXJldHVybiBDKHQsZSk7Zm9yKHZhciBuPWUubGVuZ3RoLHI9MDtyPG47cisrKXt2YXIgaT1lW3JdO2lmKG51bGw9PXR8fCFkLmNhbGwodCxpKSlyZXR1cm4hMTt0PXRbaV19cmV0dXJuISFufSxtLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gcy5fPW8sdGhpc30sbS5pZGVudGl0eT1mdW5jdGlvbih0KXtyZXR1cm4gdH0sbS5jb25zdGFudD1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdH19LG0ubm9vcD1mdW5jdGlvbigpe30sbS5wcm9wZXJ0eT1mdW5jdGlvbih0KXtyZXR1cm4gbS5pc0FycmF5KHQpP2Z1bmN0aW9uKGUpe3JldHVybiBFKGUsdCl9OlModCl9LG0ucHJvcGVydHlPZj1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09dD9mdW5jdGlvbigpe306ZnVuY3Rpb24oZSl7cmV0dXJuIG0uaXNBcnJheShlKT9FKHQsZSk6dFtlXX19LG0ubWF0Y2hlcj1tLm1hdGNoZXM9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9bS5leHRlbmRPd24oe30sdCksZnVuY3Rpb24oZSl7cmV0dXJuIG0uaXNNYXRjaChlLHQpfX0sbS50aW1lcz1mdW5jdGlvbih0LGUsbil7dmFyIHI9QXJyYXkoTWF0aC5tYXgoMCx0KSk7ZT1iKGUsbiwxKTtmb3IodmFyIGk9MDtpPHQ7aSsrKXJbaV09ZShpKTtyZXR1cm4gcn0sbS5yYW5kb209ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09ZSYmKGU9dCx0PTApLHQrTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKihlLXQrMSkpfSxtLm5vdz1EYXRlLm5vd3x8ZnVuY3Rpb24oKXtyZXR1cm4obmV3IERhdGUpLmdldFRpbWUoKX07dmFyIFY9e1wiJlwiOlwiJmFtcDtcIixcIjxcIjpcIiZsdDtcIixcIj5cIjpcIiZndDtcIiwnXCInOlwiJnF1b3Q7XCIsXCInXCI6XCImI3gyNztcIixcImBcIjpcIiYjeDYwO1wifSxLPW0uaW52ZXJ0KFYpLHo9ZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19LG49XCIoPzpcIittLmtleXModCkuam9pbihcInxcIikrXCIpXCIscj1SZWdFeHAobiksaT1SZWdFeHAobixcImdcIik7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiB0PW51bGw9PXQ/XCJcIjpcIlwiK3Qsci50ZXN0KHQpP3QucmVwbGFjZShpLGUpOnR9fTttLmVzY2FwZT16KFYpLG0udW5lc2NhcGU9eihLKSxtLnJlc3VsdD1mdW5jdGlvbih0LGUsbil7bS5pc0FycmF5KGUpfHwoZT1bZV0pO3ZhciByPWUubGVuZ3RoO2lmKCFyKXJldHVybiBtLmlzRnVuY3Rpb24obik/bi5jYWxsKHQpOm47Zm9yKHZhciBpPTA7aTxyO2krKyl7dmFyIHM9bnVsbD09dD92b2lkIDA6dFtlW2ldXTt2b2lkIDA9PT1zJiYocz1uLGk9ciksdD1tLmlzRnVuY3Rpb24ocyk/cy5jYWxsKHQpOnN9cmV0dXJuIHR9O3ZhciBHPTA7bS51bmlxdWVJZD1mdW5jdGlvbih0KXt2YXIgZT0rK0crXCJcIjtyZXR1cm4gdD90K2U6ZX0sbS50ZW1wbGF0ZVNldHRpbmdzPXtldmFsdWF0ZTovPCUoW1xcc1xcU10rPyklPi9nLGludGVycG9sYXRlOi88JT0oW1xcc1xcU10rPyklPi9nLGVzY2FwZTovPCUtKFtcXHNcXFNdKz8pJT4vZ307dmFyIEg9LyguKV4vLCQ9e1wiJ1wiOlwiJ1wiLFwiXFxcXFwiOlwiXFxcXFwiLFwiXFxyXCI6XCJyXCIsXCJcXG5cIjpcIm5cIixcIlxcdTIwMjhcIjpcInUyMDI4XCIsXCJcXHUyMDI5XCI6XCJ1MjAyOVwifSxYPS9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZyxZPWZ1bmN0aW9uKHQpe3JldHVyblwiXFxcXFwiKyRbdF19O20udGVtcGxhdGU9ZnVuY3Rpb24odCxlLG4peyFlJiZuJiYoZT1uKSxlPW0uZGVmYXVsdHMoe30sZSxtLnRlbXBsYXRlU2V0dGluZ3MpO3ZhciByPVJlZ0V4cChbKGUuZXNjYXBlfHxIKS5zb3VyY2UsKGUuaW50ZXJwb2xhdGV8fEgpLnNvdXJjZSwoZS5ldmFsdWF0ZXx8SCkuc291cmNlXS5qb2luKFwifFwiKStcInwkXCIsXCJnXCIpLGk9MCxzPVwiX19wKz0nXCI7dC5yZXBsYWNlKHIsZnVuY3Rpb24oZSxuLHIsbyxhKXtyZXR1cm4gcys9dC5zbGljZShpLGEpLnJlcGxhY2UoWCxZKSxpPWErZS5sZW5ndGgsbj9zKz1cIicrXFxuKChfX3Q9KFwiK24rXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI6cj9zKz1cIicrXFxuKChfX3Q9KFwiK3IrXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjpvJiYocys9XCInO1xcblwiK28rXCJcXG5fX3ArPSdcIiksZX0pLHMrPVwiJztcXG5cIixlLnZhcmlhYmxlfHwocz1cIndpdGgob2JqfHx7fSl7XFxuXCIrcytcIn1cXG5cIikscz1cInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiK3MrXCJyZXR1cm4gX19wO1xcblwiO3ZhciBvO3RyeXtvPW5ldyBGdW5jdGlvbihlLnZhcmlhYmxlfHxcIm9ialwiLFwiX1wiLHMpfWNhdGNoKHQpe3Rocm93IHQuc291cmNlPXMsdH12YXIgYT1mdW5jdGlvbih0KXtyZXR1cm4gby5jYWxsKHRoaXMsdCxtKX07cmV0dXJuIGEuc291cmNlPVwiZnVuY3Rpb24oXCIrKGUudmFyaWFibGV8fFwib2JqXCIpK1wiKXtcXG5cIitzK1wifVwiLGF9LG0uY2hhaW49ZnVuY3Rpb24odCl7dmFyIGU9bSh0KTtyZXR1cm4gZS5fY2hhaW49ITAsZX07dmFyIFo9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5fY2hhaW4/bShlKS5jaGFpbigpOmV9O20ubWl4aW49ZnVuY3Rpb24odCl7cmV0dXJuIG0uZWFjaChtLmZ1bmN0aW9ucyh0KSxmdW5jdGlvbihlKXt2YXIgbj1tW2VdPXRbZV07bS5wcm90b3R5cGVbZV09ZnVuY3Rpb24oKXt2YXIgdD1bdGhpcy5fd3JhcHBlZF07cmV0dXJuIGwuYXBwbHkodCxhcmd1bWVudHMpLFoodGhpcyxuLmFwcGx5KG0sdCkpfX0pLG19LG0ubWl4aW4obSksbS5lYWNoKFtcInBvcFwiLFwicHVzaFwiLFwicmV2ZXJzZVwiLFwic2hpZnRcIixcInNvcnRcIixcInNwbGljZVwiLFwidW5zaGlmdFwiXSxmdW5jdGlvbih0KXt2YXIgZT1hW3RdO20ucHJvdG90eXBlW3RdPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy5fd3JhcHBlZDtyZXR1cm4gZS5hcHBseShuLGFyZ3VtZW50cyksXCJzaGlmdFwiIT09dCYmXCJzcGxpY2VcIiE9PXR8fDAhPT1uLmxlbmd0aHx8ZGVsZXRlIG5bMF0sWih0aGlzLG4pfX0pLG0uZWFjaChbXCJjb25jYXRcIixcImpvaW5cIixcInNsaWNlXCJdLGZ1bmN0aW9uKHQpe3ZhciBlPWFbdF07bS5wcm90b3R5cGVbdF09ZnVuY3Rpb24oKXtyZXR1cm4gWih0aGlzLGUuYXBwbHkodGhpcy5fd3JhcHBlZCxhcmd1bWVudHMpKX19KSxtLnByb3RvdHlwZS52YWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl93cmFwcGVkfSxtLnByb3RvdHlwZS52YWx1ZU9mPW0ucHJvdG90eXBlLnRvSlNPTj1tLnByb3RvdHlwZS52YWx1ZSxtLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiBTdHJpbmcodGhpcy5fd3JhcHBlZCl9LHI9W10sdm9pZCAwIT09KGk9ZnVuY3Rpb24oKXtyZXR1cm4gbX0uYXBwbHkoZSxyKSkmJihuLmV4cG9ydHM9aSl9KCl9KS5jYWxsKGUsbig3KSxuKDE2KSh0KSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj0obigwKSxuKDI2KS5Qcm9taXNlKTtyLl9jb250aW51ZVdoaWxlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQoKT9lKCkudGhlbihmdW5jdGlvbigpe3JldHVybiByLl9jb250aW51ZVdoaWxlKHQsZSl9KTpyLnJlc29sdmUoKX0sdC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLGk9big0MSkscz1uKDApLG89cy5leHRlbmQsYT1uKDEpLHU9big1KSxjPW4oMyksbD1jLmdldFNlc3Npb25Ub2tlbixoPWMuYWpheCxmPWZ1bmN0aW9uKHQsZSl7dmFyIG49KG5ldyBEYXRlKS5nZXRUaW1lKCkscj1pKG4rdCk7cmV0dXJuIGU/citcIixcIituK1wiLG1hc3RlclwiOnIrXCIsXCIrbn0sZD1mdW5jdGlvbih0LGUpe2U/dFtcIlgtTEMtU2lnblwiXT1mKHUuYXBwbGljYXRpb25LZXkpOnRbXCJYLUxDLUtleVwiXT11LmFwcGxpY2F0aW9uS2V5fSxwPWZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LGU9YXJndW1lbnRzWzFdLG49e1wiWC1MQy1JZFwiOnUuYXBwbGljYXRpb25JZCxcIkNvbnRlbnQtVHlwZVwiOlwiYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04XCJ9LHI9ITE7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiB0LnVzZU1hc3RlcktleT9yPXQudXNlTWFzdGVyS2V5OlwiYm9vbGVhblwiPT10eXBlb2YgdS5fY29uZmlnLnVzZU1hc3RlcktleSYmKHI9dS5fY29uZmlnLnVzZU1hc3RlcktleSkscj91Lm1hc3RlcktleT9lP25bXCJYLUxDLVNpZ25cIl09Zih1Lm1hc3RlcktleSwhMCk6bltcIlgtTEMtS2V5XCJdPXUubWFzdGVyS2V5K1wiLG1hc3RlclwiOihjb25zb2xlLndhcm4oXCJtYXN0ZXJLZXkgaXMgbm90IHNldCwgZmFsbCBiYWNrIHRvIHVzZSBhcHBLZXlcIiksZChuLGUpKTpkKG4sZSksdS5ob29rS2V5JiYobltcIlgtTEMtSG9vay1LZXlcIl09dS5ob29rS2V5KSxudWxsIT09dS5fY29uZmlnLnByb2R1Y3Rpb24mJihuW1wiWC1MQy1Qcm9kXCJdPVN0cmluZyh1Ll9jb25maWcucHJvZHVjdGlvbikpLG5bXCJYLUxDLVVBXCJdPXUuX3NoYXJlZENvbmZpZy51c2VyQWdlbnQsYS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpe3ZhciBlPWwodCk7aWYoZSluW1wiWC1MQy1TZXNzaW9uXCJdPWU7ZWxzZSBpZighdS5fY29uZmlnLmRpc2FibGVDdXJyZW50VXNlcilyZXR1cm4gdS5Vc2VyLmN1cnJlbnRBc3luYygpLnRoZW4oZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuX3Nlc3Npb25Ub2tlbiYmKG5bXCJYLUxDLVNlc3Npb25cIl09dC5fc2Vzc2lvblRva2VuKSxufSk7cmV0dXJuIG59KX0sXz1mdW5jdGlvbih0KXt2YXIgZT10LnNlcnZpY2Usbj12b2lkIDA9PT1lP1wiYXBpXCI6ZSxyPXQudmVyc2lvbixpPXZvaWQgMD09PXI/XCIxLjFcIjpyLHM9dC5wYXRoLG89dS5fY29uZmlnLnNlcnZlclVSTHNbbl07aWYoIW8pdGhyb3cgbmV3IEVycm9yKFwidW5kZWZpbmVkIHNlcnZlciBVUkwgZm9yIFwiK24pO3JldHVyblwiL1wiIT09by5jaGFyQXQoby5sZW5ndGgtMSkmJihvKz1cIi9cIiksbys9aSxzJiYobys9cyksb30sdj1mdW5jdGlvbih0KXt2YXIgZT10LnNlcnZpY2Usbj10LnZlcnNpb24saT10Lm1ldGhvZCxzPXQucGF0aCxvPXQucXVlcnksYT10LmRhdGEsYz10LmF1dGhPcHRpb25zLGw9dC5zaWduS2V5LGY9dm9pZCAwPT09bHx8bDtpZighdS5hcHBsaWNhdGlvbklkfHwhdS5hcHBsaWNhdGlvbktleSYmIXUubWFzdGVyS2V5KXRocm93IG5ldyBFcnJvcihcIk5vdCBpbml0aWFsaXplZFwiKTt1Ll9hcHBSb3V0ZXIucmVmcmVzaCgpO3ZhciBkPXUuX2NvbmZpZy5yZXF1ZXN0VGltZW91dCx2PV8oe3NlcnZpY2U6ZSxwYXRoOnMsdmVyc2lvbjpufSk7cmV0dXJuIHAoYyxmKS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiBoKHttZXRob2Q6aSx1cmw6dixxdWVyeTpvLGRhdGE6YSxoZWFkZXJzOnQsdGltZW91dDpkfSkuY2F0Y2goZnVuY3Rpb24odCl7dmFyIGU9e2NvZGU6dC5jb2RlfHwtMSxlcnJvcjp0Lm1lc3NhZ2V8fHQucmVzcG9uc2VUZXh0fTtpZih0LnJlc3BvbnNlJiZ0LnJlc3BvbnNlLmNvZGUpZT10LnJlc3BvbnNlO2Vsc2UgaWYodC5yZXNwb25zZVRleHQpdHJ5e2U9SlNPTi5wYXJzZSh0LnJlc3BvbnNlVGV4dCl9Y2F0Y2godCl7fWUucmF3TWVzc2FnZT1lLnJhd01lc3NhZ2V8fGUuZXJyb3IsdS5fc2hhcmVkQ29uZmlnLmtlZXBFcnJvclJhd01lc3NhZ2V8fChlLmVycm9yKz1cIiBbXCIrKHQuc3RhdHVzQ29kZXx8XCJOL0FcIikrXCIgXCIraStcIiBcIit2K1wiXVwiKTt2YXIgbj1uZXcgRXJyb3IoZS5lcnJvcik7dGhyb3cgZGVsZXRlIGUuZXJyb3Isci5leHRlbmQobixlKX0pfSl9LHk9ZnVuY3Rpb24odCxlLG4scixpLHMsYSl7dmFyIHU9XCJcIjtpZih0JiYodSs9XCIvXCIrdCksZSYmKHUrPVwiL1wiK2UpLG4mJih1Kz1cIi9cIituKSxpJiZpLl9mZXRjaFdoZW5TYXZlKXRocm93IG5ldyBFcnJvcihcIl9mZXRjaFdoZW5TYXZlIHNob3VsZCBiZSBpbiB0aGUgcXVlcnlcIik7aWYoaSYmaS5fd2hlcmUpdGhyb3cgbmV3IEVycm9yKFwiX3doZXJlIHNob3VsZCBiZSBpbiB0aGUgcXVlcnlcIik7cmV0dXJuIHImJlwiZ2V0XCI9PT1yLnRvTG93ZXJDYXNlKCkmJihhPW8oe30sYSxpKSxpPW51bGwpLHYoe21ldGhvZDpyLHBhdGg6dSxxdWVyeTphLGRhdGE6aSxhdXRoT3B0aW9uczpzfSl9O3UucmVxdWVzdD12LHQuZXhwb3J0cz17X3JlcXVlc3Q6eSxyZXF1ZXN0OnZ9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXt2YXIgZT1uZXcgUmVnRXhwKFwiXihbMC05XXsxLDR9KS0oWzAtOV17MSwyfSktKFswLTldezEsMn0pVChbMC05XXsxLDJ9KTooWzAtOV17MSwyfSk6KFswLTldezEsMn0pKC4oWzAtOV0rKSk/WiRcIiksbj1lLmV4ZWModCk7aWYoIW4pcmV0dXJuIG51bGw7dmFyIHI9blsxXXx8MCxpPShuWzJdfHwxKS0xLHM9blszXXx8MCxvPW5bNF18fDAsYT1uWzVdfHwwLHU9bls2XXx8MCxjPW5bOF18fDA7cmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHIsaSxzLG8sYSx1LGMpKX12YXIgaT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSxzPW4oMCksbz1uKDgpLGE9big2KSx1PWEoXCJsZWFuY2xvdWQ6cmVxdWVzdFwiKSxjPWEoXCJsZWFuY2xvdWQ6cmVxdWVzdDplcnJvclwiKSxsPW4oMSksaD0wLGY9ZnVuY3Rpb24odCl7dmFyIGU9dC5tZXRob2Qsbj10LnVybCxyPXQucXVlcnkscz10LmRhdGEsZj10LmhlYWRlcnMsZD12b2lkIDA9PT1mP3t9OmYscD10Lm9ucHJvZ3Jlc3MsXz10LnRpbWVvdXQsdj1oKys7dShcInJlcXVlc3QoJWQpICVzICVzICVvICVvICVvXCIsdixlLG4scixzLGQpO3ZhciB5PXt9O2lmKHIpZm9yKHZhciBtIGluIHIpXCJvYmplY3RcIj09PWkoclttXSk/eVttXT1KU09OLnN0cmluZ2lmeShyW21dKTp5W21dPXJbbV07cmV0dXJuIG5ldyBsKGZ1bmN0aW9uKHQsaSl7dmFyIGw9byhlLG4pLnNldChkKS5xdWVyeSh5KS5zZW5kKHMpO3AmJmwub24oXCJwcm9ncmVzc1wiLHApLF8mJmwudGltZW91dChfKSxsLmVuZChmdW5jdGlvbihvLGwpe3JldHVybiBvPyhsJiYoYS5lbmFibGVkKFwibGVhbmNsb3VkOnJlcXVlc3RcIil8fGMoXCJyZXF1ZXN0KCVkKSAlcyAlcyAlbyAlbyAlb1wiLHYsZSxuLHIscyxkKSxjKFwicmVzcG9uc2UoJWQpICVkICVPICVvXCIsdixsLnN0YXR1cyxsLmJvZHl8fGwudGV4dCxsLmhlYWRlciksby5zdGF0dXNDb2RlPWwuc3RhdHVzLG8ucmVzcG9uc2VUZXh0PWwudGV4dCxvLnJlc3BvbnNlPWwuYm9keSksaShvKSk6KHUoXCJyZXNwb25zZSglZCkgJWQgJU8gJW9cIix2LGwuc3RhdHVzLGwuYm9keXx8bC50ZXh0LGwuaGVhZGVyKSx0KGwuYm9keSkpfSl9KX0sZD1mdW5jdGlvbih0KXtyZXR1cm4gcy5pc051bGwodCl8fHMuaXNVbmRlZmluZWQodCl9LHA9ZnVuY3Rpb24odCl7cmV0dXJuIHMuaXNBcnJheSh0KT90OnZvaWQgMD09PXR8fG51bGw9PT10P1tdOlt0XX0sXz1mdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSxlPXQua2V5cyxuPXQuaW5jbHVkZSxyPXQuaW5jbHVkZUFDTCxpPXt9O3JldHVybiBlJiYoaS5rZXlzPXAoZSkuam9pbihcIixcIikpLG4mJihpLmluY2x1ZGU9cChuKS5qb2luKFwiLFwiKSksciYmKGkucmV0dXJuQUNMPXIpLGl9LHY9ZnVuY3Rpb24odCl7cmV0dXJuIHQuc2Vzc2lvblRva2VuP3Quc2Vzc2lvblRva2VuOnQudXNlciYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC51c2VyLmdldFNlc3Npb25Ub2tlbj90LnVzZXIuZ2V0U2Vzc2lvblRva2VuKCk6dm9pZCAwfSx5PWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gdChlKSxlfX0sbT1mdW5jdGlvbigpe30sZz1mdW5jdGlvbih0LGUsbil7dmFyIHI7cmV0dXJuIHI9ZSYmZS5oYXNPd25Qcm9wZXJ0eShcImNvbnN0cnVjdG9yXCIpP2UuY29uc3RydWN0b3I6ZnVuY3Rpb24oKXt0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0scy5leHRlbmQocix0KSxtLnByb3RvdHlwZT10LnByb3RvdHlwZSxyLnByb3RvdHlwZT1uZXcgbSxlJiZzLmV4dGVuZChyLnByb3RvdHlwZSxlKSxuJiZzLmV4dGVuZChyLG4pLHIucHJvdG90eXBlLmNvbnN0cnVjdG9yPXIsci5fX3N1cGVyX189dC5wcm90b3R5cGUscn0sYj1mdW5jdGlvbih0LGUsbil7dmFyIHI9ZS5zcGxpdChcIi5cIiksaT1yLnBvcCgpLHM9dDtyZXR1cm4gci5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZvaWQgMD09PXNbdF0mJihzW3RdPXt9KSxzPXNbdF19KSxzW2ldPW4sdH0sdz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lLnNwbGl0KFwiLlwiKSxyPW5bMF0saT1uLnBvcCgpLHM9dCxvPTA7bzxuLmxlbmd0aDtvKyspaWYodm9pZCAwPT09KHM9c1tuW29dXSkpcmV0dXJuW3ZvaWQgMCx2b2lkIDAsaV07cmV0dXJuW3NbaV0scyxpLHJdfSxPPWZ1bmN0aW9uKHQpe3JldHVybiBzLmlzT2JqZWN0KHQpJiZPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk9PT1PYmplY3QucHJvdG90eXBlfTt0LmV4cG9ydHM9e2FqYXg6Zixpc051bGxPclVuZGVmaW5lZDpkLGVuc3VyZUFycmF5OnAsdHJhbnNmb3JtRmV0Y2hPcHRpb25zOl8sZ2V0U2Vzc2lvblRva2VuOnYsdGFwOnksaW5oZXJpdHM6ZyxwYXJzZURhdGU6cixzZXRWYWx1ZTpiLGZpbmRWYWx1ZTp3LGlzUGxhaW5PYmplY3Q6T319LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQsZSl7dmFyIG49bmV3IEVycm9yKGUpO3JldHVybiBuLmNvZGU9dCxufW4oMCkuZXh0ZW5kKHIse09USEVSX0NBVVNFOi0xLElOVEVSTkFMX1NFUlZFUl9FUlJPUjoxLENPTk5FQ1RJT05fRkFJTEVEOjEwMCxPQkpFQ1RfTk9UX0ZPVU5EOjEwMSxJTlZBTElEX1FVRVJZOjEwMixJTlZBTElEX0NMQVNTX05BTUU6MTAzLE1JU1NJTkdfT0JKRUNUX0lEOjEwNCxJTlZBTElEX0tFWV9OQU1FOjEwNSxJTlZBTElEX1BPSU5URVI6MTA2LElOVkFMSURfSlNPTjoxMDcsQ09NTUFORF9VTkFWQUlMQUJMRToxMDgsTk9UX0lOSVRJQUxJWkVEOjEwOSxJTkNPUlJFQ1RfVFlQRToxMTEsSU5WQUxJRF9DSEFOTkVMX05BTUU6MTEyLFBVU0hfTUlTQ09ORklHVVJFRDoxMTUsT0JKRUNUX1RPT19MQVJHRToxMTYsT1BFUkFUSU9OX0ZPUkJJRERFTjoxMTksQ0FDSEVfTUlTUzoxMjAsSU5WQUxJRF9ORVNURURfS0VZOjEyMSxJTlZBTElEX0ZJTEVfTkFNRToxMjIsSU5WQUxJRF9BQ0w6MTIzLFRJTUVPVVQ6MTI0LElOVkFMSURfRU1BSUxfQUREUkVTUzoxMjUsTUlTU0lOR19DT05URU5UX1RZUEU6MTI2LE1JU1NJTkdfQ09OVEVOVF9MRU5HVEg6MTI3LElOVkFMSURfQ09OVEVOVF9MRU5HVEg6MTI4LEZJTEVfVE9PX0xBUkdFOjEyOSxGSUxFX1NBVkVfRVJST1I6MTMwLEZJTEVfREVMRVRFX0VSUk9SOjE1MyxEVVBMSUNBVEVfVkFMVUU6MTM3LElOVkFMSURfUk9MRV9OQU1FOjEzOSxFWENFRURFRF9RVU9UQToxNDAsU0NSSVBUX0ZBSUxFRDoxNDEsVkFMSURBVElPTl9FUlJPUjoxNDIsSU5WQUxJRF9JTUFHRV9EQVRBOjE1MCxVTlNBVkVEX0ZJTEVfRVJST1I6MTUxLElOVkFMSURfUFVTSF9USU1FX0VSUk9SOjE1MixVU0VSTkFNRV9NSVNTSU5HOjIwMCxQQVNTV09SRF9NSVNTSU5HOjIwMSxVU0VSTkFNRV9UQUtFTjoyMDIsRU1BSUxfVEFLRU46MjAzLEVNQUlMX01JU1NJTkc6MjA0LEVNQUlMX05PVF9GT1VORDoyMDUsU0VTU0lPTl9NSVNTSU5HOjIwNixNVVNUX0NSRUFURV9VU0VSX1RIUk9VR0hfU0lHTlVQOjIwNyxBQ0NPVU5UX0FMUkVBRFlfTElOS0VEOjIwOCxMSU5LRURfSURfTUlTU0lORzoyNTAsSU5WQUxJRF9MSU5LRURfU0VTU0lPTjoyNTEsVU5TVVBQT1JURURfU0VSVklDRToyNTIsWF9ET01BSU5fUkVRVUVTVDo2MDJ9KSx0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiOyhmdW5jdGlvbihlKXt2YXIgcj1uKDApLGk9bigxNykscz1uKDMpLG89cy5pbmhlcml0cyxhPXMucGFyc2VEYXRlLHU9ZS5BVnx8e307dS5fY29uZmlnPXtzZXJ2ZXJVUkxzOnt9LHVzZU1hc3RlcktleTohMSxwcm9kdWN0aW9uOm51bGwscmVhbHRpbWU6bnVsbCxyZXF1ZXN0VGltZW91dDpudWxsfSx1Ll9zaGFyZWRDb25maWc9e3VzZXJBZ2VudDppLGxpdmVRdWVyeVJlYWx0aW1lOm51bGx9LHUuX2dldEFWUGF0aD1mdW5jdGlvbih0KXtpZighdS5hcHBsaWNhdGlvbklkKXRocm93IG5ldyBFcnJvcihcIllvdSBuZWVkIHRvIGNhbGwgQVYuaW5pdGlhbGl6ZSBiZWZvcmUgdXNpbmcgQVYuXCIpO2lmKHR8fCh0PVwiXCIpLCFyLmlzU3RyaW5nKHQpKXRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGdldCBhIGxvY2FsU3RvcmFnZSBwYXRoIHRoYXQgd2Fzbid0IGEgU3RyaW5nLlwiKTtyZXR1cm5cIi9cIj09PXRbMF0mJih0PXQuc3Vic3RyaW5nKDEpKSxcIkFWL1wiK3UuYXBwbGljYXRpb25JZCtcIi9cIit0fTt2YXIgYz1mdW5jdGlvbigpe3JldHVybiBNYXRoLmZsb29yKDY1NTM2KigxK01hdGgucmFuZG9tKCkpKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpfSxsPWZ1bmN0aW9uKCl7cmV0dXJuXCJcIitjKCkrYygpK1wiLVwiK2MoKStcIi1cIitjKCkrXCItXCIrYygpK1wiLVwiK2MoKStjKCkrYygpfTt1Ll9pbnN0YWxsYXRpb25JZD1udWxsLHUuX2dldEluc3RhbGxhdGlvbklkPWZ1bmN0aW9uKCl7aWYodS5faW5zdGFsbGF0aW9uSWQpcmV0dXJuIHUuUHJvbWlzZS5yZXNvbHZlKHUuX2luc3RhbGxhdGlvbklkKTt2YXIgdD11Ll9nZXRBVlBhdGgoXCJpbnN0YWxsYXRpb25JZFwiKTtyZXR1cm4gdS5sb2NhbFN0b3JhZ2UuZ2V0SXRlbUFzeW5jKHQpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHUuX2luc3RhbGxhdGlvbklkPWUsdS5faW5zdGFsbGF0aW9uSWQ/ZToodS5faW5zdGFsbGF0aW9uSWQ9ZT1sKCksdS5sb2NhbFN0b3JhZ2Uuc2V0SXRlbUFzeW5jKHQsZSkudGhlbihmdW5jdGlvbigpe3JldHVybiBlfSkpfSl9LHUuX3N1YnNjcmlwdGlvbklkPW51bGwsdS5fcmVmcmVzaFN1YnNjcmlwdGlvbklkPWZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnUuX2dldEFWUGF0aChcInN1YnNjcmlwdGlvbklkXCIpLGU9dS5fc3Vic2NyaXB0aW9uSWQ9bCgpO3JldHVybiB1LmxvY2FsU3RvcmFnZS5zZXRJdGVtQXN5bmModCxlKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGV9KX0sdS5fZ2V0U3Vic2NyaXB0aW9uSWQ9ZnVuY3Rpb24oKXtpZih1Ll9zdWJzY3JpcHRpb25JZClyZXR1cm4gdS5Qcm9taXNlLnJlc29sdmUodS5fc3Vic2NyaXB0aW9uSWQpO3ZhciB0PXUuX2dldEFWUGF0aChcInN1YnNjcmlwdGlvbklkXCIpO3JldHVybiB1LmxvY2FsU3RvcmFnZS5nZXRJdGVtQXN5bmModCkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gdS5fc3Vic2NyaXB0aW9uSWQ9ZSx1Ll9zdWJzY3JpcHRpb25JZHx8KGU9dS5fcmVmcmVzaFN1YnNjcmlwdGlvbklkKHQpKSxlfSl9LHUuX3BhcnNlRGF0ZT1hLHUuX2V4dGVuZD1mdW5jdGlvbih0LGUpe3ZhciBuPW8odGhpcyx0LGUpO3JldHVybiBuLmV4dGVuZD10aGlzLmV4dGVuZCxufSx1Ll9lbmNvZGU9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPSEoYXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10pfHxhcmd1bWVudHNbM107aWYodCBpbnN0YW5jZW9mIHUuT2JqZWN0KXtpZihuKXRocm93IG5ldyBFcnJvcihcIkFWLk9iamVjdHMgbm90IGFsbG93ZWQgaGVyZVwiKTtyZXR1cm4gZSYmIXIuaW5jbHVkZShlLHQpJiZ0Ll9oYXNEYXRhP3QuX3RvRnVsbEpTT04oZS5jb25jYXQodCksaSk6dC5fdG9Qb2ludGVyKCl9aWYodCBpbnN0YW5jZW9mIHUuQUNMKXJldHVybiB0LnRvSlNPTigpO2lmKHIuaXNEYXRlKHQpKXJldHVybiBpP3tfX3R5cGU6XCJEYXRlXCIsaXNvOnQudG9KU09OKCl9OnQudG9KU09OKCk7aWYodCBpbnN0YW5jZW9mIHUuR2VvUG9pbnQpcmV0dXJuIHQudG9KU09OKCk7aWYoci5pc0FycmF5KHQpKXJldHVybiByLm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiB1Ll9lbmNvZGUodCxlLG4saSl9KTtpZihyLmlzUmVnRXhwKHQpKXJldHVybiB0LnNvdXJjZTtpZih0IGluc3RhbmNlb2YgdS5SZWxhdGlvbilyZXR1cm4gdC50b0pTT04oKTtpZih0IGluc3RhbmNlb2YgdS5PcClyZXR1cm4gdC50b0pTT04oKTtpZih0IGluc3RhbmNlb2YgdS5GaWxlKXtpZighdC51cmwoKSYmIXQuaWQpdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gc2F2ZSBhbiBvYmplY3QgY29udGFpbmluZyBhbiB1bnNhdmVkIGZpbGUuXCIpO3JldHVybiB0Ll90b0Z1bGxKU09OKGUsaSl9cmV0dXJuIHIuaXNPYmplY3QodCk/ci5tYXBPYmplY3QodCxmdW5jdGlvbih0LHIpe3JldHVybiB1Ll9lbmNvZGUodCxlLG4saSl9KTp0fSx1Ll9kZWNvZGU9ZnVuY3Rpb24odCxlKXtpZighci5pc09iamVjdCh0KXx8ci5pc0RhdGUodCkpcmV0dXJuIHQ7aWYoci5pc0FycmF5KHQpKXJldHVybiByLm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiB1Ll9kZWNvZGUodCl9KTtpZih0IGluc3RhbmNlb2YgdS5PYmplY3QpcmV0dXJuIHQ7aWYodCBpbnN0YW5jZW9mIHUuRmlsZSlyZXR1cm4gdDtpZih0IGluc3RhbmNlb2YgdS5PcClyZXR1cm4gdDtpZih0IGluc3RhbmNlb2YgdS5HZW9Qb2ludClyZXR1cm4gdDtpZih0IGluc3RhbmNlb2YgdS5BQ0wpcmV0dXJuIHQ7aWYoXCJBQ0xcIj09PWUpcmV0dXJuIG5ldyB1LkFDTCh0KTtpZih0Ll9fb3ApcmV0dXJuIHUuT3AuX2RlY29kZSh0KTt2YXIgbjtpZihcIlBvaW50ZXJcIj09PXQuX190eXBlKXtuPXQuY2xhc3NOYW1lO3ZhciBpPXUuT2JqZWN0Ll9jcmVhdGUobik7aWYoT2JqZWN0LmtleXModCkubGVuZ3RoPjMpe3ZhciBzPXIuY2xvbmUodCk7ZGVsZXRlIHMuX190eXBlLGRlbGV0ZSBzLmNsYXNzTmFtZSxpLl9maW5pc2hGZXRjaChzLCEwKX1lbHNlIGkuX2ZpbmlzaEZldGNoKHtvYmplY3RJZDp0Lm9iamVjdElkfSwhMSk7cmV0dXJuIGl9aWYoXCJPYmplY3RcIj09PXQuX190eXBlKXtuPXQuY2xhc3NOYW1lO3ZhciBvPXIuY2xvbmUodCk7ZGVsZXRlIG8uX190eXBlLGRlbGV0ZSBvLmNsYXNzTmFtZTt2YXIgYT11Lk9iamVjdC5fY3JlYXRlKG4pO3JldHVybiBhLl9maW5pc2hGZXRjaChvLCEwKSxhfWlmKFwiRGF0ZVwiPT09dC5fX3R5cGUpcmV0dXJuIHUuX3BhcnNlRGF0ZSh0Lmlzbyk7aWYoXCJHZW9Qb2ludFwiPT09dC5fX3R5cGUpcmV0dXJuIG5ldyB1Lkdlb1BvaW50KHtsYXRpdHVkZTp0LmxhdGl0dWRlLGxvbmdpdHVkZTp0LmxvbmdpdHVkZX0pO2lmKFwiUmVsYXRpb25cIj09PXQuX190eXBlKXtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJrZXkgbWlzc2luZyBkZWNvZGluZyBhIFJlbGF0aW9uXCIpO3ZhciBjPW5ldyB1LlJlbGF0aW9uKG51bGwsZSk7cmV0dXJuIGMudGFyZ2V0Q2xhc3NOYW1lPXQuY2xhc3NOYW1lLGN9aWYoXCJGaWxlXCI9PT10Ll9fdHlwZSl7dmFyIGw9bmV3IHUuRmlsZSh0Lm5hbWUpLGg9ci5jbG9uZSh0KTtyZXR1cm4gZGVsZXRlIGguX190eXBlLGwuX2ZpbmlzaEZldGNoKGgpLGx9cmV0dXJuIHIubWFwT2JqZWN0KHQsdS5fZGVjb2RlKX0sdS5wYXJzZUpTT049dS5fZGVjb2RlLHUuX2VuY29kZU9iamVjdE9yQXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuX3RvRnVsbEpTT04mJih0PXQuX3RvRnVsbEpTT04oW10pKSxyLm1hcE9iamVjdCh0LGZ1bmN0aW9uKHQpe3JldHVybiB1Ll9lbmNvZGUodCxbXSl9KX07cmV0dXJuIHIuaXNBcnJheSh0KT90Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZSh0KX0pOmUodCl9LHUuX2FycmF5RWFjaD1yLmVhY2gsdS5fdHJhdmVyc2U9ZnVuY3Rpb24odCxlLG4pe2lmKHQgaW5zdGFuY2VvZiB1Lk9iamVjdCl7aWYobj1ufHxbXSxyLmluZGV4T2Yobix0KT49MClyZXR1cm47cmV0dXJuIG4ucHVzaCh0KSx1Ll90cmF2ZXJzZSh0LmF0dHJpYnV0ZXMsZSxuKSxlKHQpfXJldHVybiB0IGluc3RhbmNlb2YgdS5SZWxhdGlvbnx8dCBpbnN0YW5jZW9mIHUuRmlsZT9lKHQpOnIuaXNBcnJheSh0KT8oci5lYWNoKHQsZnVuY3Rpb24ocixpKXt2YXIgcz11Ll90cmF2ZXJzZShyLGUsbik7cyYmKHRbaV09cyl9KSxlKHQpKTpyLmlzT2JqZWN0KHQpPyh1Ll9lYWNoKHQsZnVuY3Rpb24ocixpKXt2YXIgcz11Ll90cmF2ZXJzZShyLGUsbik7cyYmKHRbaV09cyl9KSxlKHQpKTplKHQpfSx1Ll9vYmplY3RFYWNoPXUuX2VhY2g9ZnVuY3Rpb24odCxlKXtyLmlzT2JqZWN0KHQpP3IuZWFjaChyLmtleXModCksZnVuY3Rpb24obil7ZSh0W25dLG4pfSk6ci5lYWNoKHQsZSl9LHQuZXhwb3J0cz11fSkuY2FsbChlLG4oNykpfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcigpe3JldHVybiEoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvd3x8IXdpbmRvdy5wcm9jZXNzfHxcInJlbmRlcmVyXCIhPT13aW5kb3cucHJvY2Vzcy50eXBlKXx8KFwidW5kZWZpbmVkXCI9PXR5cGVvZiBuYXZpZ2F0b3J8fCFuYXZpZ2F0b3IudXNlckFnZW50fHwhbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSYmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUmJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlfHxcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuY29uc29sZSYmKHdpbmRvdy5jb25zb2xlLmZpcmVidWd8fHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiYmd2luZG93LmNvbnNvbGUudGFibGUpfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IudXNlckFnZW50JiZuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSYmcGFyc2VJbnQoUmVnRXhwLiQxLDEwKT49MzF8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci51c2VyQWdlbnQmJm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSl9ZnVuY3Rpb24gaSh0KXt2YXIgbj10aGlzLnVzZUNvbG9ycztpZih0WzBdPShuP1wiJWNcIjpcIlwiKSt0aGlzLm5hbWVzcGFjZSsobj9cIiAlY1wiOlwiIFwiKSt0WzBdKyhuP1wiJWMgXCI6XCIgXCIpK1wiK1wiK2UuaHVtYW5pemUodGhpcy5kaWZmKSxuKXt2YXIgcj1cImNvbG9yOiBcIit0aGlzLmNvbG9yO3Quc3BsaWNlKDEsMCxyLFwiY29sb3I6IGluaGVyaXRcIik7dmFyIGk9MCxzPTA7dFswXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csZnVuY3Rpb24odCl7XCIlJVwiIT09dCYmKGkrKyxcIiVjXCI9PT10JiYocz1pKSl9KSx0LnNwbGljZShzLDAscil9fWZ1bmN0aW9uIHMoKXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgY29uc29sZSYmY29uc29sZS5sb2cmJkZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLGNvbnNvbGUsYXJndW1lbnRzKX1mdW5jdGlvbiBvKHQpe3RyeXtudWxsPT10P2Uuc3RvcmFnZS5yZW1vdmVJdGVtKFwiZGVidWdcIik6ZS5zdG9yYWdlLmRlYnVnPXR9Y2F0Y2godCl7fX1mdW5jdGlvbiBhKCl7dmFyIHQ7dHJ5e3Q9ZS5zdG9yYWdlLmRlYnVnfWNhdGNoKHQpe31yZXR1cm4hdCYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHByb2Nlc3MmJlwiZW52XCJpbiBwcm9jZXNzJiYodD1wcm9jZXNzLmVudi5ERUJVRyksdH1lPXQuZXhwb3J0cz1uKDI0KSxlLmxvZz1zLGUuZm9ybWF0QXJncz1pLGUuc2F2ZT1vLGUubG9hZD1hLGUudXNlQ29sb3JzPXIsZS5zdG9yYWdlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBjaHJvbWUmJnZvaWQgMCE9PWNocm9tZS5zdG9yYWdlP2Nocm9tZS5zdG9yYWdlLmxvY2FsOmZ1bmN0aW9uKCl7dHJ5e3JldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlfWNhdGNoKHQpe319KCksZS5jb2xvcnM9W1wiIzAwMDBDQ1wiLFwiIzAwMDBGRlwiLFwiIzAwMzNDQ1wiLFwiIzAwMzNGRlwiLFwiIzAwNjZDQ1wiLFwiIzAwNjZGRlwiLFwiIzAwOTlDQ1wiLFwiIzAwOTlGRlwiLFwiIzAwQ0MwMFwiLFwiIzAwQ0MzM1wiLFwiIzAwQ0M2NlwiLFwiIzAwQ0M5OVwiLFwiIzAwQ0NDQ1wiLFwiIzAwQ0NGRlwiLFwiIzMzMDBDQ1wiLFwiIzMzMDBGRlwiLFwiIzMzMzNDQ1wiLFwiIzMzMzNGRlwiLFwiIzMzNjZDQ1wiLFwiIzMzNjZGRlwiLFwiIzMzOTlDQ1wiLFwiIzMzOTlGRlwiLFwiIzMzQ0MwMFwiLFwiIzMzQ0MzM1wiLFwiIzMzQ0M2NlwiLFwiIzMzQ0M5OVwiLFwiIzMzQ0NDQ1wiLFwiIzMzQ0NGRlwiLFwiIzY2MDBDQ1wiLFwiIzY2MDBGRlwiLFwiIzY2MzNDQ1wiLFwiIzY2MzNGRlwiLFwiIzY2Q0MwMFwiLFwiIzY2Q0MzM1wiLFwiIzk5MDBDQ1wiLFwiIzk5MDBGRlwiLFwiIzk5MzNDQ1wiLFwiIzk5MzNGRlwiLFwiIzk5Q0MwMFwiLFwiIzk5Q0MzM1wiLFwiI0NDMDAwMFwiLFwiI0NDMDAzM1wiLFwiI0NDMDA2NlwiLFwiI0NDMDA5OVwiLFwiI0NDMDBDQ1wiLFwiI0NDMDBGRlwiLFwiI0NDMzMwMFwiLFwiI0NDMzMzM1wiLFwiI0NDMzM2NlwiLFwiI0NDMzM5OVwiLFwiI0NDMzNDQ1wiLFwiI0NDMzNGRlwiLFwiI0NDNjYwMFwiLFwiI0NDNjYzM1wiLFwiI0NDOTkwMFwiLFwiI0NDOTkzM1wiLFwiI0NDQ0MwMFwiLFwiI0NDQ0MzM1wiLFwiI0ZGMDAwMFwiLFwiI0ZGMDAzM1wiLFwiI0ZGMDA2NlwiLFwiI0ZGMDA5OVwiLFwiI0ZGMDBDQ1wiLFwiI0ZGMDBGRlwiLFwiI0ZGMzMwMFwiLFwiI0ZGMzMzM1wiLFwiI0ZGMzM2NlwiLFwiI0ZGMzM5OVwiLFwiI0ZGMzNDQ1wiLFwiI0ZGMzNGRlwiLFwiI0ZGNjYwMFwiLFwiI0ZGNjYzM1wiLFwiI0ZGOTkwMFwiLFwiI0ZGOTkzM1wiLFwiI0ZGQ0MwMFwiLFwiI0ZGQ0MzM1wiXSxlLmZvcm1hdHRlcnMuaj1mdW5jdGlvbih0KXt0cnl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHQpfWNhdGNoKHQpe3JldHVyblwiW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06IFwiK3QubWVzc2FnZX19LGUuZW5hYmxlKGEoKSl9LGZ1bmN0aW9uKHQsZSl7dmFyIG47bj1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3RyeXtuPW58fEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKXx8KDAsZXZhbCkoXCJ0aGlzXCIpfWNhdGNoKHQpe1wib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJihuPXdpbmRvdyl9dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKCl7fWZ1bmN0aW9uIGkodCl7aWYoIV8odCkpcmV0dXJuIHQ7dmFyIGU9W107Zm9yKHZhciBuIGluIHQpcyhlLG4sdFtuXSk7cmV0dXJuIGUuam9pbihcIiZcIil9ZnVuY3Rpb24gcyh0LGUsbil7aWYobnVsbCE9bilpZihBcnJheS5pc0FycmF5KG4pKW4uZm9yRWFjaChmdW5jdGlvbihuKXtzKHQsZSxuKX0pO2Vsc2UgaWYoXyhuKSlmb3IodmFyIHIgaW4gbilzKHQsZStcIltcIityK1wiXVwiLG5bcl0pO2Vsc2UgdC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChlKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQobikpO2Vsc2UgbnVsbD09PW4mJnQucHVzaChlbmNvZGVVUklDb21wb25lbnQoZSkpfWZ1bmN0aW9uIG8odCl7Zm9yKHZhciBlLG4scj17fSxpPXQuc3BsaXQoXCImXCIpLHM9MCxvPWkubGVuZ3RoO3M8bzsrK3MpZT1pW3NdLG49ZS5pbmRleE9mKFwiPVwiKSwtMT09bj9yW2RlY29kZVVSSUNvbXBvbmVudChlKV09XCJcIjpyW2RlY29kZVVSSUNvbXBvbmVudChlLnNsaWNlKDAsbikpXT1kZWNvZGVVUklDb21wb25lbnQoZS5zbGljZShuKzEpKTtyZXR1cm4gcn1mdW5jdGlvbiBhKHQpe2Zvcih2YXIgZSxuLHIsaSxzPXQuc3BsaXQoL1xccj9cXG4vKSxvPXt9LGE9MCx1PXMubGVuZ3RoO2E8dTsrK2Epbj1zW2FdLC0xIT09KGU9bi5pbmRleE9mKFwiOlwiKSkmJihyPW4uc2xpY2UoMCxlKS50b0xvd2VyQ2FzZSgpLGk9ZyhuLnNsaWNlKGUrMSkpLG9bcl09aSk7cmV0dXJuIG99ZnVuY3Rpb24gdSh0KXtyZXR1cm4vW1xcLytdanNvbigkfFteLVxcd10pLy50ZXN0KHQpfWZ1bmN0aW9uIGModCl7dGhpcy5yZXE9dCx0aGlzLnhocj10aGlzLnJlcS54aHIsdGhpcy50ZXh0PVwiSEVBRFwiIT10aGlzLnJlcS5tZXRob2QmJihcIlwiPT09dGhpcy54aHIucmVzcG9uc2VUeXBlfHxcInRleHRcIj09PXRoaXMueGhyLnJlc3BvbnNlVHlwZSl8fHZvaWQgMD09PXRoaXMueGhyLnJlc3BvbnNlVHlwZT90aGlzLnhoci5yZXNwb25zZVRleHQ6bnVsbCx0aGlzLnN0YXR1c1RleHQ9dGhpcy5yZXEueGhyLnN0YXR1c1RleHQ7dmFyIGU9dGhpcy54aHIuc3RhdHVzOzEyMjM9PT1lJiYoZT0yMDQpLHRoaXMuX3NldFN0YXR1c1Byb3BlcnRpZXMoZSksdGhpcy5oZWFkZXI9dGhpcy5oZWFkZXJzPWEodGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpLHRoaXMuaGVhZGVyW1wiY29udGVudC10eXBlXCJdPXRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiY29udGVudC10eXBlXCIpLHRoaXMuX3NldEhlYWRlclByb3BlcnRpZXModGhpcy5oZWFkZXIpLG51bGw9PT10aGlzLnRleHQmJnQuX3Jlc3BvbnNlVHlwZT90aGlzLmJvZHk9dGhpcy54aHIucmVzcG9uc2U6dGhpcy5ib2R5PVwiSEVBRFwiIT10aGlzLnJlcS5tZXRob2Q/dGhpcy5fcGFyc2VCb2R5KHRoaXMudGV4dD90aGlzLnRleHQ6dGhpcy54aHIucmVzcG9uc2UpOm51bGx9ZnVuY3Rpb24gbCh0LGUpe3ZhciBuPXRoaXM7dGhpcy5fcXVlcnk9dGhpcy5fcXVlcnl8fFtdLHRoaXMubWV0aG9kPXQsdGhpcy51cmw9ZSx0aGlzLmhlYWRlcj17fSx0aGlzLl9oZWFkZXI9e30sdGhpcy5vbihcImVuZFwiLGZ1bmN0aW9uKCl7dmFyIHQ9bnVsbCxlPW51bGw7dHJ5e2U9bmV3IGMobil9Y2F0Y2goZSl7cmV0dXJuIHQ9bmV3IEVycm9yKFwiUGFyc2VyIGlzIHVuYWJsZSB0byBwYXJzZSB0aGUgcmVzcG9uc2VcIiksdC5wYXJzZT0hMCx0Lm9yaWdpbmFsPWUsbi54aHI/KHQucmF3UmVzcG9uc2U9dm9pZCAwPT09bi54aHIucmVzcG9uc2VUeXBlP24ueGhyLnJlc3BvbnNlVGV4dDpuLnhoci5yZXNwb25zZSx0LnN0YXR1cz1uLnhoci5zdGF0dXM/bi54aHIuc3RhdHVzOm51bGwsdC5zdGF0dXNDb2RlPXQuc3RhdHVzKToodC5yYXdSZXNwb25zZT1udWxsLHQuc3RhdHVzPW51bGwpLG4uY2FsbGJhY2sodCl9bi5lbWl0KFwicmVzcG9uc2VcIixlKTt2YXIgcjt0cnl7bi5faXNSZXNwb25zZU9LKGUpfHwocj1uZXcgRXJyb3IoZS5zdGF0dXNUZXh0fHxcIlVuc3VjY2Vzc2Z1bCBIVFRQIHJlc3BvbnNlXCIpKX1jYXRjaCh0KXtyPXR9cj8oci5vcmlnaW5hbD10LHIucmVzcG9uc2U9ZSxyLnN0YXR1cz1lLnN0YXR1cyxuLmNhbGxiYWNrKHIsZSkpOm4uY2FsbGJhY2sobnVsbCxlKX0pfWZ1bmN0aW9uIGgodCxlLG4pe3ZhciByPW0oXCJERUxFVEVcIix0KTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiYobj1lLGU9bnVsbCksZSYmci5zZW5kKGUpLG4mJnIuZW5kKG4pLHJ9dmFyIGY7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz9mPXdpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9mPXNlbGY6KGNvbnNvbGUud2FybihcIlVzaW5nIGJyb3dzZXItb25seSB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIiksZj10aGlzKTt2YXIgZD1uKDE5KSxwPW4oMjApLF89bigxMCksdj1uKDIxKSx5PW4oMjMpLG09ZT10LmV4cG9ydHM9ZnVuY3Rpb24odCxuKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBuP25ldyBlLlJlcXVlc3QoXCJHRVRcIix0KS5lbmQobik6MT09YXJndW1lbnRzLmxlbmd0aD9uZXcgZS5SZXF1ZXN0KFwiR0VUXCIsdCk6bmV3IGUuUmVxdWVzdCh0LG4pfTtlLlJlcXVlc3Q9bCxtLmdldFhIUj1mdW5jdGlvbigpe2lmKCEoIWYuWE1MSHR0cFJlcXVlc3R8fGYubG9jYXRpb24mJlwiZmlsZTpcIj09Zi5sb2NhdGlvbi5wcm90b2NvbCYmZi5BY3RpdmVYT2JqZWN0KSlyZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0O3RyeXtyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKX1jYXRjaCh0KXt9dHJ5e3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQLjYuMFwiKX1jYXRjaCh0KXt9dHJ5e3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQLjMuMFwiKX1jYXRjaCh0KXt9dHJ5e3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1zeG1sMi5YTUxIVFRQXCIpfWNhdGNoKHQpe310aHJvdyBFcnJvcihcIkJyb3dzZXItb25seSB2ZXJzaW9uIG9mIHN1cGVyYWdlbnQgY291bGQgbm90IGZpbmQgWEhSXCIpfTt2YXIgZz1cIlwiLnRyaW0/ZnVuY3Rpb24odCl7cmV0dXJuIHQudHJpbSgpfTpmdW5jdGlvbih0KXtyZXR1cm4gdC5yZXBsYWNlKC8oXlxccyp8XFxzKiQpL2csXCJcIil9O20uc2VyaWFsaXplT2JqZWN0PWksbS5wYXJzZVN0cmluZz1vLG0udHlwZXM9e2h0bWw6XCJ0ZXh0L2h0bWxcIixqc29uOlwiYXBwbGljYXRpb24vanNvblwiLHhtbDpcInRleHQveG1sXCIsdXJsZW5jb2RlZDpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLGZvcm06XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcImZvcm0tZGF0YVwiOlwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJ9LG0uc2VyaWFsaXplPXtcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiOmksXCJhcHBsaWNhdGlvbi9qc29uXCI6SlNPTi5zdHJpbmdpZnl9LG0ucGFyc2U9e1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI6byxcImFwcGxpY2F0aW9uL2pzb25cIjpKU09OLnBhcnNlfSx2KGMucHJvdG90eXBlKSxjLnByb3RvdHlwZS5fcGFyc2VCb2R5PWZ1bmN0aW9uKHQpe3ZhciBlPW0ucGFyc2VbdGhpcy50eXBlXTtyZXR1cm4gdGhpcy5yZXEuX3BhcnNlcj90aGlzLnJlcS5fcGFyc2VyKHRoaXMsdCk6KCFlJiZ1KHRoaXMudHlwZSkmJihlPW0ucGFyc2VbXCJhcHBsaWNhdGlvbi9qc29uXCJdKSxlJiZ0JiYodC5sZW5ndGh8fHQgaW5zdGFuY2VvZiBPYmplY3QpP2UodCk6bnVsbCl9LGMucHJvdG90eXBlLnRvRXJyb3I9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnJlcSxlPXQubWV0aG9kLG49dC51cmwscj1cImNhbm5vdCBcIitlK1wiIFwiK24rXCIgKFwiK3RoaXMuc3RhdHVzK1wiKVwiLGk9bmV3IEVycm9yKHIpO3JldHVybiBpLnN0YXR1cz10aGlzLnN0YXR1cyxpLm1ldGhvZD1lLGkudXJsPW4saX0sbS5SZXNwb25zZT1jLGQobC5wcm90b3R5cGUpLHAobC5wcm90b3R5cGUpLGwucHJvdG90eXBlLnR5cGU9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc2V0KFwiQ29udGVudC1UeXBlXCIsbS50eXBlc1t0XXx8dCksdGhpc30sbC5wcm90b3R5cGUuYWNjZXB0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnNldChcIkFjY2VwdFwiLG0udHlwZXNbdF18fHQpLHRoaXN9LGwucHJvdG90eXBlLmF1dGg9ZnVuY3Rpb24odCxlLG4pezE9PT1hcmd1bWVudHMubGVuZ3RoJiYoZT1cIlwiKSxcIm9iamVjdFwiPT10eXBlb2YgZSYmbnVsbCE9PWUmJihuPWUsZT1cIlwiKSxufHwobj17dHlwZTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBidG9hP1wiYmFzaWNcIjpcImF1dG9cIn0pO3ZhciByPWZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGJ0b2EpcmV0dXJuIGJ0b2EodCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSBiYXNpYyBhdXRoLCBidG9hIGlzIG5vdCBhIGZ1bmN0aW9uXCIpfTtyZXR1cm4gdGhpcy5fYXV0aCh0LGUsbixyKX0sbC5wcm90b3R5cGUucXVlcnk9ZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIHQmJih0PWkodCkpLHQmJnRoaXMuX3F1ZXJ5LnB1c2godCksdGhpc30sbC5wcm90b3R5cGUuYXR0YWNoPWZ1bmN0aW9uKHQsZSxuKXtpZihlKXtpZih0aGlzLl9kYXRhKXRocm93IEVycm9yKFwic3VwZXJhZ2VudCBjYW4ndCBtaXggLnNlbmQoKSBhbmQgLmF0dGFjaCgpXCIpO3RoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKHQsZSxufHxlLm5hbWUpfXJldHVybiB0aGlzfSxsLnByb3RvdHlwZS5fZ2V0Rm9ybURhdGE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZm9ybURhdGF8fCh0aGlzLl9mb3JtRGF0YT1uZXcgZi5Gb3JtRGF0YSksdGhpcy5fZm9ybURhdGF9LGwucHJvdG90eXBlLmNhbGxiYWNrPWZ1bmN0aW9uKHQsZSl7aWYodGhpcy5fc2hvdWxkUmV0cnkodCxlKSlyZXR1cm4gdGhpcy5fcmV0cnkoKTt2YXIgbj10aGlzLl9jYWxsYmFjazt0aGlzLmNsZWFyVGltZW91dCgpLHQmJih0aGlzLl9tYXhSZXRyaWVzJiYodC5yZXRyaWVzPXRoaXMuX3JldHJpZXMtMSksdGhpcy5lbWl0KFwiZXJyb3JcIix0KSksbih0LGUpfSxsLnByb3RvdHlwZS5jcm9zc0RvbWFpbkVycm9yPWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEVycm9yKFwiUmVxdWVzdCBoYXMgYmVlbiB0ZXJtaW5hdGVkXFxuUG9zc2libGUgY2F1c2VzOiB0aGUgbmV0d29yayBpcyBvZmZsaW5lLCBPcmlnaW4gaXMgbm90IGFsbG93ZWQgYnkgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luLCB0aGUgcGFnZSBpcyBiZWluZyB1bmxvYWRlZCwgZXRjLlwiKTt0LmNyb3NzRG9tYWluPSEwLHQuc3RhdHVzPXRoaXMuc3RhdHVzLHQubWV0aG9kPXRoaXMubWV0aG9kLHQudXJsPXRoaXMudXJsLHRoaXMuY2FsbGJhY2sodCl9LGwucHJvdG90eXBlLmJ1ZmZlcj1sLnByb3RvdHlwZS5jYT1sLnByb3RvdHlwZS5hZ2VudD1mdW5jdGlvbigpe3JldHVybiBjb25zb2xlLndhcm4oXCJUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB2ZXJzaW9uIG9mIHN1cGVyYWdlbnRcIiksdGhpc30sbC5wcm90b3R5cGUucGlwZT1sLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbigpe3Rocm93IEVycm9yKFwiU3RyZWFtaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB2ZXJzaW9uIG9mIHN1cGVyYWdlbnRcIil9LGwucHJvdG90eXBlLl9pc0hvc3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiYhQXJyYXkuaXNBcnJheSh0KSYmXCJbb2JqZWN0IE9iamVjdF1cIiE9PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KX0sbC5wcm90b3R5cGUuZW5kPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9lbmRDYWxsZWQmJmNvbnNvbGUud2FybihcIldhcm5pbmc6IC5lbmQoKSB3YXMgY2FsbGVkIHR3aWNlLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gc3VwZXJhZ2VudFwiKSx0aGlzLl9lbmRDYWxsZWQ9ITAsdGhpcy5fY2FsbGJhY2s9dHx8cix0aGlzLl9maW5hbGl6ZVF1ZXJ5U3RyaW5nKCksdGhpcy5fZW5kKCl9LGwucHJvdG90eXBlLl9lbmQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9dGhpcy54aHI9bS5nZXRYSFIoKSxuPXRoaXMuX2Zvcm1EYXRhfHx0aGlzLl9kYXRhO3RoaXMuX3NldFRpbWVvdXRzKCksZS5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXt2YXIgbj1lLnJlYWR5U3RhdGU7aWYobj49MiYmdC5fcmVzcG9uc2VUaW1lb3V0VGltZXImJmNsZWFyVGltZW91dCh0Ll9yZXNwb25zZVRpbWVvdXRUaW1lciksND09bil7dmFyIHI7dHJ5e3I9ZS5zdGF0dXN9Y2F0Y2godCl7cj0wfWlmKCFyKXtpZih0LnRpbWVkb3V0fHx0Ll9hYm9ydGVkKXJldHVybjtyZXR1cm4gdC5jcm9zc0RvbWFpbkVycm9yKCl9dC5lbWl0KFwiZW5kXCIpfX07dmFyIHI9ZnVuY3Rpb24oZSxuKXtuLnRvdGFsPjAmJihuLnBlcmNlbnQ9bi5sb2FkZWQvbi50b3RhbCoxMDApLG4uZGlyZWN0aW9uPWUsdC5lbWl0KFwicHJvZ3Jlc3NcIixuKX07aWYodGhpcy5oYXNMaXN0ZW5lcnMoXCJwcm9ncmVzc1wiKSl0cnl7ZS5vbnByb2dyZXNzPXIuYmluZChudWxsLFwiZG93bmxvYWRcIiksZS51cGxvYWQmJihlLnVwbG9hZC5vbnByb2dyZXNzPXIuYmluZChudWxsLFwidXBsb2FkXCIpKX1jYXRjaCh0KXt9dHJ5e3RoaXMudXNlcm5hbWUmJnRoaXMucGFzc3dvcmQ/ZS5vcGVuKHRoaXMubWV0aG9kLHRoaXMudXJsLCEwLHRoaXMudXNlcm5hbWUsdGhpcy5wYXNzd29yZCk6ZS5vcGVuKHRoaXMubWV0aG9kLHRoaXMudXJsLCEwKX1jYXRjaCh0KXtyZXR1cm4gdGhpcy5jYWxsYmFjayh0KX1pZih0aGlzLl93aXRoQ3JlZGVudGlhbHMmJihlLndpdGhDcmVkZW50aWFscz0hMCksIXRoaXMuX2Zvcm1EYXRhJiZcIkdFVFwiIT10aGlzLm1ldGhvZCYmXCJIRUFEXCIhPXRoaXMubWV0aG9kJiZcInN0cmluZ1wiIT10eXBlb2YgbiYmIXRoaXMuX2lzSG9zdChuKSl7dmFyIGk9dGhpcy5faGVhZGVyW1wiY29udGVudC10eXBlXCJdLHM9dGhpcy5fc2VyaWFsaXplcnx8bS5zZXJpYWxpemVbaT9pLnNwbGl0KFwiO1wiKVswXTpcIlwiXTshcyYmdShpKSYmKHM9bS5zZXJpYWxpemVbXCJhcHBsaWNhdGlvbi9qc29uXCJdKSxzJiYobj1zKG4pKX1mb3IodmFyIG8gaW4gdGhpcy5oZWFkZXIpbnVsbCE9dGhpcy5oZWFkZXJbb10mJnRoaXMuaGVhZGVyLmhhc093blByb3BlcnR5KG8pJiZlLnNldFJlcXVlc3RIZWFkZXIobyx0aGlzLmhlYWRlcltvXSk7cmV0dXJuIHRoaXMuX3Jlc3BvbnNlVHlwZSYmKGUucmVzcG9uc2VUeXBlPXRoaXMuX3Jlc3BvbnNlVHlwZSksdGhpcy5lbWl0KFwicmVxdWVzdFwiLHRoaXMpLGUuc2VuZCh2b2lkIDAhPT1uP246bnVsbCksdGhpc30sbS5hZ2VudD1mdW5jdGlvbigpe3JldHVybiBuZXcgeX0sW1wiR0VUXCIsXCJQT1NUXCIsXCJPUFRJT05TXCIsXCJQQVRDSFwiLFwiUFVUXCIsXCJERUxFVEVcIl0uZm9yRWFjaChmdW5jdGlvbih0KXt5LnByb3RvdHlwZVt0LnRvTG93ZXJDYXNlKCldPWZ1bmN0aW9uKGUsbil7dmFyIHI9bmV3IG0uUmVxdWVzdCh0LGUpO3JldHVybiB0aGlzLl9zZXREZWZhdWx0cyhyKSxuJiZyLmVuZChuKSxyfX0pLHkucHJvdG90eXBlLmRlbD15LnByb3RvdHlwZS5kZWxldGUsbS5nZXQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW0oXCJHRVRcIix0KTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiYobj1lLGU9bnVsbCksZSYmci5xdWVyeShlKSxuJiZyLmVuZChuKSxyfSxtLmhlYWQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW0oXCJIRUFEXCIsdCk7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmKG49ZSxlPW51bGwpLGUmJnIucXVlcnkoZSksbiYmci5lbmQobikscn0sbS5vcHRpb25zPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1tKFwiT1BUSU9OU1wiLHQpO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJihuPWUsZT1udWxsKSxlJiZyLnNlbmQoZSksbiYmci5lbmQobikscn0sbS5kZWw9aCxtLmRlbGV0ZT1oLG0ucGF0Y2g9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW0oXCJQQVRDSFwiLHQpO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJihuPWUsZT1udWxsKSxlJiZyLnNlbmQoZSksbiYmci5lbmQobikscn0sbS5wb3N0PWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1tKFwiUE9TVFwiLHQpO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJihuPWUsZT1udWxsKSxlJiZyLnNlbmQoZSksbiYmci5lbmQobikscn0sbS5wdXQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW0oXCJQVVRcIix0KTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiYobj1lLGU9bnVsbCksZSYmci5zZW5kKGUpLG4mJnIuZW5kKG4pLHJ9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPVwiMy43LjNcIn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7cmV0dXJuIG51bGwhPT10JiZcIm9iamVjdFwiPT10eXBlb2YgdH10LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMCksaT1uKDEpLHM9bigyOCksbz1bXCJnZXRJdGVtXCIsXCJzZXRJdGVtXCIsXCJyZW1vdmVJdGVtXCIsXCJjbGVhclwiXTtzLmFzeW5jP3IobykuZWFjaChmdW5jdGlvbih0KXtcImZ1bmN0aW9uXCIhPXR5cGVvZiBzW3RdJiYoc1t0XT1mdW5jdGlvbigpe3ZhciBlPW5ldyBFcnJvcihcIlN5bmNocm9ub3VzIEFQSSBbXCIrdCtcIl0gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIHJ1bnRpbWUuXCIpO3Rocm93IGUuY29kZT1cIlNZTkNfQVBJX05PVF9BVkFJTEFCTEVcIixlfSl9KTpyKG8pLmVhY2goZnVuY3Rpb24odCl7XCJmdW5jdGlvblwiPT10eXBlb2Ygc1t0XSYmKHNbdCtcIkFzeW5jXCJdPWZ1bmN0aW9uKCl7cmV0dXJuIGkucmVzb2x2ZShzW3RdLmFwcGx5KHMsYXJndW1lbnRzKSl9KX0pLHQuZXhwb3J0cz1zfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigxMSksaT1uKDUpLHM9ZS5yZW1vdmVBc3luYz1yLnJlbW92ZUl0ZW1Bc3luYy5iaW5kKHIpLG89ZnVuY3Rpb24odCxlKXt0cnl7dD1KU09OLnBhcnNlKHQpfWNhdGNoKHQpe3JldHVybiBudWxsfWlmKHQpe3JldHVybiB0LmV4cGlyZWRBdCYmdC5leHBpcmVkQXQ8RGF0ZS5ub3coKT9zKGUpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0pOnQudmFsdWV9cmV0dXJuIG51bGx9O2UuZ2V0QXN5bmM9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9XCJBVi9cIitpLmFwcGxpY2F0aW9uSWQrXCIvXCIrdCxyLmdldEl0ZW1Bc3luYyh0KS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBvKGUsdCl9KX0sZS5zZXRBc3luYz1mdW5jdGlvbih0LGUsbil7dmFyIHM9e3ZhbHVlOmV9O3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBuJiYocy5leHBpcmVkQXQ9RGF0ZS5ub3coKStuKSxyLnNldEl0ZW1Bc3luYyhcIkFWL1wiK2kuYXBwbGljYXRpb25JZCtcIi9cIit0LEpTT04uc3RyaW5naWZ5KHMpKX19LGZ1bmN0aW9uKHQsZSl7dmFyIG49e3V0Zjg6e3N0cmluZ1RvQnl0ZXM6ZnVuY3Rpb24odCl7cmV0dXJuIG4uYmluLnN0cmluZ1RvQnl0ZXModW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHQpKSl9LGJ5dGVzVG9TdHJpbmc6ZnVuY3Rpb24odCl7cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUobi5iaW4uYnl0ZXNUb1N0cmluZyh0KSkpfX0sYmluOntzdHJpbmdUb0J5dGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDtuKyspZS5wdXNoKDI1NSZ0LmNoYXJDb2RlQXQobikpO3JldHVybiBlfSxieXRlc1RvU3RyaW5nOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDtuKyspZS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUodFtuXSkpO3JldHVybiBlLmpvaW4oXCJcIil9fX07dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjsvKiFcbiAqIExlYW5DbG91ZCBKYXZhU2NyaXB0IFNES1xuICogaHR0cHM6Ly9sZWFuY2xvdWQuY25cbiAqXG4gKiBDb3B5cmlnaHQgMjAxNiBMZWFuQ2xvdWQuY24sIEluYy5cbiAqIFRoZSBMZWFuQ2xvdWQgSmF2YVNjcmlwdCBTREsgaXMgZnJlZWx5IGRpc3RyaWJ1dGFibGUgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5uKDE1KTt2YXIgcj1uKDApLGk9big1KTtpLl89cixpLnZlcnNpb249big5KSxpLlByb21pc2U9bigxKSxpLmxvY2FsU3RvcmFnZT1uKDExKSxpLkNhY2hlPW4oMTIpLGkuRXJyb3I9big0KSxuKDMwKSxuKDMyKShpKSxuKDMzKShpKSxuKDM0KShpKSxuKDM1KShpKSxuKDM2KShpKSxuKDM3KShpKSxuKDQ1KShpKSxuKDQ2KShpKSxuKDQ3KShpKSxuKDQ4KShpKSxuKDQ5KShpKSxuKDUxKShpKSxuKDUyKShpKSxuKDUzKShpKSxuKDU0KShpKSxuKDU1KShpKSxuKDU2KShpKSxpLkNvbnZlcnNhdGlvbj1uKDU3KSxuKDU4KSx0LmV4cG9ydHM9aX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwifSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gdC53ZWJwYWNrUG9seWZpbGx8fCh0LmRlcHJlY2F0ZT1mdW5jdGlvbigpe30sdC5wYXRocz1bXSx0LmNoaWxkcmVufHwodC5jaGlsZHJlbj1bXSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJsb2FkZWRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdC5sfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiaWRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdC5pfX0pLHQud2VicGFja1BvbHlmaWxsPTEpLHR9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big5KSxpPVtcIkJyb3dzZXJcIl0uY29uY2F0KG4oMTgpKTt0LmV4cG9ydHM9XCJMZWFuQ2xvdWQtSlMtU0RLL1wiK3IrXCIgKFwiK2kuam9pbihcIjsgXCIpK1wiKVwifSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dC5leHBvcnRzPVtdfSxmdW5jdGlvbih0LGUsbil7ZnVuY3Rpb24gcih0KXtpZih0KXJldHVybiBpKHQpfWZ1bmN0aW9uIGkodCl7Zm9yKHZhciBlIGluIHIucHJvdG90eXBlKXRbZV09ci5wcm90b3R5cGVbZV07cmV0dXJuIHR9dC5leHBvcnRzPXIsci5wcm90b3R5cGUub249ci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9jYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzfHx7fSwodGhpcy5fY2FsbGJhY2tzW1wiJFwiK3RdPXRoaXMuX2NhbGxiYWNrc1tcIiRcIit0XXx8W10pLnB1c2goZSksdGhpc30sci5wcm90b3R5cGUub25jZT1mdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4oKXt0aGlzLm9mZih0LG4pLGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBuLmZuPWUsdGhpcy5vbih0LG4pLHRoaXN9LHIucHJvdG90eXBlLm9mZj1yLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcj1yLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM9ci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbih0LGUpe2lmKHRoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9LDA9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX2NhbGxiYWNrcz17fSx0aGlzO3ZhciBuPXRoaXMuX2NhbGxiYWNrc1tcIiRcIit0XTtpZighbilyZXR1cm4gdGhpcztpZigxPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW1wiJFwiK3RdLHRoaXM7Zm9yKHZhciByLGk9MDtpPG4ubGVuZ3RoO2krKylpZigocj1uW2ldKT09PWV8fHIuZm49PT1lKXtuLnNwbGljZShpLDEpO2JyZWFrfXJldHVybiB0aGlzfSxyLnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uKHQpe3RoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9O3ZhciBlPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLG49dGhpcy5fY2FsbGJhY2tzW1wiJFwiK3RdO2lmKG4pe249bi5zbGljZSgwKTtmb3IodmFyIHI9MCxpPW4ubGVuZ3RoO3I8aTsrK3IpbltyXS5hcHBseSh0aGlzLGUpfXJldHVybiB0aGlzfSxyLnByb3RvdHlwZS5saXN0ZW5lcnM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9LHRoaXMuX2NhbGxiYWNrc1tcIiRcIit0XXx8W119LHIucHJvdG90eXBlLmhhc0xpc3RlbmVycz1mdW5jdGlvbih0KXtyZXR1cm4hIXRoaXMubGlzdGVuZXJzKHQpLmxlbmd0aH19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe2lmKHQpcmV0dXJuIGkodCl9ZnVuY3Rpb24gaSh0KXtmb3IodmFyIGUgaW4gci5wcm90b3R5cGUpdFtlXT1yLnByb3RvdHlwZVtlXTtyZXR1cm4gdH12YXIgcz1uKDEwKTt0LmV4cG9ydHM9cixyLnByb3RvdHlwZS5jbGVhclRpbWVvdXQ9ZnVuY3Rpb24oKXtyZXR1cm4gY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKSxjbGVhclRpbWVvdXQodGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpLGRlbGV0ZSB0aGlzLl90aW1lcixkZWxldGUgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIsdGhpc30sci5wcm90b3R5cGUucGFyc2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3BhcnNlcj10LHRoaXN9LHIucHJvdG90eXBlLnJlc3BvbnNlVHlwZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcmVzcG9uc2VUeXBlPXQsdGhpc30sci5wcm90b3R5cGUuc2VyaWFsaXplPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9zZXJpYWxpemVyPXQsdGhpc30sci5wcm90b3R5cGUudGltZW91dD1mdW5jdGlvbih0KXtpZighdHx8XCJvYmplY3RcIiE9dHlwZW9mIHQpcmV0dXJuIHRoaXMuX3RpbWVvdXQ9dCx0aGlzLl9yZXNwb25zZVRpbWVvdXQ9MCx0aGlzO2Zvcih2YXIgZSBpbiB0KXN3aXRjaChlKXtjYXNlXCJkZWFkbGluZVwiOnRoaXMuX3RpbWVvdXQ9dC5kZWFkbGluZTticmVhaztjYXNlXCJyZXNwb25zZVwiOnRoaXMuX3Jlc3BvbnNlVGltZW91dD10LnJlc3BvbnNlO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS53YXJuKFwiVW5rbm93biB0aW1lb3V0IG9wdGlvblwiLGUpfXJldHVybiB0aGlzfSxyLnByb3RvdHlwZS5yZXRyeT1mdW5jdGlvbih0LGUpe3JldHVybiAwIT09YXJndW1lbnRzLmxlbmd0aCYmITAhPT10fHwodD0xKSx0PD0wJiYodD0wKSx0aGlzLl9tYXhSZXRyaWVzPXQsdGhpcy5fcmV0cmllcz0wLHRoaXMuX3JldHJ5Q2FsbGJhY2s9ZSx0aGlzfTt2YXIgbz1bXCJFQ09OTlJFU0VUXCIsXCJFVElNRURPVVRcIixcIkVBRERSSU5GT1wiLFwiRVNPQ0tFVFRJTUVET1VUXCJdO3IucHJvdG90eXBlLl9zaG91bGRSZXRyeT1mdW5jdGlvbih0LGUpe2lmKCF0aGlzLl9tYXhSZXRyaWVzfHx0aGlzLl9yZXRyaWVzKys+PXRoaXMuX21heFJldHJpZXMpcmV0dXJuITE7aWYodGhpcy5fcmV0cnlDYWxsYmFjayl0cnl7dmFyIG49dGhpcy5fcmV0cnlDYWxsYmFjayh0LGUpO2lmKCEwPT09bilyZXR1cm4hMDtpZighMT09PW4pcmV0dXJuITF9Y2F0Y2godCl7Y29uc29sZS5lcnJvcih0KX1pZihlJiZlLnN0YXR1cyYmZS5zdGF0dXM+PTUwMCYmNTAxIT1lLnN0YXR1cylyZXR1cm4hMDtpZih0KXtpZih0LmNvZGUmJn5vLmluZGV4T2YodC5jb2RlKSlyZXR1cm4hMDtpZih0LnRpbWVvdXQmJlwiRUNPTk5BQk9SVEVEXCI9PXQuY29kZSlyZXR1cm4hMDtpZih0LmNyb3NzRG9tYWluKXJldHVybiEwfXJldHVybiExfSxyLnByb3RvdHlwZS5fcmV0cnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbGVhclRpbWVvdXQoKSx0aGlzLnJlcSYmKHRoaXMucmVxPW51bGwsdGhpcy5yZXE9dGhpcy5yZXF1ZXN0KCkpLHRoaXMuX2Fib3J0ZWQ9ITEsdGhpcy50aW1lZG91dD0hMSx0aGlzLl9lbmQoKX0sci5wcm90b3R5cGUudGhlbj1mdW5jdGlvbih0LGUpe2lmKCF0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSl7dmFyIG49dGhpczt0aGlzLl9lbmRDYWxsZWQmJmNvbnNvbGUud2FybihcIldhcm5pbmc6IHN1cGVyYWdlbnQgcmVxdWVzdCB3YXMgc2VudCB0d2ljZSwgYmVjYXVzZSBib3RoIC5lbmQoKSBhbmQgLnRoZW4oKSB3ZXJlIGNhbGxlZC4gTmV2ZXIgY2FsbCAuZW5kKCkgaWYgeW91IHVzZSBwcm9taXNlc1wiKSx0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZT1uZXcgUHJvbWlzZShmdW5jdGlvbih0LGUpe24uZW5kKGZ1bmN0aW9uKG4scil7bj9lKG4pOnQocil9KX0pfXJldHVybiB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZS50aGVuKHQsZSl9LHIucHJvdG90eXBlLmNhdGNoPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRoZW4odm9pZCAwLHQpfSxyLnByb3RvdHlwZS51c2U9ZnVuY3Rpb24odCl7cmV0dXJuIHQodGhpcyksdGhpc30sci5wcm90b3R5cGUub2s9ZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBFcnJvcihcIkNhbGxiYWNrIHJlcXVpcmVkXCIpO3JldHVybiB0aGlzLl9va0NhbGxiYWNrPXQsdGhpc30sci5wcm90b3R5cGUuX2lzUmVzcG9uc2VPSz1mdW5jdGlvbih0KXtyZXR1cm4hIXQmJih0aGlzLl9va0NhbGxiYWNrP3RoaXMuX29rQ2FsbGJhY2sodCk6dC5zdGF0dXM+PTIwMCYmdC5zdGF0dXM8MzAwKX0sci5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9oZWFkZXJbdC50b0xvd2VyQ2FzZSgpXX0sci5wcm90b3R5cGUuZ2V0SGVhZGVyPXIucHJvdG90eXBlLmdldCxyLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCxlKXtpZihzKHQpKXtmb3IodmFyIG4gaW4gdCl0aGlzLnNldChuLHRbbl0pO3JldHVybiB0aGlzfXJldHVybiB0aGlzLl9oZWFkZXJbdC50b0xvd2VyQ2FzZSgpXT1lLHRoaXMuaGVhZGVyW3RdPWUsdGhpc30sci5wcm90b3R5cGUudW5zZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIGRlbGV0ZSB0aGlzLl9oZWFkZXJbdC50b0xvd2VyQ2FzZSgpXSxkZWxldGUgdGhpcy5oZWFkZXJbdF0sdGhpc30sci5wcm90b3R5cGUuZmllbGQ9ZnVuY3Rpb24odCxlKXtpZihudWxsPT09dHx8dm9pZCAwPT09dCl0aHJvdyBuZXcgRXJyb3IoXCIuZmllbGQobmFtZSwgdmFsKSBuYW1lIGNhbiBub3QgYmUgZW1wdHlcIik7aWYodGhpcy5fZGF0YSYmY29uc29sZS5lcnJvcihcIi5maWVsZCgpIGNhbid0IGJlIHVzZWQgaWYgLnNlbmQoKSBpcyB1c2VkLiBQbGVhc2UgdXNlIG9ubHkgLnNlbmQoKSBvciBvbmx5IC5maWVsZCgpICYgLmF0dGFjaCgpXCIpLHModCkpe2Zvcih2YXIgbiBpbiB0KXRoaXMuZmllbGQobix0W25dKTtyZXR1cm4gdGhpc31pZihBcnJheS5pc0FycmF5KGUpKXtmb3IodmFyIHIgaW4gZSl0aGlzLmZpZWxkKHQsZVtyXSk7cmV0dXJuIHRoaXN9aWYobnVsbD09PWV8fHZvaWQgMD09PWUpdGhyb3cgbmV3IEVycm9yKFwiLmZpZWxkKG5hbWUsIHZhbCkgdmFsIGNhbiBub3QgYmUgZW1wdHlcIik7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiBlJiYoZT1cIlwiK2UpLHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKHQsZSksdGhpc30sci5wcm90b3R5cGUuYWJvcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYWJvcnRlZD90aGlzOih0aGlzLl9hYm9ydGVkPSEwLHRoaXMueGhyJiZ0aGlzLnhoci5hYm9ydCgpLHRoaXMucmVxJiZ0aGlzLnJlcS5hYm9ydCgpLHRoaXMuY2xlYXJUaW1lb3V0KCksdGhpcy5lbWl0KFwiYWJvcnRcIiksdGhpcyl9LHIucHJvdG90eXBlLl9hdXRoPWZ1bmN0aW9uKHQsZSxuLHIpe3N3aXRjaChuLnR5cGUpe2Nhc2VcImJhc2ljXCI6dGhpcy5zZXQoXCJBdXRob3JpemF0aW9uXCIsXCJCYXNpYyBcIityKHQrXCI6XCIrZSkpO2JyZWFrO2Nhc2VcImF1dG9cIjp0aGlzLnVzZXJuYW1lPXQsdGhpcy5wYXNzd29yZD1lO2JyZWFrO2Nhc2VcImJlYXJlclwiOnRoaXMuc2V0KFwiQXV0aG9yaXphdGlvblwiLFwiQmVhcmVyIFwiK3QpfXJldHVybiB0aGlzfSxyLnByb3RvdHlwZS53aXRoQ3JlZGVudGlhbHM9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09dCYmKHQ9ITApLHRoaXMuX3dpdGhDcmVkZW50aWFscz10LHRoaXN9LHIucHJvdG90eXBlLnJlZGlyZWN0cz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fbWF4UmVkaXJlY3RzPXQsdGhpc30sci5wcm90b3R5cGUubWF4UmVzcG9uc2VTaXplPWZ1bmN0aW9uKHQpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiB0KXRocm93IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7cmV0dXJuIHRoaXMuX21heFJlc3BvbnNlU2l6ZT10LHRoaXN9LHIucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnttZXRob2Q6dGhpcy5tZXRob2QsdXJsOnRoaXMudXJsLGRhdGE6dGhpcy5fZGF0YSxoZWFkZXJzOnRoaXMuX2hlYWRlcn19LHIucHJvdG90eXBlLnNlbmQ9ZnVuY3Rpb24odCl7dmFyIGU9cyh0KSxuPXRoaXMuX2hlYWRlcltcImNvbnRlbnQtdHlwZVwiXTtpZih0aGlzLl9mb3JtRGF0YSYmY29uc29sZS5lcnJvcihcIi5zZW5kKCkgY2FuJ3QgYmUgdXNlZCBpZiAuYXR0YWNoKCkgb3IgLmZpZWxkKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiKSxlJiYhdGhpcy5fZGF0YSlBcnJheS5pc0FycmF5KHQpP3RoaXMuX2RhdGE9W106dGhpcy5faXNIb3N0KHQpfHwodGhpcy5fZGF0YT17fSk7ZWxzZSBpZih0JiZ0aGlzLl9kYXRhJiZ0aGlzLl9pc0hvc3QodGhpcy5fZGF0YSkpdGhyb3cgRXJyb3IoXCJDYW4ndCBtZXJnZSB0aGVzZSBzZW5kIGNhbGxzXCIpO2lmKGUmJnModGhpcy5fZGF0YSkpZm9yKHZhciByIGluIHQpdGhpcy5fZGF0YVtyXT10W3JdO2Vsc2VcInN0cmluZ1wiPT10eXBlb2YgdD8obnx8dGhpcy50eXBlKFwiZm9ybVwiKSxuPXRoaXMuX2hlYWRlcltcImNvbnRlbnQtdHlwZVwiXSx0aGlzLl9kYXRhPVwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI9PW4/dGhpcy5fZGF0YT90aGlzLl9kYXRhK1wiJlwiK3Q6dDoodGhpcy5fZGF0YXx8XCJcIikrdCk6dGhpcy5fZGF0YT10O3JldHVybiFlfHx0aGlzLl9pc0hvc3QodCk/dGhpczoobnx8dGhpcy50eXBlKFwianNvblwiKSx0aGlzKX0sci5wcm90b3R5cGUuc29ydFF1ZXJ5PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9zb3J0PXZvaWQgMD09PXR8fHQsdGhpc30sci5wcm90b3R5cGUuX2ZpbmFsaXplUXVlcnlTdHJpbmc9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9xdWVyeS5qb2luKFwiJlwiKTtpZih0JiYodGhpcy51cmwrPSh0aGlzLnVybC5pbmRleE9mKFwiP1wiKT49MD9cIiZcIjpcIj9cIikrdCksdGhpcy5fcXVlcnkubGVuZ3RoPTAsdGhpcy5fc29ydCl7dmFyIGU9dGhpcy51cmwuaW5kZXhPZihcIj9cIik7aWYoZT49MCl7dmFyIG49dGhpcy51cmwuc3Vic3RyaW5nKGUrMSkuc3BsaXQoXCImXCIpO1wiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuX3NvcnQ/bi5zb3J0KHRoaXMuX3NvcnQpOm4uc29ydCgpLHRoaXMudXJsPXRoaXMudXJsLnN1YnN0cmluZygwLGUpK1wiP1wiK24uam9pbihcIiZcIil9fX0sci5wcm90b3R5cGUuX2FwcGVuZFF1ZXJ5U3RyaW5nPWZ1bmN0aW9uKCl7Y29uc29sZS50cmFjZShcIlVuc3VwcG9ydGVkXCIpfSxyLnByb3RvdHlwZS5fdGltZW91dEVycm9yPWZ1bmN0aW9uKHQsZSxuKXtpZighdGhpcy5fYWJvcnRlZCl7dmFyIHI9bmV3IEVycm9yKHQrZStcIm1zIGV4Y2VlZGVkXCIpO3IudGltZW91dD1lLHIuY29kZT1cIkVDT05OQUJPUlRFRFwiLHIuZXJybm89bix0aGlzLnRpbWVkb3V0PSEwLHRoaXMuYWJvcnQoKSx0aGlzLmNhbGxiYWNrKHIpfX0sci5wcm90b3R5cGUuX3NldFRpbWVvdXRzPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLl90aW1lb3V0JiYhdGhpcy5fdGltZXImJih0aGlzLl90aW1lcj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC5fdGltZW91dEVycm9yKFwiVGltZW91dCBvZiBcIix0Ll90aW1lb3V0LFwiRVRJTUVcIil9LHRoaXMuX3RpbWVvdXQpKSx0aGlzLl9yZXNwb25zZVRpbWVvdXQmJiF0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lciYmKHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyPXNldFRpbWVvdXQoZnVuY3Rpb24oKXt0Ll90aW1lb3V0RXJyb3IoXCJSZXNwb25zZSB0aW1lb3V0IG9mIFwiLHQuX3Jlc3BvbnNlVGltZW91dCxcIkVUSU1FRE9VVFwiKX0sdGhpcy5fcmVzcG9uc2VUaW1lb3V0KSl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXtpZih0KXJldHVybiBpKHQpfWZ1bmN0aW9uIGkodCl7Zm9yKHZhciBlIGluIHIucHJvdG90eXBlKXRbZV09ci5wcm90b3R5cGVbZV07cmV0dXJuIHR9dmFyIHM9bigyMik7dC5leHBvcnRzPXIsci5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmhlYWRlclt0LnRvTG93ZXJDYXNlKCldfSxyLnByb3RvdHlwZS5fc2V0SGVhZGVyUHJvcGVydGllcz1mdW5jdGlvbih0KXt2YXIgZT10W1wiY29udGVudC10eXBlXCJdfHxcIlwiO3RoaXMudHlwZT1zLnR5cGUoZSk7dmFyIG49cy5wYXJhbXMoZSk7Zm9yKHZhciByIGluIG4pdGhpc1tyXT1uW3JdO3RoaXMubGlua3M9e307dHJ5e3QubGluayYmKHRoaXMubGlua3M9cy5wYXJzZUxpbmtzKHQubGluaykpfWNhdGNoKHQpe319LHIucHJvdG90eXBlLl9zZXRTdGF0dXNQcm9wZXJ0aWVzPWZ1bmN0aW9uKHQpe3ZhciBlPXQvMTAwfDA7dGhpcy5zdGF0dXM9dGhpcy5zdGF0dXNDb2RlPXQsdGhpcy5zdGF0dXNUeXBlPWUsdGhpcy5pbmZvPTE9PWUsdGhpcy5vaz0yPT1lLHRoaXMucmVkaXJlY3Q9Mz09ZSx0aGlzLmNsaWVudEVycm9yPTQ9PWUsdGhpcy5zZXJ2ZXJFcnJvcj01PT1lLHRoaXMuZXJyb3I9KDQ9PWV8fDU9PWUpJiZ0aGlzLnRvRXJyb3IoKSx0aGlzLmNyZWF0ZWQ9MjAxPT10LHRoaXMuYWNjZXB0ZWQ9MjAyPT10LHRoaXMubm9Db250ZW50PTIwND09dCx0aGlzLmJhZFJlcXVlc3Q9NDAwPT10LHRoaXMudW5hdXRob3JpemVkPTQwMT09dCx0aGlzLm5vdEFjY2VwdGFibGU9NDA2PT10LHRoaXMuZm9yYmlkZGVuPTQwMz09dCx0aGlzLm5vdEZvdW5kPTQwND09dCx0aGlzLnVucHJvY2Vzc2FibGVFbnRpdHk9NDIyPT10fX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2UudHlwZT1mdW5jdGlvbih0KXtyZXR1cm4gdC5zcGxpdCgvICo7ICovKS5zaGlmdCgpfSxlLnBhcmFtcz1mdW5jdGlvbih0KXtyZXR1cm4gdC5zcGxpdCgvICo7ICovKS5yZWR1Y2UoZnVuY3Rpb24odCxlKXt2YXIgbj1lLnNwbGl0KC8gKj0gKi8pLHI9bi5zaGlmdCgpLGk9bi5zaGlmdCgpO3JldHVybiByJiZpJiYodFtyXT1pKSx0fSx7fSl9LGUucGFyc2VMaW5rcz1mdW5jdGlvbih0KXtyZXR1cm4gdC5zcGxpdCgvICosICovKS5yZWR1Y2UoZnVuY3Rpb24odCxlKXt2YXIgbj1lLnNwbGl0KC8gKjsgKi8pLHI9blswXS5zbGljZSgxLC0xKTtyZXR1cm4gdFtuWzFdLnNwbGl0KC8gKj0gKi8pWzFdLnNsaWNlKDEsLTEpXT1yLHR9LHt9KX0sZS5jbGVhbkhlYWRlcj1mdW5jdGlvbih0LGUpe3JldHVybiBkZWxldGUgdFtcImNvbnRlbnQtdHlwZVwiXSxkZWxldGUgdFtcImNvbnRlbnQtbGVuZ3RoXCJdLGRlbGV0ZSB0W1widHJhbnNmZXItZW5jb2RpbmdcIl0sZGVsZXRlIHQuaG9zdCxlJiYoZGVsZXRlIHQuYXV0aG9yaXphdGlvbixkZWxldGUgdC5jb29raWUpLHR9fSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4oKXt0aGlzLl9kZWZhdWx0cz1bXX1bXCJ1c2VcIixcIm9uXCIsXCJvbmNlXCIsXCJzZXRcIixcInF1ZXJ5XCIsXCJ0eXBlXCIsXCJhY2NlcHRcIixcImF1dGhcIixcIndpdGhDcmVkZW50aWFsc1wiLFwic29ydFF1ZXJ5XCIsXCJyZXRyeVwiLFwib2tcIixcInJlZGlyZWN0c1wiLFwidGltZW91dFwiLFwiYnVmZmVyXCIsXCJzZXJpYWxpemVcIixcInBhcnNlXCIsXCJjYVwiLFwia2V5XCIsXCJwZnhcIixcImNlcnRcIl0uZm9yRWFjaChmdW5jdGlvbih0KXtuLnByb3RvdHlwZVt0XT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9kZWZhdWx0cy5wdXNoKHtmbjp0LGFyZ3VtZW50czphcmd1bWVudHN9KSx0aGlzfX0pLG4ucHJvdG90eXBlLl9zZXREZWZhdWx0cz1mdW5jdGlvbih0KXt0aGlzLl9kZWZhdWx0cy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3RbZS5mbl0uYXBwbHkodCxlLmFyZ3VtZW50cyl9KX0sdC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSxuKXtmdW5jdGlvbiByKHQpe3ZhciBuLHI9MDtmb3IobiBpbiB0KXI9KHI8PDUpLXIrdC5jaGFyQ29kZUF0KG4pLHJ8PTA7cmV0dXJuIGUuY29sb3JzW01hdGguYWJzKHIpJWUuY29sb3JzLmxlbmd0aF19ZnVuY3Rpb24gaSh0KXtmdW5jdGlvbiBuKCl7aWYobi5lbmFibGVkKXt2YXIgdD1uLHI9K25ldyBEYXRlLHM9ci0oaXx8cik7dC5kaWZmPXMsdC5wcmV2PWksdC5jdXJyPXIsaT1yO2Zvcih2YXIgbz1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCksYT0wO2E8by5sZW5ndGg7YSsrKW9bYV09YXJndW1lbnRzW2FdO29bMF09ZS5jb2VyY2Uob1swXSksXCJzdHJpbmdcIiE9dHlwZW9mIG9bMF0mJm8udW5zaGlmdChcIiVPXCIpO3ZhciB1PTA7b1swXT1vWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLGZ1bmN0aW9uKG4scil7aWYoXCIlJVwiPT09bilyZXR1cm4gbjt1Kys7dmFyIGk9ZS5mb3JtYXR0ZXJzW3JdO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGkpe3ZhciBzPW9bdV07bj1pLmNhbGwodCxzKSxvLnNwbGljZSh1LDEpLHUtLX1yZXR1cm4gbn0pLGUuZm9ybWF0QXJncy5jYWxsKHQsbyk7KG4ubG9nfHxlLmxvZ3x8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSkuYXBwbHkodCxvKX19dmFyIGk7cmV0dXJuIG4ubmFtZXNwYWNlPXQsbi5lbmFibGVkPWUuZW5hYmxlZCh0KSxuLnVzZUNvbG9ycz1lLnVzZUNvbG9ycygpLG4uY29sb3I9cih0KSxuLmRlc3Ryb3k9cyxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmluaXQmJmUuaW5pdChuKSxlLmluc3RhbmNlcy5wdXNoKG4pLG59ZnVuY3Rpb24gcygpe3ZhciB0PWUuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7cmV0dXJuLTEhPT10JiYoZS5pbnN0YW5jZXMuc3BsaWNlKHQsMSksITApfWZ1bmN0aW9uIG8odCl7ZS5zYXZlKHQpLGUubmFtZXM9W10sZS5za2lwcz1bXTt2YXIgbixyPShcInN0cmluZ1wiPT10eXBlb2YgdD90OlwiXCIpLnNwbGl0KC9bXFxzLF0rLyksaT1yLmxlbmd0aDtmb3Iobj0wO248aTtuKyspcltuXSYmKHQ9cltuXS5yZXBsYWNlKC9cXCovZyxcIi4qP1wiKSxcIi1cIj09PXRbMF0/ZS5za2lwcy5wdXNoKG5ldyBSZWdFeHAoXCJeXCIrdC5zdWJzdHIoMSkrXCIkXCIpKTplLm5hbWVzLnB1c2gobmV3IFJlZ0V4cChcIl5cIit0K1wiJFwiKSkpO2ZvcihuPTA7bjxlLmluc3RhbmNlcy5sZW5ndGg7bisrKXt2YXIgcz1lLmluc3RhbmNlc1tuXTtzLmVuYWJsZWQ9ZS5lbmFibGVkKHMubmFtZXNwYWNlKX19ZnVuY3Rpb24gYSgpe2UuZW5hYmxlKFwiXCIpfWZ1bmN0aW9uIHUodCl7aWYoXCIqXCI9PT10W3QubGVuZ3RoLTFdKXJldHVybiEwO3ZhciBuLHI7Zm9yKG49MCxyPWUuc2tpcHMubGVuZ3RoO248cjtuKyspaWYoZS5za2lwc1tuXS50ZXN0KHQpKXJldHVybiExO2ZvcihuPTAscj1lLm5hbWVzLmxlbmd0aDtuPHI7bisrKWlmKGUubmFtZXNbbl0udGVzdCh0KSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBjKHQpe3JldHVybiB0IGluc3RhbmNlb2YgRXJyb3I/dC5zdGFja3x8dC5tZXNzYWdlOnR9ZT10LmV4cG9ydHM9aS5kZWJ1Zz1pLmRlZmF1bHQ9aSxlLmNvZXJjZT1jLGUuZGlzYWJsZT1hLGUuZW5hYmxlPW8sZS5lbmFibGVkPXUsZS5odW1hbml6ZT1uKDI1KSxlLmluc3RhbmNlcz1bXSxlLm5hbWVzPVtdLGUuc2tpcHM9W10sZS5mb3JtYXR0ZXJzPXt9fSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4odCl7aWYodD1TdHJpbmcodCksISh0Lmxlbmd0aD4xMDApKXt2YXIgZT0vXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHQpO2lmKGUpe3ZhciBuPXBhcnNlRmxvYXQoZVsxXSk7c3dpdGNoKChlWzJdfHxcIm1zXCIpLnRvTG93ZXJDYXNlKCkpe2Nhc2VcInllYXJzXCI6Y2FzZVwieWVhclwiOmNhc2VcInlyc1wiOmNhc2VcInlyXCI6Y2FzZVwieVwiOnJldHVybiBuKmw7Y2FzZVwiZGF5c1wiOmNhc2VcImRheVwiOmNhc2VcImRcIjpyZXR1cm4gbipjO2Nhc2VcImhvdXJzXCI6Y2FzZVwiaG91clwiOmNhc2VcImhyc1wiOmNhc2VcImhyXCI6Y2FzZVwiaFwiOnJldHVybiBuKnU7Y2FzZVwibWludXRlc1wiOmNhc2VcIm1pbnV0ZVwiOmNhc2VcIm1pbnNcIjpjYXNlXCJtaW5cIjpjYXNlXCJtXCI6cmV0dXJuIG4qYTtjYXNlXCJzZWNvbmRzXCI6Y2FzZVwic2Vjb25kXCI6Y2FzZVwic2Vjc1wiOmNhc2VcInNlY1wiOmNhc2VcInNcIjpyZXR1cm4gbipvO2Nhc2VcIm1pbGxpc2Vjb25kc1wiOmNhc2VcIm1pbGxpc2Vjb25kXCI6Y2FzZVwibXNlY3NcIjpjYXNlXCJtc2VjXCI6Y2FzZVwibXNcIjpyZXR1cm4gbjtkZWZhdWx0OnJldHVybn19fX1mdW5jdGlvbiByKHQpe3JldHVybiB0Pj1jP01hdGgucm91bmQodC9jKStcImRcIjp0Pj11P01hdGgucm91bmQodC91KStcImhcIjp0Pj1hP01hdGgucm91bmQodC9hKStcIm1cIjp0Pj1vP01hdGgucm91bmQodC9vKStcInNcIjp0K1wibXNcIn1mdW5jdGlvbiBpKHQpe3JldHVybiBzKHQsYyxcImRheVwiKXx8cyh0LHUsXCJob3VyXCIpfHxzKHQsYSxcIm1pbnV0ZVwiKXx8cyh0LG8sXCJzZWNvbmRcIil8fHQrXCIgbXNcIn1mdW5jdGlvbiBzKHQsZSxuKXtpZighKHQ8ZSkpcmV0dXJuIHQ8MS41KmU/TWF0aC5mbG9vcih0L2UpK1wiIFwiK246TWF0aC5jZWlsKHQvZSkrXCIgXCIrbitcInNcIn12YXIgbz0xZTMsYT02MCpvLHU9NjAqYSxjPTI0KnUsbD0zNjUuMjUqYzt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtlPWV8fHt9O3ZhciBzPXR5cGVvZiB0O2lmKFwic3RyaW5nXCI9PT1zJiZ0Lmxlbmd0aD4wKXJldHVybiBuKHQpO2lmKFwibnVtYmVyXCI9PT1zJiYhMT09PWlzTmFOKHQpKXJldHVybiBlLmxvbmc/aSh0KTpyKHQpO3Rocm93IG5ldyBFcnJvcihcInZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9XCIrSlNPTi5zdHJpbmdpZnkodCkpfX0sZnVuY3Rpb24odCxlLG4peyhmdW5jdGlvbihlKXsvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlL21hc3Rlci9MSUNFTlNFXG4gKiBAdmVyc2lvbiAgIHY0LjIuMytiMzNmNDczNFxuICovXG4hZnVuY3Rpb24oZSxuKXt0LmV4cG9ydHM9bigpfSgwLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gdCh0KXt2YXIgZT10eXBlb2YgdDtyZXR1cm4gbnVsbCE9PXQmJihcIm9iamVjdFwiPT09ZXx8XCJmdW5jdGlvblwiPT09ZSl9ZnVuY3Rpb24gcih0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0fWZ1bmN0aW9uIGkodCl7Qj10fWZ1bmN0aW9uIHModCl7Sj10fWZ1bmN0aW9uIG8oKXtyZXR1cm4gdm9pZCAwIT09TT9mdW5jdGlvbigpe00odSl9OmEoKX1mdW5jdGlvbiBhKCl7dmFyIHQ9c2V0VGltZW91dDtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdCh1LDEpfX1mdW5jdGlvbiB1KCl7Zm9yKHZhciB0PTA7dDxxO3QrPTIpeygwLEdbdF0pKEdbdCsxXSksR1t0XT12b2lkIDAsR1t0KzFdPXZvaWQgMH1xPTB9ZnVuY3Rpb24gYyh0LGUpe3ZhciBuPXRoaXMscj1uZXcgdGhpcy5jb25zdHJ1Y3RvcihoKTt2b2lkIDA9PT1yWyRdJiZqKHIpO3ZhciBpPW4uX3N0YXRlO2lmKGkpe3ZhciBzPWFyZ3VtZW50c1tpLTFdO0ooZnVuY3Rpb24oKXtyZXR1cm4gRShpLHIscyxuLl9yZXN1bHQpfSl9ZWxzZSBBKG4scix0LGUpO3JldHVybiByfWZ1bmN0aW9uIGwodCl7dmFyIGU9dGhpcztpZih0JiZcIm9iamVjdFwiPT10eXBlb2YgdCYmdC5jb25zdHJ1Y3Rvcj09PWUpcmV0dXJuIHQ7dmFyIG49bmV3IGUoaCk7cmV0dXJuIGcobix0KSxufWZ1bmN0aW9uIGgoKXt9ZnVuY3Rpb24gZigpe3JldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKX1mdW5jdGlvbiBkKCl7cmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuXCIpfWZ1bmN0aW9uIHAodCl7dHJ5e3JldHVybiB0LnRoZW59Y2F0Y2godCl7cmV0dXJuIHR0LmVycm9yPXQsdHR9fWZ1bmN0aW9uIF8odCxlLG4scil7dHJ5e3QuY2FsbChlLG4scil9Y2F0Y2godCl7cmV0dXJuIHR9fWZ1bmN0aW9uIHYodCxlLG4pe0ooZnVuY3Rpb24odCl7dmFyIHI9ITEsaT1fKG4sZSxmdW5jdGlvbihuKXtyfHwocj0hMCxlIT09bj9nKHQsbik6dyh0LG4pKX0sZnVuY3Rpb24oZSl7cnx8KHI9ITAsTyh0LGUpKX0sXCJTZXR0bGU6IFwiKyh0Ll9sYWJlbHx8XCIgdW5rbm93biBwcm9taXNlXCIpKTshciYmaSYmKHI9ITAsTyh0LGkpKX0sdCl9ZnVuY3Rpb24geSh0LGUpe2UuX3N0YXRlPT09WT93KHQsZS5fcmVzdWx0KTplLl9zdGF0ZT09PVo/Tyh0LGUuX3Jlc3VsdCk6QShlLHZvaWQgMCxmdW5jdGlvbihlKXtyZXR1cm4gZyh0LGUpfSxmdW5jdGlvbihlKXtyZXR1cm4gTyh0LGUpfSl9ZnVuY3Rpb24gbSh0LGUsbil7ZS5jb25zdHJ1Y3Rvcj09PXQuY29uc3RydWN0b3ImJm49PT1jJiZlLmNvbnN0cnVjdG9yLnJlc29sdmU9PT1sP3kodCxlKTpuPT09dHQ/KE8odCx0dC5lcnJvciksdHQuZXJyb3I9bnVsbCk6dm9pZCAwPT09bj93KHQsZSk6cihuKT92KHQsZSxuKTp3KHQsZSl9ZnVuY3Rpb24gZyhlLG4pe2U9PT1uP08oZSxmKCkpOnQobik/bShlLG4scChuKSk6dyhlLG4pfWZ1bmN0aW9uIGIodCl7dC5fb25lcnJvciYmdC5fb25lcnJvcih0Ll9yZXN1bHQpLFModCl9ZnVuY3Rpb24gdyh0LGUpe3QuX3N0YXRlPT09WCYmKHQuX3Jlc3VsdD1lLHQuX3N0YXRlPVksMCE9PXQuX3N1YnNjcmliZXJzLmxlbmd0aCYmSihTLHQpKX1mdW5jdGlvbiBPKHQsZSl7dC5fc3RhdGU9PT1YJiYodC5fc3RhdGU9Wix0Ll9yZXN1bHQ9ZSxKKGIsdCkpfWZ1bmN0aW9uIEEodCxlLG4scil7dmFyIGk9dC5fc3Vic2NyaWJlcnMscz1pLmxlbmd0aDt0Ll9vbmVycm9yPW51bGwsaVtzXT1lLGlbcytZXT1uLGlbcytaXT1yLDA9PT1zJiZ0Ll9zdGF0ZSYmSihTLHQpfWZ1bmN0aW9uIFModCl7dmFyIGU9dC5fc3Vic2NyaWJlcnMsbj10Ll9zdGF0ZTtpZigwIT09ZS5sZW5ndGgpe2Zvcih2YXIgcj12b2lkIDAsaT12b2lkIDAscz10Ll9yZXN1bHQsbz0wO288ZS5sZW5ndGg7bys9MylyPWVbb10saT1lW28rbl0scj9FKG4scixpLHMpOmkocyk7dC5fc3Vic2NyaWJlcnMubGVuZ3RoPTB9fWZ1bmN0aW9uIEModCxlKXt0cnl7cmV0dXJuIHQoZSl9Y2F0Y2godCl7cmV0dXJuIHR0LmVycm9yPXQsdHR9fWZ1bmN0aW9uIEUodCxlLG4saSl7dmFyIHM9cihuKSxvPXZvaWQgMCxhPXZvaWQgMCx1PXZvaWQgMCxjPXZvaWQgMDtpZihzKXtpZihvPUMobixpKSxvPT09dHQ/KGM9ITAsYT1vLmVycm9yLG8uZXJyb3I9bnVsbCk6dT0hMCxlPT09bylyZXR1cm4gdm9pZCBPKGUsZCgpKX1lbHNlIG89aSx1PSEwO2UuX3N0YXRlIT09WHx8KHMmJnU/ZyhlLG8pOmM/TyhlLGEpOnQ9PT1ZP3coZSxvKTp0PT09WiYmTyhlLG8pKX1mdW5jdGlvbiBUKHQsZSl7dHJ5e2UoZnVuY3Rpb24oZSl7Zyh0LGUpfSxmdW5jdGlvbihlKXtPKHQsZSl9KX1jYXRjaChlKXtPKHQsZSl9fWZ1bmN0aW9uIE4oKXtyZXR1cm4gZXQrK31mdW5jdGlvbiBqKHQpe3RbJF09ZXQrKyx0Ll9zdGF0ZT12b2lkIDAsdC5fcmVzdWx0PXZvaWQgMCx0Ll9zdWJzY3JpYmVycz1bXX1mdW5jdGlvbiB4KCl7cmV0dXJuIG5ldyBFcnJvcihcIkFycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheVwiKX1mdW5jdGlvbiBVKHQpe3JldHVybiBuZXcgbnQodGhpcyx0KS5wcm9taXNlfWZ1bmN0aW9uIGsodCl7dmFyIGU9dGhpcztyZXR1cm4gbmV3IGUoRih0KT9mdW5jdGlvbihuLHIpe2Zvcih2YXIgaT10Lmxlbmd0aCxzPTA7czxpO3MrKyllLnJlc29sdmUodFtzXSkudGhlbihuLHIpfTpmdW5jdGlvbih0LGUpe3JldHVybiBlKG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuXCIpKX0pfWZ1bmN0aW9uIEkodCl7dmFyIGU9dGhpcyxuPW5ldyBlKGgpO3JldHVybiBPKG4sdCksbn1mdW5jdGlvbiBSKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3JcIil9ZnVuY3Rpb24gUCgpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIil9ZnVuY3Rpb24gRCgpe3ZhciB0PXZvaWQgMDtpZih2b2lkIDAhPT1lKXQ9ZTtlbHNlIGlmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmKXQ9c2VsZjtlbHNlIHRyeXt0PUZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKX1jYXRjaCh0KXt0aHJvdyBuZXcgRXJyb3IoXCJwb2x5ZmlsbCBmYWlsZWQgYmVjYXVzZSBnbG9iYWwgb2JqZWN0IGlzIHVuYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnRcIil9dmFyIG49dC5Qcm9taXNlO2lmKG4pe3ZhciByPW51bGw7dHJ5e3I9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG4ucmVzb2x2ZSgpKX1jYXRjaCh0KXt9aWYoXCJbb2JqZWN0IFByb21pc2VdXCI9PT1yJiYhbi5jYXN0KXJldHVybn10LlByb21pc2U9cnR9dmFyIEw9dm9pZCAwO0w9QXJyYXkuaXNBcnJheT9BcnJheS5pc0FycmF5OmZ1bmN0aW9uKHQpe3JldHVyblwiW29iamVjdCBBcnJheV1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KX07dmFyIEY9TCxxPTAsTT12b2lkIDAsQj12b2lkIDAsSj1mdW5jdGlvbih0LGUpe0dbcV09dCxHW3ErMV09ZSwyPT09KHErPTIpJiYoQj9CKHUpOkgoKSl9LFc9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6dm9pZCAwLFE9V3x8e30sVj1RLk11dGF0aW9uT2JzZXJ2ZXJ8fFEuV2ViS2l0TXV0YXRpb25PYnNlcnZlcixLPVwidW5kZWZpbmVkXCI9PXR5cGVvZiBzZWxmJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgcHJvY2VzcyYmXCJbb2JqZWN0IHByb2Nlc3NdXCI9PT17fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpLHo9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5JiZcInVuZGVmaW5lZFwiIT10eXBlb2YgaW1wb3J0U2NyaXB0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIE1lc3NhZ2VDaGFubmVsLEc9bmV3IEFycmF5KDFlMyksSD12b2lkIDA7SD1LP2Z1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHByb2Nlc3MubmV4dFRpY2sodSl9fSgpOlY/ZnVuY3Rpb24oKXt2YXIgdD0wLGU9bmV3IFYodSksbj1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtyZXR1cm4gZS5vYnNlcnZlKG4se2NoYXJhY3RlckRhdGE6ITB9KSxmdW5jdGlvbigpe24uZGF0YT10PSsrdCUyfX0oKTp6P2Z1bmN0aW9uKCl7dmFyIHQ9bmV3IE1lc3NhZ2VDaGFubmVsO3JldHVybiB0LnBvcnQxLm9ubWVzc2FnZT11LGZ1bmN0aW9uKCl7cmV0dXJuIHQucG9ydDIucG9zdE1lc3NhZ2UoMCl9fSgpOnZvaWQgMD09PVc/ZnVuY3Rpb24oKXt0cnl7dmFyIHQ9bigyNyk7cmV0dXJuIE09dC5ydW5Pbkxvb3B8fHQucnVuT25Db250ZXh0LG8oKX1jYXRjaCh0KXtyZXR1cm4gYSgpfX0oKTphKCk7dmFyICQ9TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIpLFg9dm9pZCAwLFk9MSxaPTIsdHQ9e2Vycm9yOm51bGx9LGV0PTAsbnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7dGhpcy5faW5zdGFuY2VDb25zdHJ1Y3Rvcj10LHRoaXMucHJvbWlzZT1uZXcgdChoKSx0aGlzLnByb21pc2VbJF18fGoodGhpcy5wcm9taXNlKSxGKGUpPyh0aGlzLmxlbmd0aD1lLmxlbmd0aCx0aGlzLl9yZW1haW5pbmc9ZS5sZW5ndGgsdGhpcy5fcmVzdWx0PW5ldyBBcnJheSh0aGlzLmxlbmd0aCksMD09PXRoaXMubGVuZ3RoP3codGhpcy5wcm9taXNlLHRoaXMuX3Jlc3VsdCk6KHRoaXMubGVuZ3RoPXRoaXMubGVuZ3RofHwwLHRoaXMuX2VudW1lcmF0ZShlKSwwPT09dGhpcy5fcmVtYWluaW5nJiZ3KHRoaXMucHJvbWlzZSx0aGlzLl9yZXN1bHQpKSk6Tyh0aGlzLnByb21pc2UseCgpKX1yZXR1cm4gdC5wcm90b3R5cGUuX2VudW1lcmF0ZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9MDt0aGlzLl9zdGF0ZT09PVgmJmU8dC5sZW5ndGg7ZSsrKXRoaXMuX2VhY2hFbnRyeSh0W2VdLGUpfSx0LnByb3RvdHlwZS5fZWFjaEVudHJ5PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5faW5zdGFuY2VDb25zdHJ1Y3RvcixyPW4ucmVzb2x2ZTtpZihyPT09bCl7dmFyIGk9cCh0KTtpZihpPT09YyYmdC5fc3RhdGUhPT1YKXRoaXMuX3NldHRsZWRBdCh0Ll9zdGF0ZSxlLHQuX3Jlc3VsdCk7ZWxzZSBpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBpKXRoaXMuX3JlbWFpbmluZy0tLHRoaXMuX3Jlc3VsdFtlXT10O2Vsc2UgaWYobj09PXJ0KXt2YXIgcz1uZXcgbihoKTttKHMsdCxpKSx0aGlzLl93aWxsU2V0dGxlQXQocyxlKX1lbHNlIHRoaXMuX3dpbGxTZXR0bGVBdChuZXcgbihmdW5jdGlvbihlKXtyZXR1cm4gZSh0KX0pLGUpfWVsc2UgdGhpcy5fd2lsbFNldHRsZUF0KHIodCksZSl9LHQucHJvdG90eXBlLl9zZXR0bGVkQXQ9ZnVuY3Rpb24odCxlLG4pe3ZhciByPXRoaXMucHJvbWlzZTtyLl9zdGF0ZT09PVgmJih0aGlzLl9yZW1haW5pbmctLSx0PT09Wj9PKHIsbik6dGhpcy5fcmVzdWx0W2VdPW4pLDA9PT10aGlzLl9yZW1haW5pbmcmJncocix0aGlzLl9yZXN1bHQpfSx0LnByb3RvdHlwZS5fd2lsbFNldHRsZUF0PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztBKHQsdm9pZCAwLGZ1bmN0aW9uKHQpe3JldHVybiBuLl9zZXR0bGVkQXQoWSxlLHQpfSxmdW5jdGlvbih0KXtyZXR1cm4gbi5fc2V0dGxlZEF0KFosZSx0KX0pfSx0fSgpLHJ0PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdChlKXt0aGlzWyRdPU4oKSx0aGlzLl9yZXN1bHQ9dGhpcy5fc3RhdGU9dm9pZCAwLHRoaXMuX3N1YnNjcmliZXJzPVtdLGghPT1lJiYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmUigpLHRoaXMgaW5zdGFuY2VvZiB0P1QodGhpcyxlKTpQKCkpfXJldHVybiB0LnByb3RvdHlwZS5jYXRjaD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aGVuKG51bGwsdCl9LHQucHJvdG90eXBlLmZpbmFsbHk9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxuPWUuY29uc3RydWN0b3I7cmV0dXJuIGUudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gbi5yZXNvbHZlKHQoKSkudGhlbihmdW5jdGlvbigpe3JldHVybiBlfSl9LGZ1bmN0aW9uKGUpe3JldHVybiBuLnJlc29sdmUodCgpKS50aGVuKGZ1bmN0aW9uKCl7dGhyb3cgZX0pfSl9LHR9KCk7cmV0dXJuIHJ0LnByb3RvdHlwZS50aGVuPWMscnQuYWxsPVUscnQucmFjZT1rLHJ0LnJlc29sdmU9bCxydC5yZWplY3Q9SSxydC5fc2V0U2NoZWR1bGVyPWkscnQuX3NldEFzYXA9cyxydC5fYXNhcD1KLHJ0LnBvbHlmaWxsPUQscnQuUHJvbWlzZT1ydCxydH0pfSkuY2FsbChlLG4oNykpfSxmdW5jdGlvbih0LGUpe30sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiOyhmdW5jdGlvbihlKXt2YXIgcj1uKDApLGk9KG4oMSkse30pLHM9W1wiZ2V0SXRlbVwiLFwic2V0SXRlbVwiLFwicmVtb3ZlSXRlbVwiLFwiY2xlYXJcIl0sbz1lLmxvY2FsU3RvcmFnZTt0cnl7dmFyIGE9XCJfX3N0b3JlanNfX1wiO2lmKG8uc2V0SXRlbShhLGEpLG8uZ2V0SXRlbShhKSE9YSl0aHJvdyBuZXcgRXJyb3I7by5yZW1vdmVJdGVtKGEpfWNhdGNoKHQpe289bigyOSl9cihzKS5lYWNoKGZ1bmN0aW9uKHQpe2lbdF09ZnVuY3Rpb24oKXtyZXR1cm4gb1t0XS5hcHBseShvLGFyZ3VtZW50cyl9fSksaS5hc3luYz0hMSx0LmV4cG9ydHM9aX0pLmNhbGwoZSxuKDcpKX0sZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihlKXt2YXIgbj17fSxyPXt9O24ubGVuZ3RoPTAsbi5nZXRJdGVtPWZ1bmN0aW9uKHQpe3JldHVybiByW3RdfHxudWxsfSxuLnNldEl0ZW09ZnVuY3Rpb24odCxlKXt2b2lkIDA9PT1lP24ucmVtb3ZlSXRlbSh0KTooci5oYXNPd25Qcm9wZXJ0eSh0KXx8bi5sZW5ndGgrKyxyW3RdPVwiXCIrZSl9LG4ucmVtb3ZlSXRlbT1mdW5jdGlvbih0KXtyLmhhc093blByb3BlcnR5KHQpJiYoZGVsZXRlIHJbdF0sbi5sZW5ndGgtLSl9LG4ua2V5PWZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3Qua2V5cyhyKVt0XXx8bnVsbH0sbi5jbGVhcj1mdW5jdGlvbigpe3I9e30sbi5sZW5ndGg9MH0sdC5leHBvcnRzPW59KCl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQsZSl7aWYoXCJ1c1wiPT09ZSlyZXR1cm4gaChcImh0dHBzOi8vdXMtYXBpLmxlYW5jbG91ZC5jblwiKTt2YXIgbj12b2lkIDA7c3dpdGNoKHQuc2xpY2UoLTkpKXtjYXNlXCItOU5oOWowVmFcIjpyZXR1cm4gbj10LnNsaWNlKDAsOCkudG9Mb3dlckNhc2UoKSx7cHVzaDpcImh0dHBzOi8vXCIrbitcIi5wdXNoLmxuY2xkYXBpLmNvbVwiLHN0YXRzOlwiaHR0cHM6Ly9cIituK1wiLnN0YXRzLmxuY2xkYXBpLmNvbVwiLGVuZ2luZTpcImh0dHBzOi8vXCIrbitcIi5lbmdpbmUubG5jbGRhcGkuY29tXCIsYXBpOlwiaHR0cHM6Ly9cIituK1wiLmFwaS5sbmNsZGFwaS5jb21cIn07Y2FzZVwiLU1kWVhiTU1JXCI6cmV0dXJuIGgoXCJodHRwczovL3VzLWFwaS5sZWFuY2xvdWQuY25cIik7ZGVmYXVsdDpyZXR1cm4gbj10LnNsaWNlKDAsOCkudG9Mb3dlckNhc2UoKSx7cHVzaDpcImh0dHBzOi8vXCIrbitcIi5wdXNoLmxuY2xkLm5ldFwiLHN0YXRzOlwiaHR0cHM6Ly9cIituK1wiLnN0YXRzLmxuY2xkLm5ldFwiLGVuZ2luZTpcImh0dHBzOi8vXCIrbitcIi5lbmdpbmUubG5jbGQubmV0XCIsYXBpOlwiaHR0cHM6Ly9cIituK1wiLmFwaS5sbmNsZC5uZXRcIn19fXZhciBpPW4oNSkscz1uKDMxKSxvPW4oMyksYT1vLmlzTnVsbE9yVW5kZWZpbmVkLHU9bigwKSxjPXUuZXh0ZW5kLGw9dS5pc09iamVjdCxoPWZ1bmN0aW9uKHQpe3JldHVybntwdXNoOnQsc3RhdHM6dCxlbmdpbmU6dCxhcGk6dH19LGY9ITE7aS5pbml0PWZ1bmN0aW9uKHQpe2lmKCFsKHQpKXJldHVybiBpLmluaXQoe2FwcElkOnQsYXBwS2V5OmFyZ3VtZW50cy5sZW5ndGg8PTE/dm9pZCAwOmFyZ3VtZW50c1sxXSxtYXN0ZXJLZXk6YXJndW1lbnRzLmxlbmd0aDw9Mj92b2lkIDA6YXJndW1lbnRzWzJdLHJlZ2lvbjphcmd1bWVudHMubGVuZ3RoPD0zP3ZvaWQgMDphcmd1bWVudHNbM119KTt2YXIgZT10LmFwcElkLG49dC5hcHBLZXksbz10Lm1hc3RlcktleSxhPSh0Lmhvb2tLZXksdC5yZWdpb24pLHU9dm9pZCAwPT09YT9cImNuXCI6YSxkPXQuc2VydmVyVVJMcyxwPXQuZGlzYWJsZUN1cnJlbnRVc2VyLF89dC5wcm9kdWN0aW9uLHY9dC5yZWFsdGltZTtpZihpLmFwcGxpY2F0aW9uSWQpdGhyb3cgbmV3IEVycm9yKFwiU0RLIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXCIpO2lmKCFlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhcHBJZCBtdXN0IGJlIGEgc3RyaW5nXCIpO2lmKCFuKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhcHBLZXkgbXVzdCBiZSBhIHN0cmluZ1wiKTtvJiZjb25zb2xlLndhcm4oXCJNYXN0ZXJLZXkgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHVzZWQgaW4gYnJvd3Nlci5cIiksaS5fY29uZmlnLmFwcGxpY2F0aW9uSWQ9ZSxpLl9jb25maWcuYXBwbGljYXRpb25LZXk9bixpLl9jb25maWcubWFzdGVyS2V5PW8sdm9pZCAwIT09XyYmKGkuX2NvbmZpZy5wcm9kdWN0aW9uPV8pLHZvaWQgMCE9PXAmJihpLl9jb25maWcuZGlzYWJsZUN1cnJlbnRVc2VyPXApLGkuX2FwcFJvdXRlcj1uZXcgcyhpKTt2YXIgeT1mfHx2b2lkIDAhPT1kfHxcImNuXCIhPT11O2kuX3NldFNlcnZlclVSTHMoYyh7fSxyKGUsdSksaS5fY29uZmlnLnNlcnZlclVSTHMsXCJzdHJpbmdcIj09dHlwZW9mIGQ/aChkKTpkKSx5KSx2P2kuX2NvbmZpZy5yZWFsdGltZT12OmkuX3NoYXJlZENvbmZpZy5saXZlUXVlcnlSZWFsdGltZSYmKGkuX2NvbmZpZy5yZWFsdGltZT1uZXcgaS5fc2hhcmVkQ29uZmlnLmxpdmVRdWVyeVJlYWx0aW1lKHthcHBJZDplLGFwcEtleTpuLHJlZ2lvbjp1fSkpfSxpLnNldFByb2R1Y3Rpb249ZnVuY3Rpb24odCl7YSh0KT9pLl9jb25maWcucHJvZHVjdGlvbj1udWxsOmkuX2NvbmZpZy5wcm9kdWN0aW9uPXQ/MTowfSxpLl9zZXRTZXJ2ZXJVUkxzPWZ1bmN0aW9uKHQpe3ZhciBlPSEoYXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0pfHxhcmd1bWVudHNbMV07XCJzdHJpbmdcIiE9dHlwZW9mIHQ/YyhpLl9jb25maWcuc2VydmVyVVJMcyx0KTppLl9jb25maWcuc2VydmVyVVJMcz1oKHQpLGUmJihpLl9hcHBSb3V0ZXI/aS5fYXBwUm91dGVyLmRpc2FibGUoKTpmPSEwKX0saS5zZXRTZXJ2ZXJVUkxzPWZ1bmN0aW9uKHQpe3JldHVybiBpLl9zZXRTZXJ2ZXJVUkxzKHQpfSxpLmtlZXBFcnJvclJhd01lc3NhZ2U9ZnVuY3Rpb24odCl7aS5fc2hhcmVkQ29uZmlnLmtlZXBFcnJvclJhd01lc3NhZ2U9dH0saS5zZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbih0KXtpLl9jb25maWcucmVxdWVzdFRpbWVvdXQ9dH0saS5pbml0aWFsaXplPWkuaW5pdCxbXCJhcHBsaWNhdGlvbklkXCIsXCJhcHBsaWNhdGlvbktleVwiLFwibWFzdGVyS2V5XCIsXCJob29rS2V5XCJdLmZvckVhY2goZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLHQse2dldDpmdW5jdGlvbigpe3JldHVybiBpLl9jb25maWdbdF19LHNldDpmdW5jdGlvbihlKXtpLl9jb25maWdbdF09ZX19KX0pfSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0KXt2YXIgZT10aGlzO3RoaXMuQVY9dCx0aGlzLmxvY2tlZFVudGlsPTAsby5nZXRBc3luYyhcInNlcnZlclVSTHNcIikudGhlbihmdW5jdGlvbih0KXtpZighdClyZXR1cm4gZS5sb2NrKDApO3ZhciBuPXQuc2VydmVyVVJMcyxyPXQubG9ja2VkVW50aWw7ZS5BVi5fc2V0U2VydmVyVVJMcyhuLCExKSxlLmxvY2tlZFVudGlsPXJ9KS5jYXRjaChmdW5jdGlvbigpe3JldHVybiBlLmxvY2soMCl9KX12YXIgaT1uKDMpLHM9aS5hamF4LG89bigxMik7ci5wcm90b3R5cGUuZGlzYWJsZT1mdW5jdGlvbigpe3RoaXMuZGlzYWJsZWQ9ITB9LHIucHJvdG90eXBlLmxvY2s9ZnVuY3Rpb24odCl7dGhpcy5sb2NrZWRVbnRpbD1EYXRlLm5vdygpK3R9LHIucHJvdG90eXBlLnJlZnJlc2g9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO2lmKCEodGhpcy5kaXNhYmxlZHx8RGF0ZS5ub3coKTx0aGlzLmxvY2tlZFVudGlsKSl7dGhpcy5sb2NrKDEwKTtyZXR1cm4gcyh7bWV0aG9kOlwiZ2V0XCIsdXJsOlwiaHR0cHM6Ly9hcHAtcm91dGVyLmxlYW5jbG91ZC5jbi8yL3JvdXRlXCIscXVlcnk6e2FwcElkOnRoaXMuQVYuYXBwbGljYXRpb25JZH19KS50aGVuKGZ1bmN0aW9uKGUpe2lmKCF0LmRpc2FibGVkKXt2YXIgbj1lLnR0bDtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIHR0bFwiKTtuKj0xZTM7dmFyIHI9e3B1c2g6XCJodHRwczovL1wiK2UucHVzaF9zZXJ2ZXIsc3RhdHM6XCJodHRwczovL1wiK2Uuc3RhdHNfc2VydmVyLGVuZ2luZTpcImh0dHBzOi8vXCIrZS5lbmdpbmVfc2VydmVyLGFwaTpcImh0dHBzOi8vXCIrZS5hcGlfc2VydmVyfTtyZXR1cm4gdC5BVi5fc2V0U2VydmVyVVJMcyhyLCExKSx0LmxvY2sobiksby5zZXRBc3luYyhcInNlcnZlclVSTHNcIix7c2VydmVyVVJMczpyLGxvY2tlZFVudGlsOnQubG9ja2VkVW50aWx9LG4pfX0pLmNhdGNoKGZ1bmN0aW9uKGUpe2NvbnNvbGUud2FybihcInJlZnJlc2ggc2VydmVyIFVSTHMgZmFpbGVkOiBcIitlLm1lc3NhZ2UpLHQubG9jayg2MDApfSl9fSx0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBlPS9cXHMrLyxuPUFycmF5LnByb3RvdHlwZS5zbGljZTt0LkV2ZW50cz17b246ZnVuY3Rpb24odCxuLHIpe3ZhciBpLHMsbyxhLHU7aWYoIW4pcmV0dXJuIHRoaXM7Zm9yKHQ9dC5zcGxpdChlKSxpPXRoaXMuX2NhbGxiYWNrc3x8KHRoaXMuX2NhbGxiYWNrcz17fSkscz10LnNoaWZ0KCk7czspdT1pW3NdLG89dT91LnRhaWw6e30sby5uZXh0PWE9e30sby5jb250ZXh0PXIsby5jYWxsYmFjaz1uLGlbc109e3RhaWw6YSxuZXh0OnU/dS5uZXh0Om99LHM9dC5zaGlmdCgpO3JldHVybiB0aGlzfSxvZmY6ZnVuY3Rpb24odCxuLGkpe3ZhciBzLG8sYSx1LGMsbDtpZihvPXRoaXMuX2NhbGxiYWNrcyl7aWYoISh0fHxufHxpKSlyZXR1cm4gZGVsZXRlIHRoaXMuX2NhbGxiYWNrcyx0aGlzO2Zvcih0PXQ/dC5zcGxpdChlKTpyLmtleXMobykscz10LnNoaWZ0KCk7czspaWYoYT1vW3NdLGRlbGV0ZSBvW3NdLGEmJihufHxpKSl7Zm9yKHU9YS50YWlsLGE9YS5uZXh0O2EhPT11OyljPWEuY2FsbGJhY2ssbD1hLmNvbnRleHQsKG4mJmMhPT1ufHxpJiZsIT09aSkmJnRoaXMub24ocyxjLGwpLGE9YS5uZXh0O3M9dC5zaGlmdCgpfXJldHVybiB0aGlzfX0sdHJpZ2dlcjpmdW5jdGlvbih0KXt2YXIgcixpLHMsbyxhLHUsYztpZighKHM9dGhpcy5fY2FsbGJhY2tzKSlyZXR1cm4gdGhpcztmb3IodT1zLmFsbCx0PXQuc3BsaXQoZSksYz1uLmNhbGwoYXJndW1lbnRzLDEpLHI9dC5zaGlmdCgpO3I7KXtpZihpPXNbcl0pZm9yKG89aS50YWlsOyhpPWkubmV4dCkhPT1vOylpLmNhbGxiYWNrLmFwcGx5KGkuY29udGV4dHx8dGhpcyxjKTtpZihpPXUpZm9yKG89aS50YWlsLGE9W3JdLmNvbmNhdChjKTsoaT1pLm5leHQpIT09bzspaS5jYWxsYmFjay5hcHBseShpLmNvbnRleHR8fHRoaXMsYSk7cj10LnNoaWZ0KCl9cmV0dXJuIHRoaXN9fSx0LkV2ZW50cy5iaW5kPXQuRXZlbnRzLm9uLHQuRXZlbnRzLnVuYmluZD10LkV2ZW50cy5vZmZ9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dC5HZW9Qb2ludD1mdW5jdGlvbihlLG4pe3IuaXNBcnJheShlKT8odC5HZW9Qb2ludC5fdmFsaWRhdGUoZVswXSxlWzFdKSx0aGlzLmxhdGl0dWRlPWVbMF0sdGhpcy5sb25naXR1ZGU9ZVsxXSk6ci5pc09iamVjdChlKT8odC5HZW9Qb2ludC5fdmFsaWRhdGUoZS5sYXRpdHVkZSxlLmxvbmdpdHVkZSksdGhpcy5sYXRpdHVkZT1lLmxhdGl0dWRlLHRoaXMubG9uZ2l0dWRlPWUubG9uZ2l0dWRlKTpyLmlzTnVtYmVyKGUpJiZyLmlzTnVtYmVyKG4pPyh0Lkdlb1BvaW50Ll92YWxpZGF0ZShlLG4pLHRoaXMubGF0aXR1ZGU9ZSx0aGlzLmxvbmdpdHVkZT1uKToodGhpcy5sYXRpdHVkZT0wLHRoaXMubG9uZ2l0dWRlPTApO3ZhciBpPXRoaXM7dGhpcy5fX2RlZmluZUdldHRlcl9fJiZ0aGlzLl9fZGVmaW5lU2V0dGVyX18mJih0aGlzLl9sYXRpdHVkZT10aGlzLmxhdGl0dWRlLHRoaXMuX2xvbmdpdHVkZT10aGlzLmxvbmdpdHVkZSx0aGlzLl9fZGVmaW5lR2V0dGVyX18oXCJsYXRpdHVkZVwiLGZ1bmN0aW9uKCl7cmV0dXJuIGkuX2xhdGl0dWRlfSksdGhpcy5fX2RlZmluZUdldHRlcl9fKFwibG9uZ2l0dWRlXCIsZnVuY3Rpb24oKXtyZXR1cm4gaS5fbG9uZ2l0dWRlfSksdGhpcy5fX2RlZmluZVNldHRlcl9fKFwibGF0aXR1ZGVcIixmdW5jdGlvbihlKXt0Lkdlb1BvaW50Ll92YWxpZGF0ZShlLGkubG9uZ2l0dWRlKSxpLl9sYXRpdHVkZT1lfSksdGhpcy5fX2RlZmluZVNldHRlcl9fKFwibG9uZ2l0dWRlXCIsZnVuY3Rpb24oZSl7dC5HZW9Qb2ludC5fdmFsaWRhdGUoaS5sYXRpdHVkZSxlKSxpLl9sb25naXR1ZGU9ZX0pKX0sdC5HZW9Qb2ludC5fdmFsaWRhdGU9ZnVuY3Rpb24odCxlKXtpZih0PC05MCl0aHJvdyBuZXcgRXJyb3IoXCJBVi5HZW9Qb2ludCBsYXRpdHVkZSBcIit0K1wiIDwgLTkwLjAuXCIpO2lmKHQ+OTApdGhyb3cgbmV3IEVycm9yKFwiQVYuR2VvUG9pbnQgbGF0aXR1ZGUgXCIrdCtcIiA+IDkwLjAuXCIpO2lmKGU8LTE4MCl0aHJvdyBuZXcgRXJyb3IoXCJBVi5HZW9Qb2ludCBsb25naXR1ZGUgXCIrZStcIiA8IC0xODAuMC5cIik7aWYoZT4xODApdGhyb3cgbmV3IEVycm9yKFwiQVYuR2VvUG9pbnQgbG9uZ2l0dWRlIFwiK2UrXCIgPiAxODAuMC5cIil9LHQuR2VvUG9pbnQuY3VycmVudD1mdW5jdGlvbigpe3JldHVybiBuZXcgdC5Qcm9taXNlKGZ1bmN0aW9uKGUsbil7bmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihmdW5jdGlvbihuKXtlKG5ldyB0Lkdlb1BvaW50KHtsYXRpdHVkZTpuLmNvb3Jkcy5sYXRpdHVkZSxsb25naXR1ZGU6bi5jb29yZHMubG9uZ2l0dWRlfSkpfSxuKX0pfSxyLmV4dGVuZCh0Lkdlb1BvaW50LnByb3RvdHlwZSx7dG9KU09OOmZ1bmN0aW9uKCl7cmV0dXJuIHQuR2VvUG9pbnQuX3ZhbGlkYXRlKHRoaXMubGF0aXR1ZGUsdGhpcy5sb25naXR1ZGUpLHtfX3R5cGU6XCJHZW9Qb2ludFwiLGxhdGl0dWRlOnRoaXMubGF0aXR1ZGUsbG9uZ2l0dWRlOnRoaXMubG9uZ2l0dWRlfX0scmFkaWFuc1RvOmZ1bmN0aW9uKHQpe3ZhciBlPU1hdGguUEkvMTgwLG49dGhpcy5sYXRpdHVkZSplLHI9dGhpcy5sb25naXR1ZGUqZSxpPXQubGF0aXR1ZGUqZSxzPXQubG9uZ2l0dWRlKmUsbz1uLWksYT1yLXMsdT1NYXRoLnNpbihvLzIpLGM9TWF0aC5zaW4oYS8yKSxsPXUqdStNYXRoLmNvcyhuKSpNYXRoLmNvcyhpKSpjKmM7cmV0dXJuIGw9TWF0aC5taW4oMSxsKSwyKk1hdGguYXNpbihNYXRoLnNxcnQobCkpfSxraWxvbWV0ZXJzVG86ZnVuY3Rpb24odCl7cmV0dXJuIDYzNzEqdGhpcy5yYWRpYW5zVG8odCl9LG1pbGVzVG86ZnVuY3Rpb24odCl7cmV0dXJuIDM5NTguOCp0aGlzLnJhZGlhbnNUbyh0KX19KX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt0LkFDTD1mdW5jdGlvbihlKXt2YXIgbj10aGlzO2lmKG4ucGVybWlzc2lvbnNCeUlkPXt9LHIuaXNPYmplY3QoZSkpaWYoZSBpbnN0YW5jZW9mIHQuVXNlciluLnNldFJlYWRBY2Nlc3MoZSwhMCksbi5zZXRXcml0ZUFjY2VzcyhlLCEwKTtlbHNle2lmKHIuaXNGdW5jdGlvbihlKSl0aHJvdyBuZXcgRXJyb3IoXCJBVi5BQ0woKSBjYWxsZWQgd2l0aCBhIGZ1bmN0aW9uLiAgRGlkIHlvdSBmb3JnZXQgKCk/XCIpO3QuX29iamVjdEVhY2goZSxmdW5jdGlvbihlLGkpe2lmKCFyLmlzU3RyaW5nKGkpKXRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGNyZWF0ZSBhbiBBQ0wgd2l0aCBhbiBpbnZhbGlkIHVzZXJJZC5cIik7bi5wZXJtaXNzaW9uc0J5SWRbaV09e30sdC5fb2JqZWN0RWFjaChlLGZ1bmN0aW9uKHQsZSl7aWYoXCJyZWFkXCIhPT1lJiZcIndyaXRlXCIhPT1lKXRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGNyZWF0ZSBhbiBBQ0wgd2l0aCBhbiBpbnZhbGlkIHBlcm1pc3Npb24gdHlwZS5cIik7aWYoIXIuaXNCb29sZWFuKHQpKXRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGNyZWF0ZSBhbiBBQ0wgd2l0aCBhbiBpbnZhbGlkIHBlcm1pc3Npb24gdmFsdWUuXCIpO24ucGVybWlzc2lvbnNCeUlkW2ldW2VdPXR9KX0pfX0sdC5BQ0wucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiByLmNsb25lKHRoaXMucGVybWlzc2lvbnNCeUlkKX0sdC5BQ0wucHJvdG90eXBlLl9zZXRBY2Nlc3M9ZnVuY3Rpb24oZSxuLGkpe2lmKG4gaW5zdGFuY2VvZiB0LlVzZXI/bj1uLmlkOm4gaW5zdGFuY2VvZiB0LlJvbGUmJihuPVwicm9sZTpcIituLmdldE5hbWUoKSksIXIuaXNTdHJpbmcobikpdGhyb3cgbmV3IEVycm9yKFwidXNlcklkIG11c3QgYmUgYSBzdHJpbmcuXCIpO2lmKCFyLmlzQm9vbGVhbihpKSl0aHJvdyBuZXcgRXJyb3IoXCJhbGxvd2VkIG11c3QgYmUgZWl0aGVyIHRydWUgb3IgZmFsc2UuXCIpO3ZhciBzPXRoaXMucGVybWlzc2lvbnNCeUlkW25dO2lmKCFzKXtpZighaSlyZXR1cm47cz17fSx0aGlzLnBlcm1pc3Npb25zQnlJZFtuXT1zfWk/dGhpcy5wZXJtaXNzaW9uc0J5SWRbbl1bZV09ITA6KGRlbGV0ZSBzW2VdLHIuaXNFbXB0eShzKSYmZGVsZXRlIHRoaXMucGVybWlzc2lvbnNCeUlkW25dKX0sdC5BQ0wucHJvdG90eXBlLl9nZXRBY2Nlc3M9ZnVuY3Rpb24oZSxuKXtuIGluc3RhbmNlb2YgdC5Vc2VyP249bi5pZDpuIGluc3RhbmNlb2YgdC5Sb2xlJiYobj1cInJvbGU6XCIrbi5nZXROYW1lKCkpO3ZhciByPXRoaXMucGVybWlzc2lvbnNCeUlkW25dO3JldHVybiEhciYmISFyW2VdfSx0LkFDTC5wcm90b3R5cGUuc2V0UmVhZEFjY2Vzcz1mdW5jdGlvbih0LGUpe3RoaXMuX3NldEFjY2VzcyhcInJlYWRcIix0LGUpfSx0LkFDTC5wcm90b3R5cGUuZ2V0UmVhZEFjY2Vzcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fZ2V0QWNjZXNzKFwicmVhZFwiLHQpfSx0LkFDTC5wcm90b3R5cGUuc2V0V3JpdGVBY2Nlc3M9ZnVuY3Rpb24odCxlKXt0aGlzLl9zZXRBY2Nlc3MoXCJ3cml0ZVwiLHQsZSl9LHQuQUNMLnByb3RvdHlwZS5nZXRXcml0ZUFjY2Vzcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fZ2V0QWNjZXNzKFwid3JpdGVcIix0KX0sdC5BQ0wucHJvdG90eXBlLnNldFB1YmxpY1JlYWRBY2Nlc3M9ZnVuY3Rpb24odCl7dGhpcy5zZXRSZWFkQWNjZXNzKFwiKlwiLHQpfSx0LkFDTC5wcm90b3R5cGUuZ2V0UHVibGljUmVhZEFjY2Vzcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFJlYWRBY2Nlc3MoXCIqXCIpfSx0LkFDTC5wcm90b3R5cGUuc2V0UHVibGljV3JpdGVBY2Nlc3M9ZnVuY3Rpb24odCl7dGhpcy5zZXRXcml0ZUFjY2VzcyhcIipcIix0KX0sdC5BQ0wucHJvdG90eXBlLmdldFB1YmxpY1dyaXRlQWNjZXNzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0V3JpdGVBY2Nlc3MoXCIqXCIpfSx0LkFDTC5wcm90b3R5cGUuZ2V0Um9sZVJlYWRBY2Nlc3M9ZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIHQuUm9sZSYmKGU9ZS5nZXROYW1lKCkpLHIuaXNTdHJpbmcoZSkpcmV0dXJuIHRoaXMuZ2V0UmVhZEFjY2VzcyhcInJvbGU6XCIrZSk7dGhyb3cgbmV3IEVycm9yKFwicm9sZSBtdXN0IGJlIGEgQVYuUm9sZSBvciBhIFN0cmluZ1wiKX0sdC5BQ0wucHJvdG90eXBlLmdldFJvbGVXcml0ZUFjY2Vzcz1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgdC5Sb2xlJiYoZT1lLmdldE5hbWUoKSksci5pc1N0cmluZyhlKSlyZXR1cm4gdGhpcy5nZXRXcml0ZUFjY2VzcyhcInJvbGU6XCIrZSk7dGhyb3cgbmV3IEVycm9yKFwicm9sZSBtdXN0IGJlIGEgQVYuUm9sZSBvciBhIFN0cmluZ1wiKX0sdC5BQ0wucHJvdG90eXBlLnNldFJvbGVSZWFkQWNjZXNzPWZ1bmN0aW9uKGUsbil7aWYoZSBpbnN0YW5jZW9mIHQuUm9sZSYmKGU9ZS5nZXROYW1lKCkpLHIuaXNTdHJpbmcoZSkpcmV0dXJuIHZvaWQgdGhpcy5zZXRSZWFkQWNjZXNzKFwicm9sZTpcIitlLG4pO3Rocm93IG5ldyBFcnJvcihcInJvbGUgbXVzdCBiZSBhIEFWLlJvbGUgb3IgYSBTdHJpbmdcIil9LHQuQUNMLnByb3RvdHlwZS5zZXRSb2xlV3JpdGVBY2Nlc3M9ZnVuY3Rpb24oZSxuKXtpZihlIGluc3RhbmNlb2YgdC5Sb2xlJiYoZT1lLmdldE5hbWUoKSksci5pc1N0cmluZyhlKSlyZXR1cm4gdm9pZCB0aGlzLnNldFdyaXRlQWNjZXNzKFwicm9sZTpcIitlLG4pO3Rocm93IG5ldyBFcnJvcihcInJvbGUgbXVzdCBiZSBhIEFWLlJvbGUgb3IgYSBTdHJpbmdcIil9fX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3QuT3A9ZnVuY3Rpb24oKXt0aGlzLl9pbml0aWFsaXplLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sci5leHRlbmQodC5PcC5wcm90b3R5cGUse19pbml0aWFsaXplOmZ1bmN0aW9uKCl7fX0pLHIuZXh0ZW5kKHQuT3Ase19leHRlbmQ6dC5fZXh0ZW5kLF9vcERlY29kZXJNYXA6e30sX3JlZ2lzdGVyRGVjb2RlcjpmdW5jdGlvbihlLG4pe3QuT3AuX29wRGVjb2Rlck1hcFtlXT1ufSxfZGVjb2RlOmZ1bmN0aW9uKGUpe3ZhciBuPXQuT3AuX29wRGVjb2Rlck1hcFtlLl9fb3BdO3JldHVybiBuP24oZSk6dm9pZCAwfX0pLHQuT3AuX3JlZ2lzdGVyRGVjb2RlcihcIkJhdGNoXCIsZnVuY3Rpb24oZSl7dmFyIG49bnVsbDtyZXR1cm4gdC5fYXJyYXlFYWNoKGUub3BzLGZ1bmN0aW9uKGUpe2U9dC5PcC5fZGVjb2RlKGUpLG49ZS5fbWVyZ2VXaXRoUHJldmlvdXMobil9KSxufSksdC5PcC5TZXQ9dC5PcC5fZXh0ZW5kKHtfaW5pdGlhbGl6ZTpmdW5jdGlvbih0KXt0aGlzLl92YWx1ZT10fSx2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl92YWx1ZX0sdG9KU09OOmZ1bmN0aW9uKCl7cmV0dXJuIHQuX2VuY29kZSh0aGlzLnZhbHVlKCkpfSxfbWVyZ2VXaXRoUHJldmlvdXM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXN9LF9lc3RpbWF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy52YWx1ZSgpfX0pLHQuT3AuX1VOU0VUPXt9LHQuT3AuVW5zZXQ9dC5PcC5fZXh0ZW5kKHt0b0pTT046ZnVuY3Rpb24oKXtyZXR1cm57X19vcDpcIkRlbGV0ZVwifX0sX21lcmdlV2l0aFByZXZpb3VzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzfSxfZXN0aW1hdGU6ZnVuY3Rpb24oZSl7cmV0dXJuIHQuT3AuX1VOU0VUfX0pLHQuT3AuX3JlZ2lzdGVyRGVjb2RlcihcIkRlbGV0ZVwiLGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdC5PcC5VbnNldH0pLHQuT3AuSW5jcmVtZW50PXQuT3AuX2V4dGVuZCh7X2luaXRpYWxpemU6ZnVuY3Rpb24odCl7dGhpcy5fYW1vdW50PXR9LGFtb3VudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9hbW91bnR9LHRvSlNPTjpmdW5jdGlvbigpe3JldHVybntfX29wOlwiSW5jcmVtZW50XCIsYW1vdW50OnRoaXMuX2Ftb3VudH19LF9tZXJnZVdpdGhQcmV2aW91czpmdW5jdGlvbihlKXtpZihlKXtpZihlIGluc3RhbmNlb2YgdC5PcC5VbnNldClyZXR1cm4gbmV3IHQuT3AuU2V0KHRoaXMuYW1vdW50KCkpO2lmKGUgaW5zdGFuY2VvZiB0Lk9wLlNldClyZXR1cm4gbmV3IHQuT3AuU2V0KGUudmFsdWUoKSt0aGlzLmFtb3VudCgpKTtpZihlIGluc3RhbmNlb2YgdC5PcC5JbmNyZW1lbnQpcmV0dXJuIG5ldyB0Lk9wLkluY3JlbWVudCh0aGlzLmFtb3VudCgpK2UuYW1vdW50KCkpO3Rocm93IG5ldyBFcnJvcihcIk9wIGlzIGludmFsaWQgYWZ0ZXIgcHJldmlvdXMgb3AuXCIpfXJldHVybiB0aGlzfSxfZXN0aW1hdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHQ/dCt0aGlzLmFtb3VudCgpOnRoaXMuYW1vdW50KCl9fSksdC5PcC5fcmVnaXN0ZXJEZWNvZGVyKFwiSW5jcmVtZW50XCIsZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0Lk9wLkluY3JlbWVudChlLmFtb3VudCl9KSx0Lk9wLkJpdEFuZD10Lk9wLl9leHRlbmQoe19pbml0aWFsaXplOmZ1bmN0aW9uKHQpe3RoaXMuX3ZhbHVlPXR9LHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3ZhbHVlfSx0b0pTT046ZnVuY3Rpb24oKXtyZXR1cm57X19vcDpcIkJpdEFuZFwiLHZhbHVlOnRoaXMudmFsdWUoKX19LF9tZXJnZVdpdGhQcmV2aW91czpmdW5jdGlvbihlKXtpZihlKXtpZihlIGluc3RhbmNlb2YgdC5PcC5VbnNldClyZXR1cm4gbmV3IHQuT3AuU2V0KDApO2lmKGUgaW5zdGFuY2VvZiB0Lk9wLlNldClyZXR1cm4gbmV3IHQuT3AuU2V0KGUudmFsdWUoKSZ0aGlzLnZhbHVlKCkpO3Rocm93IG5ldyBFcnJvcihcIk9wIGlzIGludmFsaWQgYWZ0ZXIgcHJldmlvdXMgb3AuXCIpfXJldHVybiB0aGlzfSxfZXN0aW1hdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHQmdGhpcy52YWx1ZSgpfX0pLHQuT3AuX3JlZ2lzdGVyRGVjb2RlcihcIkJpdEFuZFwiLGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdC5PcC5CaXRBbmQoZS52YWx1ZSl9KSx0Lk9wLkJpdE9yPXQuT3AuX2V4dGVuZCh7X2luaXRpYWxpemU6ZnVuY3Rpb24odCl7dGhpcy5fdmFsdWU9dH0sdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdmFsdWV9LHRvSlNPTjpmdW5jdGlvbigpe3JldHVybntfX29wOlwiQml0T3JcIix2YWx1ZTp0aGlzLnZhbHVlKCl9fSxfbWVyZ2VXaXRoUHJldmlvdXM6ZnVuY3Rpb24oZSl7aWYoZSl7aWYoZSBpbnN0YW5jZW9mIHQuT3AuVW5zZXQpcmV0dXJuIG5ldyB0Lk9wLlNldCh0aGlzLnZhbHVlKCkpO2lmKGUgaW5zdGFuY2VvZiB0Lk9wLlNldClyZXR1cm4gbmV3IHQuT3AuU2V0KGUudmFsdWUoKXx0aGlzLnZhbHVlKCkpO3Rocm93IG5ldyBFcnJvcihcIk9wIGlzIGludmFsaWQgYWZ0ZXIgcHJldmlvdXMgb3AuXCIpfXJldHVybiB0aGlzfSxfZXN0aW1hdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHR8dGhpcy52YWx1ZSgpfX0pLHQuT3AuX3JlZ2lzdGVyRGVjb2RlcihcIkJpdE9yXCIsZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0Lk9wLkJpdE9yKGUudmFsdWUpfSksdC5PcC5CaXRYb3I9dC5PcC5fZXh0ZW5kKHtfaW5pdGlhbGl6ZTpmdW5jdGlvbih0KXt0aGlzLl92YWx1ZT10fSx2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl92YWx1ZX0sdG9KU09OOmZ1bmN0aW9uKCl7cmV0dXJue19fb3A6XCJCaXRYb3JcIix2YWx1ZTp0aGlzLnZhbHVlKCl9fSxfbWVyZ2VXaXRoUHJldmlvdXM6ZnVuY3Rpb24oZSl7aWYoZSl7aWYoZSBpbnN0YW5jZW9mIHQuT3AuVW5zZXQpcmV0dXJuIG5ldyB0Lk9wLlNldCh0aGlzLnZhbHVlKCkpO2lmKGUgaW5zdGFuY2VvZiB0Lk9wLlNldClyZXR1cm4gbmV3IHQuT3AuU2V0KGUudmFsdWUoKV50aGlzLnZhbHVlKCkpO3Rocm93IG5ldyBFcnJvcihcIk9wIGlzIGludmFsaWQgYWZ0ZXIgcHJldmlvdXMgb3AuXCIpfXJldHVybiB0aGlzfSxfZXN0aW1hdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRedGhpcy52YWx1ZSgpfX0pLHQuT3AuX3JlZ2lzdGVyRGVjb2RlcihcIkJpdFhvclwiLGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgdC5PcC5CaXRYb3IoZS52YWx1ZSl9KSx0Lk9wLkFkZD10Lk9wLl9leHRlbmQoe19pbml0aWFsaXplOmZ1bmN0aW9uKHQpe3RoaXMuX29iamVjdHM9dH0sb2JqZWN0czpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9vYmplY3RzfSx0b0pTT046ZnVuY3Rpb24oKXtyZXR1cm57X19vcDpcIkFkZFwiLG9iamVjdHM6dC5fZW5jb2RlKHRoaXMub2JqZWN0cygpKX19LF9tZXJnZVdpdGhQcmV2aW91czpmdW5jdGlvbihlKXtpZihlKXtpZihlIGluc3RhbmNlb2YgdC5PcC5VbnNldClyZXR1cm4gbmV3IHQuT3AuU2V0KHRoaXMub2JqZWN0cygpKTtpZihlIGluc3RhbmNlb2YgdC5PcC5TZXQpcmV0dXJuIG5ldyB0Lk9wLlNldCh0aGlzLl9lc3RpbWF0ZShlLnZhbHVlKCkpKTtpZihlIGluc3RhbmNlb2YgdC5PcC5BZGQpcmV0dXJuIG5ldyB0Lk9wLkFkZChlLm9iamVjdHMoKS5jb25jYXQodGhpcy5vYmplY3RzKCkpKTt0aHJvdyBuZXcgRXJyb3IoXCJPcCBpcyBpbnZhbGlkIGFmdGVyIHByZXZpb3VzIG9wLlwiKX1yZXR1cm4gdGhpc30sX2VzdGltYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0P3QuY29uY2F0KHRoaXMub2JqZWN0cygpKTpyLmNsb25lKHRoaXMub2JqZWN0cygpKX19KSx0Lk9wLl9yZWdpc3RlckRlY29kZXIoXCJBZGRcIixmdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQuT3AuQWRkKHQuX2RlY29kZShlLm9iamVjdHMpKX0pLHQuT3AuQWRkVW5pcXVlPXQuT3AuX2V4dGVuZCh7X2luaXRpYWxpemU6ZnVuY3Rpb24odCl7dGhpcy5fb2JqZWN0cz1yLnVuaXEodCl9LG9iamVjdHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fb2JqZWN0c30sdG9KU09OOmZ1bmN0aW9uKCl7cmV0dXJue19fb3A6XCJBZGRVbmlxdWVcIixvYmplY3RzOnQuX2VuY29kZSh0aGlzLm9iamVjdHMoKSl9fSxfbWVyZ2VXaXRoUHJldmlvdXM6ZnVuY3Rpb24oZSl7aWYoZSl7aWYoZSBpbnN0YW5jZW9mIHQuT3AuVW5zZXQpcmV0dXJuIG5ldyB0Lk9wLlNldCh0aGlzLm9iamVjdHMoKSk7aWYoZSBpbnN0YW5jZW9mIHQuT3AuU2V0KXJldHVybiBuZXcgdC5PcC5TZXQodGhpcy5fZXN0aW1hdGUoZS52YWx1ZSgpKSk7aWYoZSBpbnN0YW5jZW9mIHQuT3AuQWRkVW5pcXVlKXJldHVybiBuZXcgdC5PcC5BZGRVbmlxdWUodGhpcy5fZXN0aW1hdGUoZS5vYmplY3RzKCkpKTt0aHJvdyBuZXcgRXJyb3IoXCJPcCBpcyBpbnZhbGlkIGFmdGVyIHByZXZpb3VzIG9wLlwiKX1yZXR1cm4gdGhpc30sX2VzdGltYXRlOmZ1bmN0aW9uKGUpe2lmKGUpe3ZhciBuPXIuY2xvbmUoZSk7cmV0dXJuIHQuX2FycmF5RWFjaCh0aGlzLm9iamVjdHMoKSxmdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgdC5PYmplY3QmJmUuaWQpe3ZhciBpPXIuZmluZChuLGZ1bmN0aW9uKG4pe3JldHVybiBuIGluc3RhbmNlb2YgdC5PYmplY3QmJm4uaWQ9PT1lLmlkfSk7aWYoaSl7dmFyIHM9ci5pbmRleE9mKG4saSk7bltzXT1lfWVsc2Ugbi5wdXNoKGUpfWVsc2Ugci5jb250YWlucyhuLGUpfHxuLnB1c2goZSl9KSxufXJldHVybiByLmNsb25lKHRoaXMub2JqZWN0cygpKX19KSx0Lk9wLl9yZWdpc3RlckRlY29kZXIoXCJBZGRVbmlxdWVcIixmdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQuT3AuQWRkVW5pcXVlKHQuX2RlY29kZShlLm9iamVjdHMpKX0pLHQuT3AuUmVtb3ZlPXQuT3AuX2V4dGVuZCh7X2luaXRpYWxpemU6ZnVuY3Rpb24odCl7dGhpcy5fb2JqZWN0cz1yLnVuaXEodCl9LG9iamVjdHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fb2JqZWN0c30sdG9KU09OOmZ1bmN0aW9uKCl7cmV0dXJue19fb3A6XCJSZW1vdmVcIixvYmplY3RzOnQuX2VuY29kZSh0aGlzLm9iamVjdHMoKSl9fSxfbWVyZ2VXaXRoUHJldmlvdXM6ZnVuY3Rpb24oZSl7aWYoZSl7aWYoZSBpbnN0YW5jZW9mIHQuT3AuVW5zZXQpcmV0dXJuIGU7aWYoZSBpbnN0YW5jZW9mIHQuT3AuU2V0KXJldHVybiBuZXcgdC5PcC5TZXQodGhpcy5fZXN0aW1hdGUoZS52YWx1ZSgpKSk7aWYoZSBpbnN0YW5jZW9mIHQuT3AuUmVtb3ZlKXJldHVybiBuZXcgdC5PcC5SZW1vdmUoci51bmlvbihlLm9iamVjdHMoKSx0aGlzLm9iamVjdHMoKSkpO3Rocm93IG5ldyBFcnJvcihcIk9wIGlzIGludmFsaWQgYWZ0ZXIgcHJldmlvdXMgb3AuXCIpfXJldHVybiB0aGlzfSxfZXN0aW1hdGU6ZnVuY3Rpb24oZSl7aWYoZSl7dmFyIG49ci5kaWZmZXJlbmNlKGUsdGhpcy5vYmplY3RzKCkpO3JldHVybiB0Ll9hcnJheUVhY2godGhpcy5vYmplY3RzKCksZnVuY3Rpb24oZSl7ZSBpbnN0YW5jZW9mIHQuT2JqZWN0JiZlLmlkJiYobj1yLnJlamVjdChuLGZ1bmN0aW9uKG4pe3JldHVybiBuIGluc3RhbmNlb2YgdC5PYmplY3QmJm4uaWQ9PT1lLmlkfSkpfSksbn1yZXR1cm5bXX19KSx0Lk9wLl9yZWdpc3RlckRlY29kZXIoXCJSZW1vdmVcIixmdW5jdGlvbihlKXtyZXR1cm4gbmV3IHQuT3AuUmVtb3ZlKHQuX2RlY29kZShlLm9iamVjdHMpKX0pLHQuT3AuUmVsYXRpb249dC5PcC5fZXh0ZW5kKHtfaW5pdGlhbGl6ZTpmdW5jdGlvbihlLG4pe3RoaXMuX3RhcmdldENsYXNzTmFtZT1udWxsO3ZhciBpPXRoaXMscz1mdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgdC5PYmplY3Qpe2lmKCFlLmlkKXRocm93IG5ldyBFcnJvcihcIllvdSBjYW4ndCBhZGQgYW4gdW5zYXZlZCBBVi5PYmplY3QgdG8gYSByZWxhdGlvbi5cIik7aWYoaS5fdGFyZ2V0Q2xhc3NOYW1lfHwoaS5fdGFyZ2V0Q2xhc3NOYW1lPWUuY2xhc3NOYW1lKSxpLl90YXJnZXRDbGFzc05hbWUhPT1lLmNsYXNzTmFtZSl0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBjcmVhdGUgYSBBVi5SZWxhdGlvbiB3aXRoIDIgZGlmZmVyZW50IHR5cGVzOiBcIitpLl90YXJnZXRDbGFzc05hbWUrXCIgYW5kIFwiK2UuY2xhc3NOYW1lK1wiLlwiKTtyZXR1cm4gZS5pZH1yZXR1cm4gZX07dGhpcy5yZWxhdGlvbnNUb0FkZD1yLnVuaXEoci5tYXAoZSxzKSksdGhpcy5yZWxhdGlvbnNUb1JlbW92ZT1yLnVuaXEoci5tYXAobixzKSl9LGFkZGVkOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm4gci5tYXAodGhpcy5yZWxhdGlvbnNUb0FkZCxmdW5jdGlvbihuKXt2YXIgcj10Lk9iamVjdC5fY3JlYXRlKGUuX3RhcmdldENsYXNzTmFtZSk7cmV0dXJuIHIuaWQ9bixyfSl9LHJlbW92ZWQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiByLm1hcCh0aGlzLnJlbGF0aW9uc1RvUmVtb3ZlLGZ1bmN0aW9uKG4pe3ZhciByPXQuT2JqZWN0Ll9jcmVhdGUoZS5fdGFyZ2V0Q2xhc3NOYW1lKTtyZXR1cm4gci5pZD1uLHJ9KX0sdG9KU09OOmZ1bmN0aW9uKCl7dmFyIHQ9bnVsbCxlPW51bGwsbj10aGlzLGk9ZnVuY3Rpb24odCl7cmV0dXJue19fdHlwZTpcIlBvaW50ZXJcIixjbGFzc05hbWU6bi5fdGFyZ2V0Q2xhc3NOYW1lLG9iamVjdElkOnR9fSxzPW51bGw7cmV0dXJuIHRoaXMucmVsYXRpb25zVG9BZGQubGVuZ3RoPjAmJihzPXIubWFwKHRoaXMucmVsYXRpb25zVG9BZGQsaSksdD17X19vcDpcIkFkZFJlbGF0aW9uXCIsb2JqZWN0czpzfSksdGhpcy5yZWxhdGlvbnNUb1JlbW92ZS5sZW5ndGg+MCYmKHM9ci5tYXAodGhpcy5yZWxhdGlvbnNUb1JlbW92ZSxpKSxlPXtfX29wOlwiUmVtb3ZlUmVsYXRpb25cIixvYmplY3RzOnN9KSx0JiZlP3tfX29wOlwiQmF0Y2hcIixvcHM6W3QsZV19OnR8fGV8fHt9fSxfbWVyZ2VXaXRoUHJldmlvdXM6ZnVuY3Rpb24oZSl7aWYoZSl7aWYoZSBpbnN0YW5jZW9mIHQuT3AuVW5zZXQpdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbid0IG1vZGlmeSBhIHJlbGF0aW9uIGFmdGVyIGRlbGV0aW5nIGl0LlwiKTtpZihlIGluc3RhbmNlb2YgdC5PcC5SZWxhdGlvbil7aWYoZS5fdGFyZ2V0Q2xhc3NOYW1lJiZlLl90YXJnZXRDbGFzc05hbWUhPT10aGlzLl90YXJnZXRDbGFzc05hbWUpdGhyb3cgbmV3IEVycm9yKFwiUmVsYXRlZCBvYmplY3QgbXVzdCBiZSBvZiBjbGFzcyBcIitlLl90YXJnZXRDbGFzc05hbWUrXCIsIGJ1dCBcIit0aGlzLl90YXJnZXRDbGFzc05hbWUrXCIgd2FzIHBhc3NlZCBpbi5cIik7dmFyIG49ci51bmlvbihyLmRpZmZlcmVuY2UoZS5yZWxhdGlvbnNUb0FkZCx0aGlzLnJlbGF0aW9uc1RvUmVtb3ZlKSx0aGlzLnJlbGF0aW9uc1RvQWRkKSxpPXIudW5pb24oci5kaWZmZXJlbmNlKGUucmVsYXRpb25zVG9SZW1vdmUsdGhpcy5yZWxhdGlvbnNUb0FkZCksdGhpcy5yZWxhdGlvbnNUb1JlbW92ZSkscz1uZXcgdC5PcC5SZWxhdGlvbihuLGkpO3JldHVybiBzLl90YXJnZXRDbGFzc05hbWU9dGhpcy5fdGFyZ2V0Q2xhc3NOYW1lLHN9dGhyb3cgbmV3IEVycm9yKFwiT3AgaXMgaW52YWxpZCBhZnRlciBwcmV2aW91cyBvcC5cIil9cmV0dXJuIHRoaXN9LF9lc3RpbWF0ZTpmdW5jdGlvbihlLG4scil7aWYoZSl7aWYoZSBpbnN0YW5jZW9mIHQuUmVsYXRpb24pe2lmKHRoaXMuX3RhcmdldENsYXNzTmFtZSlpZihlLnRhcmdldENsYXNzTmFtZSl7aWYoZS50YXJnZXRDbGFzc05hbWUhPT10aGlzLl90YXJnZXRDbGFzc05hbWUpdGhyb3cgbmV3IEVycm9yKFwiUmVsYXRlZCBvYmplY3QgbXVzdCBiZSBhIFwiK2UudGFyZ2V0Q2xhc3NOYW1lK1wiLCBidXQgYSBcIit0aGlzLl90YXJnZXRDbGFzc05hbWUrXCIgd2FzIHBhc3NlZCBpbi5cIil9ZWxzZSBlLnRhcmdldENsYXNzTmFtZT10aGlzLl90YXJnZXRDbGFzc05hbWU7cmV0dXJuIGV9dGhyb3cgbmV3IEVycm9yKFwiT3AgaXMgaW52YWxpZCBhZnRlciBwcmV2aW91cyBvcC5cIil9bmV3IHQuUmVsYXRpb24obixyKS50YXJnZXRDbGFzc05hbWU9dGhpcy5fdGFyZ2V0Q2xhc3NOYW1lfX0pLHQuT3AuX3JlZ2lzdGVyRGVjb2RlcihcIkFkZFJlbGF0aW9uXCIsZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0Lk9wLlJlbGF0aW9uKHQuX2RlY29kZShlLm9iamVjdHMpLFtdKX0pLHQuT3AuX3JlZ2lzdGVyRGVjb2RlcihcIlJlbW92ZVJlbGF0aW9uXCIsZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0Lk9wLlJlbGF0aW9uKFtdLHQuX2RlY29kZShlLm9iamVjdHMpKX0pfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3QuUmVsYXRpb249ZnVuY3Rpb24odCxlKXtpZighci5pc1N0cmluZyhlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5IG11c3QgYmUgYSBzdHJpbmdcIik7dGhpcy5wYXJlbnQ9dCx0aGlzLmtleT1lLHRoaXMudGFyZ2V0Q2xhc3NOYW1lPW51bGx9LHQuUmVsYXRpb24ucmV2ZXJzZVF1ZXJ5PWZ1bmN0aW9uKGUsbixyKXt2YXIgaT1uZXcgdC5RdWVyeShlKTtyZXR1cm4gaS5lcXVhbFRvKG4sci5fdG9Qb2ludGVyKCkpLGl9LHIuZXh0ZW5kKHQuUmVsYXRpb24ucHJvdG90eXBlLHtfZW5zdXJlUGFyZW50QW5kS2V5OmZ1bmN0aW9uKHQsZSl7aWYodGhpcy5wYXJlbnQ9dGhpcy5wYXJlbnR8fHQsdGhpcy5rZXk9dGhpcy5rZXl8fGUsdGhpcy5wYXJlbnQhPT10KXRocm93IG5ldyBFcnJvcihcIkludGVybmFsIEVycm9yLiBSZWxhdGlvbiByZXRyaWV2ZWQgZnJvbSB0d28gZGlmZmVyZW50IE9iamVjdHMuXCIpO2lmKHRoaXMua2V5IT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBFcnJvci4gUmVsYXRpb24gcmV0cmlldmVkIGZyb20gdHdvIGRpZmZlcmVudCBrZXlzLlwiKX0sYWRkOmZ1bmN0aW9uKGUpe3IuaXNBcnJheShlKXx8KGU9W2VdKTt2YXIgbj1uZXcgdC5PcC5SZWxhdGlvbihlLFtdKTt0aGlzLnBhcmVudC5zZXQodGhpcy5rZXksbiksdGhpcy50YXJnZXRDbGFzc05hbWU9bi5fdGFyZ2V0Q2xhc3NOYW1lfSxyZW1vdmU6ZnVuY3Rpb24oZSl7ci5pc0FycmF5KGUpfHwoZT1bZV0pO3ZhciBuPW5ldyB0Lk9wLlJlbGF0aW9uKFtdLGUpO3RoaXMucGFyZW50LnNldCh0aGlzLmtleSxuKSx0aGlzLnRhcmdldENsYXNzTmFtZT1uLl90YXJnZXRDbGFzc05hbWV9LHRvSlNPTjpmdW5jdGlvbigpe3JldHVybntfX3R5cGU6XCJSZWxhdGlvblwiLGNsYXNzTmFtZTp0aGlzLnRhcmdldENsYXNzTmFtZX19LHF1ZXJ5OmZ1bmN0aW9uKCl7dmFyIGUsbjtyZXR1cm4gdGhpcy50YXJnZXRDbGFzc05hbWU/KGU9dC5PYmplY3QuX2dldFN1YmNsYXNzKHRoaXMudGFyZ2V0Q2xhc3NOYW1lKSxuPW5ldyB0LlF1ZXJ5KGUpKTooZT10Lk9iamVjdC5fZ2V0U3ViY2xhc3ModGhpcy5wYXJlbnQuY2xhc3NOYW1lKSxuPW5ldyB0LlF1ZXJ5KGUpLG4uX2V4dHJhT3B0aW9ucy5yZWRpcmVjdENsYXNzTmFtZUZvcktleT10aGlzLmtleSksbi5fYWRkQ29uZGl0aW9uKFwiJHJlbGF0ZWRUb1wiLFwib2JqZWN0XCIsdGhpcy5wYXJlbnQuX3RvUG9pbnRlcigpKSxuLl9hZGRDb25kaXRpb24oXCIkcmVsYXRlZFRvXCIsXCJrZXlcIix0aGlzLmtleSksbn19KX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLGk9bigzOCkscz1uKDM5KSxvPW4oNDApLGE9big0KSx1PW4oMikuX3JlcXVlc3QsYz1uKDEpLGw9bigzKSxoPWwudGFwLGY9bC50cmFuc2Zvcm1GZXRjaE9wdGlvbnMsZD1uKDYpKFwibGVhbmNsb3VkOmZpbGVcIikscD1uKDQ0KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5mbG9vcig2NTUzNiooMStNYXRoLnJhbmRvbSgpKSkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKX0sbj1mdW5jdGlvbih0KXtyZXR1cm4gci5pc1N0cmluZyh0KT90Lm1hdGNoKC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvKVs0XTpcIlwifSxsPWZ1bmN0aW9uKHQpe2lmKHQ8MjYpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoNjUrdCk7aWYodDw1MilyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0LTI2Kzk3KTtpZih0PDYyKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHQtNTIrNDgpO2lmKDYyPT09dClyZXR1cm5cIitcIjtpZig2Mz09PXQpcmV0dXJuXCIvXCI7dGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gZW5jb2RlIGxhcmdlIGRpZ2l0IFwiK3QrXCIgaW4gYmFzZTY0LlwiKX0sXz1mdW5jdGlvbih0KXt2YXIgZT1bXTtyZXR1cm4gZS5sZW5ndGg9TWF0aC5jZWlsKHQubGVuZ3RoLzMpLHIudGltZXMoZS5sZW5ndGgsZnVuY3Rpb24obil7dmFyIHI9dFszKm5dLGk9dFszKm4rMV18fDAscz10WzMqbisyXXx8MCxvPTMqbisxPHQubGVuZ3RoLGE9MypuKzI8dC5sZW5ndGg7ZVtuXT1bbChyPj4yJjYzKSxsKHI8PDQmNDh8aT4+NCYxNSksbz9sKGk8PDImNjB8cz4+NiYzKTpcIj1cIixhP2woNjMmcyk6XCI9XCJdLmpvaW4oXCJcIil9KSxlLmpvaW4oXCJcIil9O3QuRmlsZT1mdW5jdGlvbihlLGkscyl7aWYodGhpcy5hdHRyaWJ1dGVzPXtuYW1lOmUsdXJsOlwiXCIsbWV0YURhdGE6e30sYmFzZTY0OlwiXCJ9LHIuaXNTdHJpbmcoaSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNyZWF0aW5nIGFuIEFWLkZpbGUgZnJvbSBhIFN0cmluZyBpcyBub3QgeWV0IHN1cHBvcnRlZC5cIik7ci5pc0FycmF5KGkpJiYodGhpcy5hdHRyaWJ1dGVzLm1ldGFEYXRhLnNpemU9aS5sZW5ndGgsaT17YmFzZTY0Ol8oaSl9KSx0aGlzLl9leHROYW1lPVwiXCIsdGhpcy5fZGF0YT1pLHRoaXMuX3VwbG9hZEhlYWRlcnM9e30sXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEJsb2ImJmkgaW5zdGFuY2VvZiBCbG9iJiYoaS5zaXplJiYodGhpcy5hdHRyaWJ1dGVzLm1ldGFEYXRhLnNpemU9aS5zaXplKSxpLm5hbWUmJih0aGlzLl9leHROYW1lPW4oaS5uYW1lKSkpO3ZhciBvPXZvaWQgMDtpZihpJiZpLm93bmVyKW89aS5vd25lcjtlbHNlIGlmKCF0Ll9jb25maWcuZGlzYWJsZUN1cnJlbnRVc2VyKXRyeXtvPXQuVXNlci5jdXJyZW50KCl9Y2F0Y2godCl7aWYoXCJTWU5DX0FQSV9OT1RfQVZBSUxBQkxFXCIhPT10LmNvZGUpdGhyb3cgdH10aGlzLmF0dHJpYnV0ZXMubWV0YURhdGEub3duZXI9bz9vLmlkOlwidW5rbm93blwiLHRoaXMuc2V0KFwibWltZV90eXBlXCIscyl9LHQuRmlsZS53aXRoVVJMPWZ1bmN0aW9uKGUsbixyLGkpe2lmKCFlfHwhbil0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBmaWxlIG5hbWUgYW5kIHVybFwiKTt2YXIgcz1uZXcgdC5GaWxlKGUsbnVsbCxpKTtpZihyKWZvcih2YXIgbyBpbiByKXMuYXR0cmlidXRlcy5tZXRhRGF0YVtvXXx8KHMuYXR0cmlidXRlcy5tZXRhRGF0YVtvXT1yW29dKTtyZXR1cm4gcy5hdHRyaWJ1dGVzLnVybD1uLHMuYXR0cmlidXRlcy5tZXRhRGF0YS5fX3NvdXJjZT1cImV4dGVybmFsXCIsc30sdC5GaWxlLmNyZWF0ZVdpdGhvdXREYXRhPWZ1bmN0aW9uKGUpe3ZhciBuPW5ldyB0LkZpbGU7cmV0dXJuIG4uaWQ9ZSxufSxyLmV4dGVuZCh0LkZpbGUucHJvdG90eXBlLHtjbGFzc05hbWU6XCJfRmlsZVwiLF90b0Z1bGxKU09OOmZ1bmN0aW9uKGUpe3ZhciBuPXRoaXMsaT0hKGFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdKXx8YXJndW1lbnRzWzFdLHM9ci5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO3JldHVybiB0Ll9vYmplY3RFYWNoKHMsZnVuY3Rpb24obixyKXtzW3JdPXQuX2VuY29kZShuLGUsdm9pZCAwLGkpfSksdC5fb2JqZWN0RWFjaCh0aGlzLl9vcGVyYXRpb25zLGZ1bmN0aW9uKHQsZSl7c1tlXT10fSksci5oYXModGhpcyxcImlkXCIpJiYocy5vYmplY3RJZD10aGlzLmlkKSxyKFtcImNyZWF0ZWRBdFwiLFwidXBkYXRlZEF0XCJdKS5lYWNoKGZ1bmN0aW9uKHQpe2lmKHIuaGFzKG4sdCkpe3ZhciBlPW5bdF07c1t0XT1yLmlzRGF0ZShlKT9lLnRvSlNPTigpOmV9fSksaSYmKHMuX190eXBlPVwiRmlsZVwiKSxzfSx0b0Z1bGxKU09OOmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOltdO3JldHVybiB0aGlzLl90b0Z1bGxKU09OKHQpfSx0b0pTT046ZnVuY3Rpb24odCxlKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06W3RoaXNdO3JldHVybiB0aGlzLl90b0Z1bGxKU09OKG4sITEpfSxfdG9Qb2ludGVyOmZ1bmN0aW9uKCl7cmV0dXJue19fdHlwZTpcIlBvaW50ZXJcIixjbGFzc05hbWU6dGhpcy5jbGFzc05hbWUsb2JqZWN0SWQ6dGhpcy5pZH19LGdldEFDTDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9hY2x9LHNldEFDTDpmdW5jdGlvbihlKXtpZighKGUgaW5zdGFuY2VvZiB0LkFDTCkpcmV0dXJuIG5ldyBhKGEuT1RIRVJfQ0FVU0UsXCJBQ0wgbXVzdCBiZSBhIEFWLkFDTC5cIik7dGhpcy5fYWNsPWV9LG5hbWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXQoXCJuYW1lXCIpfSx1cmw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXQoXCJ1cmxcIil9LGdldDpmdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZVwib2JqZWN0SWRcIjpyZXR1cm4gdGhpcy5pZDtjYXNlXCJ1cmxcIjpjYXNlXCJuYW1lXCI6Y2FzZVwibWltZV90eXBlXCI6Y2FzZVwibWV0YURhdGFcIjpjYXNlXCJjcmVhdGVkQXRcIjpjYXNlXCJ1cGRhdGVkQXRcIjpyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW3RdO2RlZmF1bHQ6cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5tZXRhRGF0YVt0XX19LHNldDpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLGU9ZnVuY3Rpb24oZSxuKXtzd2l0Y2goZSl7Y2FzZVwibmFtZVwiOmNhc2VcInVybFwiOmNhc2VcIm1pbWVfdHlwZVwiOmNhc2VcImJhc2U2NFwiOmNhc2VcIm1ldGFEYXRhXCI6dC5hdHRyaWJ1dGVzW2VdPW47YnJlYWs7ZGVmYXVsdDp0LmF0dHJpYnV0ZXMubWV0YURhdGFbZV09bn19LG49YXJndW1lbnRzLmxlbmd0aCxyPUFycmF5KG4pLGk9MDtpPG47aSsrKXJbaV09YXJndW1lbnRzW2ldO3N3aXRjaChyLmxlbmd0aCl7Y2FzZSAxOmZvcih2YXIgcyBpbiByWzBdKWUocyxyWzBdW3NdKTticmVhaztjYXNlIDI6ZShyWzBdLHJbMV0pfX0sc2V0VXBsb2FkSGVhZGVyOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX3VwbG9hZEhlYWRlcnNbdF09ZSx0aGlzfSxtZXRhRGF0YTpmdW5jdGlvbih0LGUpe3JldHVybiB0JiZlPyh0aGlzLmF0dHJpYnV0ZXMubWV0YURhdGFbdF09ZSx0aGlzKTp0JiYhZT90aGlzLmF0dHJpYnV0ZXMubWV0YURhdGFbdF06dGhpcy5hdHRyaWJ1dGVzLm1ldGFEYXRhfSx0aHVtYm5haWxVUkw6ZnVuY3Rpb24odCxlLG4scixpKXt2YXIgcz10aGlzLmF0dHJpYnV0ZXMudXJsO2lmKCFzKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdXJsLlwiKTtpZighdHx8IWV8fHQ8PTB8fGU8PTApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB3aWR0aCBvciBoZWlnaHQgdmFsdWUuXCIpO2lmKG49bnx8MTAwLHI9cnx8ITAsbjw9MHx8bj4xMDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBxdWFsaXR5IHZhbHVlLlwiKTtyZXR1cm4gaT1pfHxcInBuZ1wiLHMrXCI/aW1hZ2VWaWV3L1wiKyhyPzI6MSkrXCIvdy9cIit0K1wiL2gvXCIrZStcIi9xL1wiK24rXCIvZm9ybWF0L1wiK2l9LHNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tZXRhRGF0YSgpLnNpemV9LG93bmVySWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tZXRhRGF0YSgpLm93bmVyfSxkZXN0cm95OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmlkP3UoXCJmaWxlc1wiLG51bGwsdGhpcy5pZCxcIkRFTEVURVwiLG51bGwsdCk6Yy5yZWplY3QobmV3IEVycm9yKFwiVGhlIGZpbGUgaWQgZG9lcyBub3QgZWl4c3QuXCIpKX0sX2ZpbGVUb2tlbjpmdW5jdGlvbih0KXt2YXIgcj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06XCJmaWxlVG9rZW5zXCIsaT10aGlzLmF0dHJpYnV0ZXMubmFtZSxzPW4oaSk7IXMmJnRoaXMuX2V4dE5hbWUmJihpKz10aGlzLl9leHROYW1lLHM9dGhpcy5fZXh0TmFtZSk7dmFyIG89ZSgpK2UoKStlKCkrZSgpK2UoKStzLGE9e2tleTpvLG5hbWU6aSxBQ0w6dGhpcy5fYWNsLG1pbWVfdHlwZTp0LG1ldGFEYXRhOnRoaXMuYXR0cmlidXRlcy5tZXRhRGF0YX07cmV0dXJuIHRoaXMuX3Fpbml1X2tleT1vLHUocixudWxsLG51bGwsXCJQT1NUXCIsYSl9LHNhdmU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZih0aGlzLmlkKXRocm93IG5ldyBFcnJvcihcIkZpbGUgYWxyZWFkeSBzYXZlZC4gSWYgeW91IHdhbnQgdG8gbWFuaXB1bGF0ZSBhIGZpbGUsIHVzZSBBVi5RdWVyeSB0byBnZXQgaXQuXCIpO2lmKCF0aGlzLl9wcmV2aW91c1NhdmUpaWYodGhpcy5fZGF0YSl7dmFyIG49dGhpcy5nZXQoXCJtaW1lX3R5cGVcIik7dGhpcy5fcHJldmlvdXNTYXZlPXRoaXMuX2ZpbGVUb2tlbihuKS50aGVuKGZ1bmN0aW9uKHIpe3JldHVybiByLm1pbWVfdHlwZSYmKG49ci5taW1lX3R5cGUsZS5zZXQoXCJtaW1lX3R5cGVcIixuKSksZS5fdG9rZW49ci50b2tlbixjLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIHQ9ZS5fZGF0YTtpZih0JiZ0LmJhc2U2NClyZXR1cm4gcCh0LmJhc2U2NCxuKTtpZih0JiZ0LmJsb2IpcmV0dXJuIXQuYmxvYi50eXBlJiZuJiYodC5ibG9iLnR5cGU9biksdC5ibG9iLm5hbWV8fCh0LmJsb2IubmFtZT1lLmdldChcIm5hbWVcIikpLHQuYmxvYjtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgQmxvYiYmdCBpbnN0YW5jZW9mIEJsb2IpcmV0dXJuIHQ7dGhyb3cgbmV3IFR5cGVFcnJvcihcIm1hbGZvcm1lZCBmaWxlIGRhdGFcIil9KS50aGVuKGZ1bmN0aW9uKG4pe3N3aXRjaChyLnByb3ZpZGVyKXtjYXNlXCJzM1wiOnJldHVybiBvKHIsbixlLHQpO2Nhc2VcInFjbG91ZFwiOnJldHVybiBpKHIsbixlLHQpO2Nhc2VcInFpbml1XCI6ZGVmYXVsdDpyZXR1cm4gcyhyLG4sZSx0KX19KS50aGVuKGgoZnVuY3Rpb24oKXtyZXR1cm4gZS5fY2FsbGJhY2soITApfSksZnVuY3Rpb24odCl7dGhyb3cgZS5fY2FsbGJhY2soITEpLHR9KX0pfWVsc2UgaWYodGhpcy5hdHRyaWJ1dGVzLnVybCYmXCJleHRlcm5hbFwiPT09dGhpcy5hdHRyaWJ1dGVzLm1ldGFEYXRhLl9fc291cmNlKXt2YXIgcj17bmFtZTp0aGlzLmF0dHJpYnV0ZXMubmFtZSxBQ0w6dGhpcy5fYWNsLG1ldGFEYXRhOnRoaXMuYXR0cmlidXRlcy5tZXRhRGF0YSxtaW1lX3R5cGU6dGhpcy5taW1lVHlwZSx1cmw6dGhpcy5hdHRyaWJ1dGVzLnVybH07dGhpcy5fcHJldmlvdXNTYXZlPXUoXCJmaWxlc1wiLHRoaXMuYXR0cmlidXRlcy5uYW1lLG51bGwsXCJwb3N0XCIscikudGhlbihmdW5jdGlvbih0KXtyZXR1cm4gZS5hdHRyaWJ1dGVzLm5hbWU9dC5uYW1lLGUuYXR0cmlidXRlcy51cmw9dC51cmwsZS5pZD10Lm9iamVjdElkLHQuc2l6ZSYmKGUuYXR0cmlidXRlcy5tZXRhRGF0YS5zaXplPXQuc2l6ZSksZX0pfXJldHVybiB0aGlzLl9wcmV2aW91c1NhdmV9LF9jYWxsYmFjazpmdW5jdGlvbih0KXt1KFwiZmlsZUNhbGxiYWNrXCIsbnVsbCxudWxsLFwicG9zdFwiLHt0b2tlbjp0aGlzLl90b2tlbixyZXN1bHQ6dH0pLmNhdGNoKGQpLGRlbGV0ZSB0aGlzLl90b2tlbixkZWxldGUgdGhpcy5fZGF0YX0sZmV0Y2g6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdShcImZpbGVzXCIsbnVsbCx0aGlzLmlkLFwiR0VUXCIsZih0KSxlKS50aGVuKHRoaXMuX2ZpbmlzaEZldGNoLmJpbmQodGhpcykpfSxfZmluaXNoRmV0Y2g6ZnVuY3Rpb24oZSl7dmFyIG49dC5PYmplY3QucHJvdG90eXBlLnBhcnNlKGUpO3JldHVybiBuLmF0dHJpYnV0ZXM9e25hbWU6bi5uYW1lLHVybDpuLnVybCxtaW1lX3R5cGU6bi5taW1lX3R5cGUsYnVja2V0Om4uYnVja2V0fSxuLmF0dHJpYnV0ZXMubWV0YURhdGE9bi5tZXRhRGF0YXx8e30sbi5pZD1uLm9iamVjdElkLGRlbGV0ZSBuLm9iamVjdElkLGRlbGV0ZSBuLm1ldGFEYXRhLGRlbGV0ZSBuLnVybCxkZWxldGUgbi5uYW1lLGRlbGV0ZSBuLm1pbWVfdHlwZSxkZWxldGUgbi5idWNrZXQsci5leHRlbmQodGhpcyxuKSx0aGlzfX0pfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oOCksaT1uKDYpKFwiY29zXCIpLHM9bigxKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe3ZhciBvPWFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTp7fTtuLmF0dHJpYnV0ZXMudXJsPXQudXJsLG4uX2J1Y2tldD10LmJ1Y2tldCxuLmlkPXQub2JqZWN0SWQ7dmFyIGE9dC51cGxvYWRfdXJsK1wiP3NpZ249XCIrZW5jb2RlVVJJQ29tcG9uZW50KHQudG9rZW4pO3JldHVybiBuZXcgcyhmdW5jdGlvbih0LHMpe3ZhciB1PXIoXCJQT1NUXCIsYSkuc2V0KG4uX3VwbG9hZEhlYWRlcnMpLmF0dGFjaChcImZpbGVDb250ZW50XCIsZSxuLmF0dHJpYnV0ZXMubmFtZSkuZmllbGQoXCJvcFwiLFwidXBsb2FkXCIpO28ub25wcm9ncmVzcyYmdS5vbihcInByb2dyZXNzXCIsby5vbnByb2dyZXNzKSx1LmVuZChmdW5jdGlvbihlLHIpe2lmKHImJmkoci5zdGF0dXMsci5ib2R5LHIudGV4dCksZSlyZXR1cm4gciYmKGUuc3RhdHVzQ29kZT1yLnN0YXR1cyxlLnJlc3BvbnNlVGV4dD1yLnRleHQsZS5yZXNwb25zZT1yLmJvZHkpLHMoZSk7dChuKX0pfSl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9big4KSxpPW4oMSkscz1uKDYpKFwicWluaXVcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuKXt2YXIgbz1hcmd1bWVudHMubGVuZ3RoPjMmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106e307bi5hdHRyaWJ1dGVzLnVybD10LnVybCxuLl9idWNrZXQ9dC5idWNrZXQsbi5pZD10Lm9iamVjdElkO3ZhciBhPXQudG9rZW4sdT10LnVwbG9hZF91cmx8fFwiaHR0cHM6Ly91cGxvYWQucWluaXVwLmNvbVwiO3JldHVybiBuZXcgaShmdW5jdGlvbih0LGkpe3ZhciBjPXIoXCJQT1NUXCIsdSkuc2V0KG4uX3VwbG9hZEhlYWRlcnMpLmF0dGFjaChcImZpbGVcIixlLG4uYXR0cmlidXRlcy5uYW1lKS5maWVsZChcIm5hbWVcIixuLmF0dHJpYnV0ZXMubmFtZSkuZmllbGQoXCJrZXlcIixuLl9xaW5pdV9rZXkpLmZpZWxkKFwidG9rZW5cIixhKTtvLm9ucHJvZ3Jlc3MmJmMub24oXCJwcm9ncmVzc1wiLG8ub25wcm9ncmVzcyksYy5lbmQoZnVuY3Rpb24oZSxyKXtpZihyJiZzKHIuc3RhdHVzLHIuYm9keSxyLnRleHQpLGUpcmV0dXJuIHImJihlLnN0YXR1c0NvZGU9ci5zdGF0dXMsZS5yZXNwb25zZVRleHQ9ci50ZXh0LGUucmVzcG9uc2U9ci5ib2R5KSxpKGUpO3Qobil9KX0pfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oOCksaT1uKDEpLHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZSYmKHQuc3RhdHVzQ29kZT1lLnN0YXR1cyx0LnJlc3BvbnNlVGV4dD1lLnRleHQsdC5yZXNwb25zZT1lLmJvZHkpLHR9O3QuZXhwb3J0cz1mdW5jdGlvbih0LGUsbil7dmFyIG89YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOnt9O3JldHVybiBuLmF0dHJpYnV0ZXMudXJsPXQudXJsLG4uX2J1Y2tldD10LmJ1Y2tldCxuLmlkPXQub2JqZWN0SWQsbmV3IGkoZnVuY3Rpb24oaSxhKXt2YXIgdT1yKFwiUFVUXCIsdC51cGxvYWRfdXJsKS5zZXQoT2JqZWN0LmFzc2lnbih7XCJDb250ZW50LVR5cGVcIjpuLmdldChcIm1pbWVfdHlwZVwiKSxcIkNhY2hlLUNvbnRyb2xcIjpcInB1YmxpYywgbWF4LWFnZT0zMTUzNjAwMFwifSxuLl91cGxvYWRIZWFkZXJzKSk7by5vbnByb2dyZXNzJiZ1Lm9uKFwicHJvZ3Jlc3NcIixvLm9ucHJvZ3Jlc3MpLHUub24oXCJyZXNwb25zZVwiLGZ1bmN0aW9uKHQpe2lmKHQub2spcmV0dXJuIGkobik7YShzKHQuZXJyb3IsdCkpfSksdS5vbihcImVycm9yXCIsZnVuY3Rpb24odCxlKXtyZXR1cm4gYShzKHQsZSkpfSksdS5zZW5kKGUpLmVuZCgpfSl9fSxmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKCl7dmFyIGU9big0Mikscj1uKDEzKS51dGY4LGk9big0Mykscz1uKDEzKS5iaW4sbz1mdW5jdGlvbih0LG4pe3QuY29uc3RydWN0b3I9PVN0cmluZz90PW4mJlwiYmluYXJ5XCI9PT1uLmVuY29kaW5nP3Muc3RyaW5nVG9CeXRlcyh0KTpyLnN0cmluZ1RvQnl0ZXModCk6aSh0KT90PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHQsMCk6QXJyYXkuaXNBcnJheSh0KXx8KHQ9dC50b1N0cmluZygpKTtmb3IodmFyIGE9ZS5ieXRlc1RvV29yZHModCksdT04KnQubGVuZ3RoLGM9MTczMjU4NDE5MyxsPS0yNzE3MzM4NzksaD0tMTczMjU4NDE5NCxmPTI3MTczMzg3OCxkPTA7ZDxhLmxlbmd0aDtkKyspYVtkXT0xNjcxMTkzNSYoYVtkXTw8OHxhW2RdPj4+MjQpfDQyNzgyNTUzNjAmKGFbZF08PDI0fGFbZF0+Pj44KTthW3U+Pj41XXw9MTI4PDx1JTMyLGFbMTQrKHUrNjQ+Pj45PDw0KV09dTtmb3IodmFyIHA9by5fZmYsXz1vLl9nZyx2PW8uX2hoLHk9by5faWksZD0wO2Q8YS5sZW5ndGg7ZCs9MTYpe3ZhciBtPWMsZz1sLGI9aCx3PWY7Yz1wKGMsbCxoLGYsYVtkKzBdLDcsLTY4MDg3NjkzNiksZj1wKGYsYyxsLGgsYVtkKzFdLDEyLC0zODk1NjQ1ODYpLGg9cChoLGYsYyxsLGFbZCsyXSwxNyw2MDYxMDU4MTkpLGw9cChsLGgsZixjLGFbZCszXSwyMiwtMTA0NDUyNTMzMCksYz1wKGMsbCxoLGYsYVtkKzRdLDcsLTE3NjQxODg5NyksZj1wKGYsYyxsLGgsYVtkKzVdLDEyLDEyMDAwODA0MjYpLGg9cChoLGYsYyxsLGFbZCs2XSwxNywtMTQ3MzIzMTM0MSksbD1wKGwsaCxmLGMsYVtkKzddLDIyLC00NTcwNTk4MyksYz1wKGMsbCxoLGYsYVtkKzhdLDcsMTc3MDAzNTQxNiksZj1wKGYsYyxsLGgsYVtkKzldLDEyLC0xOTU4NDE0NDE3KSxoPXAoaCxmLGMsbCxhW2QrMTBdLDE3LC00MjA2MyksbD1wKGwsaCxmLGMsYVtkKzExXSwyMiwtMTk5MDQwNDE2MiksYz1wKGMsbCxoLGYsYVtkKzEyXSw3LDE4MDQ2MDM2ODIpLGY9cChmLGMsbCxoLGFbZCsxM10sMTIsLTQwMzQxMTAxKSxoPXAoaCxmLGMsbCxhW2QrMTRdLDE3LC0xNTAyMDAyMjkwKSxsPXAobCxoLGYsYyxhW2QrMTVdLDIyLDEyMzY1MzUzMjkpLGM9XyhjLGwsaCxmLGFbZCsxXSw1LC0xNjU3OTY1MTApLGY9XyhmLGMsbCxoLGFbZCs2XSw5LC0xMDY5NTAxNjMyKSxoPV8oaCxmLGMsbCxhW2QrMTFdLDE0LDY0MzcxNzcxMyksbD1fKGwsaCxmLGMsYVtkKzBdLDIwLC0zNzM4OTczMDIpLGM9XyhjLGwsaCxmLGFbZCs1XSw1LC03MDE1NTg2OTEpLGY9XyhmLGMsbCxoLGFbZCsxMF0sOSwzODAxNjA4MyksaD1fKGgsZixjLGwsYVtkKzE1XSwxNCwtNjYwNDc4MzM1KSxsPV8obCxoLGYsYyxhW2QrNF0sMjAsLTQwNTUzNzg0OCksYz1fKGMsbCxoLGYsYVtkKzldLDUsNTY4NDQ2NDM4KSxmPV8oZixjLGwsaCxhW2QrMTRdLDksLTEwMTk4MDM2OTApLGg9XyhoLGYsYyxsLGFbZCszXSwxNCwtMTg3MzYzOTYxKSxsPV8obCxoLGYsYyxhW2QrOF0sMjAsMTE2MzUzMTUwMSksYz1fKGMsbCxoLGYsYVtkKzEzXSw1LC0xNDQ0NjgxNDY3KSxmPV8oZixjLGwsaCxhW2QrMl0sOSwtNTE0MDM3ODQpLGg9XyhoLGYsYyxsLGFbZCs3XSwxNCwxNzM1MzI4NDczKSxsPV8obCxoLGYsYyxhW2QrMTJdLDIwLC0xOTI2NjA3NzM0KSxjPXYoYyxsLGgsZixhW2QrNV0sNCwtMzc4NTU4KSxmPXYoZixjLGwsaCxhW2QrOF0sMTEsLTIwMjI1NzQ0NjMpLGg9dihoLGYsYyxsLGFbZCsxMV0sMTYsMTgzOTAzMDU2MiksbD12KGwsaCxmLGMsYVtkKzE0XSwyMywtMzUzMDk1NTYpLGM9dihjLGwsaCxmLGFbZCsxXSw0LC0xNTMwOTkyMDYwKSxmPXYoZixjLGwsaCxhW2QrNF0sMTEsMTI3Mjg5MzM1MyksaD12KGgsZixjLGwsYVtkKzddLDE2LC0xNTU0OTc2MzIpLGw9dihsLGgsZixjLGFbZCsxMF0sMjMsLTEwOTQ3MzA2NDApLGM9dihjLGwsaCxmLGFbZCsxM10sNCw2ODEyNzkxNzQpLGY9dihmLGMsbCxoLGFbZCswXSwxMSwtMzU4NTM3MjIyKSxoPXYoaCxmLGMsbCxhW2QrM10sMTYsLTcyMjUyMTk3OSksbD12KGwsaCxmLGMsYVtkKzZdLDIzLDc2MDI5MTg5KSxjPXYoYyxsLGgsZixhW2QrOV0sNCwtNjQwMzY0NDg3KSxmPXYoZixjLGwsaCxhW2QrMTJdLDExLC00MjE4MTU4MzUpLGg9dihoLGYsYyxsLGFbZCsxNV0sMTYsNTMwNzQyNTIwKSxsPXYobCxoLGYsYyxhW2QrMl0sMjMsLTk5NTMzODY1MSksYz15KGMsbCxoLGYsYVtkKzBdLDYsLTE5ODYzMDg0NCksZj15KGYsYyxsLGgsYVtkKzddLDEwLDExMjY4OTE0MTUpLGg9eShoLGYsYyxsLGFbZCsxNF0sMTUsLTE0MTYzNTQ5MDUpLGw9eShsLGgsZixjLGFbZCs1XSwyMSwtNTc0MzQwNTUpLGM9eShjLGwsaCxmLGFbZCsxMl0sNiwxNzAwNDg1NTcxKSxmPXkoZixjLGwsaCxhW2QrM10sMTAsLTE4OTQ5ODY2MDYpLGg9eShoLGYsYyxsLGFbZCsxMF0sMTUsLTEwNTE1MjMpLGw9eShsLGgsZixjLGFbZCsxXSwyMSwtMjA1NDkyMjc5OSksYz15KGMsbCxoLGYsYVtkKzhdLDYsMTg3MzMxMzM1OSksZj15KGYsYyxsLGgsYVtkKzE1XSwxMCwtMzA2MTE3NDQpLGg9eShoLGYsYyxsLGFbZCs2XSwxNSwtMTU2MDE5ODM4MCksbD15KGwsaCxmLGMsYVtkKzEzXSwyMSwxMzA5MTUxNjQ5KSxjPXkoYyxsLGgsZixhW2QrNF0sNiwtMTQ1NTIzMDcwKSxmPXkoZixjLGwsaCxhW2QrMTFdLDEwLC0xMTIwMjEwMzc5KSxoPXkoaCxmLGMsbCxhW2QrMl0sMTUsNzE4Nzg3MjU5KSxsPXkobCxoLGYsYyxhW2QrOV0sMjEsLTM0MzQ4NTU1MSksYz1jK20+Pj4wLGw9bCtnPj4+MCxoPWgrYj4+PjAsZj1mK3c+Pj4wfXJldHVybiBlLmVuZGlhbihbYyxsLGgsZl0pfTtvLl9mZj1mdW5jdGlvbih0LGUsbixyLGkscyxvKXt2YXIgYT10KyhlJm58fmUmcikrKGk+Pj4wKStvO3JldHVybihhPDxzfGE+Pj4zMi1zKStlfSxvLl9nZz1mdW5jdGlvbih0LGUsbixyLGkscyxvKXt2YXIgYT10KyhlJnJ8biZ+cikrKGk+Pj4wKStvO3JldHVybihhPDxzfGE+Pj4zMi1zKStlfSxvLl9oaD1mdW5jdGlvbih0LGUsbixyLGkscyxvKXt2YXIgYT10KyhlXm5ecikrKGk+Pj4wKStvO3JldHVybihhPDxzfGE+Pj4zMi1zKStlfSxvLl9paT1mdW5jdGlvbih0LGUsbixyLGkscyxvKXt2YXIgYT10KyhuXihlfH5yKSkrKGk+Pj4wKStvO3JldHVybihhPDxzfGE+Pj4zMi1zKStlfSxvLl9ibG9ja3NpemU9MTYsby5fZGlnZXN0c2l6ZT0xNix0LmV4cG9ydHM9ZnVuY3Rpb24odCxuKXtpZih2b2lkIDA9PT10fHxudWxsPT09dCl0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGFyZ3VtZW50IFwiK3QpO3ZhciByPWUud29yZHNUb0J5dGVzKG8odCxuKSk7cmV0dXJuIG4mJm4uYXNCeXRlcz9yOm4mJm4uYXNTdHJpbmc/cy5ieXRlc1RvU3RyaW5nKHIpOmUuYnl0ZXNUb0hleChyKX19KCl9LGZ1bmN0aW9uKHQsZSl7IWZ1bmN0aW9uKCl7dmFyIGU9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIsbj17cm90bDpmdW5jdGlvbih0LGUpe3JldHVybiB0PDxlfHQ+Pj4zMi1lfSxyb3RyOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ8PDMyLWV8dD4+PmV9LGVuZGlhbjpmdW5jdGlvbih0KXtpZih0LmNvbnN0cnVjdG9yPT1OdW1iZXIpcmV0dXJuIDE2NzExOTM1Jm4ucm90bCh0LDgpfDQyNzgyNTUzNjAmbi5yb3RsKHQsMjQpO2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09bi5lbmRpYW4odFtlXSk7cmV0dXJuIHR9LHJhbmRvbUJ5dGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXTt0PjA7dC0tKWUucHVzaChNYXRoLmZsb29yKDI1NipNYXRoLnJhbmRvbSgpKSk7cmV0dXJuIGV9LGJ5dGVzVG9Xb3JkczpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wLHI9MDtuPHQubGVuZ3RoO24rKyxyKz04KWVbcj4+PjVdfD10W25dPDwyNC1yJTMyO3JldHVybiBlfSx3b3Jkc1RvQnl0ZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPDMyKnQubGVuZ3RoO24rPTgpZS5wdXNoKHRbbj4+PjVdPj4+MjQtbiUzMiYyNTUpO3JldHVybiBlfSxieXRlc1RvSGV4OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDtuKyspZS5wdXNoKCh0W25dPj4+NCkudG9TdHJpbmcoMTYpKSxlLnB1c2goKDE1JnRbbl0pLnRvU3RyaW5nKDE2KSk7cmV0dXJuIGUuam9pbihcIlwiKX0saGV4VG9CeXRlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7bis9MillLnB1c2gocGFyc2VJbnQodC5zdWJzdHIobiwyKSwxNikpO3JldHVybiBlfSxieXRlc1RvQmFzZTY0OmZ1bmN0aW9uKHQpe2Zvcih2YXIgbj1bXSxyPTA7cjx0Lmxlbmd0aDtyKz0zKWZvcih2YXIgaT10W3JdPDwxNnx0W3IrMV08PDh8dFtyKzJdLHM9MDtzPDQ7cysrKTgqcis2KnM8PTgqdC5sZW5ndGg/bi5wdXNoKGUuY2hhckF0KGk+Pj42KigzLXMpJjYzKSk6bi5wdXNoKFwiPVwiKTtyZXR1cm4gbi5qb2luKFwiXCIpfSxiYXNlNjRUb0J5dGVzOmZ1bmN0aW9uKHQpe3Q9dC5yZXBsYWNlKC9bXkEtWjAtOStcXC9dL2dpLFwiXCIpO2Zvcih2YXIgbj1bXSxyPTAsaT0wO3I8dC5sZW5ndGg7aT0rK3IlNCkwIT1pJiZuLnB1c2goKGUuaW5kZXhPZih0LmNoYXJBdChyLTEpKSZNYXRoLnBvdygyLC0yKmkrOCktMSk8PDIqaXxlLmluZGV4T2YodC5jaGFyQXQocikpPj4+Ni0yKmkpO3JldHVybiBufX07dC5leHBvcnRzPW59KCl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4hIXQuY29uc3RydWN0b3ImJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuY29uc3RydWN0b3IuaXNCdWZmZXImJnQuY29uc3RydWN0b3IuaXNCdWZmZXIodCl9ZnVuY3Rpb24gcih0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnJlYWRGbG9hdExFJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnNsaWNlJiZuKHQuc2xpY2UoMCwwKSl9LyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xudC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT10JiYobih0KXx8cih0KXx8ISF0Ll9pc0J1ZmZlcil9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9ZnVuY3Rpb24odCxlKXt2YXIgbjt0LmluZGV4T2YoXCJiYXNlNjRcIik8MD9uPWF0b2IodCk6dC5zcGxpdChcIixcIilbMF0uaW5kZXhPZihcImJhc2U2NFwiKT49MD8oZT1lfHx0LnNwbGl0KFwiLFwiKVswXS5zcGxpdChcIjpcIilbMV0uc3BsaXQoXCI7XCIpWzBdLG49YXRvYih0LnNwbGl0KFwiLFwiKVsxXSkpOm49dW5lc2NhcGUodC5zcGxpdChcIixcIilbMV0pO2Zvcih2YXIgcj1uZXcgVWludDhBcnJheShuLmxlbmd0aCksaT0wO2k8bi5sZW5ndGg7aSsrKXJbaV09bi5jaGFyQ29kZUF0KGkpO3JldHVybiBuZXcgQmxvYihbcl0se3R5cGU6ZX0pfTt0LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCxlKXtyZXR1cm4gdCYmdFtlXT9zLmlzRnVuY3Rpb24odFtlXSk/dFtlXSgpOnRbZV06bnVsbH12YXIgaT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt2YXIgbj1bXSxyPSEwLGk9ITEscz12b2lkIDA7dHJ5e2Zvcih2YXIgbyxhPXRbU3ltYm9sLml0ZXJhdG9yXSgpOyEocj0obz1hLm5leHQoKSkuZG9uZSkmJihuLnB1c2goby52YWx1ZSksIWV8fG4ubGVuZ3RoIT09ZSk7cj0hMCk7fWNhdGNoKHQpe2k9ITAscz10fWZpbmFsbHl7dHJ5eyFyJiZhLnJldHVybiYmYS5yZXR1cm4oKX1maW5hbGx5e2lmKGkpdGhyb3cgc319cmV0dXJuIG59cmV0dXJuIGZ1bmN0aW9uKGUsbil7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZTtpZihTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpKXJldHVybiB0KGUsbik7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9fSgpLHM9bigwKSxvPW4oNCksYT1uKDIpLHU9YS5fcmVxdWVzdCxjPW4oMyksbD1jLmlzTnVsbE9yVW5kZWZpbmVkLGg9Yy5lbnN1cmVBcnJheSxmPWMudHJhbnNmb3JtRmV0Y2hPcHRpb25zLGQ9Yy5zZXRWYWx1ZSxwPWMuZmluZFZhbHVlLF89Yy5pc1BsYWluT2JqZWN0LHY9ZnVuY3Rpb24gdChlKXtyZXR1cm4gcy5pc0FycmF5KGUpP2UubWFwKHQpOl8oZSk/cy5tYXBPYmplY3QoZSx0KTpzLmlzT2JqZWN0KGUpJiZlLl90b1BvaW50ZXI/ZS5fdG9Qb2ludGVyKCk6ZX0seT1bXCJvYmplY3RJZFwiLFwiY3JlYXRlZEF0XCIsXCJ1cGRhdGVkQXRcIl0sbT1mdW5jdGlvbih0KXtpZigtMSE9PXkuaW5kZXhPZih0KSl0aHJvdyBuZXcgRXJyb3IoXCJrZXlbXCIrdCtcIl0gaXMgcmVzZXJ2ZWRcIil9LGc9ZnVuY3Rpb24odCl7dmFyIGU9cy5maW5kKHQsZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBFcnJvcn0pO2lmKCFlKXJldHVybiB0O3ZhciBuPW5ldyBvKGUuY29kZSxlLm1lc3NhZ2UpO3Rocm93IG4ucmVzdWx0cz10LG59O3QuZXhwb3J0cz1mdW5jdGlvbih0KXt0Lk9iamVjdD1mdW5jdGlvbihlLG4pe2lmKHMuaXNTdHJpbmcoZSkpcmV0dXJuIHQuT2JqZWN0Ll9jcmVhdGUuYXBwbHkodGhpcyxhcmd1bWVudHMpO2U9ZXx8e30sbiYmbi5wYXJzZSYmKGU9dGhpcy5wYXJzZShlKSxlPXRoaXMuX21lcmdlTWFnaWNGaWVsZHMoZSkpO3ZhciBpPXIodGhpcyxcImRlZmF1bHRzXCIpO2kmJihlPXMuZXh0ZW5kKHt9LGksZSkpLG4mJm4uY29sbGVjdGlvbiYmKHRoaXMuY29sbGVjdGlvbj1uLmNvbGxlY3Rpb24pLHRoaXMuX3NlcnZlckRhdGE9e30sdGhpcy5fb3BTZXRRdWV1ZT1be31dLHRoaXMuX2ZsYWdzPXt9LHRoaXMuYXR0cmlidXRlcz17fSx0aGlzLl9oYXNoZWRKU09OPXt9LHRoaXMuX2VzY2FwZWRBdHRyaWJ1dGVzPXt9LHRoaXMuY2lkPXMudW5pcXVlSWQoXCJjXCIpLHRoaXMuY2hhbmdlZD17fSx0aGlzLl9zaWxlbnQ9e30sdGhpcy5fcGVuZGluZz17fSx0aGlzLnNldChlLHtzaWxlbnQ6ITB9KSx0aGlzLmNoYW5nZWQ9e30sdGhpcy5fc2lsZW50PXt9LHRoaXMuX3BlbmRpbmc9e30sdGhpcy5faGFzRGF0YT0hMCx0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXM9cy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpLHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LHQuT2JqZWN0LnNhdmVBbGw9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5PYmplY3QuX2RlZXBTYXZlQXN5bmMoZSxudWxsLG4pfSx0Lk9iamVjdC5mZXRjaEFsbD1mdW5jdGlvbihlLG4pe3JldHVybiB0LlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gdShcImJhdGNoXCIsbnVsbCxudWxsLFwiUE9TVFwiLHtyZXF1ZXN0czpzLm1hcChlLGZ1bmN0aW9uKHQpe2lmKCF0LmNsYXNzTmFtZSl0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgbXVzdCBoYXZlIGNsYXNzTmFtZSB0byBmZXRjaFwiKTtpZighdC5pZCl0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgbXVzdCBoYXZlIGlkIHRvIGZldGNoXCIpO2lmKHQuZGlydHkoKSl0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaXMgbW9kaWZpZWQgYnV0IG5vdCBzYXZlZFwiKTtyZXR1cm57bWV0aG9kOlwiR0VUXCIscGF0aDpcIi8xLjEvY2xhc3Nlcy9cIit0LmNsYXNzTmFtZStcIi9cIit0LmlkfX0pfSxuKX0pLnRoZW4oZnVuY3Rpb24odCl7dmFyIG49cy5tYXAoZSxmdW5jdGlvbihlLG4pe2lmKHRbbl0uc3VjY2Vzcyl7dmFyIHI9ZS5wYXJzZSh0W25dLnN1Y2Nlc3MpO3JldHVybiBlLl9jbGVhbnVwVW5zZXRLZXlzKHIpLGUuX2ZpbmlzaEZldGNoKHIpLGV9cmV0dXJuIG51bGw9PT10W25dLnN1Y2Nlc3M/bmV3IG8oby5PQkpFQ1RfTk9UX0ZPVU5ELFwiT2JqZWN0IG5vdCBmb3VuZC5cIik6bmV3IG8odFtuXS5lcnJvci5jb2RlLHRbbl0uZXJyb3IuZXJyb3IpfSk7cmV0dXJuIGcobil9KX0scy5leHRlbmQodC5PYmplY3QucHJvdG90eXBlLHQuRXZlbnRzLHtfZmV0Y2hXaGVuU2F2ZTohMSxpbml0aWFsaXplOmZ1bmN0aW9uKCl7fSxmZXRjaFdoZW5TYXZlOmZ1bmN0aW9uKHQpe2lmKGNvbnNvbGUud2FybihcIkFWLk9iamVjdCNmZXRjaFdoZW5TYXZlIGlzIGRlcHJlY2F0ZWQsIHVzZSBBVi5PYmplY3Qjc2F2ZSB3aXRoIG9wdGlvbnMuZmV0Y2hXaGVuU2F2ZSBpbnN0ZWFkLlwiKSwhcy5pc0Jvb2xlYW4odCkpdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0IGJvb2xlYW4gdmFsdWUgZm9yIGZldGNoV2hlblNhdmVcIik7dGhpcy5fZmV0Y2hXaGVuU2F2ZT10fSxnZXRPYmplY3RJZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlkfSxnZXRDcmVhdGVkQXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGVkQXR8fHRoaXMuZ2V0KFwiY3JlYXRlZEF0XCIpfSxnZXRVcGRhdGVkQXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51cGRhdGVkQXR8fHRoaXMuZ2V0KFwidXBkYXRlZEF0XCIpfSx0b0pTT046ZnVuY3Rpb24odCxlKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06W107cmV0dXJuIHRoaXMuX3RvRnVsbEpTT04obiwhMSl9LHRvRnVsbEpTT046ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06W107cmV0dXJuIHRoaXMuX3RvRnVsbEpTT04odCl9LF90b0Z1bGxKU09OOmZ1bmN0aW9uKGUpe3ZhciBuPXRoaXMscj0hKGFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdKXx8YXJndW1lbnRzWzFdLGk9cy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO2lmKHMuaXNBcnJheShlKSl2YXIgbz1lLmNvbmNhdCh0aGlzKTtyZXR1cm4gdC5fb2JqZWN0RWFjaChpLGZ1bmN0aW9uKGUsbil7aVtuXT10Ll9lbmNvZGUoZSxvLHZvaWQgMCxyKX0pLHQuX29iamVjdEVhY2godGhpcy5fb3BlcmF0aW9ucyxmdW5jdGlvbih0LGUpe2lbZV09dH0pLHMuaGFzKHRoaXMsXCJpZFwiKSYmKGkub2JqZWN0SWQ9dGhpcy5pZCkscyhbXCJjcmVhdGVkQXRcIixcInVwZGF0ZWRBdFwiXSkuZWFjaChmdW5jdGlvbih0KXtpZihzLmhhcyhuLHQpKXt2YXIgZT1uW3RdO2lbdF09cy5pc0RhdGUoZSk/ZS50b0pTT04oKTplfX0pLHImJihpLl9fdHlwZT1cIk9iamVjdFwiLHMuaXNBcnJheShlKSYmZS5sZW5ndGgmJihpLl9fdHlwZT1cIlBvaW50ZXJcIiksaS5jbGFzc05hbWU9dGhpcy5jbGFzc05hbWUpLGl9LF9yZWZyZXNoQ2FjaGU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2UuX3JlZnJlc2hpbmdDYWNoZXx8KGUuX3JlZnJlc2hpbmdDYWNoZT0hMCx0Ll9vYmplY3RFYWNoKHRoaXMuYXR0cmlidXRlcyxmdW5jdGlvbihuLHIpe24gaW5zdGFuY2VvZiB0Lk9iamVjdD9uLl9yZWZyZXNoQ2FjaGUoKTpzLmlzT2JqZWN0KG4pJiZlLl9yZXNldENhY2hlRm9yS2V5KHIpJiZlLnNldChyLG5ldyB0Lk9wLlNldChuKSx7c2lsZW50OiEwfSl9KSxkZWxldGUgZS5fcmVmcmVzaGluZ0NhY2hlKX0sZGlydHk6ZnVuY3Rpb24odCl7dGhpcy5fcmVmcmVzaENhY2hlKCk7dmFyIGU9cy5sYXN0KHRoaXMuX29wU2V0UXVldWUpO3JldHVybiB0PyEhZVt0XTohdGhpcy5pZHx8cy5rZXlzKGUpLmxlbmd0aD4wfSxfdG9Qb2ludGVyOmZ1bmN0aW9uKCl7cmV0dXJue19fdHlwZTpcIlBvaW50ZXJcIixjbGFzc05hbWU6dGhpcy5jbGFzc05hbWUsb2JqZWN0SWQ6dGhpcy5pZH19LGdldDpmdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZVwib2JqZWN0SWRcIjpyZXR1cm4gdGhpcy5pZDtjYXNlXCJjcmVhdGVkQXRcIjpjYXNlXCJ1cGRhdGVkQXRcIjpyZXR1cm4gdGhpc1t0XTtkZWZhdWx0OnJldHVybiB0aGlzLmF0dHJpYnV0ZXNbdF19fSxyZWxhdGlvbjpmdW5jdGlvbihlKXt2YXIgbj10aGlzLmdldChlKTtpZihuKXtpZighKG4gaW5zdGFuY2VvZiB0LlJlbGF0aW9uKSl0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgcmVsYXRpb24oKSBvbiBub24tcmVsYXRpb24gZmllbGQgXCIrZSk7cmV0dXJuIG4uX2Vuc3VyZVBhcmVudEFuZEtleSh0aGlzLGUpLG59cmV0dXJuIG5ldyB0LlJlbGF0aW9uKHRoaXMsZSl9LGVzY2FwZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9lc2NhcGVkQXR0cmlidXRlc1t0XTtpZihlKXJldHVybiBlO3ZhciBuLHI9dGhpcy5hdHRyaWJ1dGVzW3RdO3JldHVybiBuPWwocik/XCJcIjpzLmVzY2FwZShyLnRvU3RyaW5nKCkpLHRoaXMuX2VzY2FwZWRBdHRyaWJ1dGVzW3RdPW4sbn0saGFzOmZ1bmN0aW9uKHQpe3JldHVybiFsKHRoaXMuYXR0cmlidXRlc1t0XSl9LF9tZXJnZU1hZ2ljRmllbGRzOmZ1bmN0aW9uKGUpe3ZhciBuPXRoaXMscj1bXCJvYmplY3RJZFwiLFwiY3JlYXRlZEF0XCIsXCJ1cGRhdGVkQXRcIl07cmV0dXJuIHQuX2FycmF5RWFjaChyLGZ1bmN0aW9uKHIpe2Vbcl0mJihcIm9iamVjdElkXCI9PT1yP24uaWQ9ZVtyXTpcImNyZWF0ZWRBdFwiIT09ciYmXCJ1cGRhdGVkQXRcIiE9PXJ8fHMuaXNEYXRlKGVbcl0pP25bcl09ZVtyXTpuW3JdPXQuX3BhcnNlRGF0ZShlW3JdKSxkZWxldGUgZVtyXSl9KSxlfSxfc3RhcnRTYXZlOmZ1bmN0aW9uKCl7dGhpcy5fb3BTZXRRdWV1ZS5wdXNoKHt9KX0sX2NhbmNlbFNhdmU6ZnVuY3Rpb24oKXt2YXIgZT1zLmZpcnN0KHRoaXMuX29wU2V0UXVldWUpO3RoaXMuX29wU2V0UXVldWU9cy5yZXN0KHRoaXMuX29wU2V0UXVldWUpO3ZhciBuPXMuZmlyc3QodGhpcy5fb3BTZXRRdWV1ZSk7dC5fb2JqZWN0RWFjaChlLGZ1bmN0aW9uKHQscil7dmFyIGk9ZVtyXSxzPW5bcl07aSYmcz9uW3JdPXMuX21lcmdlV2l0aFByZXZpb3VzKGkpOmkmJihuW3JdPWkpfSksdGhpcy5fc2F2aW5nPXRoaXMuX3NhdmluZy0xfSxfZmluaXNoU2F2ZTpmdW5jdGlvbihlKXt2YXIgbj17fTt0Ll90cmF2ZXJzZSh0aGlzLmF0dHJpYnV0ZXMsZnVuY3Rpb24oZSl7ZSBpbnN0YW5jZW9mIHQuT2JqZWN0JiZlLmlkJiZlLl9oYXNEYXRhJiYobltlLmlkXT1lKX0pO3ZhciByPXMuZmlyc3QodGhpcy5fb3BTZXRRdWV1ZSk7dGhpcy5fb3BTZXRRdWV1ZT1zLnJlc3QodGhpcy5fb3BTZXRRdWV1ZSksdGhpcy5fYXBwbHlPcFNldChyLHRoaXMuX3NlcnZlckRhdGEpLHRoaXMuX21lcmdlTWFnaWNGaWVsZHMoZSk7dmFyIGk9dGhpczt0Ll9vYmplY3RFYWNoKGUsZnVuY3Rpb24oZSxyKXtpLl9zZXJ2ZXJEYXRhW3JdPXQuX2RlY29kZShlLHIpO3ZhciBzPXQuX3RyYXZlcnNlKGkuX3NlcnZlckRhdGFbcl0sZnVuY3Rpb24oZSl7aWYoZSBpbnN0YW5jZW9mIHQuT2JqZWN0JiZuW2UuaWRdKXJldHVybiBuW2UuaWRdfSk7cyYmKGkuX3NlcnZlckRhdGFbcl09cyl9KSx0aGlzLl9yZWJ1aWxkQWxsRXN0aW1hdGVkRGF0YSgpO3ZhciBvPXRoaXMuX29wU2V0UXVldWUubWFwKHMuY2xvbmUpO3RoaXMuX3JlZnJlc2hDYWNoZSgpLHRoaXMuX29wU2V0UXVldWU9byx0aGlzLl9zYXZpbmc9dGhpcy5fc2F2aW5nLTF9LF9maW5pc2hGZXRjaDpmdW5jdGlvbihlLG4pe3RoaXMuX29wU2V0UXVldWU9W3t9XSx0aGlzLl9tZXJnZU1hZ2ljRmllbGRzKGUpO3ZhciByPXRoaXM7dC5fb2JqZWN0RWFjaChlLGZ1bmN0aW9uKGUsbil7ci5fc2VydmVyRGF0YVtuXT10Ll9kZWNvZGUoZSxuKX0pLHRoaXMuX3JlYnVpbGRBbGxFc3RpbWF0ZWREYXRhKCksdGhpcy5fcmVmcmVzaENhY2hlKCksdGhpcy5fb3BTZXRRdWV1ZT1be31dLHRoaXMuX2hhc0RhdGE9bn0sX2FwcGx5T3BTZXQ6ZnVuY3Rpb24oZSxuKXt2YXIgcj10aGlzO3QuX29iamVjdEVhY2goZSxmdW5jdGlvbihlLHMpe3ZhciBvPXAobixzKSxhPWkobywzKSx1PWFbMF0sYz1hWzFdLGw9YVsyXTtkKG4scyxlLl9lc3RpbWF0ZSh1LHIscykpLGMmJmNbbF09PT10Lk9wLl9VTlNFVCYmZGVsZXRlIGNbbF19KX0sX3Jlc2V0Q2FjaGVGb3JLZXk6ZnVuY3Rpb24oZSl7dmFyIG49dGhpcy5hdHRyaWJ1dGVzW2VdO2lmKHMuaXNPYmplY3QobikmJiEobiBpbnN0YW5jZW9mIHQuT2JqZWN0KSYmIShuIGluc3RhbmNlb2YgdC5GaWxlKSl7dmFyIHI9SlNPTi5zdHJpbmdpZnkodihuKSk7aWYodGhpcy5faGFzaGVkSlNPTltlXSE9PXIpe3ZhciBpPSEhdGhpcy5faGFzaGVkSlNPTltlXTtyZXR1cm4gdGhpcy5faGFzaGVkSlNPTltlXT1yLGl9fXJldHVybiExfSxfcmVidWlsZEVzdGltYXRlZERhdGFGb3JLZXk6ZnVuY3Rpb24oZSl7dmFyIG49dGhpcztkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW2VdLHRoaXMuX3NlcnZlckRhdGFbZV0mJih0aGlzLmF0dHJpYnV0ZXNbZV09dGhpcy5fc2VydmVyRGF0YVtlXSksdC5fYXJyYXlFYWNoKHRoaXMuX29wU2V0UXVldWUsZnVuY3Rpb24ocil7dmFyIHM9cltlXTtpZihzKXt2YXIgbz1wKG4uYXR0cmlidXRlcyxlKSxhPWkobyw0KSx1PWFbMF0sYz1hWzFdLGw9YVsyXSxoPWFbM107ZChuLmF0dHJpYnV0ZXMsZSxzLl9lc3RpbWF0ZSh1LG4sZSkpLGMmJmNbbF09PT10Lk9wLl9VTlNFVCYmZGVsZXRlIGNbbF0sbi5fcmVzZXRDYWNoZUZvcktleShoKX19KX0sX3JlYnVpbGRBbGxFc3RpbWF0ZWREYXRhOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyxuPXMuY2xvbmUodGhpcy5hdHRyaWJ1dGVzKTt0aGlzLmF0dHJpYnV0ZXM9cy5jbG9uZSh0aGlzLl9zZXJ2ZXJEYXRhKSx0Ll9hcnJheUVhY2godGhpcy5fb3BTZXRRdWV1ZSxmdW5jdGlvbihuKXtlLl9hcHBseU9wU2V0KG4sZS5hdHRyaWJ1dGVzKSx0Ll9vYmplY3RFYWNoKG4sZnVuY3Rpb24odCxuKXtlLl9yZXNldENhY2hlRm9yS2V5KG4pfSl9KSx0Ll9vYmplY3RFYWNoKG4sZnVuY3Rpb24odCxuKXtlLmF0dHJpYnV0ZXNbbl0hPT10JiZlLnRyaWdnZXIoXCJjaGFuZ2U6XCIrbixlLGUuYXR0cmlidXRlc1tuXSx7fSl9KSx0Ll9vYmplY3RFYWNoKHRoaXMuYXR0cmlidXRlcyxmdW5jdGlvbih0LHIpe3MuaGFzKG4scil8fGUudHJpZ2dlcihcImNoYW5nZTpcIityLGUsdCx7fSl9KX0sc2V0OmZ1bmN0aW9uKGUsbixyKXt2YXIgaTtpZihzLmlzT2JqZWN0KGUpfHxsKGUpPyhpPXMubWFwT2JqZWN0KGUsZnVuY3Rpb24oZSxuKXtyZXR1cm4gbShuKSx0Ll9kZWNvZGUoZSxuKX0pLHI9bik6KGk9e30sbShlKSxpW2VdPXQuX2RlY29kZShuLGUpKSxyPXJ8fHt9LCFpKXJldHVybiB0aGlzO2kgaW5zdGFuY2VvZiB0Lk9iamVjdCYmKGk9aS5hdHRyaWJ1dGVzKSxyLnVuc2V0JiZ0Ll9vYmplY3RFYWNoKGksZnVuY3Rpb24oZSxuKXtpW25dPW5ldyB0Lk9wLlVuc2V0fSk7dmFyIG89cy5jbG9uZShpKSxhPXRoaXM7dC5fb2JqZWN0RWFjaChvLGZ1bmN0aW9uKGUsbil7ZSBpbnN0YW5jZW9mIHQuT3AmJihvW25dPWUuX2VzdGltYXRlKGEuYXR0cmlidXRlc1tuXSxhLG4pLG9bbl09PT10Lk9wLl9VTlNFVCYmZGVsZXRlIG9bbl0pfSksdGhpcy5fdmFsaWRhdGUoaSxyKSxyLmNoYW5nZXM9e307dmFyIHU9dGhpcy5fZXNjYXBlZEF0dHJpYnV0ZXM7dGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzO3JldHVybiB0Ll9hcnJheUVhY2gocy5rZXlzKGkpLGZ1bmN0aW9uKGUpe3ZhciBuPWlbZV07biBpbnN0YW5jZW9mIHQuUmVsYXRpb24mJihuLnBhcmVudD1hKSxuIGluc3RhbmNlb2YgdC5PcHx8KG49bmV3IHQuT3AuU2V0KG4pKTt2YXIgbz0hMDtuIGluc3RhbmNlb2YgdC5PcC5TZXQmJnMuaXNFcXVhbChhLmF0dHJpYnV0ZXNbZV0sbi52YWx1ZSkmJihvPSExKSxvJiYoZGVsZXRlIHVbZV0sci5zaWxlbnQ/YS5fc2lsZW50W2VdPSEwOnIuY2hhbmdlc1tlXT0hMCk7dmFyIGM9cy5sYXN0KGEuX29wU2V0UXVldWUpO2NbZV09bi5fbWVyZ2VXaXRoUHJldmlvdXMoY1tlXSksYS5fcmVidWlsZEVzdGltYXRlZERhdGFGb3JLZXkoZSksbz8oYS5jaGFuZ2VkW2VdPWEuYXR0cmlidXRlc1tlXSxyLnNpbGVudHx8KGEuX3BlbmRpbmdbZV09ITApKTooZGVsZXRlIGEuY2hhbmdlZFtlXSxkZWxldGUgYS5fcGVuZGluZ1tlXSl9KSxyLnNpbGVudHx8dGhpcy5jaGFuZ2UociksdGhpc30sdW5zZXQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gZT1lfHx7fSxlLnVuc2V0PSEwLHRoaXMuc2V0KHQsbnVsbCxlKX0saW5jcmVtZW50OmZ1bmN0aW9uKGUsbil7cmV0dXJuKHMuaXNVbmRlZmluZWQobil8fHMuaXNOdWxsKG4pKSYmKG49MSksdGhpcy5zZXQoZSxuZXcgdC5PcC5JbmNyZW1lbnQobikpfSxhZGQ6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdGhpcy5zZXQoZSxuZXcgdC5PcC5BZGQoaChuKSkpfSxhZGRVbmlxdWU6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdGhpcy5zZXQoZSxuZXcgdC5PcC5BZGRVbmlxdWUoaChuKSkpfSxyZW1vdmU6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdGhpcy5zZXQoZSxuZXcgdC5PcC5SZW1vdmUoaChuKSkpfSxiaXRBbmQ6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdGhpcy5zZXQoZSxuZXcgdC5PcC5CaXRBbmQobikpfSxiaXRPcjpmdW5jdGlvbihlLG4pe3JldHVybiB0aGlzLnNldChlLG5ldyB0Lk9wLkJpdE9yKG4pKX0sYml0WG9yOmZ1bmN0aW9uKGUsbil7cmV0dXJuIHRoaXMuc2V0KGUsbmV3IHQuT3AuQml0WG9yKG4pKX0sb3A6ZnVuY3Rpb24odCl7cmV0dXJuIHMubGFzdCh0aGlzLl9vcFNldFF1ZXVlKVt0XX0sY2xlYXI6ZnVuY3Rpb24odCl7dD10fHx7fSx0LnVuc2V0PSEwO3ZhciBlPXMuZXh0ZW5kKHRoaXMuYXR0cmlidXRlcyx0aGlzLl9vcGVyYXRpb25zKTtyZXR1cm4gdGhpcy5zZXQoZSx0KX0sX2dldFNhdmVKU09OOmZ1bmN0aW9uKCl7dmFyIGU9cy5jbG9uZShzLmZpcnN0KHRoaXMuX29wU2V0UXVldWUpKTtyZXR1cm4gdC5fb2JqZWN0RWFjaChlLGZ1bmN0aW9uKHQsbil7ZVtuXT10LnRvSlNPTigpfSksZX0sX2NhbkJlU2VyaWFsaXplZDpmdW5jdGlvbigpe3JldHVybiB0Lk9iamVjdC5fY2FuQmVTZXJpYWxpemVkQXNWYWx1ZSh0aGlzLmF0dHJpYnV0ZXMpfSxmZXRjaDpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSxlPWFyZ3VtZW50c1sxXSxuPXRoaXM7cmV0dXJuIHUoXCJjbGFzc2VzXCIsdGhpcy5jbGFzc05hbWUsdGhpcy5pZCxcIkdFVFwiLGYodCksZSkudGhlbihmdW5jdGlvbihlKXt2YXIgcj1uLnBhcnNlKGUpO3JldHVybiB0LmtleXN8fG4uX2NsZWFudXBVbnNldEtleXMociksbi5fZmluaXNoRmV0Y2gociwhMCksbn0pfSxfY2xlYW51cFVuc2V0S2V5czpmdW5jdGlvbihlKXt2YXIgbj10aGlzO3QuX29iamVjdEVhY2godGhpcy5fc2VydmVyRGF0YSxmdW5jdGlvbih0LHIpe3ZvaWQgMD09PWVbcl0mJmRlbGV0ZSBuLl9zZXJ2ZXJEYXRhW3JdfSl9LHNhdmU6ZnVuY3Rpb24oZSxuLHIpe3ZhciBpLG8sYTtzLmlzT2JqZWN0KGUpfHxsKGUpPyhpPWUsYT1uKTooaT17fSxpW2VdPW4sYT1yKSxhPXMuY2xvbmUoYSl8fHt9LGEud2FpdCYmKG89cy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpKTt2YXIgYz1zLmNsb25lKGEpfHx7fTtjLndhaXQmJihjLnNpbGVudD0hMCksaSYmdGhpcy5zZXQoaSxjKTt2YXIgaD10aGlzLGY9W10sZD1bXTtyZXR1cm4gdC5PYmplY3QuX2ZpbmRVbnNhdmVkQ2hpbGRyZW4oaCxmLGQpLGYubGVuZ3RoK2QubGVuZ3RoPjE/dC5PYmplY3QuX2RlZXBTYXZlQXN5bmModGhpcyxoLGEpOih0aGlzLl9zdGFydFNhdmUoKSx0aGlzLl9zYXZpbmc9KHRoaXMuX3NhdmluZ3x8MCkrMSx0aGlzLl9hbGxQcmV2aW91c1NhdmVzPXRoaXMuX2FsbFByZXZpb3VzU2F2ZXN8fHQuUHJvbWlzZS5yZXNvbHZlKCksdGhpcy5fYWxsUHJldmlvdXNTYXZlcz10aGlzLl9hbGxQcmV2aW91c1NhdmVzLmNhdGNoKGZ1bmN0aW9uKHQpe30pLnRoZW4oZnVuY3Rpb24oKXt2YXIgdD1oLmlkP1wiUFVUXCI6XCJQT1NUXCIsZT1oLl9nZXRTYXZlSlNPTigpLG49e307aWYoKGguX2ZldGNoV2hlblNhdmV8fGEuZmV0Y2hXaGVuU2F2ZSkmJihuLm5ldz1cInRydWVcIiksYS5fZmFpbE9uTm90RXhpc3QmJihuLmZhaWxPbk5vdEV4aXN0PVwidHJ1ZVwiKSxhLnF1ZXJ5KXt2YXIgcjtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLnF1ZXJ5LnRvSlNPTiYmKHI9YS5xdWVyeS50b0pTT04oKSkmJihuLndoZXJlPXIud2hlcmUpLCFuLndoZXJlKXt0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLnF1ZXJ5IGlzIG5vdCBhbiBBVi5RdWVyeVwiKX19cy5leHRlbmQoZSxoLl9mbGFncyk7dmFyIGw9XCJjbGFzc2VzXCIsZj1oLmNsYXNzTmFtZTtcIl9Vc2VyXCIhPT1oLmNsYXNzTmFtZXx8aC5pZHx8KGw9XCJ1c2Vyc1wiLGY9bnVsbCk7dmFyIGQ9YS5fbWFrZVJlcXVlc3R8fHUscD1kKGwsZixoLmlkLHQsZSxhLG4pO3JldHVybiBwPXAudGhlbihmdW5jdGlvbih0KXt2YXIgZT1oLnBhcnNlKHQpO3JldHVybiBhLndhaXQmJihlPXMuZXh0ZW5kKGl8fHt9LGUpKSxoLl9maW5pc2hTYXZlKGUpLGEud2FpdCYmaC5zZXQobyxjKSxofSxmdW5jdGlvbih0KXt0aHJvdyBoLl9jYW5jZWxTYXZlKCksdH0pfSksdGhpcy5fYWxsUHJldmlvdXNTYXZlcyl9LGRlc3Ryb3k6ZnVuY3Rpb24odCl7dD10fHx7fTt2YXIgZT10aGlzLG49ZnVuY3Rpb24oKXtlLnRyaWdnZXIoXCJkZXN0cm95XCIsZSxlLmNvbGxlY3Rpb24sdCl9O3JldHVybiB0aGlzLmlkPyh0LndhaXR8fG4oKSx1KFwiY2xhc3Nlc1wiLHRoaXMuY2xhc3NOYW1lLHRoaXMuaWQsXCJERUxFVEVcIix0aGlzLl9mbGFncyx0KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHQud2FpdCYmbigpLGV9KSk6bigpfSxwYXJzZTpmdW5jdGlvbihlKXt2YXIgbj1zLmNsb25lKGUpO3JldHVybiBzKFtcImNyZWF0ZWRBdFwiLFwidXBkYXRlZEF0XCJdKS5lYWNoKGZ1bmN0aW9uKGUpe25bZV0mJihuW2VdPXQuX3BhcnNlRGF0ZShuW2VdKSl9KSxuLmNyZWF0ZWRBdCYmIW4udXBkYXRlZEF0JiYobi51cGRhdGVkQXQ9bi5jcmVhdGVkQXQpLG59LGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYXR0cmlidXRlcyl9LGlzTmV3OmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaWR9LGNoYW5nZTpmdW5jdGlvbihlKXtlPWV8fHt9O3ZhciBuPXRoaXMuX2NoYW5naW5nO3RoaXMuX2NoYW5naW5nPSEwO3ZhciByPXRoaXM7dC5fb2JqZWN0RWFjaCh0aGlzLl9zaWxlbnQsZnVuY3Rpb24odCl7ci5fcGVuZGluZ1t0XT0hMH0pO3ZhciBpPXMuZXh0ZW5kKHt9LGUuY2hhbmdlcyx0aGlzLl9zaWxlbnQpO2lmKHRoaXMuX3NpbGVudD17fSx0Ll9vYmplY3RFYWNoKGksZnVuY3Rpb24odCxuKXtyLnRyaWdnZXIoXCJjaGFuZ2U6XCIrbixyLHIuZ2V0KG4pLGUpfSksbilyZXR1cm4gdGhpcztmb3IodmFyIG89ZnVuY3Rpb24odCxlKXtyLl9wZW5kaW5nW2VdfHxyLl9zaWxlbnRbZV18fGRlbGV0ZSByLmNoYW5nZWRbZV19OyFzLmlzRW1wdHkodGhpcy5fcGVuZGluZyk7KXRoaXMuX3BlbmRpbmc9e30sdGhpcy50cmlnZ2VyKFwiY2hhbmdlXCIsdGhpcyxlKSx0Ll9vYmplY3RFYWNoKHRoaXMuY2hhbmdlZCxvKSxyLl9wcmV2aW91c0F0dHJpYnV0ZXM9cy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO3JldHVybiB0aGlzLl9jaGFuZ2luZz0hMSx0aGlzfSxoYXNDaGFuZ2VkOmZ1bmN0aW9uKHQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoP3RoaXMuY2hhbmdlZCYmcy5oYXModGhpcy5jaGFuZ2VkLHQpOiFzLmlzRW1wdHkodGhpcy5jaGFuZ2VkKX0sY2hhbmdlZEF0dHJpYnV0ZXM6ZnVuY3Rpb24oZSl7aWYoIWUpcmV0dXJuISF0aGlzLmhhc0NoYW5nZWQoKSYmcy5jbG9uZSh0aGlzLmNoYW5nZWQpO3ZhciBuPXt9LHI9dGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzO3JldHVybiB0Ll9vYmplY3RFYWNoKGUsZnVuY3Rpb24odCxlKXtzLmlzRXF1YWwocltlXSx0KXx8KG5bZV09dCl9KSxufSxwcmV2aW91czpmdW5jdGlvbih0KXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCYmdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzP3RoaXMuX3ByZXZpb3VzQXR0cmlidXRlc1t0XTpudWxsfSxwcmV2aW91c0F0dHJpYnV0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gcy5jbG9uZSh0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMpfSxpc1ZhbGlkOmZ1bmN0aW9uKCl7dHJ5e3RoaXMudmFsaWRhdGUodGhpcy5hdHRyaWJ1dGVzKX1jYXRjaCh0KXtyZXR1cm4hMX1yZXR1cm4hMH0sdmFsaWRhdGU6ZnVuY3Rpb24oZSl7aWYocy5oYXMoZSxcIkFDTFwiKSYmIShlLkFDTCBpbnN0YW5jZW9mIHQuQUNMKSl0aHJvdyBuZXcgbyhvLk9USEVSX0NBVVNFLFwiQUNMIG11c3QgYmUgYSBBVi5BQ0wuXCIpfSxfdmFsaWRhdGU6ZnVuY3Rpb24odCxlKXshZS5zaWxlbnQmJnRoaXMudmFsaWRhdGUmJih0PXMuZXh0ZW5kKHt9LHRoaXMuYXR0cmlidXRlcyx0KSx0aGlzLnZhbGlkYXRlKHQpKX0sZ2V0QUNMOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0KFwiQUNMXCIpfSxzZXRBQ0w6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zZXQoXCJBQ0xcIix0LGUpfSxkaXNhYmxlQmVmb3JlSG9vazpmdW5jdGlvbigpe3RoaXMuaWdub3JlSG9vayhcImJlZm9yZVNhdmVcIiksdGhpcy5pZ25vcmVIb29rKFwiYmVmb3JlVXBkYXRlXCIpLHRoaXMuaWdub3JlSG9vayhcImJlZm9yZURlbGV0ZVwiKX0sZGlzYWJsZUFmdGVySG9vazpmdW5jdGlvbigpe3RoaXMuaWdub3JlSG9vayhcImFmdGVyU2F2ZVwiKSx0aGlzLmlnbm9yZUhvb2soXCJhZnRlclVwZGF0ZVwiKSx0aGlzLmlnbm9yZUhvb2soXCJhZnRlckRlbGV0ZVwiKX0saWdub3JlSG9vazpmdW5jdGlvbihlKXtzLmNvbnRhaW5zKFtcImJlZm9yZVNhdmVcIixcImFmdGVyU2F2ZVwiLFwiYmVmb3JlVXBkYXRlXCIsXCJhZnRlclVwZGF0ZVwiLFwiYmVmb3JlRGVsZXRlXCIsXCJhZnRlckRlbGV0ZVwiXSxlKXx8Y29uc29sZS50cmFjZShcIlVuc3VwcG9ydGVkIGhvb2tOYW1lOiBcIitlKSx0Lmhvb2tLZXl8fGNvbnNvbGUudHJhY2UoXCJpZ25vcmVIb29rIHJlcXVpcmVkIGhvb2tLZXlcIiksdGhpcy5fZmxhZ3MuX19pZ25vcmVfaG9va3N8fCh0aGlzLl9mbGFncy5fX2lnbm9yZV9ob29rcz1bXSksdGhpcy5fZmxhZ3MuX19pZ25vcmVfaG9va3MucHVzaChlKX19KSx0Lk9iamVjdC5jcmVhdGVXaXRob3V0RGF0YT1mdW5jdGlvbihlLG4scil7dmFyIGk9bmV3IHQuT2JqZWN0KGUpO3JldHVybiBpLmlkPW4saS5faGFzRGF0YT1yLGl9LHQuT2JqZWN0LmRlc3Ryb3lBbGw9ZnVuY3Rpb24oZSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9O2lmKCFlfHwwPT09ZS5sZW5ndGgpcmV0dXJuIHQuUHJvbWlzZS5yZXNvbHZlKCk7dmFyIHI9cy5ncm91cEJ5KGUsZnVuY3Rpb24odCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHtjbGFzc05hbWU6dC5jbGFzc05hbWUsZmxhZ3M6dC5fZmxhZ3N9KX0pLGk9e3JlcXVlc3RzOnMubWFwKHIsZnVuY3Rpb24odCl7dmFyIGU9cy5tYXAodCxcImlkXCIpLmpvaW4oXCIsXCIpO3JldHVybnttZXRob2Q6XCJERUxFVEVcIixwYXRoOlwiLzEuMS9jbGFzc2VzL1wiK3RbMF0uY2xhc3NOYW1lK1wiL1wiK2UsYm9keTp0WzBdLl9mbGFnc319KX07cmV0dXJuIHUoXCJiYXRjaFwiLG51bGwsbnVsbCxcIlBPU1RcIixpLG4pLnRoZW4oZnVuY3Rpb24odCl7dmFyIGU9cy5maW5kKHQsZnVuY3Rpb24odCl7cmV0dXJuIXQuc3VjY2Vzc30pO2lmKGUpdGhyb3cgbmV3IG8oZS5lcnJvci5jb2RlLGUuZXJyb3IuZXJyb3IpfSl9LHQuT2JqZWN0Ll9nZXRTdWJjbGFzcz1mdW5jdGlvbihlKXtpZighcy5pc1N0cmluZyhlKSl0aHJvdyBuZXcgRXJyb3IoXCJBVi5PYmplY3QuX2dldFN1YmNsYXNzIHJlcXVpcmVzIGEgc3RyaW5nIGFyZ3VtZW50LlwiKTt2YXIgbj10Lk9iamVjdC5fY2xhc3NNYXBbZV07cmV0dXJuIG58fChuPXQuT2JqZWN0LmV4dGVuZChlKSx0Lk9iamVjdC5fY2xhc3NNYXBbZV09biksbn0sdC5PYmplY3QuX2NyZWF0ZT1mdW5jdGlvbihlLG4scil7cmV0dXJuIG5ldyh0Lk9iamVjdC5fZ2V0U3ViY2xhc3MoZSkpKG4scil9LHQuT2JqZWN0Ll9jbGFzc01hcD17fSx0Lk9iamVjdC5fZXh0ZW5kPXQuX2V4dGVuZCx0Lk9iamVjdC5uZXc9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gbmV3IHQuT2JqZWN0KGUsbil9LHQuT2JqZWN0LmV4dGVuZD1mdW5jdGlvbihlLG4scil7aWYoIXMuaXNTdHJpbmcoZSkpe2lmKGUmJnMuaGFzKGUsXCJjbGFzc05hbWVcIikpcmV0dXJuIHQuT2JqZWN0LmV4dGVuZChlLmNsYXNzTmFtZSxlLG4pO3Rocm93IG5ldyBFcnJvcihcIkFWLk9iamVjdC5leHRlbmQncyBmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgdGhlIGNsYXNzTmFtZS5cIil9XCJVc2VyXCI9PT1lJiYoZT1cIl9Vc2VyXCIpO3ZhciBpPW51bGw7aWYocy5oYXModC5PYmplY3QuX2NsYXNzTWFwLGUpKXt2YXIgbz10Lk9iamVjdC5fY2xhc3NNYXBbZV07aWYoIW4mJiFyKXJldHVybiBvO2k9by5fZXh0ZW5kKG4scil9ZWxzZSBuPW58fHt9LG4uX2NsYXNzTmFtZT1lLGk9dGhpcy5fZXh0ZW5kKG4scik7cmV0dXJuIGkuZXh0ZW5kPWZ1bmN0aW9uKG4pe2lmKHMuaXNTdHJpbmcobil8fG4mJnMuaGFzKG4sXCJjbGFzc05hbWVcIikpcmV0dXJuIHQuT2JqZWN0LmV4dGVuZC5hcHBseShpLGFyZ3VtZW50cyk7dmFyIHI9W2VdLmNvbmNhdChzLnRvQXJyYXkoYXJndW1lbnRzKSk7cmV0dXJuIHQuT2JqZWN0LmV4dGVuZC5hcHBseShpLHIpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoaSxcInF1ZXJ5XCIsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0Lk9iamVjdCxcInF1ZXJ5XCIpKSxpLm5ldz1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgaSh0LGUpfSx0Lk9iamVjdC5fY2xhc3NNYXBbZV09aSxpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodC5PYmplY3QucHJvdG90eXBlLFwiY2xhc3NOYW1lXCIse2dldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2NsYXNzTmFtZXx8dGhpcy5jb25zdHJ1Y3Rvci5fTENDbGFzc05hbWV8fHRoaXMuY29uc3RydWN0b3IubmFtZTtyZXR1cm5cIlVzZXJcIj09PXQ/XCJfVXNlclwiOnR9fSksdC5PYmplY3QucmVnaXN0ZXI9ZnVuY3Rpb24oZSxuKXtpZighKGUucHJvdG90eXBlIGluc3RhbmNlb2YgdC5PYmplY3QpKXRocm93IG5ldyBFcnJvcihcInJlZ2lzdGVyZWQgY2xhc3MgaXMgbm90IGEgc3ViY2xhc3Mgb2YgQVYuT2JqZWN0XCIpO3ZhciByPW58fGUubmFtZTtpZighci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwicmVnaXN0ZXJlZCBjbGFzcyBtdXN0IGJlIG5hbWVkXCIpO24mJihlLl9MQ0NsYXNzTmFtZT1uKSx0Lk9iamVjdC5fY2xhc3NNYXBbcl09ZX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuT2JqZWN0LFwicXVlcnlcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB0LlF1ZXJ5KHRoaXMucHJvdG90eXBlLmNsYXNzTmFtZSl9fSksdC5PYmplY3QuX2ZpbmRVbnNhdmVkQ2hpbGRyZW49ZnVuY3Rpb24oZSxuLHIpe3QuX3RyYXZlcnNlKGUsZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiB0Lk9iamVjdD92b2lkKGUuZGlydHkoKSYmbi5wdXNoKGUpKTplIGluc3RhbmNlb2YgdC5GaWxlP3ZvaWQoZS5pZHx8ci5wdXNoKGUpKTp2b2lkIDB9KX0sdC5PYmplY3QuX2NhbkJlU2VyaWFsaXplZEFzVmFsdWU9ZnVuY3Rpb24oZSl7dmFyIG49ITA7cmV0dXJuIGUgaW5zdGFuY2VvZiB0Lk9iamVjdHx8ZSBpbnN0YW5jZW9mIHQuRmlsZT9uPSEhZS5pZDpzLmlzQXJyYXkoZSk/dC5fYXJyYXlFYWNoKGUsZnVuY3Rpb24oZSl7dC5PYmplY3QuX2NhbkJlU2VyaWFsaXplZEFzVmFsdWUoZSl8fChuPSExKX0pOnMuaXNPYmplY3QoZSkmJnQuX29iamVjdEVhY2goZSxmdW5jdGlvbihlKXt0Lk9iamVjdC5fY2FuQmVTZXJpYWxpemVkQXNWYWx1ZShlKXx8KG49ITEpfSksbn0sdC5PYmplY3QuX2RlZXBTYXZlQXN5bmM9ZnVuY3Rpb24oZSxuLHIpe3ZhciBpPVtdLGE9W107dC5PYmplY3QuX2ZpbmRVbnNhdmVkQ2hpbGRyZW4oZSxpLGEpO3ZhciBjPXQuUHJvbWlzZS5yZXNvbHZlKCk7cy5lYWNoKGEsZnVuY3Rpb24odCl7Yz1jLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gdC5zYXZlKCl9KX0pO3ZhciBsPXMudW5pcShpKSxoPXMudW5pcShsKTtyZXR1cm4gYy50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHQuUHJvbWlzZS5fY29udGludWVXaGlsZShmdW5jdGlvbigpe3JldHVybiBoLmxlbmd0aD4wfSxmdW5jdGlvbigpe3ZhciBlPVtdLG49W107aWYodC5fYXJyYXlFYWNoKGgsZnVuY3Rpb24odCl7aWYoZS5sZW5ndGg+MjApcmV0dXJuIHZvaWQgbi5wdXNoKHQpO3QuX2NhbkJlU2VyaWFsaXplZCgpP2UucHVzaCh0KTpuLnB1c2godCl9KSxoPW4sMD09PWUubGVuZ3RoKXJldHVybiB0LlByb21pc2UucmVqZWN0KG5ldyBvKG8uT1RIRVJfQ0FVU0UsXCJUcmllZCB0byBzYXZlIGEgYmF0Y2ggd2l0aCBhIGN5Y2xlLlwiKSk7dmFyIGk9dC5Qcm9taXNlLnJlc29sdmUocy5tYXAoZSxmdW5jdGlvbihlKXtyZXR1cm4gZS5fYWxsUHJldmlvdXNTYXZlc3x8dC5Qcm9taXNlLnJlc29sdmUoKX0pKSxhPWkudGhlbihmdW5jdGlvbigpe3JldHVybiB1KFwiYmF0Y2hcIixudWxsLG51bGwsXCJQT1NUXCIse3JlcXVlc3RzOnMubWFwKGUsZnVuY3Rpb24odCl7dmFyIGU9dC5pZD9cIlBVVFwiOlwiUE9TVFwiLG49dC5fZ2V0U2F2ZUpTT04oKTtzLmV4dGVuZChuLHQuX2ZsYWdzKTt2YXIgcj10LmNsYXNzTmFtZSxpPVwiL2NsYXNzZXMvXCIrcjtcIl9Vc2VyXCIhPT10LmNsYXNzTmFtZXx8dC5pZHx8KGk9XCIvdXNlcnNcIik7dmFyIGk9XCIvMS4xXCIraTtyZXR1cm4gdC5pZCYmKGk9aStcIi9cIit0LmlkKSx0Ll9zdGFydFNhdmUoKSx7bWV0aG9kOmUscGF0aDppLGJvZHk6bn19KX0scikudGhlbihmdW5jdGlvbih0KXt2YXIgbj1zLm1hcChlLGZ1bmN0aW9uKGUsbil7cmV0dXJuIHRbbl0uc3VjY2Vzcz8oZS5fZmluaXNoU2F2ZShlLnBhcnNlKHRbbl0uc3VjY2VzcykpLGUpOihlLl9jYW5jZWxTYXZlKCksbmV3IG8odFtuXS5lcnJvci5jb2RlLHRbbl0uZXJyb3IuZXJyb3IpKX0pO3JldHVybiBnKG4pfSl9KTtyZXR1cm4gdC5fYXJyYXlFYWNoKGUsZnVuY3Rpb24odCl7dC5fYWxsUHJldmlvdXNTYXZlcz1hfSksYX0pfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBlfSl9fX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMCksaT1uKDQpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt0LlJvbGU9dC5PYmplY3QuZXh0ZW5kKFwiX1JvbGVcIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24oZSxuKXtpZihyLmlzU3RyaW5nKGUpPyh0Lk9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuY2FsbCh0aGlzLG51bGwsbnVsbCksdGhpcy5zZXROYW1lKGUpKTp0Lk9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuY2FsbCh0aGlzLGUsbiksbil7aWYoIShuIGluc3RhbmNlb2YgdC5BQ0wpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhY2wgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBBVi5BQ0xcIik7dGhpcy5zZXRBQ0wobil9fSxnZXROYW1lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0KFwibmFtZVwiKX0sc2V0TmFtZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnNldChcIm5hbWVcIix0LGUpfSxnZXRVc2VyczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJlbGF0aW9uKFwidXNlcnNcIil9LGdldFJvbGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVsYXRpb24oXCJyb2xlc1wiKX0sdmFsaWRhdGU6ZnVuY3Rpb24oZSxuKXtpZihcIm5hbWVcImluIGUmJmUubmFtZSE9PXRoaXMuZ2V0TmFtZSgpKXt2YXIgcz1lLm5hbWU7aWYodGhpcy5pZCYmdGhpcy5pZCE9PWUub2JqZWN0SWQpcmV0dXJuIG5ldyBpKGkuT1RIRVJfQ0FVU0UsXCJBIHJvbGUncyBuYW1lIGNhbiBvbmx5IGJlIHNldCBiZWZvcmUgaXQgaGFzIGJlZW4gc2F2ZWQuXCIpO2lmKCFyLmlzU3RyaW5nKHMpKXJldHVybiBuZXcgaShpLk9USEVSX0NBVVNFLFwiQSByb2xlJ3MgbmFtZSBtdXN0IGJlIGEgU3RyaW5nLlwiKTtpZighL15bMC05YS16QS1aXFwtXyBdKyQvLnRlc3QocykpcmV0dXJuIG5ldyBpKGkuT1RIRVJfQ0FVU0UsXCJBIHJvbGUncyBuYW1lIGNhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMsIF8sIC0sIGFuZCBzcGFjZXMuXCIpfXJldHVybiEhdC5PYmplY3QucHJvdG90eXBlLnZhbGlkYXRlJiZ0Lk9iamVjdC5wcm90b3R5cGUudmFsaWRhdGUuY2FsbCh0aGlzLGUsbil9fSl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcih0LGUsbil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9dmFyIGk9bigwKSxzPW4oNCksbz1uKDIpLGE9by5fcmVxdWVzdCx1PW8ucmVxdWVzdCxjPW4oMSksbD1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiB3eHx8XCJmdW5jdGlvblwiIT10eXBlb2Ygd3gubG9naW4pdGhyb3cgbmV3IEVycm9yKFwiV2VhcHAgTG9naW4gaXMgb25seSBhdmFpbGFibGUgaW4gV2VhcHBcIik7cmV0dXJuIG5ldyBjKGZ1bmN0aW9uKHQsZSl7d3gubG9naW4oe3N1Y2Nlc3M6ZnVuY3Rpb24obil7dmFyIHI9bi5jb2RlLGk9bi5lcnJNc2c7cj90KHIpOmUobmV3IEVycm9yKGkpKX0sZmFpbDpmdW5jdGlvbigpe3JldHVybiBlKG5ldyBFcnJvcihcInd4LmxvZ2luIOWksei0pVwiKSl9fSl9KX0saD1mdW5jdGlvbih0LGUpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTp7fSxyPW4udW5pb25JZFBsYXRmb3JtLG89dm9pZCAwPT09cj9cIndlaXhpblwiOnIsYT1uLmFzTWFpbkFjY291bnQsdT12b2lkIDAhPT1hJiZhO2lmKFwic3RyaW5nXCIhPXR5cGVvZiBlKXRocm93IG5ldyBzKHMuT1RIRVJfQ0FVU0UsXCJ1bmlvbklkIGlzIG5vdCBhIHN0cmluZ1wiKTtpZihcInN0cmluZ1wiIT10eXBlb2Ygbyl0aHJvdyBuZXcgcyhzLk9USEVSX0NBVVNFLFwidW5pb25JZFBsYXRmb3JtIGlzIG5vdCBhIHN0cmluZ1wiKTtyZXR1cm4gaS5leHRlbmQoe30sdCx7cGxhdGZvcm06byx1bmlvbmlkOmUsbWFpbl9hY2NvdW50OkJvb2xlYW4odSl9KX07dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3QuVXNlcj10Lk9iamVjdC5leHRlbmQoXCJfVXNlclwiLHtfaXNDdXJyZW50VXNlcjohMSxfbWVyZ2VNYWdpY0ZpZWxkczpmdW5jdGlvbihlKXtyZXR1cm4gZS5zZXNzaW9uVG9rZW4mJih0aGlzLl9zZXNzaW9uVG9rZW49ZS5zZXNzaW9uVG9rZW4sZGVsZXRlIGUuc2Vzc2lvblRva2VuKSx0LlVzZXIuX19zdXBlcl9fLl9tZXJnZU1hZ2ljRmllbGRzLmNhbGwodGhpcyxlKX0sX2NsZWFudXBBdXRoRGF0YTpmdW5jdGlvbigpe2lmKHRoaXMuaXNDdXJyZW50KCkpe3ZhciBlPXRoaXMuZ2V0KFwiYXV0aERhdGFcIik7ZSYmdC5fb2JqZWN0RWFjaCh0aGlzLmdldChcImF1dGhEYXRhXCIpLGZ1bmN0aW9uKHQsbil7ZVtuXXx8ZGVsZXRlIGVbbl19KX19LF9zeW5jaHJvbml6ZUFsbEF1dGhEYXRhOmZ1bmN0aW9uKCl7aWYodGhpcy5nZXQoXCJhdXRoRGF0YVwiKSl7dmFyIGU9dGhpczt0Ll9vYmplY3RFYWNoKHRoaXMuZ2V0KFwiYXV0aERhdGFcIiksZnVuY3Rpb24odCxuKXtlLl9zeW5jaHJvbml6ZUF1dGhEYXRhKG4pfSl9fSxfc3luY2hyb25pemVBdXRoRGF0YTpmdW5jdGlvbihlKXtpZih0aGlzLmlzQ3VycmVudCgpKXt2YXIgbjtpLmlzU3RyaW5nKGUpPyhuPWUsZT10LlVzZXIuX2F1dGhQcm92aWRlcnNbbl0pOm49ZS5nZXRBdXRoVHlwZSgpO3ZhciByPXRoaXMuZ2V0KFwiYXV0aERhdGFcIik7aWYociYmZSl7ZS5yZXN0b3JlQXV0aGVudGljYXRpb24ocltuXSl8fHRoaXMuZGlzc29jaWF0ZUF1dGhEYXRhKGUpfX19LF9oYW5kbGVTYXZlUmVzdWx0OmZ1bmN0aW9uKGUpe3JldHVybiBlJiYhdC5fY29uZmlnLmRpc2FibGVDdXJyZW50VXNlciYmKHRoaXMuX2lzQ3VycmVudFVzZXI9ITApLHRoaXMuX2NsZWFudXBBdXRoRGF0YSgpLHRoaXMuX3N5bmNocm9uaXplQWxsQXV0aERhdGEoKSxkZWxldGUgdGhpcy5fc2VydmVyRGF0YS5wYXNzd29yZCx0aGlzLl9yZWJ1aWxkRXN0aW1hdGVkRGF0YUZvcktleShcInBhc3N3b3JkXCIpLHRoaXMuX3JlZnJlc2hDYWNoZSgpLCFlJiYhdGhpcy5pc0N1cnJlbnQoKXx8dC5fY29uZmlnLmRpc2FibGVDdXJyZW50VXNlcj9jLnJlc29sdmUoKTpjLnJlc29sdmUodC5Vc2VyLl9zYXZlQ3VycmVudFVzZXIodGhpcykpfSxfbGlua1dpdGg6ZnVuY3Rpb24oZSxuKXt2YXIgcyxvPXRoaXMsYT1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e30sdT1hLmZhaWxPbk5vdEV4aXN0LGM9dm9pZCAwIT09dSYmdTtyZXR1cm4gaS5pc1N0cmluZyhlKT8ocz1lLGU9dC5Vc2VyLl9hdXRoUHJvdmlkZXJzW2VdKTpzPWUuZ2V0QXV0aFR5cGUoKSxuP3RoaXMuc2F2ZSh7YXV0aERhdGE6cih7fSxzLG4pfSx7ZmV0Y2hXaGVuU2F2ZTohIXRoaXMuZ2V0KFwiYXV0aERhdGFcIiksX2ZhaWxPbk5vdEV4aXN0OmN9KS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiB0Ll9oYW5kbGVTYXZlUmVzdWx0KCEwKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHR9KX0pOmUuYXV0aGVudGljYXRlKCkudGhlbihmdW5jdGlvbih0KXtyZXR1cm4gby5fbGlua1dpdGgoZSx0KX0pfSxhc3NvY2lhdGVXaXRoQXV0aERhdGE6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fbGlua1dpdGgoZSx0KX0sYXNzb2NpYXRlV2l0aEF1dGhEYXRhQW5kVW5pb25JZDpmdW5jdGlvbih0LGUsbixyKXtyZXR1cm4gdGhpcy5fbGlua1dpdGgoZSxoKHQsbixyKSl9LGxpbmtXaXRoV2VhcHA6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBsKCkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gdC5fbGlua1dpdGgoXCJsY193ZWFwcFwiLHtjb2RlOmV9KX0pfSxkaXNzb2NpYXRlQXV0aERhdGE6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudW5zZXQoXCJhdXRoRGF0YS5cIit0KSx0aGlzLnNhdmUoKS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiB0Ll9oYW5kbGVTYXZlUmVzdWx0KCEwKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHR9KX0pfSxfdW5saW5rRnJvbTpmdW5jdGlvbih0KXtyZXR1cm4gY29uc29sZS53YXJuKFwiREVQUkVDQVRFRDogVXNlciNfdW5saW5rRnJvbSDlt7Llup/lvIPvvIzor7fkvb/nlKggVXNlciNkaXNzb2NpYXRlQXV0aERhdGEg5Luj5pu/XCIpLHRoaXMuZGlzc29jaWF0ZUF1dGhEYXRhKHQpfSxfaXNMaW5rZWQ6ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIGU9aS5pc1N0cmluZyh0KT90OnQuZ2V0QXV0aFR5cGUoKSwhISh0aGlzLmdldChcImF1dGhEYXRhXCIpfHx7fSlbZV19LGxvZ091dDpmdW5jdGlvbigpe3RoaXMuX2xvZ091dFdpdGhBbGwoKSx0aGlzLl9pc0N1cnJlbnRVc2VyPSExfSxfbG9nT3V0V2l0aEFsbDpmdW5jdGlvbigpe2lmKHRoaXMuZ2V0KFwiYXV0aERhdGFcIikpe3ZhciBlPXRoaXM7dC5fb2JqZWN0RWFjaCh0aGlzLmdldChcImF1dGhEYXRhXCIpLGZ1bmN0aW9uKHQsbil7ZS5fbG9nT3V0V2l0aChuKX0pfX0sX2xvZ091dFdpdGg6ZnVuY3Rpb24oZSl7dGhpcy5pc0N1cnJlbnQoKSYmKGkuaXNTdHJpbmcoZSkmJihlPXQuVXNlci5fYXV0aFByb3ZpZGVyc1tlXSksZSYmZS5kZWF1dGhlbnRpY2F0ZSYmZS5kZWF1dGhlbnRpY2F0ZSgpKX0sc2lnblVwOmZ1bmN0aW9uKHQsZSl7dmFyIG49dCYmdC51c2VybmFtZXx8dGhpcy5nZXQoXCJ1c2VybmFtZVwiKTtpZighbnx8XCJcIj09PW4pdGhyb3cgbmV3IHMocy5PVEhFUl9DQVVTRSxcIkNhbm5vdCBzaWduIHVwIHVzZXIgd2l0aCBhbiBlbXB0eSBuYW1lLlwiKTt2YXIgcj10JiZ0LnBhc3N3b3JkfHx0aGlzLmdldChcInBhc3N3b3JkXCIpO2lmKCFyfHxcIlwiPT09cil0aHJvdyBuZXcgcyhzLk9USEVSX0NBVVNFLFwiQ2Fubm90IHNpZ24gdXAgdXNlciB3aXRoIGFuIGVtcHR5IHBhc3N3b3JkLlwiKTtyZXR1cm4gdGhpcy5zYXZlKHQsZSkudGhlbihmdW5jdGlvbih0KXtyZXR1cm4gdC5faGFuZGxlU2F2ZVJlc3VsdCghMCkudGhlbihmdW5jdGlvbigpe3JldHVybiB0fSl9KX0sc2lnblVwT3Jsb2dJbldpdGhNb2JpbGVQaG9uZTpmdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e30sbj10JiZ0Lm1vYmlsZVBob25lTnVtYmVyfHx0aGlzLmdldChcIm1vYmlsZVBob25lTnVtYmVyXCIpO2lmKCFufHxcIlwiPT09bil0aHJvdyBuZXcgcyhzLk9USEVSX0NBVVNFLFwiQ2Fubm90IHNpZ24gdXAgb3IgbG9naW4gdXNlciBieSBtb2JpbGVQaG9uZU51bWJlciB3aXRoIGFuIGVtcHR5IG1vYmlsZVBob25lTnVtYmVyLlwiKTt2YXIgcj10JiZ0LnNtc0NvZGV8fHRoaXMuZ2V0KFwic21zQ29kZVwiKTtpZighcnx8XCJcIj09PXIpdGhyb3cgbmV3IHMocy5PVEhFUl9DQVVTRSxcIkNhbm5vdCBzaWduIHVwIG9yIGxvZ2luIHVzZXIgYnkgbW9iaWxlUGhvbmVOdW1iZXIgIHdpdGggYW4gZW1wdHkgc21zQ29kZS5cIik7cmV0dXJuIGUuX21ha2VSZXF1ZXN0PWZ1bmN0aW9uKHQsZSxuLHIsaSl7cmV0dXJuIGEoXCJ1c2Vyc0J5TW9iaWxlUGhvbmVcIixudWxsLG51bGwsXCJQT1NUXCIsaSl9LHRoaXMuc2F2ZSh0LGUpLnRoZW4oZnVuY3Rpb24odCl7cmV0dXJuIGRlbGV0ZSB0LmF0dHJpYnV0ZXMuc21zQ29kZSxkZWxldGUgdC5fc2VydmVyRGF0YS5zbXNDb2RlLHQuX2hhbmRsZVNhdmVSZXN1bHQoITApLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gdH0pfSl9LGxvZ2luV2l0aEF1dGhEYXRhOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5fbGlua1dpdGgoZSx0LG4pfSxsb2dpbldpdGhBdXRoRGF0YUFuZFVuaW9uSWQ6ZnVuY3Rpb24odCxlLG4scil7cmV0dXJuIHRoaXMubG9naW5XaXRoQXV0aERhdGEoaCh0LG4sciksZSxyKX0sbG9naW5XaXRoV2VhcHA6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gbCgpLnRoZW4oZnVuY3Rpb24obil7cmV0dXJuIGUubG9naW5XaXRoQXV0aERhdGEoe2NvZGU6bn0sXCJsY193ZWFwcFwiLHQpfSl9LGxvZ0luOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyZXR1cm4gYShcImxvZ2luXCIsbnVsbCxudWxsLFwiUE9TVFwiLHRoaXMudG9KU09OKCkpLnRoZW4oZnVuY3Rpb24oZSl7dmFyIG49dC5wYXJzZShlKTtyZXR1cm4gdC5fZmluaXNoRmV0Y2gobiksdC5faGFuZGxlU2F2ZVJlc3VsdCghMCkudGhlbihmdW5jdGlvbigpe3JldHVybiBuLnNtc0NvZGV8fGRlbGV0ZSB0LmF0dHJpYnV0ZXMuc21zQ29kZSx0fSl9KX0sc2F2ZTpmdW5jdGlvbihlLG4scil7dmFyIHMsbztyZXR1cm4gaS5pc09iamVjdChlKXx8aS5pc051bGwoZSl8fGkuaXNVbmRlZmluZWQoZSk/KHM9ZSxvPW4pOihzPXt9LHNbZV09bixvPXIpLG89b3x8e30sdC5PYmplY3QucHJvdG90eXBlLnNhdmUuY2FsbCh0aGlzLHMsbykudGhlbihmdW5jdGlvbih0KXtyZXR1cm4gdC5faGFuZGxlU2F2ZVJlc3VsdCghMSkudGhlbihmdW5jdGlvbigpe3JldHVybiB0fSl9KX0sZm9sbG93OmZ1bmN0aW9uKGUsbil7aWYoIXRoaXMuaWQpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHNpZ25pbi5cIik7dmFyIHI9dm9pZCAwLHM9dm9pZCAwO2UudXNlcj8ocj1lLnVzZXIscz1lLmF0dHJpYnV0ZXMpOnI9ZTt2YXIgbz1pLmlzU3RyaW5nKHIpP3I6ci5pZDtpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRhcmdldCB1c2VyLlwiKTt2YXIgdT1cInVzZXJzL1wiK3RoaXMuaWQrXCIvZnJpZW5kc2hpcC9cIitvO3JldHVybiBhKHUsbnVsbCxudWxsLFwiUE9TVFwiLHQuX2VuY29kZShzKSxuKX0sdW5mb2xsb3c6ZnVuY3Rpb24odCxlKXtpZighdGhpcy5pZCl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2Ugc2lnbmluLlwiKTt2YXIgbj12b2lkIDA7bj10LnVzZXI/dC51c2VyOnQ7dmFyIHI9aS5pc1N0cmluZyhuKT9uOm4uaWQ7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0YXJnZXQgdXNlci5cIik7dmFyIHM9XCJ1c2Vycy9cIit0aGlzLmlkK1wiL2ZyaWVuZHNoaXAvXCIrcjtyZXR1cm4gYShzLG51bGwsbnVsbCxcIkRFTEVURVwiLG51bGwsZSl9LGZvbGxvd2VyUXVlcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdC5Vc2VyLmZvbGxvd2VyUXVlcnkodGhpcy5pZCl9LGZvbGxvd2VlUXVlcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdC5Vc2VyLmZvbGxvd2VlUXVlcnkodGhpcy5pZCl9LGZldGNoOmZ1bmN0aW9uKGUsbil7cmV0dXJuIHQuT2JqZWN0LnByb3RvdHlwZS5mZXRjaC5jYWxsKHRoaXMsZSxuKS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiB0Ll9oYW5kbGVTYXZlUmVzdWx0KCExKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHR9KX0pfSx1cGRhdGVQYXNzd29yZDpmdW5jdGlvbih0LGUsbil7dmFyIHI9XCJ1c2Vycy9cIit0aGlzLmlkK1wiL3VwZGF0ZVBhc3N3b3JkXCI7cmV0dXJuIGEocixudWxsLG51bGwsXCJQVVRcIix7b2xkX3Bhc3N3b3JkOnQsbmV3X3Bhc3N3b3JkOmV9LG4pfSxpc0N1cnJlbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNDdXJyZW50VXNlcn0sZ2V0VXNlcm5hbWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXQoXCJ1c2VybmFtZVwiKX0sZ2V0TW9iaWxlUGhvbmVOdW1iZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXQoXCJtb2JpbGVQaG9uZU51bWJlclwiKX0sc2V0TW9iaWxlUGhvbmVOdW1iZXI6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zZXQoXCJtb2JpbGVQaG9uZU51bWJlclwiLHQsZSl9LHNldFVzZXJuYW1lOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuc2V0KFwidXNlcm5hbWVcIix0LGUpfSxzZXRQYXNzd29yZDpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnNldChcInBhc3N3b3JkXCIsdCxlKX0sZ2V0RW1haWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXQoXCJlbWFpbFwiKX0sc2V0RW1haWw6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zZXQoXCJlbWFpbFwiLHQsZSl9LGF1dGhlbnRpY2F0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiREVQUkVDQVRFRDog5aaC5p6c6KaB5Yik5pat5b2T5YmN55So5oi355qE55m75b2V54q25oCB5piv5ZCm5pyJ5pWI77yM6K+35L2/55SoIGN1cnJlbnRVc2VyLmlzQXV0aGVudGljYXRlZCgpLnRoZW4oKe+8jOWmguaenOimgeWIpOaWreivpeeUqOaIt+aYr+WQpuaYr+W9k+WJjeeZu+W9leeUqOaIt++8jOivt+S9v+eUqCB1c2VyLmlkID09PSBjdXJyZW50VXNlci5pZOOAglwiKSwhIXRoaXMuX3Nlc3Npb25Ub2tlbiYmIXQuX2NvbmZpZy5kaXNhYmxlQ3VycmVudFVzZXImJnQuVXNlci5jdXJyZW50KCkmJnQuVXNlci5jdXJyZW50KCkuaWQ9PT10aGlzLmlkfSxpc0F1dGhlbnRpY2F0ZWQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiBjLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuISFlLl9zZXNzaW9uVG9rZW4mJnQuVXNlci5fZmV0Y2hVc2VyQnlTZXNzaW9uVG9rZW4oZS5fc2Vzc2lvblRva2VuKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuITB9LGZ1bmN0aW9uKHQpe2lmKDIxMT09PXQuY29kZSlyZXR1cm4hMTt0aHJvdyB0fSl9KX0sZ2V0U2Vzc2lvblRva2VuOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Nlc3Npb25Ub2tlbn0scmVmcmVzaFNlc3Npb25Ub2tlbjpmdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiBhKFwidXNlcnMvXCIrdGhpcy5pZCtcIi9yZWZyZXNoU2Vzc2lvblRva2VuXCIsbnVsbCxudWxsLFwiUFVUXCIsbnVsbCx0KS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiBlLl9maW5pc2hGZXRjaCh0KSxlLl9oYW5kbGVTYXZlUmVzdWx0KCEwKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGV9KX0pfSxnZXRSb2xlczpmdW5jdGlvbihlKXtyZXR1cm4gdC5SZWxhdGlvbi5yZXZlcnNlUXVlcnkoXCJfUm9sZVwiLFwidXNlcnNcIix0aGlzKS5maW5kKGUpfX0se19jdXJyZW50VXNlcjpudWxsLF9jdXJyZW50VXNlck1hdGNoZXNEaXNrOiExLF9DVVJSRU5UX1VTRVJfS0VZOlwiY3VycmVudFVzZXJcIixfYXV0aFByb3ZpZGVyczp7fSxzaWduVXA6ZnVuY3Rpb24oZSxuLHIsaSl7cmV0dXJuIHI9cnx8e30sci51c2VybmFtZT1lLHIucGFzc3dvcmQ9bix0Lk9iamVjdC5fY3JlYXRlKFwiX1VzZXJcIikuc2lnblVwKHIsaSl9LGxvZ0luOmZ1bmN0aW9uKGUsbil7dmFyIHI9dC5PYmplY3QuX2NyZWF0ZShcIl9Vc2VyXCIpO3JldHVybiByLl9maW5pc2hGZXRjaCh7dXNlcm5hbWU6ZSxwYXNzd29yZDpufSksci5sb2dJbigpfSxiZWNvbWU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2ZldGNoVXNlckJ5U2Vzc2lvblRva2VuKHQpLnRoZW4oZnVuY3Rpb24odCl7cmV0dXJuIHQuX2hhbmRsZVNhdmVSZXN1bHQoITApLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gdH0pfSl9LF9mZXRjaFVzZXJCeVNlc3Npb25Ub2tlbjpmdW5jdGlvbihlKXt2YXIgbj10Lk9iamVjdC5fY3JlYXRlKFwiX1VzZXJcIik7cmV0dXJuIHUoe21ldGhvZDpcIkdFVFwiLHBhdGg6XCIvdXNlcnMvbWVcIixhdXRoT3B0aW9uczp7c2Vzc2lvblRva2VuOmV9fSkudGhlbihmdW5jdGlvbih0KXt2YXIgZT1uLnBhcnNlKHQpO3JldHVybiBuLl9maW5pc2hGZXRjaChlKSxufSl9LGxvZ0luV2l0aE1vYmlsZVBob25lU21zQ29kZTpmdW5jdGlvbihlLG4pe3ZhciByPXQuT2JqZWN0Ll9jcmVhdGUoXCJfVXNlclwiKTtyZXR1cm4gci5fZmluaXNoRmV0Y2goe21vYmlsZVBob25lTnVtYmVyOmUsc21zQ29kZTpufSksci5sb2dJbigpfSxzaWduVXBPcmxvZ0luV2l0aE1vYmlsZVBob25lOmZ1bmN0aW9uKGUsbixyLGkpe3JldHVybiByPXJ8fHt9LHIubW9iaWxlUGhvbmVOdW1iZXI9ZSxyLnNtc0NvZGU9bix0Lk9iamVjdC5fY3JlYXRlKFwiX1VzZXJcIikuc2lnblVwT3Jsb2dJbldpdGhNb2JpbGVQaG9uZShyLGkpfSxsb2dJbldpdGhNb2JpbGVQaG9uZTpmdW5jdGlvbihlLG4pe3ZhciByPXQuT2JqZWN0Ll9jcmVhdGUoXCJfVXNlclwiKTtyZXR1cm4gci5fZmluaXNoRmV0Y2goe21vYmlsZVBob25lTnVtYmVyOmUscGFzc3dvcmQ6bn0pLHIubG9nSW4oKX0sbG9naW5XaXRoQXV0aERhdGE6ZnVuY3Rpb24oZSxuLHIpe3JldHVybiB0LlVzZXIuX2xvZ0luV2l0aChuLGUscil9LHNpZ25VcE9ybG9nSW5XaXRoQXV0aERhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiREVQUkVDQVRFRDogVXNlci5zaWduVXBPcmxvZ0luV2l0aEF1dGhEYXRhIOW3suW6n+W8g++8jOivt+S9v+eUqCBVc2VyI2xvZ2luV2l0aEF1dGhEYXRhIOS7o+abv1wiKSx0aGlzLmxvZ2luV2l0aEF1dGhEYXRhLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sbG9naW5XaXRoQXV0aERhdGFBbmRVbmlvbklkOmZ1bmN0aW9uKHQsZSxuLHIpe3JldHVybiB0aGlzLmxvZ2luV2l0aEF1dGhEYXRhKGgodCxuLHIpLGUscil9LHNpZ25VcE9ybG9nSW5XaXRoQXV0aERhdGFBbmRVbmlvbklkOmZ1bmN0aW9uKCl7cmV0dXJuIGNvbnNvbGUud2FybihcIkRFUFJFQ0FURUQ6IFVzZXIuc2lnblVwT3Jsb2dJbldpdGhBdXRoRGF0YUFuZFVuaW9uSWQg5bey5bqf5byD77yM6K+35L2/55SoIFVzZXIjbG9naW5XaXRoQXV0aERhdGFBbmRVbmlvbklkIOS7o+abv1wiKSx0aGlzLmxvZ2luV2l0aEF1dGhEYXRhQW5kVW5pb25JZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGxvZ2luV2l0aFdlYXBwOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7cmV0dXJuIGwoKS50aGVuKGZ1bmN0aW9uKG4pe3JldHVybiBlLmxvZ2luV2l0aEF1dGhEYXRhKHtjb2RlOm59LFwibGNfd2VhcHBcIix0KX0pfSxhc3NvY2lhdGVXaXRoQXV0aERhdGE6ZnVuY3Rpb24odCxlLG4pe3JldHVybiBjb25zb2xlLndhcm4oXCJERVBSRUNBVEVEOiBVc2VyLmFzc29jaWF0ZVdpdGhBdXRoRGF0YSDlt7Llup/lvIPvvIzor7fkvb/nlKggVXNlciNhc3NvY2lhdGVXaXRoQXV0aERhdGEg5Luj5pu/XCIpLHQuX2xpbmtXaXRoKGUsbil9LGxvZ091dDpmdW5jdGlvbigpe3JldHVybiB0Ll9jb25maWcuZGlzYWJsZUN1cnJlbnRVc2VyPyhjb25zb2xlLndhcm4oXCJBVi5Vc2VyLmN1cnJlbnQoKSB3YXMgZGlzYWJsZWQgaW4gbXVsdGktdXNlciBlbnZpcm9ubWVudCwgY2FsbCBsb2dPdXQoKSBmcm9tIHVzZXIgb2JqZWN0IGluc3RlYWQgaHR0cHM6Ly9sZWFuY2xvdWQuY24vZG9jcy9sZWFuZW5naW5lLW5vZGUtc2RrLXVwZ3JhZGUtMS5odG1sXCIpLGMucmVzb2x2ZShudWxsKSk6KG51bGwhPT10LlVzZXIuX2N1cnJlbnRVc2VyJiYodC5Vc2VyLl9jdXJyZW50VXNlci5fbG9nT3V0V2l0aEFsbCgpLHQuVXNlci5fY3VycmVudFVzZXIuX2lzQ3VycmVudFVzZXI9ITEpLHQuVXNlci5fY3VycmVudFVzZXJNYXRjaGVzRGlzaz0hMCx0LlVzZXIuX2N1cnJlbnRVc2VyPW51bGwsdC5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbUFzeW5jKHQuX2dldEFWUGF0aCh0LlVzZXIuX0NVUlJFTlRfVVNFUl9LRVkpKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHQuX3JlZnJlc2hTdWJzY3JpcHRpb25JZCgpfSkpfSxmb2xsb3dlclF1ZXJ5OmZ1bmN0aW9uKGUpe2lmKCFlfHwhaS5pc1N0cmluZyhlKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHVzZXIgb2JqZWN0IGlkLlwiKTt2YXIgbj1uZXcgdC5GcmllbmRTaGlwUXVlcnkoXCJfRm9sbG93ZXJcIik7cmV0dXJuIG4uX2ZyaWVuZHNoaXBUYWc9XCJmb2xsb3dlclwiLG4uZXF1YWxUbyhcInVzZXJcIix0Lk9iamVjdC5jcmVhdGVXaXRob3V0RGF0YShcIl9Vc2VyXCIsZSkpLG59LGZvbGxvd2VlUXVlcnk6ZnVuY3Rpb24oZSl7aWYoIWV8fCFpLmlzU3RyaW5nKGUpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdXNlciBvYmplY3QgaWQuXCIpO3ZhciBuPW5ldyB0LkZyaWVuZFNoaXBRdWVyeShcIl9Gb2xsb3dlZVwiKTtyZXR1cm4gbi5fZnJpZW5kc2hpcFRhZz1cImZvbGxvd2VlXCIsbi5lcXVhbFRvKFwidXNlclwiLHQuT2JqZWN0LmNyZWF0ZVdpdGhvdXREYXRhKFwiX1VzZXJcIixlKSksbn0scmVxdWVzdFBhc3N3b3JkUmVzZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIGEoXCJyZXF1ZXN0UGFzc3dvcmRSZXNldFwiLG51bGwsbnVsbCxcIlBPU1RcIix7ZW1haWw6dH0pfSxyZXF1ZXN0RW1haWxWZXJpZnk6ZnVuY3Rpb24odCl7cmV0dXJuIGEoXCJyZXF1ZXN0RW1haWxWZXJpZnlcIixudWxsLG51bGwsXCJQT1NUXCIse2VtYWlsOnR9KX0scmVxdWVzdE1vYmlsZVBob25lVmVyaWZ5OmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fSxuPXttb2JpbGVQaG9uZU51bWJlcjp0fTtyZXR1cm4gZS52YWxpZGF0ZVRva2VuJiYobi52YWxpZGF0ZV90b2tlbj1lLnZhbGlkYXRlVG9rZW4pLGEoXCJyZXF1ZXN0TW9iaWxlUGhvbmVWZXJpZnlcIixudWxsLG51bGwsXCJQT1NUXCIsbixlKX0scmVxdWVzdFBhc3N3b3JkUmVzZXRCeVNtc0NvZGU6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9LG49e21vYmlsZVBob25lTnVtYmVyOnR9O3JldHVybiBlLnZhbGlkYXRlVG9rZW4mJihuLnZhbGlkYXRlX3Rva2VuPWUudmFsaWRhdGVUb2tlbiksYShcInJlcXVlc3RQYXNzd29yZFJlc2V0QnlTbXNDb2RlXCIsbnVsbCxudWxsLFwiUE9TVFwiLG4sZSl9LHJlc2V0UGFzc3dvcmRCeVNtc0NvZGU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gYShcInJlc2V0UGFzc3dvcmRCeVNtc0NvZGVcIixudWxsLHQsXCJQVVRcIix7cGFzc3dvcmQ6ZX0pfSx2ZXJpZnlNb2JpbGVQaG9uZTpmdW5jdGlvbih0KXtyZXR1cm4gYShcInZlcmlmeU1vYmlsZVBob25lXCIsbnVsbCx0LFwiUE9TVFwiLG51bGwpfSxyZXF1ZXN0TG9naW5TbXNDb2RlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fSxuPXttb2JpbGVQaG9uZU51bWJlcjp0fTtyZXR1cm4gZS52YWxpZGF0ZVRva2VuJiYobi52YWxpZGF0ZV90b2tlbj1lLnZhbGlkYXRlVG9rZW4pLGEoXCJyZXF1ZXN0TG9naW5TbXNDb2RlXCIsbnVsbCxudWxsLFwiUE9TVFwiLG4sZSl9LGN1cnJlbnRBc3luYzpmdW5jdGlvbigpe3JldHVybiB0Ll9jb25maWcuZGlzYWJsZUN1cnJlbnRVc2VyPyhjb25zb2xlLndhcm4oXCJBVi5Vc2VyLmN1cnJlbnRBc3luYygpIHdhcyBkaXNhYmxlZCBpbiBtdWx0aS11c2VyIGVudmlyb25tZW50LCBhY2Nlc3MgdXNlciBmcm9tIHJlcXVlc3QgaW5zdGVhZCBodHRwczovL2xlYW5jbG91ZC5jbi9kb2NzL2xlYW5lbmdpbmUtbm9kZS1zZGstdXBncmFkZS0xLmh0bWxcIiksYy5yZXNvbHZlKG51bGwpKTp0LlVzZXIuX2N1cnJlbnRVc2VyP2MucmVzb2x2ZSh0LlVzZXIuX2N1cnJlbnRVc2VyKTp0LlVzZXIuX2N1cnJlbnRVc2VyTWF0Y2hlc0Rpc2s/Yy5yZXNvbHZlKHQuVXNlci5fY3VycmVudFVzZXIpOnQubG9jYWxTdG9yYWdlLmdldEl0ZW1Bc3luYyh0Ll9nZXRBVlBhdGgodC5Vc2VyLl9DVVJSRU5UX1VTRVJfS0VZKSkudGhlbihmdW5jdGlvbihlKXtpZighZSlyZXR1cm4gbnVsbDt0LlVzZXIuX2N1cnJlbnRVc2VyTWF0Y2hlc0Rpc2s9ITAsdC5Vc2VyLl9jdXJyZW50VXNlcj10Lk9iamVjdC5fY3JlYXRlKFwiX1VzZXJcIiksdC5Vc2VyLl9jdXJyZW50VXNlci5faXNDdXJyZW50VXNlcj0hMDt2YXIgbj1KU09OLnBhcnNlKGUpO3JldHVybiB0LlVzZXIuX2N1cnJlbnRVc2VyLmlkPW4uX2lkLGRlbGV0ZSBuLl9pZCx0LlVzZXIuX2N1cnJlbnRVc2VyLl9zZXNzaW9uVG9rZW49bi5fc2Vzc2lvblRva2VuLGRlbGV0ZSBuLl9zZXNzaW9uVG9rZW4sdC5Vc2VyLl9jdXJyZW50VXNlci5fZmluaXNoRmV0Y2gobiksdC5Vc2VyLl9jdXJyZW50VXNlci5fc3luY2hyb25pemVBbGxBdXRoRGF0YSgpLHQuVXNlci5fY3VycmVudFVzZXIuX3JlZnJlc2hDYWNoZSgpLHQuVXNlci5fY3VycmVudFVzZXIuX29wU2V0UXVldWU9W3t9XSx0LlVzZXIuX2N1cnJlbnRVc2VyfSl9LGN1cnJlbnQ6ZnVuY3Rpb24oKXtpZih0Ll9jb25maWcuZGlzYWJsZUN1cnJlbnRVc2VyKXJldHVybiBjb25zb2xlLndhcm4oXCJBVi5Vc2VyLmN1cnJlbnQoKSB3YXMgZGlzYWJsZWQgaW4gbXVsdGktdXNlciBlbnZpcm9ubWVudCwgYWNjZXNzIHVzZXIgZnJvbSByZXF1ZXN0IGluc3RlYWQgaHR0cHM6Ly9sZWFuY2xvdWQuY24vZG9jcy9sZWFuZW5naW5lLW5vZGUtc2RrLXVwZ3JhZGUtMS5odG1sXCIpLG51bGw7aWYodC5Vc2VyLl9jdXJyZW50VXNlcilyZXR1cm4gdC5Vc2VyLl9jdXJyZW50VXNlcjtpZih0LlVzZXIuX2N1cnJlbnRVc2VyTWF0Y2hlc0Rpc2spcmV0dXJuIHQuVXNlci5fY3VycmVudFVzZXI7dC5Vc2VyLl9jdXJyZW50VXNlck1hdGNoZXNEaXNrPSEwO3ZhciBlPXQubG9jYWxTdG9yYWdlLmdldEl0ZW0odC5fZ2V0QVZQYXRoKHQuVXNlci5fQ1VSUkVOVF9VU0VSX0tFWSkpO2lmKCFlKXJldHVybiBudWxsO3QuVXNlci5fY3VycmVudFVzZXI9dC5PYmplY3QuX2NyZWF0ZShcIl9Vc2VyXCIpLHQuVXNlci5fY3VycmVudFVzZXIuX2lzQ3VycmVudFVzZXI9ITA7dmFyIG49SlNPTi5wYXJzZShlKTtyZXR1cm4gdC5Vc2VyLl9jdXJyZW50VXNlci5pZD1uLl9pZCxkZWxldGUgbi5faWQsdC5Vc2VyLl9jdXJyZW50VXNlci5fc2Vzc2lvblRva2VuPW4uX3Nlc3Npb25Ub2tlbixkZWxldGUgbi5fc2Vzc2lvblRva2VuLHQuVXNlci5fY3VycmVudFVzZXIuX2ZpbmlzaEZldGNoKG4pLHQuVXNlci5fY3VycmVudFVzZXIuX3N5bmNocm9uaXplQWxsQXV0aERhdGEoKSx0LlVzZXIuX2N1cnJlbnRVc2VyLl9yZWZyZXNoQ2FjaGUoKSx0LlVzZXIuX2N1cnJlbnRVc2VyLl9vcFNldFF1ZXVlPVt7fV0sdC5Vc2VyLl9jdXJyZW50VXNlcn0sX3NhdmVDdXJyZW50VXNlcjpmdW5jdGlvbihlKXt2YXIgbjtyZXR1cm4gbj10LlVzZXIuX2N1cnJlbnRVc2VyIT09ZT90LlVzZXIubG9nT3V0KCk6Yy5yZXNvbHZlKCksbi50aGVuKGZ1bmN0aW9uKCl7ZS5faXNDdXJyZW50VXNlcj0hMCx0LlVzZXIuX2N1cnJlbnRVc2VyPWU7dmFyIG49ZS5fdG9GdWxsSlNPTigpO3JldHVybiBuLl9pZD1lLmlkLG4uX3Nlc3Npb25Ub2tlbj1lLl9zZXNzaW9uVG9rZW4sdC5sb2NhbFN0b3JhZ2Uuc2V0SXRlbUFzeW5jKHQuX2dldEFWUGF0aCh0LlVzZXIuX0NVUlJFTlRfVVNFUl9LRVkpLEpTT04uc3RyaW5naWZ5KG4pKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHQuVXNlci5fY3VycmVudFVzZXJNYXRjaGVzRGlzaz0hMCx0Ll9yZWZyZXNoU3Vic2NyaXB0aW9uSWQoKX0pfSl9LF9yZWdpc3RlckF1dGhlbnRpY2F0aW9uUHJvdmlkZXI6ZnVuY3Rpb24oZSl7dC5Vc2VyLl9hdXRoUHJvdmlkZXJzW2UuZ2V0QXV0aFR5cGUoKV09ZSwhdC5fY29uZmlnLmRpc2FibGVDdXJyZW50VXNlciYmdC5Vc2VyLmN1cnJlbnQoKSYmdC5Vc2VyLmN1cnJlbnQoKS5fc3luY2hyb25pemVBdXRoRGF0YShlLmdldEF1dGhUeXBlKCkpfSxfbG9nSW5XaXRoOmZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gdC5PYmplY3QuX2NyZWF0ZShcIl9Vc2VyXCIpLl9saW5rV2l0aChlLG4scil9fSl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKSxpPW4oNikoXCJsZWFuY2xvdWQ6cXVlcnlcIikscz1uKDEpLG89big0KSxhPW4oMiksdT1hLl9yZXF1ZXN0LGM9YS5yZXF1ZXN0LGw9bigzKSxoPWwuZW5zdXJlQXJyYXksZj1sLnRyYW5zZm9ybUZldGNoT3B0aW9ucyxkPWZ1bmN0aW9uKHQsZSl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgRXJyb3IoZSl9O3QuZXhwb3J0cz1mdW5jdGlvbih0KXt0LlF1ZXJ5PWZ1bmN0aW9uKGUpe3IuaXNTdHJpbmcoZSkmJihlPXQuT2JqZWN0Ll9nZXRTdWJjbGFzcyhlKSksdGhpcy5vYmplY3RDbGFzcz1lLHRoaXMuY2xhc3NOYW1lPWUucHJvdG90eXBlLmNsYXNzTmFtZSx0aGlzLl93aGVyZT17fSx0aGlzLl9pbmNsdWRlPVtdLHRoaXMuX3NlbGVjdD1bXSx0aGlzLl9saW1pdD0tMSx0aGlzLl9za2lwPTAsdGhpcy5fZXh0cmFPcHRpb25zPXt9fSx0LlF1ZXJ5Lm9yPWZ1bmN0aW9uKCl7dmFyIGU9ci50b0FycmF5KGFyZ3VtZW50cyksbj1udWxsO3QuX2FycmF5RWFjaChlLGZ1bmN0aW9uKHQpe2lmKHIuaXNOdWxsKG4pJiYobj10LmNsYXNzTmFtZSksbiE9PXQuY2xhc3NOYW1lKXRocm93IG5ldyBFcnJvcihcIkFsbCBxdWVyaWVzIG11c3QgYmUgZm9yIHRoZSBzYW1lIGNsYXNzXCIpfSk7dmFyIGk9bmV3IHQuUXVlcnkobik7cmV0dXJuIGkuX29yUXVlcnkoZSksaX0sdC5RdWVyeS5hbmQ9ZnVuY3Rpb24oKXt2YXIgZT1yLnRvQXJyYXkoYXJndW1lbnRzKSxuPW51bGw7dC5fYXJyYXlFYWNoKGUsZnVuY3Rpb24odCl7aWYoci5pc051bGwobikmJihuPXQuY2xhc3NOYW1lKSxuIT09dC5jbGFzc05hbWUpdGhyb3cgbmV3IEVycm9yKFwiQWxsIHF1ZXJpZXMgbXVzdCBiZSBmb3IgdGhlIHNhbWUgY2xhc3NcIil9KTt2YXIgaT1uZXcgdC5RdWVyeShuKTtyZXR1cm4gaS5fYW5kUXVlcnkoZSksaX0sdC5RdWVyeS5kb0Nsb3VkUXVlcnk9ZnVuY3Rpb24oZSxuLGkpe3ZhciBzPXtjcWw6ZX07cmV0dXJuIHIuaXNBcnJheShuKT9zLnB2YWx1ZXM9bjppPW4sdShcImNsb3VkUXVlcnlcIixudWxsLG51bGwsXCJHRVRcIixzLGkpLnRoZW4oZnVuY3Rpb24oZSl7dmFyIG49bmV3IHQuUXVlcnkoZS5jbGFzc05hbWUpO3JldHVybntyZXN1bHRzOnIubWFwKGUucmVzdWx0cyxmdW5jdGlvbih0KXt2YXIgcj1uLl9uZXdPYmplY3QoZSk7cmV0dXJuIHIuX2ZpbmlzaEZldGNoJiZyLl9maW5pc2hGZXRjaChuLl9wcm9jZXNzUmVzdWx0KHQpLCEwKSxyfSksY291bnQ6ZS5jb3VudCxjbGFzc05hbWU6ZS5jbGFzc05hbWV9fSl9LHQuUXVlcnkuX2V4dGVuZD10Ll9leHRlbmQsci5leHRlbmQodC5RdWVyeS5wcm90b3R5cGUse19wcm9jZXNzUmVzdWx0OmZ1bmN0aW9uKHQpe3JldHVybiB0fSxnZXQ6ZnVuY3Rpb24odCxlKXtpZighdCl7dGhyb3cgbmV3IG8oby5PQkpFQ1RfTk9UX0ZPVU5ELFwiT2JqZWN0IG5vdCBmb3VuZC5cIil9dmFyIG49dGhpcy5fbmV3T2JqZWN0KCk7bi5pZD10O3ZhciBpPXRoaXMudG9KU09OKCkscz17fTtyZXR1cm4gaS5rZXlzJiYocy5rZXlzPWkua2V5cyksaS5pbmNsdWRlJiYocy5pbmNsdWRlPWkuaW5jbHVkZSksaS5pbmNsdWRlQUNMJiYocy5pbmNsdWRlQUNMPWkuaW5jbHVkZUFDTCksdShcImNsYXNzZXNcIix0aGlzLmNsYXNzTmFtZSx0LFwiR0VUXCIsZihzKSxlKS50aGVuKGZ1bmN0aW9uKHQpe2lmKHIuaXNFbXB0eSh0KSl0aHJvdyBuZXcgbyhvLk9CSkVDVF9OT1RfRk9VTkQsXCJPYmplY3Qgbm90IGZvdW5kLlwiKTtyZXR1cm4gbi5fZmluaXNoRmV0Y2gobi5wYXJzZSh0KSwhMCksbn0pfSx0b0pTT046ZnVuY3Rpb24oKXt2YXIgZT17d2hlcmU6dGhpcy5fd2hlcmV9O3JldHVybiB0aGlzLl9pbmNsdWRlLmxlbmd0aD4wJiYoZS5pbmNsdWRlPXRoaXMuX2luY2x1ZGUuam9pbihcIixcIikpLHRoaXMuX3NlbGVjdC5sZW5ndGg+MCYmKGUua2V5cz10aGlzLl9zZWxlY3Quam9pbihcIixcIikpLHZvaWQgMCE9PXRoaXMuX2luY2x1ZGVBQ0wmJihlLnJldHVybkFDTD10aGlzLl9pbmNsdWRlQUNMKSx0aGlzLl9saW1pdD49MCYmKGUubGltaXQ9dGhpcy5fbGltaXQpLHRoaXMuX3NraXA+MCYmKGUuc2tpcD10aGlzLl9za2lwKSx2b2lkIDAhPT10aGlzLl9vcmRlciYmKGUub3JkZXI9dGhpcy5fb3JkZXIpLHQuX29iamVjdEVhY2godGhpcy5fZXh0cmFPcHRpb25zLGZ1bmN0aW9uKHQsbil7ZVtuXT10fSksZX0sX25ld09iamVjdDpmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5jbGFzc05hbWU/bmV3IHQuT2JqZWN0KGUuY2xhc3NOYW1lKTpuZXcgdGhpcy5vYmplY3RDbGFzc30sX2NyZWF0ZVJlcXVlc3Q6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06dGhpcy50b0pTT04oKSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpcIi9jbGFzc2VzL1wiK3RoaXMuY2xhc3NOYW1lO2lmKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeSh0KSkubGVuZ3RoPjJlMyl7cmV0dXJuIGMoe3BhdGg6XCIvYmF0Y2hcIixtZXRob2Q6XCJQT1NUXCIsZGF0YTp7cmVxdWVzdHM6W3ttZXRob2Q6XCJHRVRcIixwYXRoOlwiLzEuMVwiK24scGFyYW1zOnR9XX0sYXV0aE9wdGlvbnM6ZX0pLnRoZW4oZnVuY3Rpb24odCl7dmFyIGU9dFswXTtpZihlLnN1Y2Nlc3MpcmV0dXJuIGUuc3VjY2Vzczt2YXIgbj1uZXcgRXJyb3IoZS5lcnJvci5lcnJvcnx8XCJVbmtub3duIGJhdGNoIGVycm9yXCIpO3Rocm93IG4uY29kZT1lLmVycm9yLmNvZGUsbn0pfXJldHVybiBjKHttZXRob2Q6XCJHRVRcIixwYXRoOm4scXVlcnk6dCxhdXRoT3B0aW9uczplfSl9LF9wYXJzZVJlc3BvbnNlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7cmV0dXJuIHIubWFwKHQucmVzdWx0cyxmdW5jdGlvbihuKXt2YXIgcj1lLl9uZXdPYmplY3QodCk7cmV0dXJuIHIuX2ZpbmlzaEZldGNoJiZyLl9maW5pc2hGZXRjaChlLl9wcm9jZXNzUmVzdWx0KG4pLCEwKSxyfSl9LGZpbmQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2NyZWF0ZVJlcXVlc3Qodm9pZCAwLHQpLnRoZW4odGhpcy5fcGFyc2VSZXNwb25zZS5iaW5kKHRoaXMpKX0sc2NhbjpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06e30sbj1lLm9yZGVyZWRCeSxvPWUuYmF0Y2hTaXplLGE9YXJndW1lbnRzWzFdLGM9dGhpcy50b0pTT04oKTtpKFwic2NhbiAlT1wiLGMpLGMub3JkZXImJihjb25zb2xlLndhcm4oXCJUaGUgb3JkZXIgb2YgdGhlIHF1ZXJ5IGlzIGlnbm9yZWQgZm9yIFF1ZXJ5I3NjYW4uIENoZWNrb3V0IHRoZSBvcmRlcmVkQnkgb3B0aW9uIG9mIFF1ZXJ5I3NjYW4uXCIpLGRlbGV0ZSBjLm9yZGVyKSxjLnNraXAmJihjb25zb2xlLndhcm4oXCJUaGUgc2tpcCBvcHRpb24gb2YgdGhlIHF1ZXJ5IGlzIGlnbm9yZWQgZm9yIFF1ZXJ5I3NjYW4uXCIpLGRlbGV0ZSBjLnNraXApLGMubGltaXQmJihjb25zb2xlLndhcm4oXCJUaGUgbGltaXQgb3B0aW9uIG9mIHRoZSBxdWVyeSBpcyBpZ25vcmVkIGZvciBRdWVyeSNzY2FuLlwiKSxkZWxldGUgYy5saW1pdCksbiYmKGMuc2Nhbl9rZXk9biksbyYmKGMubGltaXQ9byk7dmFyIGw9cy5yZXNvbHZlKFtdKSxoPXZvaWQgMCxmPSExO3JldHVybntuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIGw9bC50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBmP1tdOmUubGVuZ3RoPjE/ZTpofHwwPT09ZS5sZW5ndGg/dShcInNjYW4vY2xhc3Nlc1wiLHQuY2xhc3NOYW1lLG51bGwsXCJHRVRcIixoP3IuZXh0ZW5kKHt9LGMse2N1cnNvcjpofSk6YyxhKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBoPWUuY3Vyc29yLHQuX3BhcnNlUmVzcG9uc2UoZSl9KS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiB0Lmxlbmd0aHx8KGY9ITApLGUuY29uY2F0KHQpfSk6KGY9ITAsZSl9KSxsLnRoZW4oZnVuY3Rpb24odCl7cmV0dXJuIHQuc2hpZnQoKX0pLnRoZW4oZnVuY3Rpb24odCl7cmV0dXJue3ZhbHVlOnQsZG9uZTpmfX0pfX19LGRlc3Ryb3lBbGw6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZmluZChlKS50aGVuKGZ1bmN0aW9uKG4pe3JldHVybiB0Lk9iamVjdC5kZXN0cm95QWxsKG4sZSl9KX0sY291bnQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy50b0pTT04oKTtyZXR1cm4gZS5saW1pdD0wLGUuY291bnQ9MSx0aGlzLl9jcmVhdGVSZXF1ZXN0KGUsdCkudGhlbihmdW5jdGlvbih0KXtyZXR1cm4gdC5jb3VudH0pfSxmaXJzdDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLG49dGhpcy50b0pTT04oKTtyZXR1cm4gbi5saW1pdD0xLHRoaXMuX2NyZWF0ZVJlcXVlc3Qobix0KS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiByLm1hcCh0LnJlc3VsdHMsZnVuY3Rpb24odCl7dmFyIG49ZS5fbmV3T2JqZWN0KCk7cmV0dXJuIG4uX2ZpbmlzaEZldGNoJiZuLl9maW5pc2hGZXRjaChlLl9wcm9jZXNzUmVzdWx0KHQpLCEwKSxufSlbMF19KX0sc2tpcDpmdW5jdGlvbih0KXtyZXR1cm4gZCh0LFwidW5kZWZpbmVkIGlzIG5vdCBhIHZhbGlkIHNraXAgdmFsdWVcIiksdGhpcy5fc2tpcD10LHRoaXN9LGxpbWl0OmZ1bmN0aW9uKHQpe3JldHVybiBkKHQsXCJ1bmRlZmluZWQgaXMgbm90IGEgdmFsaWQgbGltaXQgdmFsdWVcIiksdGhpcy5fbGltaXQ9dCx0aGlzfSxlcXVhbFRvOmZ1bmN0aW9uKGUsbil7cmV0dXJuIGQoZSxcInVuZGVmaW5lZCBpcyBub3QgYSB2YWxpZCBrZXlcIiksZChuLFwidW5kZWZpbmVkIGlzIG5vdCBhIHZhbGlkIHZhbHVlXCIpLHRoaXMuX3doZXJlW2VdPXQuX2VuY29kZShuKSx0aGlzfSxfYWRkQ29uZGl0aW9uOmZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gZChlLFwidW5kZWZpbmVkIGlzIG5vdCBhIHZhbGlkIGNvbmRpdGlvbiBrZXlcIiksZChuLFwidW5kZWZpbmVkIGlzIG5vdCBhIHZhbGlkIGNvbmRpdGlvblwiKSxkKHIsXCJ1bmRlZmluZWQgaXMgbm90IGEgdmFsaWQgY29uZGl0aW9uIHZhbHVlXCIpLHRoaXMuX3doZXJlW2VdfHwodGhpcy5fd2hlcmVbZV09e30pLHRoaXMuX3doZXJlW2VdW25dPXQuX2VuY29kZShyKSx0aGlzfSxzaXplRXF1YWxUbzpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9hZGRDb25kaXRpb24odCxcIiRzaXplXCIsZSksdGhpc30sbm90RXF1YWxUbzpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9hZGRDb25kaXRpb24odCxcIiRuZVwiLGUpLHRoaXN9LGxlc3NUaGFuOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2FkZENvbmRpdGlvbih0LFwiJGx0XCIsZSksdGhpc30sZ3JlYXRlclRoYW46ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fYWRkQ29uZGl0aW9uKHQsXCIkZ3RcIixlKSx0aGlzfSxsZXNzVGhhbk9yRXF1YWxUbzpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9hZGRDb25kaXRpb24odCxcIiRsdGVcIixlKSx0aGlzfSxncmVhdGVyVGhhbk9yRXF1YWxUbzpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9hZGRDb25kaXRpb24odCxcIiRndGVcIixlKSx0aGlzfSxjb250YWluZWRJbjpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9hZGRDb25kaXRpb24odCxcIiRpblwiLGUpLHRoaXN9LG5vdENvbnRhaW5lZEluOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2FkZENvbmRpdGlvbih0LFwiJG5pblwiLGUpLHRoaXN9LGNvbnRhaW5zQWxsOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX2FkZENvbmRpdGlvbih0LFwiJGFsbFwiLGUpLHRoaXN9LGV4aXN0czpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fYWRkQ29uZGl0aW9uKHQsXCIkZXhpc3RzXCIsITApLHRoaXN9LGRvZXNOb3RFeGlzdDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fYWRkQ29uZGl0aW9uKHQsXCIkZXhpc3RzXCIsITEpLHRoaXN9LG1hdGNoZXM6ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLl9hZGRDb25kaXRpb24odCxcIiRyZWdleFwiLGUpLG58fChuPVwiXCIpLGUuaWdub3JlQ2FzZSYmKG4rPVwiaVwiKSxlLm11bHRpbGluZSYmKG4rPVwibVwiKSxuJiZuLmxlbmd0aCYmdGhpcy5fYWRkQ29uZGl0aW9uKHQsXCIkb3B0aW9uc1wiLG4pLHRoaXN9LG1hdGNoZXNRdWVyeTpmdW5jdGlvbih0LGUpe3ZhciBuPWUudG9KU09OKCk7cmV0dXJuIG4uY2xhc3NOYW1lPWUuY2xhc3NOYW1lLHRoaXMuX2FkZENvbmRpdGlvbih0LFwiJGluUXVlcnlcIixuKSx0aGlzfSxkb2VzTm90TWF0Y2hRdWVyeTpmdW5jdGlvbih0LGUpe3ZhciBuPWUudG9KU09OKCk7cmV0dXJuIG4uY2xhc3NOYW1lPWUuY2xhc3NOYW1lLHRoaXMuX2FkZENvbmRpdGlvbih0LFwiJG5vdEluUXVlcnlcIixuKSx0aGlzfSxtYXRjaGVzS2V5SW5RdWVyeTpmdW5jdGlvbih0LGUsbil7dmFyIHI9bi50b0pTT04oKTtyZXR1cm4gci5jbGFzc05hbWU9bi5jbGFzc05hbWUsdGhpcy5fYWRkQ29uZGl0aW9uKHQsXCIkc2VsZWN0XCIse2tleTplLHF1ZXJ5OnJ9KSx0aGlzfSxkb2VzTm90TWF0Y2hLZXlJblF1ZXJ5OmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1uLnRvSlNPTigpO3JldHVybiByLmNsYXNzTmFtZT1uLmNsYXNzTmFtZSx0aGlzLl9hZGRDb25kaXRpb24odCxcIiRkb250U2VsZWN0XCIse2tleTplLHF1ZXJ5OnJ9KSx0aGlzfSxfb3JRdWVyeTpmdW5jdGlvbih0KXt2YXIgZT1yLm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiB0LnRvSlNPTigpLndoZXJlfSk7cmV0dXJuIHRoaXMuX3doZXJlLiRvcj1lLHRoaXN9LF9hbmRRdWVyeTpmdW5jdGlvbih0KXt2YXIgZT1yLm1hcCh0LGZ1bmN0aW9uKHQpe3JldHVybiB0LnRvSlNPTigpLndoZXJlfSk7cmV0dXJuIHRoaXMuX3doZXJlLiRhbmQ9ZSx0aGlzfSxfcXVvdGU6ZnVuY3Rpb24odCl7cmV0dXJuXCJcXFxcUVwiK3QucmVwbGFjZShcIlxcXFxFXCIsXCJcXFxcRVxcXFxcXFxcRVxcXFxRXCIpK1wiXFxcXEVcIn0sY29udGFpbnM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fYWRkQ29uZGl0aW9uKHQsXCIkcmVnZXhcIix0aGlzLl9xdW90ZShlKSksdGhpc30sc3RhcnRzV2l0aDpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9hZGRDb25kaXRpb24odCxcIiRyZWdleFwiLFwiXlwiK3RoaXMuX3F1b3RlKGUpKSx0aGlzfSxlbmRzV2l0aDpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9hZGRDb25kaXRpb24odCxcIiRyZWdleFwiLHRoaXMuX3F1b3RlKGUpK1wiJFwiKSx0aGlzfSxhc2NlbmRpbmc6ZnVuY3Rpb24odCl7cmV0dXJuIGQodCxcInVuZGVmaW5lZCBpcyBub3QgYSB2YWxpZCBrZXlcIiksdGhpcy5fb3JkZXI9dCx0aGlzfSxhZGRBc2NlbmRpbmc6ZnVuY3Rpb24odCl7cmV0dXJuIGQodCxcInVuZGVmaW5lZCBpcyBub3QgYSB2YWxpZCBrZXlcIiksdGhpcy5fb3JkZXI/dGhpcy5fb3JkZXIrPVwiLFwiK3Q6dGhpcy5fb3JkZXI9dCx0aGlzfSxkZXNjZW5kaW5nOmZ1bmN0aW9uKHQpe3JldHVybiBkKHQsXCJ1bmRlZmluZWQgaXMgbm90IGEgdmFsaWQga2V5XCIpLHRoaXMuX29yZGVyPVwiLVwiK3QsdGhpc30sYWRkRGVzY2VuZGluZzpmdW5jdGlvbih0KXtyZXR1cm4gZCh0LFwidW5kZWZpbmVkIGlzIG5vdCBhIHZhbGlkIGtleVwiKSx0aGlzLl9vcmRlcj90aGlzLl9vcmRlcis9XCIsLVwiK3Q6dGhpcy5fb3JkZXI9XCItXCIrdCx0aGlzfSxuZWFyOmZ1bmN0aW9uKGUsbil7cmV0dXJuIG4gaW5zdGFuY2VvZiB0Lkdlb1BvaW50fHwobj1uZXcgdC5HZW9Qb2ludChuKSksdGhpcy5fYWRkQ29uZGl0aW9uKGUsXCIkbmVhclNwaGVyZVwiLG4pLHRoaXN9LHdpdGhpblJhZGlhbnM6ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLm5lYXIodCxlKSx0aGlzLl9hZGRDb25kaXRpb24odCxcIiRtYXhEaXN0YW5jZVwiLG4pLHRoaXN9LHdpdGhpbk1pbGVzOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy53aXRoaW5SYWRpYW5zKHQsZSxuLzM5NTguOCl9LHdpdGhpbktpbG9tZXRlcnM6ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLndpdGhpblJhZGlhbnModCxlLG4vNjM3MSl9LHdpdGhpbkdlb0JveDpmdW5jdGlvbihlLG4scil7cmV0dXJuIG4gaW5zdGFuY2VvZiB0Lkdlb1BvaW50fHwobj1uZXcgdC5HZW9Qb2ludChuKSksciBpbnN0YW5jZW9mIHQuR2VvUG9pbnR8fChyPW5ldyB0Lkdlb1BvaW50KHIpKSx0aGlzLl9hZGRDb25kaXRpb24oZSxcIiR3aXRoaW5cIix7JGJveDpbbixyXX0pLHRoaXN9LGluY2x1ZGU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gZCh0LFwidW5kZWZpbmVkIGlzIG5vdCBhIHZhbGlkIGtleVwiKSxyKGFyZ3VtZW50cykuZm9yRWFjaChmdW5jdGlvbih0KXtlLl9pbmNsdWRlPWUuX2luY2x1ZGUuY29uY2F0KGgodCkpfSksdGhpc30saW5jbHVkZUFDTDpmdW5jdGlvbigpe3ZhciB0PSEoYXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0pfHxhcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuX2luY2x1ZGVBQ0w9dCx0aGlzfSxzZWxlY3Q6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztyZXR1cm4gZCh0LFwidW5kZWZpbmVkIGlzIG5vdCBhIHZhbGlkIGtleVwiKSxyKGFyZ3VtZW50cykuZm9yRWFjaChmdW5jdGlvbih0KXtlLl9zZWxlY3Q9ZS5fc2VsZWN0LmNvbmNhdChoKHQpKX0pLHRoaXN9LGVhY2g6ZnVuY3Rpb24oZSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9O2lmKHRoaXMuX29yZGVyfHx0aGlzLl9za2lwfHx0aGlzLl9saW1pdD49MCl7dmFyIGk9bmV3IEVycm9yKFwiQ2Fubm90IGl0ZXJhdGUgb24gYSBxdWVyeSB3aXRoIHNvcnQsIHNraXAsIG9yIGxpbWl0LlwiKTtyZXR1cm4gdC5Qcm9taXNlLnJlamVjdChpKX12YXIgcz1uZXcgdC5RdWVyeSh0aGlzLm9iamVjdENsYXNzKTtzLl9saW1pdD1uLmJhdGNoU2l6ZXx8MTAwLHMuX3doZXJlPXIuY2xvbmUodGhpcy5fd2hlcmUpLHMuX2luY2x1ZGU9ci5jbG9uZSh0aGlzLl9pbmNsdWRlKSxzLmFzY2VuZGluZyhcIm9iamVjdElkXCIpO3ZhciBvPSExO3JldHVybiB0LlByb21pc2UuX2NvbnRpbnVlV2hpbGUoZnVuY3Rpb24oKXtyZXR1cm4hb30sZnVuY3Rpb24oKXtyZXR1cm4gcy5maW5kKG4pLnRoZW4oZnVuY3Rpb24obil7dmFyIGk9dC5Qcm9taXNlLnJlc29sdmUoKTtyZXR1cm4gci5lYWNoKG4sZnVuY3Rpb24odCl7aT1pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZSh0KX0pfSksaS50aGVuKGZ1bmN0aW9uKCl7bi5sZW5ndGg+PXMuX2xpbWl0P3MuZ3JlYXRlclRoYW4oXCJvYmplY3RJZFwiLG5bbi5sZW5ndGgtMV0uaWQpOm89ITB9KX0pfSl9LHN1YnNjcmliZTpmdW5jdGlvbihlKXtyZXR1cm4gdC5MaXZlUXVlcnkuaW5pdCh0aGlzLGUpfX0pLHQuRnJpZW5kU2hpcFF1ZXJ5PXQuUXVlcnkuX2V4dGVuZCh7X29iamVjdENsYXNzOnQuVXNlcixfbmV3T2JqZWN0OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB0LlVzZXJ9LF9wcm9jZXNzUmVzdWx0OmZ1bmN0aW9uKHQpe2lmKHQmJnRbdGhpcy5fZnJpZW5kc2hpcFRhZ10pe3ZhciBlPXRbdGhpcy5fZnJpZW5kc2hpcFRhZ107cmV0dXJuXCJQb2ludGVyXCI9PT1lLl9fdHlwZSYmXCJfVXNlclwiPT09ZS5jbGFzc05hbWUmJihkZWxldGUgZS5fX3R5cGUsZGVsZXRlIGUuY2xhc3NOYW1lKSxlfXJldHVybiBudWxsfX0pfX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMCksaT1uKDUwKSxzPW4oMSksbz1uKDMpLGE9by5pbmhlcml0cyx1PW4oMiksYz11LnJlcXVlc3QsbD1mdW5jdGlvbih0LGUpe3JldHVybiBjKHttZXRob2Q6XCJQT1NUXCIscGF0aDpcIi9MaXZlUXVlcnkvc3Vic2NyaWJlXCIsZGF0YTp7cXVlcnk6dCxpZDplfX0pfTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dC5MaXZlUXVlcnk9YShpLHtjb25zdHJ1Y3RvcjpmdW5jdGlvbih0LGUsbixyKXt2YXIgcz10aGlzO2kuYXBwbHkodGhpcyksdGhpcy5pZD10LHRoaXMuX2NsaWVudD1lLHRoaXMuX2NsaWVudC5yZWdpc3Rlcih0aGlzKSx0aGlzLl9xdWVyeUpTT049bix0aGlzLl9zdWJzY3JpcHRpb25JZD1yLHRoaXMuX29uTWVzc2FnZT10aGlzLl9kaXNwYXRjaC5iaW5kKHRoaXMpLHRoaXMuX29uUmVjb25uZWN0PWZ1bmN0aW9uKCl7bChzLl9xdWVyeUpTT04scy5fc3Vic2NyaXB0aW9uSWQpLmNhdGNoKGZ1bmN0aW9uKHQpe3JldHVybiBjb25zb2xlLmVycm9yKFwiTGl2ZVF1ZXJ5IHJlc3Vic2NyaWJlIGVycm9yOiBcIit0Lm1lc3NhZ2UpfSl9LGUub24oXCJtZXNzYWdlXCIsdGhpcy5fb25NZXNzYWdlKSxlLm9uKFwicmVjb25uZWN0XCIsdGhpcy5fb25SZWNvbm5lY3QpfSxfZGlzcGF0Y2g6ZnVuY3Rpb24oZSl7dmFyIG49dGhpcztlLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIGk9ZS5vcCxzPWUub2JqZWN0LG89ZS5xdWVyeV9pZCxhPWUudXBkYXRlZEtleXM7aWYobz09PW4uaWQpe3ZhciB1PXQucGFyc2VKU09OKHIuZXh0ZW5kKHtfX3R5cGU6XCJfRmlsZVwiPT09cy5jbGFzc05hbWU/XCJGaWxlXCI6XCJPYmplY3RcIn0scykpO2E/bi5lbWl0KGksdSxhKTpuLmVtaXQoaSx1KX19KX0sdW5zdWJzY3JpYmU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9jbGllbnQ7cmV0dXJuIHQub2ZmKFwibWVzc2FnZVwiLHRoaXMuX29uTWVzc2FnZSksdC5vZmYoXCJyZWNvbm5lY3RcIix0aGlzLl9vblJlY29ubmVjdCksdC5kZXJlZ2lzdGVyKHRoaXMpLGMoe21ldGhvZDpcIlBPU1RcIixwYXRoOlwiL0xpdmVRdWVyeS91bnN1YnNjcmliZVwiLGRhdGE6e2lkOnQuaWQscXVlcnlfaWQ6dGhpcy5pZH19KX19LHtpbml0OmZ1bmN0aW9uKGUpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fSxyPW4uc3Vic2NyaXB0aW9uSWQsaT12b2lkIDA9PT1yP3QuX2dldFN1YnNjcmlwdGlvbklkKCk6cjtpZighdC5fY29uZmlnLnJlYWx0aW1lKXRocm93IG5ldyBFcnJvcihcIkxpdmVRdWVyeSBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIHRoZSBMaXZlUXVlcnkgYnVuZGxlLiBodHRwczovL3VybC5sZWFuYXBwLmNuL2VuYWJsZS1saXZlLXF1ZXJ5XCIpO2lmKCEoZSBpbnN0YW5jZW9mIHQuUXVlcnkpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJMaXZlUXVlcnkgbXVzdCBiZSBpbml0ZWQgd2l0aCBhIFF1ZXJ5XCIpO3JldHVybiBzLnJlc29sdmUoaSkudGhlbihmdW5jdGlvbihuKXtyZXR1cm4gdC5fY29uZmlnLnJlYWx0aW1lLmNyZWF0ZUxpdmVRdWVyeUNsaWVudChuKS50aGVuKGZ1bmN0aW9uKHIpe3ZhciBpPWUudG9KU09OKCkscz1pLndoZXJlLG89aS5rZXlzLGE9aS5yZXR1cm5BQ0wsdT17d2hlcmU6cyxrZXlzOm8scmV0dXJuQUNMOmEsY2xhc3NOYW1lOmUuY2xhc3NOYW1lfSxjPWwodSxuKS50aGVuKGZ1bmN0aW9uKGUpe3ZhciBpPWUucXVlcnlfaWQ7cmV0dXJuIG5ldyB0LkxpdmVRdWVyeShpLHIsdSxuKX0pLmZpbmFsbHkoZnVuY3Rpb24oKXtyLmRlcmVnaXN0ZXIoYyl9KTtyZXR1cm4gci5yZWdpc3RlcihjKSxjfSl9KX19KX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKCl7fWZ1bmN0aW9uIGkodCxlLG4pe3RoaXMuZm49dCx0aGlzLmNvbnRleHQ9ZSx0aGlzLm9uY2U9bnx8ITF9ZnVuY3Rpb24gcygpe3RoaXMuX2V2ZW50cz1uZXcgcix0aGlzLl9ldmVudHNDb3VudD0wfXZhciBvPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksYT1cIn5cIjtPYmplY3QuY3JlYXRlJiYoci5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShudWxsKSwobmV3IHIpLl9fcHJvdG9fX3x8KGE9ITEpKSxzLnByb3RvdHlwZS5ldmVudE5hbWVzPWZ1bmN0aW9uKCl7dmFyIHQsZSxuPVtdO2lmKDA9PT10aGlzLl9ldmVudHNDb3VudClyZXR1cm4gbjtmb3IoZSBpbiB0PXRoaXMuX2V2ZW50cylvLmNhbGwodCxlKSYmbi5wdXNoKGE/ZS5zbGljZSgxKTplKTtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scz9uLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpKTpufSxzLnByb3RvdHlwZS5saXN0ZW5lcnM9ZnVuY3Rpb24odCxlKXt2YXIgbj1hP2ErdDp0LHI9dGhpcy5fZXZlbnRzW25dO2lmKGUpcmV0dXJuISFyO2lmKCFyKXJldHVybltdO2lmKHIuZm4pcmV0dXJuW3IuZm5dO2Zvcih2YXIgaT0wLHM9ci5sZW5ndGgsbz1uZXcgQXJyYXkocyk7aTxzO2krKylvW2ldPXJbaV0uZm47cmV0dXJuIG99LHMucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24odCxlLG4scixpLHMpe3ZhciBvPWE/YSt0OnQ7aWYoIXRoaXMuX2V2ZW50c1tvXSlyZXR1cm4hMTt2YXIgdSxjLGw9dGhpcy5fZXZlbnRzW29dLGg9YXJndW1lbnRzLmxlbmd0aDtpZihsLmZuKXtzd2l0Y2gobC5vbmNlJiZ0aGlzLnJlbW92ZUxpc3RlbmVyKHQsbC5mbix2b2lkIDAsITApLGgpe2Nhc2UgMTpyZXR1cm4gbC5mbi5jYWxsKGwuY29udGV4dCksITA7Y2FzZSAyOnJldHVybiBsLmZuLmNhbGwobC5jb250ZXh0LGUpLCEwO2Nhc2UgMzpyZXR1cm4gbC5mbi5jYWxsKGwuY29udGV4dCxlLG4pLCEwO2Nhc2UgNDpyZXR1cm4gbC5mbi5jYWxsKGwuY29udGV4dCxlLG4sciksITA7Y2FzZSA1OnJldHVybiBsLmZuLmNhbGwobC5jb250ZXh0LGUsbixyLGkpLCEwO2Nhc2UgNjpyZXR1cm4gbC5mbi5jYWxsKGwuY29udGV4dCxlLG4scixpLHMpLCEwfWZvcihjPTEsdT1uZXcgQXJyYXkoaC0xKTtjPGg7YysrKXVbYy0xXT1hcmd1bWVudHNbY107bC5mbi5hcHBseShsLmNvbnRleHQsdSl9ZWxzZXt2YXIgZixkPWwubGVuZ3RoO2ZvcihjPTA7YzxkO2MrKylzd2l0Y2gobFtjXS5vbmNlJiZ0aGlzLnJlbW92ZUxpc3RlbmVyKHQsbFtjXS5mbix2b2lkIDAsITApLGgpe2Nhc2UgMTpsW2NdLmZuLmNhbGwobFtjXS5jb250ZXh0KTticmVhaztjYXNlIDI6bFtjXS5mbi5jYWxsKGxbY10uY29udGV4dCxlKTticmVhaztjYXNlIDM6bFtjXS5mbi5jYWxsKGxbY10uY29udGV4dCxlLG4pO2JyZWFrO2Nhc2UgNDpsW2NdLmZuLmNhbGwobFtjXS5jb250ZXh0LGUsbixyKTticmVhaztkZWZhdWx0OmlmKCF1KWZvcihmPTEsdT1uZXcgQXJyYXkoaC0xKTtmPGg7ZisrKXVbZi0xXT1hcmd1bWVudHNbZl07bFtjXS5mbi5hcHBseShsW2NdLmNvbnRleHQsdSl9fXJldHVybiEwfSxzLnByb3RvdHlwZS5vbj1mdW5jdGlvbih0LGUsbil7dmFyIHI9bmV3IGkoZSxufHx0aGlzKSxzPWE/YSt0OnQ7cmV0dXJuIHRoaXMuX2V2ZW50c1tzXT90aGlzLl9ldmVudHNbc10uZm4/dGhpcy5fZXZlbnRzW3NdPVt0aGlzLl9ldmVudHNbc10scl06dGhpcy5fZXZlbnRzW3NdLnB1c2gocik6KHRoaXMuX2V2ZW50c1tzXT1yLHRoaXMuX2V2ZW50c0NvdW50KyspLHRoaXN9LHMucHJvdG90eXBlLm9uY2U9ZnVuY3Rpb24odCxlLG4pe3ZhciByPW5ldyBpKGUsbnx8dGhpcywhMCkscz1hP2ErdDp0O3JldHVybiB0aGlzLl9ldmVudHNbc10/dGhpcy5fZXZlbnRzW3NdLmZuP3RoaXMuX2V2ZW50c1tzXT1bdGhpcy5fZXZlbnRzW3NdLHJdOnRoaXMuX2V2ZW50c1tzXS5wdXNoKHIpOih0aGlzLl9ldmVudHNbc109cix0aGlzLl9ldmVudHNDb3VudCsrKSx0aGlzfSxzLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcj1mdW5jdGlvbih0LGUsbixpKXt2YXIgcz1hP2ErdDp0O2lmKCF0aGlzLl9ldmVudHNbc10pcmV0dXJuIHRoaXM7aWYoIWUpcmV0dXJuIDA9PS0tdGhpcy5fZXZlbnRzQ291bnQ/dGhpcy5fZXZlbnRzPW5ldyByOmRlbGV0ZSB0aGlzLl9ldmVudHNbc10sdGhpczt2YXIgbz10aGlzLl9ldmVudHNbc107aWYoby5mbilvLmZuIT09ZXx8aSYmIW8ub25jZXx8biYmby5jb250ZXh0IT09bnx8KDA9PS0tdGhpcy5fZXZlbnRzQ291bnQ/dGhpcy5fZXZlbnRzPW5ldyByOmRlbGV0ZSB0aGlzLl9ldmVudHNbc10pO2Vsc2V7Zm9yKHZhciB1PTAsYz1bXSxsPW8ubGVuZ3RoO3U8bDt1KyspKG9bdV0uZm4hPT1lfHxpJiYhb1t1XS5vbmNlfHxuJiZvW3VdLmNvbnRleHQhPT1uKSYmYy5wdXNoKG9bdV0pO2MubGVuZ3RoP3RoaXMuX2V2ZW50c1tzXT0xPT09Yy5sZW5ndGg/Y1swXTpjOjA9PS0tdGhpcy5fZXZlbnRzQ291bnQ/dGhpcy5fZXZlbnRzPW5ldyByOmRlbGV0ZSB0aGlzLl9ldmVudHNbc119cmV0dXJuIHRoaXN9LHMucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycz1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gdD8oZT1hP2ErdDp0LHRoaXMuX2V2ZW50c1tlXSYmKDA9PS0tdGhpcy5fZXZlbnRzQ291bnQ/dGhpcy5fZXZlbnRzPW5ldyByOmRlbGV0ZSB0aGlzLl9ldmVudHNbZV0pKToodGhpcy5fZXZlbnRzPW5ldyByLHRoaXMuX2V2ZW50c0NvdW50PTApLHRoaXN9LHMucHJvdG90eXBlLm9mZj1zLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcixzLnByb3RvdHlwZS5hZGRMaXN0ZW5lcj1zLnByb3RvdHlwZS5vbixzLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30scy5wcmVmaXhlZD1hLHMuRXZlbnRFbWl0dGVyPXMsdC5leHBvcnRzPXN9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLGk9bigzKSxzPWkudGFwO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt0LkNhcHRjaGE9ZnVuY3Rpb24odCxlKXt0aGlzLl9vcHRpb25zPXQsdGhpcy5fYXV0aE9wdGlvbnM9ZSx0aGlzLnVybD12b2lkIDAsdGhpcy5jYXB0Y2hhVG9rZW49dm9pZCAwLHRoaXMudmFsaWRhdGVUb2tlbj12b2lkIDB9LHQuQ2FwdGNoYS5wcm90b3R5cGUucmVmcmVzaD1mdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJuIHQuQ2xvdWQuX3JlcXVlc3RDYXB0Y2hhKHRoaXMuX29wdGlvbnMsdGhpcy5fYXV0aE9wdGlvbnMpLnRoZW4oZnVuY3Rpb24odCl7dmFyIG49dC5jYXB0Y2hhVG9rZW4saT10LnVybDtyZXR1cm4gci5leHRlbmQoZSx7Y2FwdGNoYVRva2VuOm4sdXJsOml9KSxpfSl9LHQuQ2FwdGNoYS5wcm90b3R5cGUudmVyaWZ5PWZ1bmN0aW9uKGUpe3ZhciBuPXRoaXM7cmV0dXJuIHQuQ2xvdWQudmVyaWZ5Q2FwdGNoYShlLHRoaXMuY2FwdGNoYVRva2VuKS50aGVuKHMoZnVuY3Rpb24odCl7cmV0dXJuIG4udmFsaWRhdGVUb2tlbj10fSkpfSx0LkNhcHRjaGEucHJvdG90eXBlLmJpbmQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLHI9dC50ZXh0SW5wdXQsaT10LmltYWdlLHM9dC52ZXJpZnlCdXR0b24sbz1lLnN1Y2Nlc3MsYT1lLmVycm9yO2lmKFwic3RyaW5nXCI9PXR5cGVvZiByJiYhKHI9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocikpKXRocm93IG5ldyBFcnJvcihcInRleHRJbnB1dCB3aXRoIGlkIFwiK3IrXCIgbm90IGZvdW5kXCIpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBpJiYhKGk9ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaSkpKXRocm93IG5ldyBFcnJvcihcImltYWdlIHdpdGggaWQgXCIraStcIiBub3QgZm91bmRcIik7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHMmJiEocz1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChzKSkpdGhyb3cgbmV3IEVycm9yKFwidmVyaWZ5QnV0dG9uIHdpdGggaWQgXCIrcytcIiBub3QgZm91bmRcIik7dGhpcy5fX3JlZnJlc2g9ZnVuY3Rpb24oKXtyZXR1cm4gbi5yZWZyZXNoKCkudGhlbihmdW5jdGlvbih0KXtpLnNyYz10LHImJihyLnZhbHVlPVwiXCIsci5mb2N1cygpKX0pLmNhdGNoKGZ1bmN0aW9uKHQpe3JldHVybiBjb25zb2xlLndhcm4oXCJyZWZyZXNoIGNhcHRjaGEgZmFpbDogXCIrdC5tZXNzYWdlKX0pfSxpJiYodGhpcy5fX2ltYWdlPWksaS5zcmM9dGhpcy51cmwsaS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLl9fcmVmcmVzaCkpLHRoaXMuX192ZXJpZnk9ZnVuY3Rpb24oKXt2YXIgdD1yLnZhbHVlO24udmVyaWZ5KHQpLmNhdGNoKGZ1bmN0aW9uKHQpe3Rocm93IG4uX19yZWZyZXNoKCksdH0pLnRoZW4obyxhKS5jYXRjaChmdW5jdGlvbih0KXtyZXR1cm4gY29uc29sZS53YXJuKFwidmVyaWZ5IGNhcHRjaGEgZmFpbDogXCIrdC5tZXNzYWdlKX0pfSxyJiZzJiYodGhpcy5fX3ZlcmlmeUJ1dHRvbj1zLHMuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5fX3ZlcmlmeSkpfSx0LkNhcHRjaGEucHJvdG90eXBlLnVuYmluZD1mdW5jdGlvbigpe3RoaXMuX19pbWFnZSYmdGhpcy5fX2ltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX19yZWZyZXNoKSx0aGlzLl9fdmVyaWZ5QnV0dG9uJiZ0aGlzLl9fdmVyaWZ5QnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLHRoaXMuX192ZXJpZnkpfSx0LkNhcHRjaGEucmVxdWVzdD1mdW5jdGlvbihlLG4pe3ZhciByPW5ldyB0LkNhcHRjaGEoZSxuKTtyZXR1cm4gci5yZWZyZXNoKCkudGhlbihmdW5jdGlvbigpe3JldHVybiByfSl9fX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPW4oMCksaT1uKDIpLHM9aS5fcmVxdWVzdCxvPWkucmVxdWVzdCxhPW4oMSk7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3QuQ2xvdWQ9dC5DbG91ZHx8e30sci5leHRlbmQodC5DbG91ZCx7cnVuOmZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gbyh7c2VydmljZTpcImVuZ2luZVwiLG1ldGhvZDpcIlBPU1RcIixwYXRoOlwiL2Z1bmN0aW9ucy9cIitlLGRhdGE6dC5fZW5jb2RlKG4sbnVsbCwhMCksYXV0aE9wdGlvbnM6cn0pLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHQuX2RlY29kZShlKS5yZXN1bHR9KX0scnBjOmZ1bmN0aW9uKGUsbixpKXtyZXR1cm4gci5pc0FycmF5KG4pP2EucmVqZWN0KG5ldyBFcnJvcihcIkNhbid0IHBhc3MgQXJyYXkgYXMgdGhlIHBhcmFtIG9mIHJwYyBmdW5jdGlvbiBpbiBKYXZhU2NyaXB0IFNESy5cIikpOm8oe3NlcnZpY2U6XCJlbmdpbmVcIixtZXRob2Q6XCJQT1NUXCIscGF0aDpcIi9jYWxsL1wiK2UsZGF0YTp0Ll9lbmNvZGVPYmplY3RPckFycmF5KG4pLGF1dGhPcHRpb25zOml9KS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiB0Ll9kZWNvZGUoZSkucmVzdWx0fSl9LGdldFNlcnZlckRhdGU6ZnVuY3Rpb24oKXtyZXR1cm4gcyhcImRhdGVcIixudWxsLG51bGwsXCJHRVRcIikudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gdC5fZGVjb2RlKGUpfSl9LHJlcXVlc3RTbXNDb2RlOmZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTtpZihyLmlzU3RyaW5nKHQpJiYodD17bW9iaWxlUGhvbmVOdW1iZXI6dH0pLCF0Lm1vYmlsZVBob25lTnVtYmVyKXRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgbW9iaWxlUGhvbmVOdW1iZXIuXCIpO3JldHVybiBlLnZhbGlkYXRlVG9rZW4mJih0PXIuZXh0ZW5kKHt9LHQse3ZhbGlkYXRlX3Rva2VuOmUudmFsaWRhdGVUb2tlbn0pKSxzKFwicmVxdWVzdFNtc0NvZGVcIixudWxsLG51bGwsXCJQT1NUXCIsdCxlKX0sdmVyaWZ5U21zQ29kZTpmdW5jdGlvbih0LGUpe2lmKCF0KXRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgc21zIGNvZGUuXCIpO3ZhciBuPXt9O3JldHVybiByLmlzU3RyaW5nKGUpJiYobi5tb2JpbGVQaG9uZU51bWJlcj1lKSxzKFwidmVyaWZ5U21zQ29kZVwiLHQsbnVsbCxcIlBPU1RcIixuKX0sX3JlcXVlc3RDYXB0Y2hhOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHMoXCJyZXF1ZXN0Q2FwdGNoYVwiLG51bGwsbnVsbCxcIkdFVFwiLHQsZSkudGhlbihmdW5jdGlvbih0KXt2YXIgZT10LmNhcHRjaGFfdXJsO3JldHVybntjYXB0Y2hhVG9rZW46dC5jYXB0Y2hhX3Rva2VuLHVybDplfX0pfSxyZXF1ZXN0Q2FwdGNoYTp0LkNhcHRjaGEucmVxdWVzdCx2ZXJpZnlDYXB0Y2hhOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHMoXCJ2ZXJpZnlDYXB0Y2hhXCIsbnVsbCxudWxsLFwiUE9TVFwiLHtjYXB0Y2hhX2NvZGU6dCxjYXB0Y2hhX3Rva2VuOmV9KS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiB0LnZhbGlkYXRlX3Rva2VufSl9fSl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigyKS5yZXF1ZXN0O3QuZXhwb3J0cz1mdW5jdGlvbih0KXt0Lkluc3RhbGxhdGlvbj10Lk9iamVjdC5leHRlbmQoXCJfSW5zdGFsbGF0aW9uXCIpLHQuUHVzaD10LlB1c2h8fHt9LHQuUHVzaC5zZW5kPWZ1bmN0aW9uKHQsZSl7aWYodC53aGVyZSYmKHQud2hlcmU9dC53aGVyZS50b0pTT04oKS53aGVyZSksdC53aGVyZSYmdC5jcWwpdGhyb3cgbmV3IEVycm9yKFwiQm90aCB3aGVyZSBhbmQgY3FsIGNhbid0IGJlIHNldFwiKTtpZih0LnB1c2hfdGltZSYmKHQucHVzaF90aW1lPXQucHVzaF90aW1lLnRvSlNPTigpKSx0LmV4cGlyYXRpb25fdGltZSYmKHQuZXhwaXJhdGlvbl90aW1lPXQuZXhwaXJhdGlvbl90aW1lLnRvSlNPTigpKSx0LmV4cGlyYXRpb25fdGltZSYmdC5leHBpcmF0aW9uX3RpbWVfaW50ZXJ2YWwpdGhyb3cgbmV3IEVycm9yKFwiQm90aCBleHBpcmF0aW9uX3RpbWUgYW5kIGV4cGlyYXRpb25fdGltZV9pbnRlcnZhbCBjYW4ndCBiZSBzZXRcIik7cmV0dXJuIHIoe3NlcnZpY2U6XCJwdXNoXCIsbWV0aG9kOlwiUE9TVFwiLHBhdGg6XCIvcHVzaFwiLGRhdGE6dCxhdXRoT3B0aW9uczplfSl9fX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciByPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9LGk9bigwKSxzPW4oMSksbz1uKDIpLl9yZXF1ZXN0LGE9bigzKSx1PWEuZ2V0U2Vzc2lvblRva2VuO3QuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtyZXR1cm4gdShlKT90LlVzZXIuX2ZldGNoVXNlckJ5U2Vzc2lvblRva2VuKHUoZSkpOnQuVXNlci5jdXJyZW50QXN5bmMoKX0sbj1mdW5jdGlvbihuKXtyZXR1cm4gZShuKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiB0Lk9iamVjdC5jcmVhdGVXaXRob3V0RGF0YShcIl9Vc2VyXCIsZS5pZCkuX3RvUG9pbnRlcigpfSl9O3QuU3RhdHVzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZGF0YT17fSx0aGlzLmluYm94VHlwZT1cImRlZmF1bHRcIix0aGlzLnF1ZXJ5PW51bGwsdCYmXCJvYmplY3RcIj09PSh2b2lkIDA9PT10P1widW5kZWZpbmVkXCI6cih0KSk/dGhpcy5kYXRhPXQ6KHQmJih0aGlzLmRhdGEuaW1hZ2U9dCksZSYmKHRoaXMuZGF0YS5tZXNzYWdlPWUpKSx0aGlzfSxpLmV4dGVuZCh0LlN0YXR1cy5wcm90b3R5cGUse2dldDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRhW3RdfSxzZXQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5kYXRhW3RdPWUsdGhpc30sZGVzdHJveTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5pZD9vKFwic3RhdHVzZXNcIixudWxsLHRoaXMuaWQsXCJERUxFVEVcIixlKTp0LlByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlRoZSBzdGF0dXMgaWQgaXMgbm90IGV4aXN0cy5cIikpfSx0b09iamVjdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlkP3QuT2JqZWN0LmNyZWF0ZVdpdGhvdXREYXRhKFwiX1N0YXR1c1wiLHRoaXMuaWQpOm51bGx9LF9nZXREYXRhSlNPTjpmdW5jdGlvbigpe3ZhciBlPWkuY2xvbmUodGhpcy5kYXRhKTtyZXR1cm4gdC5fZW5jb2RlKGUpfSxzZW5kOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcyxyPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fTtpZighdShyKSYmIXQuVXNlci5jdXJyZW50KCkpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHNpZ25pbiBhbiB1c2VyLlwiKTtyZXR1cm4gdGhpcy5xdWVyeT9uKHIpLnRoZW4oZnVuY3Rpb24odCl7dmFyIG49ZS5xdWVyeS50b0pTT04oKTtuLmNsYXNzTmFtZT1lLnF1ZXJ5LmNsYXNzTmFtZTt2YXIgaT17fTtyZXR1cm4gaS5xdWVyeT1uLGUuZGF0YT1lLmRhdGF8fHt9LGUuZGF0YS5zb3VyY2U9ZS5kYXRhLnNvdXJjZXx8dCxpLmRhdGE9ZS5fZ2V0RGF0YUpTT04oKSxpLmluYm94VHlwZT1lLmluYm94VHlwZXx8XCJkZWZhdWx0XCIsbyhcInN0YXR1c2VzXCIsbnVsbCxudWxsLFwiUE9TVFwiLGkscil9KS50aGVuKGZ1bmN0aW9uKG4pe3JldHVybiBlLmlkPW4ub2JqZWN0SWQsZS5jcmVhdGVkQXQ9dC5fcGFyc2VEYXRlKG4uY3JlYXRlZEF0KSxlfSk6dC5TdGF0dXMuc2VuZFN0YXR1c1RvRm9sbG93ZXJzKHRoaXMscil9LF9maW5pc2hGZXRjaDpmdW5jdGlvbihlKXt0aGlzLmlkPWUub2JqZWN0SWQsdGhpcy5jcmVhdGVkQXQ9dC5fcGFyc2VEYXRlKGUuY3JlYXRlZEF0KSx0aGlzLnVwZGF0ZWRBdD10Ll9wYXJzZURhdGUoZS51cGRhdGVkQXQpLHRoaXMubWVzc2FnZUlkPWUubWVzc2FnZUlkLGRlbGV0ZSBlLm1lc3NhZ2VJZCxkZWxldGUgZS5vYmplY3RJZCxkZWxldGUgZS5jcmVhdGVkQXQsZGVsZXRlIGUudXBkYXRlZEF0LHRoaXMuZGF0YT10Ll9kZWNvZGUoZSl9fSksdC5TdGF0dXMuc2VuZFN0YXR1c1RvRm9sbG93ZXJzPWZ1bmN0aW9uKGUpe3ZhciByPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTtpZighdShyKSYmIXQuVXNlci5jdXJyZW50KCkpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHNpZ25pbiBhbiB1c2VyLlwiKTtyZXR1cm4gbihyKS50aGVuKGZ1bmN0aW9uKG4pe3ZhciBpPXt9O2kuY2xhc3NOYW1lPVwiX0ZvbGxvd2VyXCIsaS5rZXlzPVwiZm9sbG93ZXJcIixpLndoZXJlPXt1c2VyOm59O3ZhciBzPXt9O3JldHVybiBzLnF1ZXJ5PWksZS5kYXRhPWUuZGF0YXx8e30sZS5kYXRhLnNvdXJjZT1lLmRhdGEuc291cmNlfHxuLHMuZGF0YT1lLl9nZXREYXRhSlNPTigpLHMuaW5ib3hUeXBlPWUuaW5ib3hUeXBlfHxcImRlZmF1bHRcIixvKFwic3RhdHVzZXNcIixudWxsLG51bGwsXCJQT1NUXCIscyxyKS50aGVuKGZ1bmN0aW9uKG4pe3JldHVybiBlLmlkPW4ub2JqZWN0SWQsZS5jcmVhdGVkQXQ9dC5fcGFyc2VEYXRlKG4uY3JlYXRlZEF0KSxlfSl9KX0sdC5TdGF0dXMuc2VuZFByaXZhdGVTdGF0dXM9ZnVuY3Rpb24oZSxyKXt2YXIgcz1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06e307aWYoIXUocykmJiF0LlVzZXIuY3VycmVudCgpKXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBzaWduaW4gYW4gdXNlci5cIik7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0YXJnZXQgdXNlci5cIik7dmFyIGE9aS5pc1N0cmluZyhyKT9yOnIuaWQ7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0YXJnZXQgdXNlci5cIik7cmV0dXJuIG4ocykudGhlbihmdW5jdGlvbihuKXt2YXIgcj17fTtyLmNsYXNzTmFtZT1cIl9Vc2VyXCIsci53aGVyZT17b2JqZWN0SWQ6YX07dmFyIGk9e307cmV0dXJuIGkucXVlcnk9cixlLmRhdGE9ZS5kYXRhfHx7fSxlLmRhdGEuc291cmNlPWUuZGF0YS5zb3VyY2V8fG4saS5kYXRhPWUuX2dldERhdGFKU09OKCksaS5pbmJveFR5cGU9XCJwcml2YXRlXCIsZS5pbmJveFR5cGU9XCJwcml2YXRlXCIsbyhcInN0YXR1c2VzXCIsbnVsbCxudWxsLFwiUE9TVFwiLGkscykudGhlbihmdW5jdGlvbihuKXtyZXR1cm4gZS5pZD1uLm9iamVjdElkLGUuY3JlYXRlZEF0PXQuX3BhcnNlRGF0ZShuLmNyZWF0ZWRBdCksZX0pfSl9LHQuU3RhdHVzLmNvdW50VW5yZWFkU3RhdHVzZXM9ZnVuY3Rpb24obil7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOlwiZGVmYXVsdFwiLGE9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnt9O2lmKGkuaXNTdHJpbmcocil8fChhPXIpLCF1KGEpJiZudWxsPT1uJiYhdC5Vc2VyLmN1cnJlbnQoKSl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2Ugc2lnbmluIGFuIHVzZXIgb3IgcGFzcyB0aGUgb3duZXIgb2JqZWN0SWQuXCIpO3JldHVybiBzLnJlc29sdmUobnx8ZShhKSkudGhlbihmdW5jdGlvbihlKXt2YXIgbj17fTtyZXR1cm4gbi5pbmJveFR5cGU9dC5fZW5jb2RlKHIpLG4ub3duZXI9dC5fZW5jb2RlKGUpLG8oXCJzdWJzY3JpYmUvc3RhdHVzZXMvY291bnRcIixudWxsLG51bGwsXCJHRVRcIixuLGEpfSl9LHQuU3RhdHVzLnJlc2V0VW5yZWFkQ291bnQ9ZnVuY3Rpb24obil7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOlwiZGVmYXVsdFwiLGE9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnt9O2lmKGkuaXNTdHJpbmcocil8fChhPXIpLCF1KGEpJiZudWxsPT1uJiYhdC5Vc2VyLmN1cnJlbnQoKSl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2Ugc2lnbmluIGFuIHVzZXIgb3IgcGFzcyB0aGUgb3duZXIgb2JqZWN0SWQuXCIpO3JldHVybiBzLnJlc29sdmUobnx8ZShhKSkudGhlbihmdW5jdGlvbihlKXt2YXIgbj17fTtyZXR1cm4gbi5pbmJveFR5cGU9dC5fZW5jb2RlKHIpLG4ub3duZXI9dC5fZW5jb2RlKGUpLG8oXCJzdWJzY3JpYmUvc3RhdHVzZXMvcmVzZXRVbnJlYWRDb3VudFwiLG51bGwsbnVsbCxcIlBPU1RcIixuLGEpfSl9LHQuU3RhdHVzLnN0YXR1c1F1ZXJ5PWZ1bmN0aW9uKGUpe3ZhciBuPW5ldyB0LlF1ZXJ5KFwiX1N0YXR1c1wiKTtyZXR1cm4gZSYmbi5lcXVhbFRvKFwic291cmNlXCIsZSksbn0sdC5JbmJveFF1ZXJ5PXQuUXVlcnkuX2V4dGVuZCh7X29iamVjdENsYXNzOnQuU3RhdHVzLF9zaW5jZUlkOjAsX21heElkOjAsX2luYm94VHlwZTpcImRlZmF1bHRcIixfb3duZXI6bnVsbCxfbmV3T2JqZWN0OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB0LlN0YXR1c30sX2NyZWF0ZVJlcXVlc3Q6ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdC5JbmJveFF1ZXJ5Ll9fc3VwZXJfXy5fY3JlYXRlUmVxdWVzdC5jYWxsKHRoaXMsZSxuLFwiL3N1YnNjcmliZS9zdGF0dXNlc1wiKX0sc2luY2VJZDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fc2luY2VJZD10LHRoaXN9LG1heElkOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9tYXhJZD10LHRoaXN9LG93bmVyOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9vd25lcj10LHRoaXN9LGluYm94VHlwZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5faW5ib3hUeXBlPXQsdGhpc30sdG9KU09OOmZ1bmN0aW9uKCl7dmFyIGU9dC5JbmJveFF1ZXJ5Ll9fc3VwZXJfXy50b0pTT04uY2FsbCh0aGlzKTtyZXR1cm4gZS5vd25lcj10Ll9lbmNvZGUodGhpcy5fb3duZXIpLGUuaW5ib3hUeXBlPXQuX2VuY29kZSh0aGlzLl9pbmJveFR5cGUpLGUuc2luY2VJZD10Ll9lbmNvZGUodGhpcy5fc2luY2VJZCksZS5tYXhJZD10Ll9lbmNvZGUodGhpcy5fbWF4SWQpLGV9fSksdC5TdGF0dXMuaW5ib3hRdWVyeT1mdW5jdGlvbihlLG4pe3ZhciByPW5ldyB0LkluYm94UXVlcnkodC5TdGF0dXMpO3JldHVybiBlJiYoci5fb3duZXI9ZSksbiYmKHIuX2luYm94VHlwZT1uKSxyfX19LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgcj1uKDApLGk9bigyKS5fcmVxdWVzdDt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dC5TZWFyY2hTb3J0QnVpbGRlcj1mdW5jdGlvbigpe3RoaXMuX3NvcnRGaWVsZHM9W119LHIuZXh0ZW5kKHQuU2VhcmNoU29ydEJ1aWxkZXIucHJvdG90eXBlLHtfYWRkRmllbGQ6ZnVuY3Rpb24odCxlLG4scil7dmFyIGk9e307cmV0dXJuIGlbdF09e29yZGVyOmV8fFwiYXNjXCIsbW9kZTpufHxcImF2Z1wiLG1pc3Npbmc6XCJfXCIrKHJ8fFwibGFzdFwiKX0sdGhpcy5fc29ydEZpZWxkcy5wdXNoKGkpLHRoaXN9LGFzY2VuZGluZzpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMuX2FkZEZpZWxkKHQsXCJhc2NcIixlLG4pfSxkZXNjZW5kaW5nOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5fYWRkRmllbGQodCxcImRlc2NcIixlLG4pfSx3aGVyZU5lYXI6ZnVuY3Rpb24odCxlLG4pe249bnx8e307dmFyIHI9e30saT17bGF0OmUubGF0aXR1ZGUsbG9uOmUubG9uZ2l0dWRlfSxzPXtvcmRlcjpuLm9yZGVyfHxcImFzY1wiLG1vZGU6bi5tb2RlfHxcImF2Z1wiLHVuaXQ6bi51bml0fHxcImttXCJ9O3JldHVybiBzW3RdPWksci5fZ2VvX2Rpc3RhbmNlPXMsdGhpcy5fc29ydEZpZWxkcy5wdXNoKHIpLHRoaXN9LGJ1aWxkOmZ1bmN0aW9uKCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHQuX2VuY29kZSh0aGlzLl9zb3J0RmllbGRzKSl9fSksdC5TZWFyY2hRdWVyeT10LlF1ZXJ5Ll9leHRlbmQoe19zaWQ6bnVsbCxfaGl0czowLF9xdWVyeVN0cmluZzpudWxsLF9oaWdobGlnaHRzOm51bGwsX3NvcnRCdWlsZGVyOm51bGwsX2NyZWF0ZVJlcXVlc3Q6ZnVuY3Rpb24odCxlKXtyZXR1cm4gaShcInNlYXJjaC9zZWxlY3RcIixudWxsLG51bGwsXCJHRVRcIix0fHx0aGlzLnRvSlNPTigpLGUpfSxzaWQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3NpZD10LHRoaXN9LHF1ZXJ5U3RyaW5nOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9xdWVyeVN0cmluZz10LHRoaXN9LGhpZ2hsaWdodHM6ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIGU9dCYmci5pc1N0cmluZyh0KT9hcmd1bWVudHM6dCx0aGlzLl9oaWdobGlnaHRzPWUsdGhpc30sc29ydEJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9zb3J0QnVpbGRlcj10LHRoaXN9LGhpdHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGl0c3x8KHRoaXMuX2hpdHM9MCksdGhpcy5faGl0c30sX3Byb2Nlc3NSZXN1bHQ6ZnVuY3Rpb24odCl7cmV0dXJuIGRlbGV0ZSB0LmNsYXNzTmFtZSxkZWxldGUgdC5fYXBwX3VybCxkZWxldGUgdC5fZGVlcGxpbmssdH0saGFzTW9yZTpmdW5jdGlvbigpe3JldHVybiF0aGlzLl9oaXRFbmR9LHJlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGl0RW5kPSExLHRoaXMuX3NpZD1udWxsLHRoaXMuX2hpdHM9MH0sZmluZDpmdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIHRoaXMuX2NyZWF0ZVJlcXVlc3QoKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBlLnNpZD8odC5fb2xkU2lkPXQuX3NpZCx0Ll9zaWQ9ZS5zaWQpOih0Ll9zaWQ9bnVsbCx0Ll9oaXRFbmQ9ITApLHQuX2hpdHM9ZS5oaXRzfHwwLHIubWFwKGUucmVzdWx0cyxmdW5jdGlvbihuKXtuLmNsYXNzTmFtZSYmKGUuY2xhc3NOYW1lPW4uY2xhc3NOYW1lKTt2YXIgcj10Ll9uZXdPYmplY3QoZSk7cmV0dXJuIHIuYXBwVVJMPW4uX2FwcF91cmwsci5fZmluaXNoRmV0Y2godC5fcHJvY2Vzc1Jlc3VsdChuKSwhMCkscn0pfSl9LHRvSlNPTjpmdW5jdGlvbigpe3ZhciBlPXQuU2VhcmNoUXVlcnkuX19zdXBlcl9fLnRvSlNPTi5jYWxsKHRoaXMpO2lmKGRlbGV0ZSBlLndoZXJlLHRoaXMuY2xhc3NOYW1lJiYoZS5jbGF6ej10aGlzLmNsYXNzTmFtZSksdGhpcy5fc2lkJiYoZS5zaWQ9dGhpcy5fc2lkKSwhdGhpcy5fcXVlcnlTdHJpbmcpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHNldCBxdWVyeSBzdHJpbmcuXCIpO2lmKGUucT10aGlzLl9xdWVyeVN0cmluZyx0aGlzLl9oaWdobGlnaHRzJiYoZS5oaWdobGlnaHRzPXRoaXMuX2hpZ2hsaWdodHMuam9pbihcIixcIikpLHRoaXMuX3NvcnRCdWlsZGVyJiZlLm9yZGVyKXRocm93IG5ldyBFcnJvcihcInNvcnQgYW5kIG9yZGVyIGNhbiBub3QgYmUgc2V0IGF0IHNhbWUgdGltZS5cIik7cmV0dXJuIHRoaXMuX3NvcnRCdWlsZGVyJiYoZS5zb3J0PXRoaXMuX3NvcnRCdWlsZGVyLmJ1aWxkKCkpLGV9fSl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKSxpPW4oNCkscz1uKDIpLG89cy5yZXF1ZXN0O3QuZXhwb3J0cz1mdW5jdGlvbih0KXt0Lkluc2lnaHQ9dC5JbnNpZ2h0fHx7fSxyLmV4dGVuZCh0Lkluc2lnaHQse3N0YXJ0Sm9iOmZ1bmN0aW9uKGUsbil7aWYoIWV8fCFlLnNxbCl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSB0aGUgc3FsIHRvIHJ1biB0aGUgam9iLlwiKTt2YXIgcj17am9iQ29uZmlnOmUsYXBwSWQ6dC5hcHBsaWNhdGlvbklkfTtyZXR1cm4gbyh7cGF0aDpcIi9iaWdxdWVyeS9qb2JzXCIsbWV0aG9kOlwiUE9TVFwiLGRhdGE6dC5fZW5jb2RlKHIsbnVsbCwhMCksYXV0aE9wdGlvbnM6bixzaWduS2V5OiExfSkudGhlbihmdW5jdGlvbihlKXtyZXR1cm4gdC5fZGVjb2RlKGUpLmlkfSl9LG9uOmZ1bmN0aW9uKHQsZSl7fX0pLHQuSW5zaWdodC5Kb2JRdWVyeT1mdW5jdGlvbih0LGUpe2lmKCF0KXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIHRoZSBqb2IgaWQuXCIpO3RoaXMuaWQ9dCx0aGlzLmNsYXNzTmFtZT1lLHRoaXMuX3NraXA9MCx0aGlzLl9saW1pdD0xMDB9LHIuZXh0ZW5kKHQuSW5zaWdodC5Kb2JRdWVyeS5wcm90b3R5cGUse3NraXA6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3NraXA9dCx0aGlzfSxsaW1pdDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fbGltaXQ9dCx0aGlzfSxmaW5kOmZ1bmN0aW9uKGUpe3ZhciBuPXtza2lwOnRoaXMuX3NraXAsbGltaXQ6dGhpcy5fbGltaXR9O3JldHVybiBvKHtwYXRoOlwiL2JpZ3F1ZXJ5L2pvYnMvXCIrdGhpcy5pZCxtZXRob2Q6XCJHRVRcIixxdWVyeTpuLGF1dGhPcHRpb25zOmUsc2lnbktleTohMX0pLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGUuZXJyb3I/dC5Qcm9taXNlLnJlamVjdChuZXcgaShlLmNvZGUsZS5lcnJvcikpOnQuUHJvbWlzZS5yZXNvbHZlKGUpfSl9fSl9fSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9bigwKSxpPW4oMikscz1pLl9yZXF1ZXN0LG89big1KSxhPWZ1bmN0aW9uKHQpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHQudG9KU09OP3QudG9KU09OKCk6XCJzdHJpbmdcIiE9dHlwZW9mIHQ/SlNPTi5zdHJpbmdpZnkodCk6dH07dC5leHBvcnRzPW8uT2JqZWN0LmV4dGVuZChcIl9Db252ZXJzYXRpb25cIix7Y29uc3RydWN0b3I6ZnVuY3Rpb24odCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0/YXJndW1lbnRzWzFdOnt9O28uT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsbnVsbCxudWxsKSx0aGlzLnNldChcIm5hbWVcIix0KSx2b2lkIDAhPT1lLmlzU3lzdGVtJiZ0aGlzLnNldChcInN5c1wiLCEhZS5pc1N5c3RlbSksdm9pZCAwIT09ZS5pc1RyYW5zaWVudCYmdGhpcy5zZXQoXCJ0clwiLCEhZS5pc1RyYW5zaWVudCl9LGdldENyZWF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXQoXCJjXCIpfSxnZXRMYXN0TWVzc2FnZUF0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0KFwibG1cIil9LGdldE1lbWJlcnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXQoXCJtXCIpfSxhZGRNZW1iZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYWRkKFwibVwiLHQpfSxnZXRNdXRlZE1lbWJlcnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXQoXCJtdVwiKX0sZ2V0TmFtZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldChcIm5hbWVcIil9LGlzVHJhbnNpZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0KFwidHJcIil9LGlzU3lzdGVtOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0KFwic3lzXCIpfSxzZW5kOmZ1bmN0aW9uKHQsZSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnt9LHI9YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOnt9LGk9e2Zyb21fcGVlcjp0LGNvbnZfaWQ6dGhpcy5pZCx0cmFuc2llbnQ6ITEsbWVzc2FnZTphKGUpfTtyZXR1cm4gdm9pZCAwIT09bi50b0NsaWVudHMmJihpLnRvX3BlZXJzPW4udG9DbGllbnRzKSx2b2lkIDAhPT1uLnRyYW5zaWVudCYmKGkudHJhbnNpZW50PSEhbi50cmFuc2llbnQpLHZvaWQgMCE9PW4ucHVzaERhdGEmJihpLnB1c2hfZGF0YT1uLnB1c2hEYXRhKSxzKFwicnRtXCIsXCJtZXNzYWdlc1wiLG51bGwsXCJQT1NUXCIsaSxyKX0sYnJvYWRjYXN0OmZ1bmN0aW9uKHQsZSl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnt9LGk9YXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOnt9LG89e2Zyb21fcGVlcjp0LGNvbnZfaWQ6dGhpcy5pZCxtZXNzYWdlOmEoZSl9O2lmKHZvaWQgMCE9PW4ucHVzaERhdGEmJihvLnB1c2g9bi5wdXNoRGF0YSksdm9pZCAwIT09bi52YWxpZFRpbGwpe3ZhciB1PW4udmFsaWRUaWxsO3IuaXNEYXRlKHUpJiYodT11LmdldFRpbWUoKSksbi52YWxpZF90aWxsPXV9cmV0dXJuIHMoXCJydG1cIixcImJyb2FkY2FzdFwiLG51bGwsXCJQT1NUXCIsbyxpKX19KX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIodCl7dmFyIGU9dC5uYW1lLG49dC52YWx1ZSxyPXQudmVyc2lvbjt0aGlzLm5hbWU9ZSx0aGlzLnZhbHVlPW4sdGhpcy52ZXJzaW9uPXJ9dmFyIGk9bigwKSxzPW4oMSksbz1uKDIpLGE9by5yZXF1ZXN0LHU9bigzKSxjPXUuZW5zdXJlQXJyYXksbD11LnBhcnNlRGF0ZSxoPW4oNSk7aC5MZWFkZXJib2FyZFZlcnNpb25DaGFuZ2VJbnRlcnZhbD17TkVWRVI6XCJuZXZlclwiLEhPVVI6XCJob3VyXCIsREFZOlwiZGF5XCIsV0VFSzpcIndlZWtcIixNT05USDpcIm1vbnRoXCJ9LGguTGVhZGVyYm9hcmRPcmRlcj17QVNDRU5ESU5HOlwiYXNjZW5kaW5nXCIsREVTQ0VORElORzpcImRlc2NlbmRpbmdcIn0saC5MZWFkZXJib2FyZFVwZGF0ZVN0cmF0ZWd5PXtCRVRURVI6XCJiZXR0ZXJcIixMQVNUOlwibGFzdFwifTt2YXIgZj1mdW5jdGlvbih0KXt2YXIgZT1oLl9kZWNvZGUodCk7cmV0dXJuIG5ldyByKHtuYW1lOmUuc3RhdGlzdGljTmFtZSx2YWx1ZTplLnN0YXRpc3RpY1ZhbHVlLHZlcnNpb246ZS52ZXJzaW9ufSl9O2guTGVhZGVyYm9hcmQ9ZnVuY3Rpb24odCl7dGhpcy5zdGF0aXN0aWNOYW1lPXQsdGhpcy5vcmRlcj12b2lkIDAsdGhpcy51cGRhdGVTdHJhdGVneT12b2lkIDAsdGhpcy52ZXJzaW9uQ2hhbmdlSW50ZXJ2YWw9dm9pZCAwLHRoaXMudmVyc2lvbj12b2lkIDAsdGhpcy5uZXh0UmVzZXRBdD12b2lkIDAsdGhpcy5jcmVhdGVkQXQ9dm9pZCAwfTt2YXIgZD1oLkxlYWRlcmJvYXJkO2guTGVhZGVyYm9hcmQuY3JlYXRlV2l0aG91dERhdGE9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBkKHQpfSxoLkxlYWRlcmJvYXJkLmNyZWF0ZUxlYWRlcmJvYXJkPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5zdGF0aXN0aWNOYW1lLHI9dC5vcmRlcixpPXQudmVyc2lvbkNoYW5nZUludGVydmFsLHM9dC51cGRhdGVTdHJhdGVneTtyZXR1cm4gYSh7bWV0aG9kOlwiUE9TVFwiLHBhdGg6XCIvbGVhZGVyYm9hcmQvbGVhZGVyYm9hcmRzXCIsZGF0YTp7c3RhdGlzdGljTmFtZTpuLG9yZGVyOnIsdmVyc2lvbkNoYW5nZUludGVydmFsOmksdXBkYXRlU3RyYXRlZ3k6c30sYXV0aE9wdGlvbnM6ZX0pLnRoZW4oZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBkKG4pLl9maW5pc2hGZXRjaCh0KX0pfSxoLkxlYWRlcmJvYXJkLmdldExlYWRlcmJvYXJkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGQuY3JlYXRlV2l0aG91dERhdGEodCkuZmV0Y2goZSl9LGguTGVhZGVyYm9hcmQuZ2V0U3RhdGlzdGljcz1mdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e30sbj1lLnN0YXRpc3RpY05hbWVzLHI9YXJndW1lbnRzWzJdO3JldHVybiBzLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCl7aWYoIXR8fCF0LmlkKXRocm93IG5ldyBFcnJvcihcInVzZXIgbXVzdCBiZSBhbiBBVi5Vc2VyXCIpO3JldHVybiBhKHttZXRob2Q6XCJHRVRcIixwYXRoOlwiL2xlYWRlcmJvYXJkL3VzZXJzL1wiK3QuaWQrXCIvc3RhdGlzdGljc1wiLHF1ZXJ5OntzdGF0aXN0aWNzOm4/YyhuKS5qb2luKFwiLFwiKTp2b2lkIDB9LGF1dGhPcHRpb25zOnJ9KS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlc3VsdHMubWFwKGYpfSl9KX0saC5MZWFkZXJib2FyZC51cGRhdGVTdGF0aXN0aWNzPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gcy5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpe2lmKCF0fHwhdC5pZCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2VyIG11c3QgYmUgYW4gQVYuVXNlclwiKTt2YXIgcj1pLm1hcChlLGZ1bmN0aW9uKHQsZSl7cmV0dXJue3N0YXRpc3RpY05hbWU6ZSxzdGF0aXN0aWNWYWx1ZTp0fX0pO3JldHVybiBhKHttZXRob2Q6XCJQT1NUXCIscGF0aDpcIi9sZWFkZXJib2FyZC91c2Vycy9cIit0LmlkK1wiL3N0YXRpc3RpY3NcIixkYXRhOnIsYXV0aE9wdGlvbnM6bn0pLnRoZW4oZnVuY3Rpb24odCl7cmV0dXJuIHQucmVzdWx0cy5tYXAoZil9KX0pfSxpLmV4dGVuZChkLnByb3RvdHlwZSx7X2ZpbmlzaEZldGNoOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7cmV0dXJuIGkuZm9yRWFjaCh0LGZ1bmN0aW9uKHQsbil7XCJ1cGRhdGVkQXRcIiE9PW4mJlwib2JqZWN0SWRcIiE9PW4mJihcImV4cGlyZWRBdFwiPT09biYmKG49XCJuZXh0UmVzZXRBdFwiKSxcImNyZWF0ZWRBdFwiPT09biYmKHQ9bCh0KSksdCYmXCJEYXRlXCI9PT10Ll9fdHlwZSYmKHQ9bCh0LmlzbykpLGVbbl09dCl9KSx0aGlzfSxmZXRjaDpmdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiBhKHttZXRob2Q6XCJHRVRcIixwYXRoOlwiL2xlYWRlcmJvYXJkL2xlYWRlcmJvYXJkcy9cIit0aGlzLnN0YXRpc3RpY05hbWUsYXV0aE9wdGlvbnM6dH0pLnRoZW4oZnVuY3Rpb24odCl7cmV0dXJuIGUuX2ZpbmlzaEZldGNoKHQpfSl9LF9nZXRSZXN1bHRzOmZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10LnNraXAsaT10LmxpbWl0LHM9dC5zZWxlY3RVc2VyS2V5cyxvPXQuaW5jbHVkZVN0YXRpc3RpY3M7cmV0dXJuIGEoe21ldGhvZDpcIkdFVFwiLHBhdGg6XCIvbGVhZGVyYm9hcmQvbGVhZGVyYm9hcmRzL1wiK3RoaXMuc3RhdGlzdGljTmFtZStcIi9yYW5rc1wiKyhuP1wiL3NlbGZcIjpcIlwiKSxxdWVyeTp7c2tpcDpyLGxpbWl0OmksaW5jbHVkZVVzZXI6cz9jKHMpLmpvaW4oXCIsXCIpOnZvaWQgMCxpbmNsdWRlU3RhdGlzdGljczpvP2Mobykuam9pbihcIixcIik6dm9pZCAwfSxhdXRoT3B0aW9uczplfSkudGhlbihmdW5jdGlvbih0KXtyZXR1cm4gdC5yZXN1bHRzLm1hcChmdW5jdGlvbih0KXt2YXIgZT1oLl9kZWNvZGUodCksbj1lLnVzZXIscj1lLnN0YXRpc3RpY1ZhbHVlLGk9ZS5yYW5rLHM9ZS5zdGF0aXN0aWNzO3JldHVybnt1c2VyOm4sdmFsdWU6cixyYW5rOmksaW5jbHVkZWRTdGF0aXN0aWNzOih2b2lkIDA9PT1zP1tdOnMpLm1hcChmKX19KX0pfSxnZXRSZXN1bHRzOmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOnt9LGU9dC5za2lwLG49dC5saW1pdCxyPXQuc2VsZWN0VXNlcktleXMsaT10LmluY2x1ZGVTdGF0aXN0aWNzLHM9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLl9nZXRSZXN1bHRzKHtza2lwOmUsbGltaXQ6bixzZWxlY3RVc2VyS2V5czpyLGluY2x1ZGVTdGF0aXN0aWNzOml9LHMpfSxnZXRSZXN1bHRzQXJvdW5kVXNlcjpmdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTp7fSxlPXQubGltaXQsbj10LnNlbGVjdFVzZXJLZXlzLHI9dC5pbmNsdWRlU3RhdGlzdGljcyxpPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fZ2V0UmVzdWx0cyh7bGltaXQ6ZSxzZWxlY3RVc2VyS2V5czpuLGluY2x1ZGVTdGF0aXN0aWNzOnJ9LGksITApfSxfdXBkYXRlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcztyZXR1cm4gYSh7bWV0aG9kOlwiUFVUXCIscGF0aDpcIi9sZWFkZXJib2FyZC9sZWFkZXJib2FyZHMvXCIrdGhpcy5zdGF0aXN0aWNOYW1lLGRhdGE6dCxhdXRoT3B0aW9uczplfSkudGhlbihmdW5jdGlvbih0KXtyZXR1cm4gbi5fZmluaXNoRmV0Y2godCl9KX0sdXBkYXRlVmVyc2lvbkNoYW5nZUludGVydmFsOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX3VwZGF0ZSh7dmVyc2lvbkNoYW5nZUludGVydmFsOnR9LGUpfSx1cGRhdGVVcGRhdGVTdHJhdGVneTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl91cGRhdGUoe3VwZGF0ZVN0cmF0ZWd5OnR9LGUpfSxyZXNldDpmdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiBhKHttZXRob2Q6XCJQVVRcIixwYXRoOlwiL2xlYWRlcmJvYXJkL2xlYWRlcmJvYXJkcy9cIit0aGlzLnN0YXRpc3RpY05hbWUrXCIvaW5jcmVtZW50VmVyc2lvblwiLGF1dGhPcHRpb25zOnR9KS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiBlLl9maW5pc2hGZXRjaCh0KX0pfSxkZXN0cm95OmZ1bmN0aW9uKHQpe3JldHVybiBoLnJlcXVlc3Qoe21ldGhvZDpcIkRFTEVURVwiLHBhdGg6XCIvbGVhZGVyYm9hcmQvbGVhZGVyYm9hcmRzL1wiK3RoaXMuc3RhdGlzdGljTmFtZSxhdXRoT3B0aW9uczp0fSkudGhlbihmdW5jdGlvbigpe30pfX0pfV0pfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdi1taW4uanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/leancloud-storage/dist/av-min.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQSxtQkFBbUIsMkJBQTJCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBOztBQUVBLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQsa0RBQWtELHNCQUFzQjtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvICsgXCIgXCIgKyBvcHRpb25zLmluc2VydEF0LmJlZm9yZSk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/addStyles.js\n");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzP2Y2ZDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-loader/lib/urls.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./src/css/app.scss":
/*!**************************!*\
  !*** ./src/css/app.scss ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../node_modules/css-loader!../../node_modules/sass-loader/lib/loader.js!./app.scss */ \"./node_modules/css-loader/index.js!./node_modules/sass-loader/lib/loader.js!./src/css/app.scss\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY3NzL2FwcC5zY3NzPzZjODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEiLCJmaWxlIjoiLi9zcmMvY3NzL2FwcC5zY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vYXBwLnNjc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vYXBwLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcyEuL2FwcC5zY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/css/app.scss\n");

/***/ }),

/***/ "./src/font/core_sans.woff2":
/*!**********************************!*\
  !*** ./src/font/core_sans.woff2 ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"fonts/core_sans.woff2\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZm9udC9jb3JlX3NhbnMud29mZjI/MjA5MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIuL3NyYy9mb250L2NvcmVfc2Fucy53b2ZmMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImZvbnRzL2NvcmVfc2Fucy53b2ZmMlwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/font/core_sans.woff2\n");

/***/ }),

/***/ "./src/img/1.png":
/*!***********************!*\
  !*** ./src/img/1.png ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"000625fa0f373bb37d3fda9a22c87986.png\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1nLzEucG5nP2M1OTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiLi9zcmMvaW1nLzEucG5nLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiMDAwNjI1ZmEwZjM3M2JiMzdkM2ZkYTlhMjJjODc5ODYucG5nXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/img/1.png\n");

/***/ }),

/***/ "./src/img/dist-light.png":
/*!********************************!*\
  !*** ./src/img/dist-light.png ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA3gAAAN4CAMAAACmsLp8AAAAUVBMVEX///////////////////////////////////////////////////////////////////////////////////////////////////////////94FlRsAAAAG3RSTlMAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRqJqIEoAAAmbklEQVR4XuzTAQkAMBADsZ1/07NR+MTBQfs2AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAvSOaKYXqndBOKdSVQe6EQmeO10oqfHbtBbVhGIiiKPPz/pdcJa07BFFsSFFGwz07EHB5ExP5xVNXASRJ++5qPBaQV4S3ACCrw+OxgMx47Tqgu8RrlwPdqbYtT1W0YHmgOxUduj5Xh4Llge6+SePuhmr3JrgyO5enWrA80J0mbTl4NcsDe5ekZXdJ6qQH9i6ZdDw0i24e6C51686mF344PdCdzqxXeWKmWjM9sHbJzKTX4JUvD3RnD9qsu0yv4jcW0J0Nzcqz0yc2D7g3dyfpM3jVywNnZtI+3SUtmR7orl15Yq90srA80J3KH9U1OzbVLVW9N8Gvu+TaYvDcJmVHD3Tng+zfnT9sUx6YO29RnvqTrT43AZndy27QDoP3VK488N9Mm/jQYfLMk5X+vAmy8+TW4dD0u/fmp8MDv+5aHJsenoqMHujuOjsP73BopgKfN0F3dtHdELbz4MVleeu/sYDurrOLcNl28OJhKq9WeuCrik9i2HbyNJ58UvraBN3FD91z8D1OVX7ogTPTbs5dbHts6hGxND3g7Y+ZHimOHSdP4ojr8lKN8sCVmY6QbQcv+VV7b5UH/Fd26dAtB+/N8vR+ecAX++aCGzcMQ8Gq+pDU/Q9cb+LEWRkIo32xIRZv7jCYRxnGc1dHWsDk5bZRB9Y1j/BV5azdRg43NDd89fI1c5PQO3Rmtp1gY7O2D9C9OW8e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\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1nL2Rpc3QtbGlnaHQucG5nPzUxYzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUNBQWlDIiwiZmlsZSI6Ii4vc3JjL2ltZy9kaXN0LWxpZ2h0LnBuZy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQTNnQUFBTjRDQU1BQUFDbXNMcDhBQUFBVVZCTVZFWC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vOTRGbFJzQUFBQUczUlNUbE1BQVFJREJBVUdCd2dKQ2dzTURRNFBFQkVTRXhRVkZoY1lHUnFKcUlFb0FBQW1ia2xFUVZSNFh1elRBUWtBTUJBRHNaMS8wN05SK01UQlFmczJBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBdlNPYUtZWHFuZEJPS2RTVlFlNkVRbWVPMTBvcWZIYnRCYlZoR0lpaUtQUHovcGRjSmEwN0JGRnNTRkZHd3owN0VIQjVFeFA1eFZOWEFTUkorKzVxUEJhUVY0UzNBQ0NydytPeGdNeDQ3VHFndThScmx3UGRxYll0VDFXMFlIbWdPeFVkdWo1WGg0TGxnZTYrU2VQdWhtcjNKcmd5TzVlbldyQTgwSjBtYlRsNE5jc0RlNWVrWlhkSjZxUUg5aTZaZER3MGkyNGU2QzUxNjg2bUYzNDRQZENkenF4WGVXS21Xak05c0hiSnpLVFg0SlV2RDNSbkQ5cXN1MHl2NGpjVzBKME56Y3F6MHljMkQ3ZzNkeWZwTTNqVnl3Tm5adEkrM1NVdG1SN29ybDE1WXE5MHNyQTgwSjNLSDlVMU96YlZMVlc5TjhHdnUrVGFZdkRjSm1WSEQzVG5nK3pmblQ5c1V4NllPMjlSbnZxVHJUNDNBWm5keTI3UURvUDNWSzQ4OE45TW0valFZZkxNazVYK3ZBbXk4K1RXNGREMHUvZm1wOE1Edis1YUhKc2Vub3FNSHVqdU9qc1A3M0JvcGdLZk4wRjNkdEhkRUxiejRNVmxlZXUvc1lEdXJyT0xjTmwyOE9KaEtxOVdldUNyaWs5aTJIYnlOSjU4VXZyYUJOM0ZEOTF6OEQxT1ZYN29nVFBUYnM1ZGJIdHM2aEd4TkQzZzdZK1pIaW1PSFNkUDRvanI4bEtOOHNDVm1ZNlFiUWN2K1ZWN2I1VUgvRmQyNmRBdEIrL044dlIrZWNBWCsrYUNHemNNUThHcStwRFUvUTljYitMRVdSa0lvMzJ4SVJadjdqQ1lSeG5HYzFkSFdzRGs1YlpSQjlZMWovQlY1YXpkUmc0M05EZDg5ZkkxYzVQUU8zUm10cDFnWTdPMkQ5QzlPVzhlb1hmNHl2eWdoaHVhRStyZC84Y0M0YXVLWDd0NFk3Tksrd3B3NnNIbUVhN00rZHZ1UUNJbEx4L2V2WFRxSWRFajlBNC83ZzVFY3JUZ0FkRzc1bzJGOExvcmJ1OEdKRkR5c214TW1sZnVieDZoZDQ1MVRUWTBTdkpTbFRldzZPSHFFV28zTUZ1N2Qxb0tFanlWblV2M0pnVWcySFgzRSswQ0pTODFPV2dETVM0OXdwVXBYMmdwVVBBbXFvZEhqOUM3M3ovdVlpVXZ5UTZ3TjJtZUIwRnk1MnMza3FJRTc5TG8wVHh5WmU3a2hKYjF4Uk5WWDcxVnpDT2NtYjUyb3JwKzhvbytrUHZVKy9PZGU0VGU0ZG85S09zSGJ3ZFhELzlqZ2ZDNlEwZm1qZ1FJSHFEZWpYdVQ4THI3VWUxMjZ1TEJzKy9NRTNCdjBqeVNua0hlTXYzYUhkamFWMTR4VloxUXI3NitOMmtldFV2cHd1Tk9uN0d5OGdyWWczZjEzdlNiUnpnemNlM0NKSzkwVTFNM2VnT2VlZk9ISHFGMzJIR25KNnlYbFlQM1lMcDZ3TjZrZWRUdWh0cTlvY3NtTDNkN1IwZkF2Y2xManlRbmQwN3RQTzE4NzZ6blZZT245b21lQUtyMzhxVkhtTHNLamt3NzBMUjQ4UHpxK1ErY2pubFVqOTRCeDkya2Rtc25MOWtBWkY1NWh1YlJPM2hsMXRuanprYVdURjYyQVd4dituT1RoeDU3TitZTzBFNVAySWtsazZmZCtsM3E4Y3NDZStmbkRoMlpJNzNyZ3Q3OXRiNWhaK2JVQXk2OS85VTdNdmZwenRldS9XUHZqSElqaEdFb21JUVVHdHZzL1k5YnNWdlZpMEFOMkF1eUVzOEorQm05WnpzU011MEFMRWJlaFBDaXJwNDQ5UEl4ODBKYk9CWHZidEFPWHVCa2NMV0NBQXIxOUgyeldlOGM5WENuMSs0RmxoU01NU0l3WmNzTm8xNno0am5udlB0YW95K1pESTdtanVjSTc5dzE2cVVWclhybnlMeXIxOHp2UTNISG9MV0x3a2l3UXErZTRMTFFySGpPaWVsT2ZrRW9GZTBXYUxRV2VMZ3hEMEJYT0dWMU03U0lFNk42cVNLZjdSaEVXKy9HTXVIQzVqdVZxWGUrYjdicW5YUE11MHUxd3dYS3dSQVQ0YjU1Z3RRVExGbmFGOCtKOTJvSFcvQUpUY0VPQ1JrUURIdjYwR3ZlT3lkdXRidXhaT0lmTkZoYXJhQkFQVUhmckprWDJzVlJlS2ZYanFIUld1QXg2cjRwREwzUU1zNC9Od1Q1NGU3SVJtVU5wV0NFakNoVmovbUFlakcwakJNcmNYZHQyakU1MkNBQ0lTcmRxeGZPdW5uOVRIZ2VlWGxGUlR0NTJ1RWVCTkZLMHlSQ2dYcml3cm12WGdxdDQ2UXIwdzdnbUhlRUtaaWcwQlBjQVFUdUNkVHJTVHdYTDR1R08xWEhaR2loQkF0RXBGOXdqN1BEbm1UVTY4VTdKMzBtN2hUV0xXQzBjVHhuWkxPZVB2UTYyYXc0Y1pCcXB5K1p4RXpCQUdXbWlucDRUZC9NNy9RUmVFN2E5KzdNU2tXYWRzeHNvV3RtWXZFT3gxNkJENnMzaEQ1d2htcmNYYkxKWERHVGdaOTJmVDlvaTZSeHlwNlI5Umw0SG5uQ2txa0tPK1pSRE53U1ptSUUwNTVTdlM2OWMvTkVhZmZEenJubE5nekRRRkN4NWJlNVRPNS8yZFpBQ3lHeGxTcVVDbjZRYzRmQkxsZXdSUjF6djRMMFh4UkdFTkYrU2V0akx4OTZneDN4bk51Ykw4d0ZwMTI1ZFFraWpQcE5reWluWHZYT01wV1paOG83cDh0cDE3eGs1clFqVXUrYUVYVFFNUFVFcjNyeEZnemhSR1h0RGpBRVZRWlFRdVRlZWVLY2wwTDNUQWVlUjU1MFVsbVhTdXNPV0ZlOGJnZVJRTDMxaFJyMXhoaHM0Y1R4clhmUDByWFVMZ0hkajRONnBoTkM5NFMzbnNIQWMyNEZKVk93cUJSSWwrQVlGRmxBSkZadmE2S2V3Y0J6b2xBN2FkalJHV2orWWJNamdCTC9tbnB6eHJ6QjlMTGlrWmV4cm5IYW5RRTZ6VTN6Z0JSU0w2blhCM3M0ZldIYzFXdEhsd0RRM0RVM0FKKzV0MTBnVmM5NDRIbmtUZUtXdWRWckIreDZYWXVReklNODlpb0s1OVFGaXpqZFZKNTI2OUswWS81Q2F1TE5lSVl1YU40NHB5ZXNCcDR6RkdzbkNqdmFjOUlsbHFERXp2aGJ2WjBrc2JlVXFUZjN3U1pPUDB0dXU1cUtpUmVZMURaTnhobkIwaUxmV1laZ0ZXZVlQMTVVS3F3am5HRHFnd3JySFFtSmU5V0ZjNDdCT0I1NU5kcUpyRXZ3R2xUWTdrQ2Rla1VUWno3MFp1T0I1NUVuTDVueXRFdmN0NkJCQkRNRHJWTnYrMkRoN0lOZG5GNHdxYlN6RG1EV2VjcGJIbndBTURJMHV2YXk3bzNCTXM0NEovNmxZK0lOL00xRHBXdXVELzRCakJ4bEs2ZXNjUnAvdzNPNktaTjJnb3I1eGI2ZDVUZ093MEFBcGJ4YksrbTUvMTBueTZpaHhERUVMZUY4Tk44ZENsV200TUtxQ3crb2dkK01JZVY5Vys4VjNWbVN3aE5TZWEwYjB4V1ZYVWpnQXV6V0k3eHBuWnlsclRmQTd5YUdVOWw5ZTJPR1Y4Y0c3QXlGMERsNlpZL3FpNEpmVGl6N3ErKzJYVGdobzREWlJPR2p0c1ZaY3VLVXdoTkRabVQyM0pqaEU1cUIyVXpoMGxYMGZIdnRTZUVsaEZvYUxpcnV4T2ZLN3Y4SFQxbkNndVJkUjg5VkxrNHpnUkNqcWR5WVZmZVVNN0lLV0kyRUQ2RTRmVlh2QzZmazZWV0JFR3JWNzdHci9QVWdtN2t6dktHUmUybmlQNkVpZSsxZmUyWUdJUUFtMCtHZVVsRjFBWitZdDZZeW1Pb1F2YkxhTXl2Y0NiR215YXVhbUZXcGk1aTNwZ29ZOVp1Y1o5ZkptK0ZPaUZuL3FIcXpxMHBkYWdCR0k1NTFXNXo1d1drMmVCSmlNNlVIbGZheVM0M0F5QkFodG9mUCtickZhUlo0RW1LK0I0OG5kZmdCV1dBVUNDKzFGcC9ORlo4Mk8wUkM3Tm15YzdZOWRYaUJVQUdiSVJBUlZtU3Y5b0hCdkZvaEVtTE5sSjA3YTZ5NkZJVVIyR2k2NlprOVgvUzVwd2VJaEJoMGw0bFprenFrR3cxczNFRVJYdXNhdlRSN2UxTHVRdXdGYmRjN2RVU0hCeTdLSHhSOWMzSmVMRTZiZHJzUWc4Mm5ydi9Fakk0d0FKUHRvRGY5c3BjZm5GYW5oU2VFMHJhdzdOcTdMclVCRS91SG91N1pjOW53dVFsU1Frd3VsenJ2UCtidUx6djNtdU1vREVSaHRJQkFTSUlOOVpqWi8xSkhHWFczSWd2YkFjZnVQL2ZzNGRNdFFNbVpyZU9RTHRTSVU5NjF4Zk1yMmIwbGVNczUwQ3VBUHBmZHZsaHptUXN6cEk3YUdGazRydmJONlNZRUVJREpOYmd3T1VKNG9pWnV4bWxIajg1RGJ6bmRpQUFDY1BHSHNpdU1MbVIzYXVKdUlweFU2ZVI4OGpjS0Fjei95NnRVM2NacDlxQVcrbFhsaVg5aDl4Ym5yeFFDbUx5TFpGZDZZWEtPaUs0RE5UQ1ovS2pmbmdzOGVnb0I5SStDN0xhUzZwNnN5UnBjVFY3VnZ6bmRDNzkzVGdQYzF0eC9GbjE4NitUSG41a2FXRXdDTEZKUTM3SDJSZ1N3QThZRFcxZmNuQVJzb2ZvR1VkbkZhY1hEbHhnOGdMdlBSUmNxcUM2Z2NxSHFScE9Jais2ZTMwM1B6N1FIWVBZTnR5NWtZNk5IdklMMnlrN09udllBZEs3OGJjcUo2SnE5WGVtY1NnNm5GTTNlUXZzQUhqNVVyN3FRdW80cTYwVlZKWXVUVHU5ZWJORUJ4b0t0NHpUSlVSbW9za0cvU1E1TElqMCs4MzF2N1drZlFIZXVPazVsSis5RTkyUVhxdXlxUDhxbjcyQjdhL1NYZUFEZGZUMDhkYnh4Z3VUcEY1dXByczVyU0hJKzlNVG4vWHFoR0lCaGpXUzNSWlJHOThwM2xjTVREVlJxYjkwelVBeEFmMmpyU3FzTFNOL2czY292dGJmTkZBY3diMnVveXRicG5xSEpJOTdKK3NwdVRwa29EbURrMHVoWWNqUm1wcXFjYVpxSUZneGZLcjB0K1lnSE1LeGJ3WVVwR1NxYVlKNnFZdE4zblA3T3NIRzBQWjRwQmVESzhlaVlTNzRhYUk0eDFkU3g2YnNrN2ZCSEJrbUhCM0NWMk5RVlhwZDV4aDFWTkttWkZiUlhFQi83Z1ZJQWVzZWZyVTdmWmpwUlJRLzdwdS82VkhweXB6U0FtL3hLZFdwbXRsQkY2MTk3VWZ2bzNGN0pqZElBNWlDODA5SDlZOTl1YzF5RllTZ01Hd3FsbnhRU240VDlyL1JLMVpXWVVhZkZLWmhmNTluREs4dFdVaFRkRXg1N2hMZC9mR05meTJkRWRUL3VHOTBNZy9ocEFuUldIbC84dnIxd2t5VkV0N0NxdWhnS281c2hOT0xtRE9oYjBlYmIvd3dYV1VKMCtialNqWnNNT3YwYnp1TG1sdld6YUZRKytRenZOSWtPajdmWitVUTNTM2R4Yzg5cVlHL1BIbC9vWlJsUkg4cS9qeHZwWjdrWEw5V1ExQ2lhMk5NenJYaEUxK0F4NnRRZ0RaVTRhYUloUEtmNFdsbEcxQXptNnFLUjJpQzI0dVNVOGJSMWZNdlhsbUI2a0VOVURXSEQ2TFFBOGxtY1hDWUZVQjdmK3Z6Q3d4d2VjY2tMNDlybVZLT1dBS0RUMWUrb2lWKzB5S3IyVG1KQjFLM2Y2YlFNL3N0M3R5bWU4V3FmK0E1aVFWVHYzTndzRDVYYmJRVnZ1TWRYaXdWUlBYNWJuUmJCaTZTTnVPZ3ladDd4aFovaXJSSVRvbXYwamc1djVNNHB2QWxMMUtjK1BZb05VYXY3RHJyWmRQSTZhc0pFZ1kxM1BtM0ZocWhSaitnQVZTendPbXYyR1FXMnJHODhpQTFSUFVaRGRGb1NuVkh1SzU5elVVS3hUYlkrWE1XSzZJSU5CMTJKNUhOOGIxSkttTzFZWCtyRWlxaURRM0lXS2JYaW9KM1NrM045OFJXT1lrVjBoRU4wSnROUkhIUTUvZVJaWC94RmgxcXNpT3BCVjFUM2o1MDd5b2tRQ0lJdzNJaU9DR1J4aGE3eS9pYzE4VUhNWm8zYjBETlA5ZDJBaHorVmRBQS9CZ0R3K1dvVmpNUWREZUxEYkk4VG1kQnc2TEFESjh2WFhZamQyZmpjSDY4djlEZ2lJMlBSdVIrTERyZTRkRFdPbXNSLzZveWZEL1k0a2NHM2RhMTRRL25iK2xRaFBPeWExdWVoSTYxSWYvVkswZUUvdmFYckVlRjUrV0d4Q0pFTG11N2NqcytXN2dWaEhwVHk5eWFSbVUyYjI3Rll1b0U0NkdSOW1DeENaRUpPZElqaW02V2JTWnh4OU9qcGE3RUlrYkw2eWVod0RHZEx0eENudVNNOGZnaCtCQ3ZTWFhHd09MampoQW9mb1hjclNTSkpvRDI4VzR6SWdveVJpK09XSDU3elI5UDZzRmlNeUFVZWdEUkVlbmk5ODBhcitpYUxFUm5iTjhkdjZDMVpBZStySGQ5V0xFYWtiR2pXSEg5RHNXUUR1R3NZWVB3dEhKSHVBOVdMKzJMUERuSVRobUlvaWpxUUZBSUprSkwvL1pMOUw3UVNnMXF0VUlXcDQ5RTdlN2lqcTAvMUV1eXNMd212cjk3RmkraDVlSnNWWndZSmRvR2FWL0xUZjlYM0hXQ2R4SXRvcXRIQnFTWDNsNnNFbTZCdnFlYTlBRWZ4SWhwcVdIUHFnVThKZGwvVVpPYlhpeGZSc2RTU2w1ekJuQkJlU242bEV5K2l0bVFtWnhCOTBIZXpoWmViMzA2OGlKcVNXWnhCMlV1b3JrQk5Zb0hGSHg1Uk0yZjJabEE3Q1hXb1VKT1huMDZOZUJFMXQ4emtEUFFvb1U1NFVKT1RvSTdpUnpSb1ltNEdPRXVvQVQ5bDVhY244U1BxTmJFNEE0d1M2ckxncWEzencwSDhpRDQwUGJtSDVTcWhiaXRNWG9BVnJmZ1J0Y2dwRHIrc2s0U2FWcGpNQkZ2eEk5cnJscjdZdGJ2VmhvRVlpTUpyeDdqNWNaekVUcnFhZWY4SExSVElFcUMwVlZYNVpqN0E5d0lmV0pEc1MxeEtxSVhXSkJaNDkyd1RSUHIxUDN0TEM2OWJhVjYxK2lzMDF6WkJwTHRhVEdxZjM1OWo3T2xLZjZlRnFMK0R1WGlJblA4VW5ua3g5blJsZUtjMWVRRmlLaDRpSnlUMjFpRDJkR1dzc0NZdlFCNktoOGdlaWIwMXFKRUxzRzV2c0NZdlFQcW1FQm1aR0Z3RDIzZUI0UjBBeXhJUW5zaUlwTmhlQWNmQThQb1RZZWxxdGVwN01Jc00xZktDYThDcER3eHZJbXdEZUF6RlEyVDNnRzBBUEVlR045TzJnTlUzaEVpL3dyYkFTMkI0dTVsNHNqeGN1dUloMHQyNFVYaTdFbWE0RUEzU0l1UzErSWhjTmdydk9wUXc0NVg0bHNYalhIeEV6clE4ZU9JdGNJUCtkaU4reFdKd0tqNGlFNU5hZThVbGNBVzJYd2lmRnFHblNKNktqOGlSRnVEbHAvMWc3MjVURkFhQ0lBeTNydXRHVnpYSlRHS3E3bjlRWVg4dElDQkZReVBVYzRPQmZtR0ErY0FiMkliRU5UUWkzeHZoblVOamRxTGVtZzdzaVVQNzJ3bVpIaUY0Q28zWlFPaXQ2Wmo1b2VObElXUjZoTUFRR3JNZlFFOU54L1VTYWE0clVZRGJNVFJteHcxNmF6cG1mck56ZXhBRktCL1ZOUHQrY0NzWjJsdWt1VzlFQWE2SDBKZ2RxclpwOTBnemdpaWdYNk0zKzFxSUFzUVlhYWFpOE9RM3hzejJ2U2k4S2RMTS9MRHd6SGFOS0VET2thWVZoZGQyOFRuTTRUazhzN2tvdkJacGVsRjRjNmpNcHFMd2VxUlpYb2JIUHc3dlAzTjRTMlo0TXVqQUtWUm1JMUhneWM0ZG1DQVF3d0FVN1FKYUQvVU9zditnTGlDb3RFM3Q4ZDRPbjBCTGtocmVvQzRiRnRDaERnNHYzdW9mWHI0NTRTRzhhTEdYYnZaemhJZndZaWpod1RXU0NHOCtoSGVVYmc3aHpZTHc4dFd5RUlRblBMakVFTUlERTA5NENNL2pDdFNsd3ZPZGdQQ0VCejdRaFllSko3eVRRM2pQbUdNcklMeEVyWXV3Y0lzRTYremo1V3lndzdaK2VJLzR5cC9lWE1ITmxVajBPTUY1djVJQTUvMCtUSS80eWIxcmVDLzI3bWFuWVNnR292Q1VWa256MTNDaElIdmUvMEhac0loVWtJcGphaUhtMjJWL0owc2YzZFg4a3VpZ2JjTHdkTUs5a3VpU3RLSWw5VVRSa3FaTVY0QW8wNlV3WlFGUm1QSWZwcGhGS1diLzZ5bm1wZWpuNFQxaVJEb3JHdDZDTkhQTjhKeG54SWowWG9Mdk05Sk1WM29GRG9nUk9kTXI4RzFDbXZGeHc3TU41NGdZa1lGZWdkY1JhWVpmcmRyYXR6Z2hSbVNrVitEcmdEUjlkdFhXN3NNWk1TSVRiZU9Cdyt1UnBtdmNzYTdQcndCZUVDT3kwRzdjUGtqUHhwY09hVTczeGpVdEYxZkVpS3kwSC9JTWJDZWtPYTRNYkcwL3RnTWlSQTZOdG9OSDhmbUlORThYK3NZSGUzZTNvakFRZzJFNDA5VlJyYldybGNuUC9WL29zb2dNbnRrWTBwUHZ1WWNYQ2trNmtzV1dnVHdBaHNVa2lxNWdjMlI0azZsc1FKMWIwZ0EvRHhVL2Y0UjJIUUxER3pjS2ozZmtBYkJyS243K0NPMFNHRjQ1cThvV3RKSUhRRlZKcFM5akNRenZLQ3JKK0o4ZHlBT2dtbXhCNVJRWlhtVk5ESzV6TG1zQ0hEY0tqdzhsOXFnd3FiVjNPcElId0ZuNVNWSloyd2VmMFNjRzErbVZQQUFtNVhlU0l2aDNKV1d4eE9BNitTMjBIa0NaaGJ1OEFPMVJLTkxkRW52cnhEVkJCeGp1d2wxZWdMWlFxSnQ1VXhQK2htdVFCL0RUK0VNaUVsaWgzYmNNajhPSUp6eUFuYkNMZk1sdUc2eDZjenlwdEI3QVh2Z2I0cVV6aFpvMHJiYXV0Y2FlUVI3QWlhUElLanBScURFanVLNjk4SVhXQTdod09QbklTS0dPN09qTm83M2p1ZEJxQURNMzd2TDZpLzVFcTAwU2krdlk4VzRKUUZtNFBUR25CdGhxOUFzUStzZmVIYUFtRUFOUkdKNnRxMWFyVlp1OE4zci9peFlLSlNDMjduUW5TNEgzM1NDUVA4Q0VFTytCVDhYREV4bm92T05Odnd4dkhDMVhUUTZQRXlHK0VKRVZuSTk1VjdjNldLNlNFeDdEWGkxS1pNdW5Pb1ZueVQ2dUtjbkZIU3hLNUkwVGVhNXJzV1NuYTBweGNXZUxFams1SS9MQ08vK0hleEhPQllERm9rU0tNeTRqdktNbDIwVnljODRENGh2TFlMMkp3bXQ4Vm9ON1M3YWhQOE1NdU1PNnRoaVJzUklBNS9LNHJTVmJZZG5rbXIzRmlPeEFmRms2UDQ2V2JFQnlidzEreFpQRmlMdzc3bkdSQVBtU0hsNWROTGttUE5ZVU9Uc2VZdS84TUZpMlMyWnhKS1ppOU9NU2tZdmpaMlMvL2pwczFxTXpDUUpxUlZsYmhNaFlpQ2ZZSjc5amw1ZUZuQWNnSXVxWDZIUkZaSWRwQ0RCSnUwM0l0dUVNQ0JmWEJFOFJrWU9qVmt6SExMNjFkQ3YreVNjN2Q1T2NNQXlEWVZnRVFnaS9KWkpzOS80WGJRc0xNUzJBWEpEWmZNOE5zbmhIdGljanJTTi9wVDNWQU5obk9kUEc5ZVhGKzhQVFduS0RIanZ5QStpT1NZeWE4UDd5UE9Cck9LNDVsYnNHOGdNWVJPVVhqY292ZmwvQzdKQ2JKbWVxYnF3QTZ5elhSZGVYUDJZaE45WVhONmZpd21sRGZnQ2JMS1psZkdWTEFWYjVkY0Y1bXp2UmlrMWpBTE5Ea2dkVXRKWXJ2SkVDOU9YNTVGUzgySWdzeVF1Z0Y2ZVgxeGV6OTN5Ukw0dUxqODZrZ2J3QWhzUW5FZkhkN3kvM0ZHRE8xbHlMNkl5dXlRdGdQSWZYUHI0czg1aWpjMjdhbkpGRFJ6NEEzVUg0a2pqcGZ3USthcHBOaVVwTytENVprQS9BUXRnMHlTL21VZE9zU3NpY2M1Q2VmQUI2NFZ0QzRqT2ZJNFVZUE9GSlJYVHNNWDJUTmZrQWpNTG1tZmhFNjZTeW9oQzlKcjFMYWppYk8zUCtyZ25RSGZraDhWTy9wRDJGNkQ1eTIrWU16OGtEb09QcHh4dnF5MkhqWVplYlJHZlZtU1Y1QUN5bkUxOTdMNDJ2N0NuSXBzUkh4OU5WTy9JQTJFMlh1T0hrSzFzS01tWTEwbURRR2RjU0dZRFpjZnFORzQyK3NxWWdTMG4xelgyeGQ3ZTd6Y0l3R0laZGVQdGRpQjhIMlBtZjZUdWthWmswSExkS3pmNzRPb2NiRzZVTnViazZDQVE5MlVMb0ljVnI4VFhPdm1VNk9mNnoxMkczekZLQkwzSW5Xd2czVWVYc3VuZ3U2UHp2c3JEbEo0a09CV1FrV3doakJ0RFFubGFmSGVESFNHNkdqMzBuWFNHcEkwc0loeVJZUVNwYTJ0UGo4N3dONzJhdm1nMkRyc0NHQzFsQ3VLQ1FpdmRQdm5tNWtadGpucDNXeXdMYjVFR1dFQjRaYUdpdklUN2ZHODk1OFp4MEVHaFloZ01aUWhoK3Y2UmduL2g4di9HUkZxMDRteGpWcVhobDc1b2huQVhiUkpmZms5L0M1R2lZbGVnc1VnY05mek1QRkVLNFpZWkNxbkp6ZlBOQWpzNzU5ZWpFQUJYL0JHUFhET0h3RUY1QjR4bmZtUngxTXU4ejZjQy95SmxxUWpnSmZ3RmNKcDllM3l3ZGVjS2NkeGgxNEExeW9ab1F6c0lGNzlyZUxPUXFOUnlPdDFTWFV1S2hJMTBJM1FBdXJMbjM1clV6a2F0cm5scXJBd1FhMXFwYnlZbDBJUnlGZndGREkyaHZyL3k4K2txdWV2UElvQTRWdkNsOVF5MjhFRTVJaWJkQVpiUW56N2YzajF3ZHhPV2REbHlwcnVoSUUwSTNjbHB4c2R2YU9lWE9PYnlrUmVjMjZncjBwQW1oUjFvWjdmbkVOL0ZoLzh2VHhMbTY0a0thRUM2cGNHaFBxdUZkL2UvcDlhbk96bTc4cE0zekVBNWpTbTNwUVN4L2VPVnkvMEp6RU9nWWVDMjZWVS9iUXVoTGVHWjgvTzc0cHQ3L3VmSjBkUUlWSzlIVnNsdmRhVnNJOTFTMHBXZlc5eWVmMWJsTVlrSVZiMHRxZE1WQTIwSVkwdmhKcWM5aDdaUmN6RmR5ZDV4YW92dlAzcjN1T0FyRFlCZzJrQUlrc2NPcDkzK3JTOFd5WVpwRmFjYUQ1NCtmZTNqMXVVb2x4ckxxRWgzOGoxSWQvVlBhSGorK1p3dTNNOHVTcVk2N2RXbDJ1VnRUS1Jjb0NqTHR4ZmdNM0s3Q2xiRjFqTEVqUkNUZlFFcXBCaW1TYm0rbEN1N1hQelBSOGJjdVVJcndoUVpJS1RVRWVoZkUybnNPSUtCYkM1L3FKdmJXRVI3SVFrb3BTeHRlZTFOOFpTajhUL1d6QndGbVdncVdqajkxU0hoQ0xieFRxaVhjRUg0YzMzaGxLcCsrWlRJZ3dhMnM2RGFGQitZWjlmQk9xUzdnWDV6ZDIwMmw3YTBlUkF3cm83ck0xbVd5OHg3UndGZEtHY0lUS3RvOWZueXJGZnYwSDJQck9OVzlKTGVtVW8rQW1FM3Z2dlk2RUZIUndxNnVQRHYwTzdRMW5DbFZXWHhIQmJQSGJHK2hDbVQ0OWU3cTByV0xzSUV6cFJyMDNuL1VYbUQvM2t2Yld4R0UyS1hzM1NEd3QrNnNyeUJTcWhyUTd6NXFMek44cGZuTml3TWhkWmlUNnE0RlpuWHZITllRS1ZXalA2VHBNWWN2Mzk0OE5yLzBhWWhSc3JxWEhpS2xlaCt4Yjg3aTltWUNNVzVtdk5abHFzdG10Nm5nb0ZUbHZNK21kOS91elE3RW1KRjFZVExXYnRmQ1FhbldPZWUvMTE3NGdmWkdBM0pDakU2b091OU9CamdvTlhqMy9mVDROK2RZZ1J3czJicUlXRGRtWkEzc2xETHVrS1RIbUwzYzdzWDZDQVE5cnA4T3VHUG44OWxaMThOT3FkNWZsdWZSZnpoN2RKVmVmdmtlSUtqNm1ha3JHTHZJYnVMa0tSMjhNNTlBMXMyWnZ6cHIwZkNTV3pNd3B1N2dQNmh1NXpwNFVhcnoxaFczUjV6MmZ2VjdxZTBra0YxNlkwWUdsQUl3em03eTZkM1YzdHlCcUdZcXI0Ni9kcEZyUVNtQTF0bWtQTW4wWmdPaWFtSlV4ODdPRG9OclFLbkcyYi9jdTAvU1k3YzNVUTBnZjJ1R0h6a3g4OW5acjRhTmZZQlNEeHVWekY1VW1sNUlMazFaanpsY29vdnEvckIzTGpnT3dqQVVOQ25CQkFpLyt4OTJpZFJ0MnJMaXFTN0lLOFd6WjVpZFJ5MUVsRTNNZnE5ZHdsSHBHSzU3cFJlNE4zNFR2dFVyZkc5YWtEcGdYUUpNekl3bnc0SVhOckI2dUh1eThDMEtiOHJ3Q3FRVFBOZ051SFdaNGwvTE02cHdwM3RHcUo3RXZiVlYrZUQwTzJkYWg3Mno1Rm53d2k5Z2NZclV3KzdOQ3l2OHR4bG1wSjE4WTJMdE5yanM1QmtWaHdEVXV6Wjd5NkN4dXNJQ3JBUGFBZXVBZGdsTG5nVnZwNTVnY1lxenQzYWtBTStpaVhtU2RnbDJWRFFXdkhiN0E5VURpL09UNjk1T3ZwbEpnMzdPcHdOd093QVQ4MGk3OEtkMmxqekRwK1h6cmw3QTZ1MjdKend4ekFNcGlUZUtGcWI4eVM2MHp6RHpqVXJGdUxVUERpWW5WaysrT2VlZVZLakhzMjkyZUdObWVLUHM1Rm53TW0vbUNiSW5jRy8wcE1Nd0FldXUxWTR0ZVJZOEVMMExzcGZkaS8vb1k0RHhqSTJKdFh0UVU1a1lkY3Q4c25yeFEvVjZVc0pGZ1hhbjFDN2pxRVFNMTNJQ3VJY1hwMXkrYVhTa1JSVCtudkoxN1VwUG51SDVqcWg2K0w2QXpadGlSVm8wK1had1ZldENlNkJkMHpSRkpzOXduRGw0Mk90dzlzUUhob2xKRFJmQndoVFU3aFB0RXA2S3hJSUgxQU9MRXo3dTRmQTVVcVBxa25YWGJjeUF0RXZVVkJyR0xXMmRGNEI1b0hvUzlWUS9KRkJQbDJpSGM5ZGtmRVZsWVZTKzJSQkU3MFQzSmsrS09QQlNlZWFIUFhQUmpSMkVvYURCUUI0azJmdi9YM3RYalZSclZhVW50YXVDRnM4L2pPWmc3bTFNWER2eGJ0amtPYW1jVEMvOHNYcE1MU2tIa081RUd6dXNYYzQ1RFpjOEQ5NEp6cDVkdllzUGhzZEVUY2tQM0RwbDdJVHZ0SHN5WHZJOGVNSjBYNzM3ditxNGUvOHlOU1dzaDFqWFFMdVRTT1BnUkFrZWlCNVNyMWJ0NUpUVFNpdktvYkRPOEc4blpHR2crNG9UOGdlZ2V2ckhYcjJUdmNkRWplRU5hSWRxQjd3RDJnMlhQQ2VXL0NQMUZvVjZ5TDFqWTJyTmZHeWIvdnRBZjFNUjBwT2hrdWZCVTBUdlY2djNXS2c1WmQ4Vkk5UDJnWkNGZE1JMEJnNW40ZUtwaHo4WGdIclF2V09pOXF3NzBnNWJoN1c3enQxSnBCRndZa3I1cm5yQVBmM2lQRmJxZ1BsVnZLclJibDVtWGU2RVFBUGdwQSt5VU5TRGMxblZOODZGT2lCV2RGREJFMVA3dGhONGtPUjU4TEI1d2d6YzA2bTMxMGc5c05xMFE3Rzc1eDBQWko1N2x3eUQwLzdhMnl0MVFWSWNWRkR1OEJmQ3EzWkRpT2R3RWpKUUQwVFBVcjFFWFJBcWlKMTFaZUxjaldTZUJ3OUh6NkllZHE4RzZvTmlHWm4ybGZsSm9IZkdDWW1acjlRcnRyY2VWay9jSzlRSlVmZC9zR0R0QktEZEFNbHpJak5yMVRNUFRuRnZqOVFMMDJiZm1IQmtZdTlHTU0rOSsycWVjRzBlVm0rNW03MDVVQy93WnIyb3FGZW1FSjhFZWxlY3dBS0lIcWllN2NTNU0zVkRtRGZOeHJUWFRvZ245TjU0OEdEMWdIcm1PNHNFcndmU0p0WlpjL2VmUFh2TmJSaUdZUUFzYVg3RmFlOS8zZTMzaEVFdDR3eWFSOTdoQXltN1llNzJsc2ZZVnlKNU1iMXhtZDZ6U3FMWThaTTdvTzFRZHZ2REl6eUFYci93d3VudFBhWkpwclRuRE5RQjdOeHhGN2piKzhxak96Tm9icmErc1BXZVhWTEZKbkRiWFQzdVBEdFQzVkVlby9ZVmI2K2dwMTVVZXovaW14K1NLLzBidkdNRzZvQ256TkNkcXU0cGorNGN2S1gwamxjWDU2TkxzdGh4dXJJTFIyYk1MbDZaL3dnZTRjVjdNNmFITDg3cENpOWI1VjFtaDg3TUxlVXhxcS9LS3l2bGVYcm5rSFFwaTI0N3ZPNDJoa2Q0YXV2cGpYZEw3NXhGOG1VRTZ1NWxaNm9ieTZPN04wcXYzTFkzejBNU3BoekJiUmV1VFB3eDAxUTNoMGQzYXVya3ZmYXBoMzdyZVh0RkVrYTl1eEd6QzlRQmRiY25PN3BidHpmeFcwOGxZOHAwWFFlTlRPK09kVWQ0d2Q1MDlJRFdDKzFWU1JsOTg3YnI2OW50NzQ3eWdGTVBhejFQenlSbnlnVFpyWGZIVUY1MThxN1JPNHNralMxZW1iRTdzcU04Z0I2ME4rZGhJc2tyejZzTDNBSHMvdTE1UjNwMkE3M1kzbGtsYld3QUh3Z2dPKzlPOW9YSDZCSjZEV205L0lVblV1Y0EyTVh1ZU4weEdqeHZMcVhuN2MwbWtycnlmbzBkM1ZFZXREZXh3VGxNTXFjZStHMVh5NkxyanVIY1hIN3FOVWtkN2VnUGdxODdjR1l5N0x6MTlJWks3dFI3VnliZCtWRGUvWHZURlY3YXlvdlo0ZTZVN2lnUDJwczRQUlhKWDNuZHB3SEhIYSs3T0N3OTRIa1RvRmNsZmJUSGJkZVdzYU03MGx0LzZubDdLdmxUeG5zanM0YnNjSGNNNWExb3ZTTDVJeHEzSGY2SEFMaGplT2tGOGtKNkpuOGhId04rVXltZjdKblJiUVVoREFRNTFod3YvVGVjQXZ4Qk1MbWNOcG9wd1dLMFhxTno3d0R6RHRTYm1hOHdtY29pN282MXd6dEk1bFhWVzRmZVovYm1nVDZGY3BlMDA0WjJRT3JWemN2dXBjRHo0Qm8vU2J0QjNOV0JxM0JrcVMyY3Q4OWJpOU9ieXJyZEFWeDdvVmU4YjM2aStUQm0wdTd0ZGdjY1dVb0h6cnNaRWJPZzNiT2ZkOENOUlJYelJuTml6Tk80TzE4emdjdzdQN0tNWm9VVzVXNnAzYmwzZ0hsWnZkaXRlbXBlUkNIdEhyK3FBRVZQc1pWNllUZU5rbmJadW5QdmdIMnp2SEJPdnhlbnRYYWhQMmwzZ0huVmZWT0dzM2l2M1FIbWxkVEw3am0rdVg3L2F0elZ2UU0rMDdzcW9UZGxPWXBDdTN2SU84Qzhya0xUNjgyUmZoZHVtUStjVlFEekt2Zk41SjBOa2F5cmJwbHI3d0N1UkQ5Wk9PK3dIVVFzeXQydnRqdUFFL095ZXI3dlRpWmJKdEQwc25qUmZBbFQ3NEIxTTV3Zm5qYmEzWHQ3Sm5CanllcXBPU05MN1FEMXdud0lJMmxuOEhjSE5EMzN0OWNMWCtZdmV3YzB2U0g3RVNUdFh2WU9NRyt0M3ZCL2ZIMFJkMjk3QnpTOXJGNXYvdlFJT1gwaUFPYnBYd3hBRm1zbVVQU2tGSGpPOVBCWU00R2lKeVh2ZkxtMnZmdG12d3hTSUFRQ0dMYnQrUDgzTDNnVVJ2VGkxSnI4SUVBb1hTWUFwTGR0UXkzNmNXc0hQTDE1ZXFxeGY5RzdBMGF2U042ejdOSzZBOHBUay95ZTNZTHVBSFF2UFZYSmU5Z3gvdzdZdkhsNlplNSt3ZDRCbTJlMXVSOG1UMzZ1T29Dcm82YzY4L3kxQTFiUGhlYmgzUUhsRFZlS3AzY0hiRjZuZUhaMlFIbWw0dEhkQWVuVmF0dnlzdXdBZEpxZWVyMmQyaDB3ZW1xMnp1c09LSzgvdk5Uc2dQUlU3WnpaSFZDZXlwMGp1d1BLVTd0em9pcFFYcjl6bmlwUTNxK2ZDRkdBejUyZU1GR2d2SC83ZFV3QUFBQ0RNR3orVlU5R0R4SUhIRDJZR1h3OUtMb0RpdkNBMGU3QTdRRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBSGhaQW42Z09pZHArZ0FBQUFCSlJVNUVya0pnZ2c9PVwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/img/dist-light.png\n");

/***/ }),

/***/ "./src/img/dist.png":
/*!**************************!*\
  !*** ./src/img/dist.png ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/png;base64,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\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW1nL2Rpc3QucG5nP2ZjMDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUNBQWlDIiwiZmlsZSI6Ii4vc3JjL2ltZy9kaXN0LnBuZy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQTNnQUFBTjRDQU1BQUFDbXNMcDhBQUFCbTFCTVZFVUFBQUQvLy8vaDRlRzV1Ym1ibTV2Ly8vOTlmWDF2YjI4Ykd4dFFVRkJIUjBjNU9UazlQVDFvYUdoQVFFQmNYRnduSnljeU1qSmhZV0VwS1NsV1ZsWXZMeTgyTmpiLy8vLy8vLy8vLy84akl5TWxKU1UwTkRULy8vOGRIUjBoSVNFYkd4c2xKU1VlSGg0Y0hCd2lJaUlrSkNULy8vOFFFQkQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLzhXRmhZVkZSVVBEdzhaR1JrUkVSRVRFeE1TRWhJVkZSVVVGQlFTRWhJVkZSVVFFQkFVRkJRUER3OFBEdzhVRkJRUER3OFdGaFlRRUJBUUVCQVhGeGNSRVJFU0VoSVZGUlVURXhNUkVSRVhGeGNWRlJVUkVSRVRFeE1PRGc0UkVSRVFFQkFJQ0FnUUVCQVJFUkVRRUJBTURBd1FFQkFIQndjUUVCQUVCQVFRRUJBUkVSRUdCZ1lPRGc0R0JnWVRFeE1TRWhJR0JnWU9EZzRIQndjUER3OFFFQkFEQXdNRkJRVUtDZ29FQkFRSEJ3Y1FFQkFIQndjS0Nnb0RBd01GQlFVSkNRa0hCd2NIQndjRkJRVUVCQVFHQmdZSUNBZ0NBZ0lkSFIwYkd4c0ZCUVVEQXdNUUVCQUhCd2NKQ1FrWkdSa09EZzRMQ3dzQkFRRVhGeGNVRkJRU0VoSWZIeDhORFEwV0ZoWWdJQ0FnSHgrcGRwdDBBQUFBZG5SU1RsTUFEUTRSRlJrWUcxWW1LVEV1SFNzaFFEZ2ZQU003TXhZWURraEZOUkpQVEZORFRsRktSaFRaRUFZQ0N3UUpkSGYxV1FTWHQ0ZUNzWXZvay9ydGovRjdDZHhmNUtKK25hdGxhZ0tuYmI3Zis4akR6endaODlTZE5TM3RTTDhtRC9ZeFlSOFRpTjlMMkpaRDFYUDZlSVhKNTg2MXJZQ09YbmdPOGdBQTl5UkpSRUZVZU5yczNPbFMyekFVaHVHb0ZMclNoUzZTMnFwN05iWmwzLy90VlphT2ZSd3ZrSXhpeHc3ZjJ4OWxKc3JBTVBOd0pJdGhoOVpjVVpaNTVaelFPc3VNc1ZZcTZycEpVZEphWTdKTWErRmNsWmRsc1VNSUhZV3Q4dEtNUjNhZGxzZG90S2daN2hCQ294VjU1VWEwS1NWOXRoNW5ZYUMxaVppbXdrajArWlhTcC9wb2E0T2VJT1lnUWdUT0NXTlZ6NXFIVmlNVEtkVVlhNG43Q3BVMXdnRWdlclNWdWROVzduRUwyc1FzZVlOMmJ4QktxeDMyb09neFZWYkNzRGoydGtRNkN1VFBiblFGZnVqQ0t5dHRWRHZqMHNDbEE1VDhwWUFmdXRCeWw4bnUwMFl0MXBEdVBzK1JtY3QzQ0YxSVJTNk1aSExyRUxkZmg1ODBBbzllME5iejVsUmpiaTFUN3A3cDEraFRCck1QYmJTeTNWdXVkTXhORDcvcmtOVVZSaC9hVk8yZ1Uxc3l4N1d6VHhtQjBZYzJVUzVzczdmTXhJYlRtV2xHSC9DaGRlZlJiWG5Ralc0OEZmQ2hOY2ZvTmozb1JqSldBaDlhWTZVemloNmppSXRNWjRUUE9GeTBvM1ZVYVVtVDdqSzJsL2ZnaXo5ZGRMVkQ2S3dWemdaMDhrTE9kSWMrN3JRT053M29YT1ZhTG4rb2V6S1JXQ3pkREQ2YytORGlGUldkNm95WXJ5ZXBpYmt5TXQ3eTRZb2RMVmpoTEkrNjgyRzd1Z3IvbmNsZ1pySHBSQXRXQ0J0SG5WN0MyOVZJVCtrZmZ6eldBZ0oxSEh4V3dCNmFOVlkzSjdnQnRPT0xKdHRtQkJqdFNkaERzMVVJU2VwbUVYY3Z0WnVERzFVNFRSRDIwS29yM0tsbTNUUzRDV25QUnJzTmpiODI0WERhWDdvOW5QZlFERlVuVVRjbGJzaU5lVkYzVFc4bnVtdTc3WkVjRXB6eWR3cDd1RnhIcHlvMzZlckd5ZlhBZGJGMWxIMmtYanhZczdKanNZdXdCM0NjWDdJOWcvczlsRjZwVmJnNVNESTNUYTREanJpUk5YYjJzdTNOQS9GS2xrZ0tpV0FINEJpL2RIMDJmTGMwZnFFVHBSL3NsTlVuTk5jWHgrQ1lXOWZaNjZaWEI5UXU3a3BrZ2d5dzcrOTArclJWT082aGxQS3NWaWV6VkhSc2JraU93TEczaUkyaGZhNzdGbnIvWUhGZGVBdERqQWhaSUFIczgyTjl5Zmd5cWJEbFJDbDNCOUtjM0Z3cjdpNktZM0JCRzJGcm5IMktmV2g2TjFtN2hON1NTQXdJeVNBRGpQN3VXbituMW1ja2JoalE4ZVdHdHBpcDZJYm1pQnlKNjRLTDNBZ2JLL3ZsK3hyNkYvc3lpRjZJcStyMWJERWlKSUlkZ09TUCtBMzBwZVBURm1NUEhUbnNWUGp6cnVub2h1Wm95akU1QWtmZVNGdWtGbzM5OWYzdy9ZNTluNGhlcmxmVzc0Z2FJME15U0FJSklQT2o2VGZVbDR3dnE4ZWV3dGhEY3c2N1NYUnNqc24xeEJHNG1odGg4MzZDc2orK243N25CMWV2cnQvbExRYUhoTEFtU0FCNy9wZ2Y2NXZFaDdHSFpzbnh5UzRWM1kxdjN4eE5PU0lYeERHNHlJMndzYlQvN0p4dFQ5TlFITVUxdmpFeG1oaGZBSVpwUW5CRlFRYlpScmVCRUdDeUdTaUJ2ZkN6YkhSaHZ1RjdlNS9hMDMvdnZiVjNGZVBHUGRFeDI3R0gyQi9uL005dE9mdlJPT2owTGk0SFlSVGRqRWJCYWJmYjNlTzZFeEozMmFicjA1K2ptOXVvRlY1ZTlEb0hqUjluNEZCQktCRWtBQUkvN242RVBsaGZGZmd3N1cwLzgvS3lyOWxwWmxjZE9zSWNrT01leDRnVERpZUJBMjdEM1hhdkgwWTN3Zm54M2R3NlBnOUdVZGp2dFhlSFFGQUN5QjJROFVmd28vUlZoayszUGIrMjUyWExtTzVtVndpZE1EcVpMUlZ6UUk1NW5DU09PNXdDYm5qUzZiZHVncU83djY2ajRLYlY3NXdNRllETUFSbC8wditBbjZCUEpVOXBmY1h3dWRtZVQ1eGVCUmx6clRKMWdFNFlIV1ZPdXB4RVRsaWNUSk9OYjVmUno2NlptZnY3aDlsc09wM0c4WmhwTXBuOE1tckN4UGJITVh2b2JQWndmMzluVlBkbk5PZ3hBQlYvR3hzY1ArbCtoRDVsZlNKM2N2aXFzN2ZtRTZlWHFjZEV4dnpiMElFNWJuTWN1UTF1Y29LNDN1QTIwT01rWTAyUUJzb2NCQlFsaDdNSEhjSzkwOXRCcjNHV3dZK2JIK2pMdy9lNkVueEluTDdqOU1wb1p3c1pjMDdxZE9oZ2RJSTVNY3pCNXM1T211R29hK0ROZ1RZM0NHTURnZDFSMkR6aCtQSHBUOUQzU2RFSDY5UGhjMmVQSnM0dFAreDVZYlNyVHAwc1VnRGQrcm93T3A0dE9YUEs1dmF2dm9Xakl4TndCQlFtOFJYU1dNb0oyOGxHK28wbUFJOUc0YmVyZlc1K2dqNlJQS1gxcmE4RFBsRzQyTm56dzU2WEczWjFqSGFPMUNGZ3d1cDR2QVIwd3VpVXo3MWt6RFdhcllBaUo0aFRzaUUxNXBwb0dpZWFsTkVmK1F0YXpRYWhqMWtmNE9PeEU4YUgwT25HSG9hOXVrZnZTZXZyQ2tZN1orcW8xYVV6blE0ZDk3bmRablJ0UWM3Q0ZCU0xZb1dBSmpkakIzYnhHenhJYkFGN29EcmhqK0ozSFRWM09YMDZmT25NUjR6UG1UME1leXYraXRrbnEyM1JxRlNnRGxhSGZFbWdFK0Z5MkJrRWR1UUFtcFU3OEVXM21uYmdteUc3TVhJT0JYNVorb0t3TXhSekg0RVBxUlBHTno5N29tZnhGZWVURk1kdXhRMDduVG81MVRHclUrMWxDcDAwdXBlN0Y3ZGR5aHdCenFaWUNmZjFoNGkva0FacW5Lb1VnMk9XUFRPMXkrMUZJN0UrQlo5cU81bnhpWWxQWTg4VnZSV1AzbE9Vd0s1V2xUcHFkZS9ld2VuNFJOY1BDSFB5ZU9lM2xCTTlOQUlaZDhXNnlPNUMvcWozQlpmZkpYeksrZDY5SThaWGxiMmFSKy9KeVFFNzJtR2FxRXZ6WlFhNjc1ZUJNVnVPUzJaR3c2YWNVNW9ybUVMeVlJZDRTdHdCZk5NTWZjSGcrejVpWjVJNmpleTljR2F2SmhiMm5uazlFWW5WOHRwOFprZXBvMWFuaXBSZE9CMk1icUtGU0N0amtLMld6UDJiMzlYVHE1azZmU3NsRWZSbDRPdnZNdlk0Zk1UNENIdlM5ang2WGc3WVZhRk9UbldwMVExN3Q4ZUFMazZnZytLcGR1am5zQ09zT2F2azhHajN4QW5lUVR4TnA3N2oyOTR3TlQ0NThXSGdzN1BuMGZOUzJuYkZqZzUyZWVwZ2RheEphWWZuZWVqeUxXTWNUNFdvRTFWR0RyS3ZBSnJCVTI4bVZudDA1MFBsY2g2MjJZZE02eGJOOThpNDU0S2ViemlYWG1MZHJqYXYyY2tPVTFIM1ZsR1hXRjB6eU1aTHU5MU1FODl6WmM2ZFAzVXJsS0dQWXFmSXk1ZWdHRXBKNHhJMEUrTlQ3TDFWN0ltZWMxN2JxL2wxdmFYVzU1V1NsWW85WWxLdlN3Sm1ZM0FONkdJU0lHT3JDRzVBNUhHVkdUYkhDWGlXM0VrTDJPa3NYV1FmTkpMUVNYM1BIam5MTlp3ci9teVdwZFRuT3R6T3dleEl4QlFkSnFnVFhVbzdTczY4Zk9EUUZlTkdTOFYvRDU0bGQ2YjNGWVpqazJCOFIxRmJMRE9BUGRGemtzanBhbnUxVlg4aTJUSnFwOGF3cXp0Z3AwZk1OMjhJZFdLczZ3VFpvWTVtU2l0MkJMVXF1Qm1lWlVKM2F0OWhZZzhRRXNHNkFTSldHb0lPKy9pRVBWRzEwTWhaRWoyY3pWTHpWeTRzbGI2c3VXRkh6VTVGVExRcGtycjlYb1k2aERKYVdsQlJveXZGRmFReFpEd0h6Q1p3YVQ5M0JyT2VMb1B4QmIxOXlSNjZGaFU1cWUwNW9iZm1yOWRiSGozSEZRaE8yTkdJS1ZiSkRkVHhnRG5ScUtQZ3BhZU1hQVFaeVNyaXB3Z3dqYWs4ZS9ubmdnQVdSSWRBQUlwRnZxREoySk5kaTFoYnA1SFRCVDFjdWVEWEZwWkVYM2xudHVXYU1ZMW05K205YUZOb3dzeUlkUFQ2c0pRSHJKZ2I5MnQvSVBxeVpobmVnZ2s4d2g0MGZjaGtUcm00VG16UE9YRUN2VlZmY0M2QlB2UC95YTBxWnZmcVZUclliWHhnMUIxRWgvQTZJa002czdvV2hPVStIUnhva3V3dDVsQXRnQmVjbERrdVNLaFo0MGJ0U2UwYkozd212bmNZSFREMlBteWs0OTZyVnhWc2IydlZGNXlMTDNRcWp0aFJzMFBFYklUSGhMcllxakkrWmIyTXB5eDRsdENxblJOTnRwZjFTcEtad1o1Z01wYzVqMXNueWJoSGJNK01ubTlabGwzODkyUTZZRWN5cHB6c1NNUWM5czlKd2tRVmtXOVNpbzV3aTdGQkZxK3lUNFE2Zllibm9JeVRoOWo0STU5TU1ZaTJOdGUxZFB0REVqbjV0RWNUcHdONi9QZHdQdk5hVUluaGJzMFZPMlJNbUIyUG1CanNRQjBkaFVxWjNkaEI2U0JXZnRVaC8wTDBsWTNYOWNGT3FlRG5ZNW82TWNEQzl6RHVmZGlBN1NGeHNvN1RCYjAxZjhuUXdtcW5qdUd1REhaNnhvVFpzVXNPV251WlUxUDRId3JkalAwdGkxM3gxUWpWbDlUSkdLblpJRlRzejJBVnVkTmFkRTRmSkh0N0xYWWhBMnlQSk02eTZHSFVxL3U4dVhBcXRYSm5HKzFVb1FLenV6aFB6azNST3o5VDhWZmtkZmoyeDhFT29zK2dvVmZpYldEQXhPUHhnWWxTMnp1LzBHeFBHL1pLb1ZmenEzcUxKM0dsNjN6WXFZekphMHhsZGhIcUZCdDA1SElEckFUSUw1UTdFM2hBN1ZGVnNISSsxcXdQRDZObXJRd2UwdG1McE8ySmtyTUtlbldmTnhkTE8zVU1kdzdZaWRFT0dYUHpJemU3M25XbVRsSEVnVG9jZWhwM0pzV3h2TEZaNDYvSEZrWEs3bjdtTVJGVkoxV21nVkZWeTNXUDI5N0hUU1JPTWV5VlJ3K2ozb3JQbTRzaW5qSnJidGhodEZNWjgvMG1yekd2d2oxbGR1a1ptRG1aN2F0d2RROUh0eVlUSkpEMXRFczZ6bVdEcHM2eWNhRWViL01QOVNxNnprVHdQMnA3aCtFVkx6azMzOHZFaVdIUERiM2FxdTgzRjBTaXk1d0RPL1NZU2Nac244THNOTzVJMWE0VjlUQTQ4eVUzRmxrSTBlRXk3N1Z2QjR0L2JGcGpXUjN4R3hONVNKeWdiamFia1I5RHl2Wk8yMG5peExEbmpwNC9sV1VoOUtXR0xuTWU3R1NQS1FxVnJzSU84TWdEalVseHB3OXFlWmN6alhURmtHQm5mdHlhVkpYOUJTbFZrUGErOFFIUjUwclJkUVpsZTkyTGZaWTRaY2ZwaUI3dE4ydStaUG0vdFkwVjh6bXdFNk9keUpnL3drT3R4c1NCTmpWYW5YYmsybnVVWCtVb29EN3FSaDU1UlYxMjc3T3pSNFdmUklteTZDRngvbWJ2WEh1a0dhSTRUcndoM2hCaFRWaEU1TEh1eE9YQld1Sk9oTVMza1RXWkVVL21lNXV1cXU1Zm5WdDE5Yk1YSy9wUEZ0TzE3T3I1elRubmYwNVYvNXd5emxUc1dmUm9Mc3oxMDFlVDVRN3I3Uk5NbGM2K0hkaVY5c0dRWTM3Lyt0U3pzODBEdUROR1BHbVlYakZIaWZZUHJRZzVpN2hiSGpZcnNPSVRZbGdDZVlROW1YRysvdjJRY1piMlFnTzkxV1Q1citwUlRKV0h3cTZVZGhmZkZrTkZNQWQxK0poV1pmVytXdEhMUnhzOGFZWWdEbGJwMko1Z09JeHhCQ3QrWFcvMHBmeTY1QUtzeDJqNTlxSVVlOHZSdzJSWjl3dmRVYVVUVmE2Q1hTbnR2cEE1NXRhVDkvNUQ5WW91NEpCejBRNXJNcDlpRlA0SExJeUE2UCtZeEx4MjF2bm5Gb213bCt2Z1F6NHNJblhWcjRUZWVpckwzZFJtemxUcHdlNm5YM0w3WUMrck9vS2RuM3JaM2EvdEhETWVHL09EV3JkczJGTWJqOXJ5eHR0czZIT2l2S3Izam44eEh1ZjVqei8xb05jeVdkYk93dDFUYjdnVDdYS04zYy8zUzJsbmlycjlvS2hmenNyNnJla2tjWEcvK3ByUFArb05zMWJORFVMQUZJUjdVZTdaWXUvK3p3bzkyVkpmZzk1L1R4djJtTTlabVNGMjc3NHVTanVaUElHZGZaQ1A5NjZVSWFmekVWdm1mSlFyaS93MFpzLzI2K0xSbGpqc2VlVFpydnJyN3dib2RmWVd6azdXb0hlSDlNWXd5TjVkM0tXWlRJUGRlOExJQkRyUHJhTkRGNDJOdFVNTUMyOTNabXpCdmlSL25YT2FESDZMVGpqSkVRUjY3eG4wMGd6bmZLbkgrT1lhOU82R2h1cHVzNnk0T3c2SEJkZ2R4WnZIcGsxb0s3Q0R1bzZLaXJWR0RpdlhDUjd5ZnFxWkRGU1NsNytpdXRyYm95MGF1d3RmQ2ZTT001eE9xYmRXZW5kZVErL3UzbkpQSmJYTEZYWmkvTENXeGk0Y2tkWUhMN2d1VE10MjZUbmZENmxXQXFZbkwxaUtWZGxuR0d5VE44aWRqNWI5aFNMeTlIMWFleEJSTDdmVUY3c3M5OWFlM2gzUW80UzcrZUlPSzlQQkR1UnN1TnVHMkRsaktiYVNjOGRjdXNDVEsydkNBTWpxTDJtTktrejdmSmV3ZitEMldPcUZOTldGdGdGNkdKeTlwZDVtN2VuOWkyTC9UM2U0dzFONThXbGxxUnltaVYvOVVlMXdsOVlFRGwvc1hLSVFHTjhMc2MzdW1EcFJYbW9hMi8rc3pKWlc3ODRsajRWT2tYd281RTNvWWJNOC9TSXVTMi9RTzFsM3AvK3Jlb3RSbGI0c2M4VHUyZU5NNXN1dld1eXlEdHBTaWNjMS93amxqV2t1Vk9mcGZDd2dRaTQ5VkZQbnlFYVJ4Nmx5QW5VeDYzQTQ3QTRIQ3I3RDFGeElNNXpQanVoMTVKdFVldXYwNXI4Z05pS2NiQlo1S2s5a0t6T1BRai8rMDQ4Rk83ZzdETnFCWGFPMmExS0h1cGh6cDdzUW9jOVRmWVV5RS9tVXdsM1lhbFEyTHFZUUM3YW13U21iTEptNzNWRURlQ3JxL2ZMTjQybDh1aGljaTF5V3pjbTZaZUhXUlJPaEo5eVZ6bDB1N3BLVm1iSDc0SWR6YWFuazkwalNmbS95eXpISERLWlg4Rks2RDllYzlUL05FUGFNSU10elJ2cFBwWVlySzI5T0V6bVB2Y3dCYjNmOFFob3hOaGZlLytFRDBDc3VTK3JxOVFTOTA3V3hjTXVpWjc1WlhOd1ZUMlVZaGY1U1lRZDNCK1ZqYmxrVW1DcTlUK05DaTg3NGkxVjNIQnIvYXZmRnVVbk5XR1prSjBhUFBBTHlqaHJQaVBoeUdKL0daVmxVNm0zV2J2cXRpeVpDbXp1OFRPV3BmUG90ZlR1Wlp1YjN4NVoyM1RZODNhZUJYUWQwck8zbGJrR3JycG01TW9RWjB5ZlhTaEhZcWVlUXJZcW53cm5BSi9wNjMzNHNYWllwMzRTOHRiRndaL1FPRTlHejRhNWttV054TjJEM3lkY1dPejZXYWR4dEdSeHpEYzZaV09kbGdWNFZlTTN6bXBHdDJkRXM4QmR6cG5RbzhHUGFRTE1IZVJLOXI3OGYwRXN1UzJxb3AzeHpMdWpoc2F6SFF0eWV6cHBwcGpGVlN1ZXVGSGZGeXR3ZFlNcStLWUw1cDRpNW1MclFlMEZ4Z0x2Nm5IUjBycnNPWFIwUlVzakZVS1FHK25YK0p4ZUIzdEJiS0tYZWk4OXBmM00rM1R4N1pOVnRpRFJ6ZVpZNWVDcmY2UTRDN3dVUjJGU3dvK3pUUnlzSEdBWEQwUUYzTnoyd2FlbFRnOTd4b0dZeFppUnY0SVdVMTJLWmxEbG4zVnY0Ym5CWm12bm1tbTcrMjNxckk5eGhxcEJsNXVMdTRvc0t1LzNvcUZENEs1bnBGYjBaS0l4MWpxRVJJSHBMWTlMeHRnUFVxRExWV2hjdkNQT0NIdWdOSGhiL3QxUFErK0lpbDNya20zTW1DMEZ2YmVuZGhvYm1YVmU0czFubXNiajdyYkl5NmU3dUxIWjdaOGJlMmZrWm01aEJZS0hmc0xTaTg2L0liMm1DMjNXbW1CaGVhWnpqRkprcC9QOURPdXJsdnQ1QjVadS9mWklhNnVTYjNVRnZhT2s5c3VxR1JKb1pOKzhjVTZYS01wbFRFWVlLN3dIa2oycGE3cmFCUWVGVVVxaDNXck41a1hQS1ppVVF0VzZQWi9lMFltRGw5dTVkOUpDWlE2QmJPanBaVzFYcWtXOHVNRmxPMTNUenhvU2J1VmtVN3JLWGVjd3lqNGV4djUvQ1haN0NWTmlaL0RLOXlHaFlzUGUxMlEyd2IrU2U3aHhrWGFPYWxKSkptcEdCZ0Q3UVF4SThiVXZWRjBmL3VJeXpwSmR5cVhkK1BQajltRzltZjVPZzE1TnVydTdtellpbWVWZTR3MVFoeXl5ZHUxRmtQQWM4eTdxbng2aW1KN0xQbUx1Mlo5L0JGc3VqQmRFcklkK3gvRVF5K0NYRXFzREdIRC9kWk5TanNpNzVabEhwNnBGdllyTDAySnRyTS8zbTlPWTkzTXlaY0llcFFwYVpzQ3NKWmc1Mnd4YzN6U3l2Qjl5MVQvNkp1ZXM2VWhaQlQ3ekFCVSs1a3RXVkpvbWNia1E1Tm00TGpyWW94T2lSekVNZU1VL05rZVd2S3QvRVpKa0plcmliNit3bXVzN1pUSnJtUzhKZDhqSlRscm5QU3NqeGNldmttWVZHeTVzTkJwRS9pTG9EVDlURFJqRjR5QTZJMlNuc1dEQlZ3UHV6ZmNiUk5neDhmSWpWdVh4OUFlM0dPNUVHT0Q4Zi9NMytvRWN6ZlozZHZBazlTcHE1Sk53TkhmT3Y4cUJLYldiRG5hSU90WGEvY20wR3UvbDNlK3pnUzNKNmRzNTJqbXJtUlJCcGZxTGF0RldmTS9ZM2puUE9DVEN4eVVwWlcxbGo1cEZIV2I0YSt1bkpaRmtVOUU3Vy9iSG9ocnNJY2JnYlRaWFVNUy96WVJWMVI4WFlsU3NSZHJWNEhEcUxlK2FrdmV3VUJSWGU4c2ZmZ1ZkYkhlV2V0WmtNZW5hdXp1N2xSNlhNTGlweGNiL0wvZlRKWkhHRDN0cFh1Q1c5U1JlaEs5eVZIc0pncW56OFdXa2hZS2l3Tzh4ampndU45eDZhSFIwTGo2dmt6ZXVIcUg3a2tDVTgvcy9HN05uMDJXRlA1K0UwUDFtbi8rZUc1SUZlOWpjL080NU9QMFRRTzEwTHZXc3Y3elp0N3VqZFZlR3VObFdTUkx5THNPTjFoZDM4c0NaWDV4V3R2cVk1bGhaNDBjOW9sNGJQNDBSeWpSeHJkVk40N1dOSjh2WlZVNjhLZXZUMG11UnQxa0x2VnNzN2VuZFR1RXM5aEUrVHFYTFltNUlpNWs3V2Nrb1NGSEhNWHpBTTF1U085VGMrUG1iUm15OHVXYjExeFU5dnhzTEVHaFAyNHFDM0oraTlmNUU2QzFQUW82ZTNGbnFSYnEyOEk4MXNoYnNzWGNpSDBjNHpESGc5eU1IYUQ0ZEZyQkpMYjM1WU0zUno4RXhjbFlwUDBhSWpuNGx2YW9zUWZvclh2QkhrSlhVRnZiWFFrN3JWOGc1WGhWR1ZFdTR1emlmc0RoVjJPekVRTFU4M2lybURxMWFqMlkwYjFGU3FQdXBJTHBza01wTGlYVnB5bW0walA4Ym1KS1lWUmVqdGtVYnZVR2FDRUJXQVJlOThtSnhPUVM4UHN1Q3hySVhlVGV0dHlydTVOTE5NWnBadzl4N2hicml4SXN2TXFzYWtDM3Btb05jdGFXd2pmV3RDbmIvanRaRmJRbGxBUzRnU21uanJPVkVzUG52WEJtNWVWMkMxTndCTm1VVjlBQXRCajVYR1l5SG92VmVDWHA3ZXhHT1pLL1RXMGMwckQyZWViSnBwSmsyRUhPNkttZm41ZVkwZEtvUk5YL2JWdG5QSlhmQ2hqbHJuamNHZGxUYzhWdlBpb29XNFJyUDhZVWMxN1VsTmNzWVVhZlRJMTIzWW8wMm54bGFHMTkxaElaMXdndDZEejVPOW1ZSWVqUVhTelhWMEU5Mk9yZUkzRVo1OVJvYzdiaWkzbk05c05UUm04cWtBdStBeGxkMDczVHBueDZES2g0c1dlQVRVZ2tsTndyTHRVeHIycXBoWFpnMVUyS3ZBQXoyMThiaEtLdllZbkpkRXZUcm9QZk9zMzFoWUxaWWIwRm5NWGVTcXZFQjFCM2JLVXhtUnMwWmJ4WlQvMEFTRzhwRVhHU0xmc29jQWI0cXNIeU5ib1lGblN4MUhwbkVaOEJyVm5sN1FPZ01DLyt1U29FZWxsNEtlOEZqbXlMdTNXaXhYR29vK25Va3pjVldteWN4aVpoNHE3cmlYY2xCUVlZZTRZTE9vR2U2cU9JRjZvWUVXVjR1b0krZnRqSUFPZUl6aWlLalg5Und6THNkajZGeGtuOWJsQU50RTNxSFltOVAwSmg1TE85MDhPMDdVcnhiTHcrMTV4VmJwY1ZXZWZqWnZSUGo0U3hudUx1RU9HMU5zZ3JhcVhuZkhvdFMxam1BUlo0b2RTbUdydlZzZGVHWlZBZDV4b21icklialFGNTMyRURmT3N5aXZtU3dhVUZNbXk1Y2ZEMXNXaHFBMzc3RmdzYXk3WXg5eVd1VmswNWRtMGtSNDZaVVA3cGZxam1oSHVDT2xNZU1yVUNWU1Qyd0JTeVN5d0MwWTEwU3NucGxrMGR6RitOWC9xQkpHRmtpMUh1MHVybkRWaEQwSkpsTG9aYnk0TW9ESForWElaU0x4L2djMEZqclR6YzNKT3NWeS9YWW1hYVp3VmI3UDIxMVR6bUxNVERFVHoyNlZTaVp6RW9hTFY5RDRCOTl0YlZjdmVvT0x0N05qaTlwZVExdHh0WWpzZnZod054SWhMeHFXcytnZEJYaGMxZU5DZlB3bDhTSTZKSlV0c25nc2RicTVtcHMzYldmR2FTYXVTajY2RCtwMDd3N3VmRlBiMUhiK1JYbk1ueTkzbjBIWEkraHFCS0J0aVVTRWRNRkRKdlNwakpSRG5VS0pUeXdqc3pFUDhvaHJWSHJtM3UxRzlMN0RZM0hTemRYY3ZLWXpIdTUxY0VlYW1WeVYzRVFvVXlxWEFYYlM0a1N1VFdBdTd1MFVDd3BQK3ZNbGw5L3NVOUYxMDA3TER0enc5Mm9UY1A0YW9NZEVrRUh2UU8vUFAyMUtUckpmWHFZL3grTTVjbU1oZVN5a20vUGszVnRQaEZnNG5YazZ3NTFLTXdkWDVkUHpFdTRvME1HT3UwenU2VWM3MDBmUEYza3FIcytzWWxuNjJubVVOUGthYmJLYlBsclRacmoxdEdrVm9GMGpobDVLcFFBOFZLMnJNRE5Uc21PbGg4b2RMTW9mazdteDhPbmdzYWgwczAzZTZkcFdXTlJHbUMvdlpKcDVQTjRodXlyMVRhTWZaT2VTcHFyQ2VtOXVDaVZDb1gvTVg1TTdIUi9oYm01VFFndkVia2liSFRzMmwvdVRtcUNuVDJsSGlqem5OSHc5cmpCK21KSDRvK2ttUHNpM2NVbzM3dy9EbTZTYlk2RzN0aFd1Z3p2YUNEUGxIV2xtT2Q1aHVFSGlzMUltbVJRTnRuTnI3TXFxTkxFZDR2Q2NQOWRQNUx2Q0RJL0JMaGVaQURHTnE1MFFZNlZlVHVBTHBEZFlhQ2VsOFlBRWxWV3FEekVnSXhBV0dmSWVQQmp2WkVIdnQrT3hFS1NiclVLUHRzSTZNOTA5RmQzWlJTRE52QmpOVExnajNJR2QrSENWazJPeVBZZnp4aVZuVXBydkFUdWpqaG5wTXF0WjBHaVBTWE9wVy9IYXRqK0VXQ2ZJcyt5TjNLaVRWb1M3ZVZUQlR4Ky9Jc2dEUGNnNzZuUFNUZHRYV0dlbXI4RGR5YWE3dkJ2ZHpQdHd4NjJxN3VQQlN6S1I2dWlKODNoNFRLV1JLSGo2OXJ2YS9CS0NkT1FERFhtdFIwdVAxSFIrSndwUWpaNVVla0doaDFlcGpFN2kyODZRdDlNZmxRVzhCM1RVMHlzZmplNW1iNkczT1ZuSlc5bzJqOHU3Tkp2NXpGT0RtMWxPRWN1U0pmbmVIWHczTTROK1I0L3pOVFZ4MW1ld3dKbElFbTU3blovamdzQXVMUjZSaGlyUFBaSHdzY1JiSytBS2owL2tYdkFoeUdzQ1BiTE41Rzd1MGlsa2c3djUxRE5wZGxNWGVtc3IvV0gwem16N2p2SnVhcHBmWExyY0tleXFFS2l6bnEwUjEvQmJaczdkUW5HOUZJdUwvdGxndk55VStqNmluL1o3QXZqaUUyYlE2TVkwMERNbWk1MFhVK1JCb3luMEtCMUlOeS9HWmpxRlh0dGlXVnZwaTdtTHk3czBtL25LNHorTzJGMmlWQlBrY0diM1dISzYrS0RvakQ4WE94c1RyQ0U0cmVvOVhkTjlTcktCenVmRnhzdDY2QVZiRWdtY3RhYWdKOUNTVWM5NTlwWkJUMlh4dG1VcTYyMmZQRkd4cTBMdng4ZGZTYk9iYnFHM2t2Y1FUNzViVnQ2bHJRaWF1L0dlcGpzbnVCdGJBMW1OQTl6OS9TNWJKYUJTM1hRM0dyck1kWXJwbDU0OTZlYmJMTmw4TmVRaC9ac0NYbnRzWEdmcjdwQzBTamZsb1RnK2VTVnIyWTNOOUVXRjN2b1V2VkNQem5OSDk2NTBFVDU1ditZT1Y2VUk2R3lyS0lwM3VHdGdsNzU2MUJXNUliR0pIWkdKUlFGMFlaaUxHd3c2UEVaUHBJMGZmZTcvTXRZb0t0elY3Sm1NbmJsWVhyY0JUcU0zM2NITENqNWFldTkvVXZvS2RQVGE1TjFieDhmaU1iRXVXNlYwNzRZMDgwTVY3aXgyWS9GbnFkc2QxUGdLOTE2MTdtcW5NOFJ1NjlSSE9zUHJuZFpFRXJXbHZYSUpJbEhPUWlTWHRid1drV0N6eE5oVHZINWdFcHJrbE56eTRLSEhUU3d2U1BUU1AzNVkrZ3JQUGRsbnNaeXU0Mk1CZDZmZHRrb3A3KzdiOHM1d04wNzdvWngveWlFS3VEdnN6UE50VUpoNXVROVdjRGdLT3czWGU2WXQzd2grOWtnL0ZEZERXaDZteml2TjhXUDBRa1Y2VVE5RUh3eDZ1elo2TzhqN0tCZDYzUmJMMlVxZWU4ckQyVHgzMkNxdnBabG9hNnNJN1BCWmtFNXhoSitTcGNZeWdwTWtQZXhZQVdwK29kV3hiWThvZDBYNWdROTBMSGx4M3c2cUVGRnNraUNQcUlma1k1bTFsd2w2ZUtDMXg1TFFLNFVlRmtzUGVXZVByS3AxR25HbmJaWGN2VXZsM1plRnV4cTdveGlHSGwvUzg3ZmtucFQ2M3VFODVGRzhsNUNxZzRTMTU4NXJFbVRtdWcwUHpSZWNxUXZJZmF5eWxvc2VZUGxoYjdSSVdJUEZXVzlDT0VSZEJOQWpVNEU4ZVpkM0ZIcWxveWNzbG9pOGRXVGFjTGNKc0xQYzVlN2Q1OEpWZVVBYUFuZG1ZRk1kMDE5YmJPb2NBc3VkUDcvQ0N1bzZKS2liWlE3MWNqYXZhT1VmNFE5bWZ3MHUwSnFMSHdLTElDOGRwemxsOThFR1BFa2VaVVBoVm42K1V1aWxqcDRoTDBKdnM1SzNqRHRzbFRTY1NYbDNtYmtieUp1WWtqc1VTSEdJZG9vNzhhcDE1M3p1Y0ZPbXQxblFCZUM5NjBDbloxaWFkS2tMVjVka0w1N0ZVUVZieml1RDh6UW50cXh0bFQ3ZzVMTUpnNWhYN2g2MEd2TFlyMUJaTEN0NTE4SWRkaWEyU2hyT3pOMDcwby9DSFlJN05RaEJscW01QXpzVWM4ZkZITzdnYnRFSm13RGxubW5iU1U1NHlFTTNmSm84YlJEUk96Q3pZRDU1TzBNZXNjMlFKOUJqUXg1QmoxY2VWT1R0eWhNV2pxT2JXQ3pKM0Z6SnV6cDMySm5ZS2w5OWx2dXBxT2F1dWpLMmhHeDFSM1UvWGpEWXhYUDR2bit1d2FQYmhSWlJNVzR0Z2c5dlRUMGM1aDNsMGpFeXpVL3NURC9YRmFwNXRKS3FmRmtBbkVVNjV5Z0xtTlBrZGU2SnNLbE5PVjlXZlBzVkZrdUh1Ymw1ZmlXdmNQZjhwdFBPZlByWlpLdDhmRG1JNG83YllDZFl4dUpOVFVYWUNzTmdGendnd0JCcFBaVjRtOXM4YlFCV3FHbE1yaGdnZFc0cnUzZXNqdmoxcDFIekZjaTBSb3NwZVlXY2M5cURIZ0liSm1QeTBMVGkvT05rc1R6N2REWTNWL0t1ajdzMEpUWk9xM3g0U1liSnBoRUhPOER6amwvQnpYWlBIR3ROalRsSVZqR20wMFd4OGx5WkZqTEdzRlNXU2Z2Y1FQZS9QLzRtSk5LTnh5UjVoMlhvN0ZJSFBXK1dDQ0x0VFp1eXl2TFAzUHU2bGZUNU9NVXl6SSt0NUYwOXo5UjJKa1BSbWJzQzNreTRrOE9hQ083MG1ZOE9XZEZsY1hLMDZJNzFIZUVPVlE1cGVRRnFud0pCNkdycFQvRVhIL3o4QzNETURHcWpCM2NSZXN6UDJya0dZcHh1bmVmVnNGZTI2WUhlTDhsaXdkeGN5YnNLZDQ5NTNQMCtjdmNnNUE3Zkt3aDNQRE1QVnlYbWpyZVpSeDFjTlEvWGpNRXpDMnhrNnhUZjJ6cml6RWJoeG9tYU10R09qMW5adXJMazJlRVViWDVkR3ZKbzNRRmV1ZlU0Mjc5NjVEMjJPaXlCenZxNHk1dnZqbmJtc0JrQjdwSUVkMGlHT3ptL2dybHQwMHpUaWVLVW43MVE4SXpZcWdGb0psSWFOQ3lFTFNZUHhZZHFhdlNpVFEzWlJHcU1pMm55cHY4dmtqTVcyR0ZvZi8rZGFKM1hUZk1rN2o1QnI1aWJlWXZlU3Q3VnVLTjloNTFKZWZmMzN4TjNJMTBJN0xDbEZYWkY4dGdybHl5ZUNjZEZ5WlhZRGFRMzRsbmFycHM3Uk9Vbllad0xlNVNIa01jUks4TWYrTGg5cC9vQkdxZjZZV1B1UlVYSGJaRUhDRUFlT1V4STNoZWp1VWxEcjBYZS8zbDZiTlBGM1JOd1Z6WUJwZi90aWJzZzNPbEdPZ0V2bm1EaHFzd3l4VDQ5NjJOYU05QXdGMUYzNDhmWXh1eFI3b2x0UHRGVFlHMm90K2dCV0hTRWhtY25tMTZyN2dUdEZYbUZSTWlqb1h2K0NlUTlNVS9lLzNkaWVwNDcybmVwamZEcFpWTGg3bSs0YzMxbWVjU21uUVcwTFQza1ZTdkpXZU50WjZWNUJDamlqRzh2emp3SDZCckFRK0dUb2tIUTFucVdQZHMwRjJkQ1Y0SzhRbCsxWFdpcTZFUzJhWXVGdW12T3lYK2dWMTc2aDcwemNZMnJpdUx3aUNnRlJVRndCUmNVNnE0MTdtc3JicWdCa2JTazFxQ3RObTJ0cHBwV29hUVM2WVRKMzIzbTN2dmVkOC8yM290RXpjejBDRUp2b3VpYitkNVpmdWVjKzFhU0ZSRDBJTy9XcklLWWUzMm1senZrTzJTRW5XVEo0VG5ZQVNNTm15cWNRUjdDaFNucUZIYjBjMGJZUmIxV1V0UDJmZ3AwSG5vZFZjM3FWSXdBbVYvdlZDK2k5d1pHckIzdC9RV2FnTHdFblp4MHBDV1RURHYvVmt3ZW55dmdKZlNhcG9sWEVmUUdrTGVZazdIUE0zL1h3MTJaUnZnU2Y4Y0RkN0hEYkp5WnoyRlI1U0pHellPN1pPaGFzc3lIMmh5WmtoVUdteVI0MkQraDRJdC9WY0VGZS9ZL1Bpb3VnVjRHSy9KNVNEZFRvMG16YnJHRnM1ZzhFbnErQjlpWGVWcGhHSG1QTHVJMmlCZURlWFBkbnRuS0NLK0YzT1ZEdU92WTgvZVgwUFQ2TjQ2SjdDV1o1SzQwVm9YZUF0V01IdzVTMERsUy8wN3p1MTBYWGU0RGJjQUxvczUyTERFb1A0bHhSbmUxbUs1bUdkbmNnSmFvNU1CK3ZCYTkxMXBaZ2NiTm1MekYyNEQwTFB0VlF1N3VxN243R3U2VWdPZDBzTUNkM09EaFZOTGd6b0wzbHpYWm1JaTVDWkl1djNUQTBLRjMrK1NKZnhkbkRVVjY1SDBBZTFsNlJQMjN0OERhNXlMSkN4ZHE0dDhnRHk5Wm0vVjZvR2ZJMHpXV2RQUjFUZDU5TlhtM2RvL3RsN3NrM3dYdWpwaWp4OTgxZTNOTTUxaTArcWdjNnpvbnlBM2lEZ3NKYU9sdzY0dW10VHJxbVliZUZ2ZmE2L0lMTG5qUk5iRDV4QXlqbXplUlBKM1lmSmwzbjNqK0NLM05aMVBNVkZRNFVJbDloVjZlVnBEazNkbEQzaUp0dW4zaG9RN3VhTSs4SitJTzhEanpPNlhyU1VwUnk4VHM3TG4yZ3ZHK01kdTl3bFlGaHp0RGkyRVU4clNCMnFDTUxYQ1pzZit6eFpTd2dPdjJxMm9pZ2N0TUJsbHRSemNjcFdxTUFLM2VONlkrNUIxTEhrMHNmZVF0MUhiMy9YTDM4a2QwWnlydVhIOG5kSFErYjQ0RWRJbzcwcGh5UExHcklIendYT0pJL1NJemhGcnpONzc3bWtGbldVZEtqSUpBcTV3THBGVHZxV2hLOFJMamJYVnZpVjE1TStraXowcDY4bjJLcVVRdnpRbTlmT1FXZVk0OXR3L3VVcnZLZTRvNzlqeG9IZFUyYktyTnFMWnp6RjRHTEVUZmllN1lyTHlpZTNWWE9SSGYxUmk0bERvQloxRDJISzdYZFZ6cU91Z0dabDFzd1V3OTE4WUVXSHZkSkpVVzI3Nmd5U3Zta2lmeUN1ZUlseTlOTE1QSlc0eGJ2SjU3a0h0SnVybTdQM0gzeVRHVDMyWHI0MjY3YW40SXVkTWxibEVpYU0raitWZHo3UjJNeG9tZm81K0ozenVRZGsyQmxGMitIalZxOHMvWUdSL2VEL1h0SklGMlo2NjhHMEllbnlNVkZrMmVDVzg4OG81OWtzaTd2NHM4YmpSWmtQdnpqaktBTjRTN04zYkFUajFlVGtQc0pzMldEMUkreTUxdDRwVjcvWFdUaHQyT1VQdUI1T29DZVNGSW1SeWg0UUNhVlFDeHQwMmxvaE1RUlRySHprT04zamFJbFllbHQybFcvSUdyMnZVQWVLSXJVNFdibGp6N1NzNW5id3dnanlHaG82UDV0MGYzeVowWVJoaFhrS1dqVUVwWE03Qk80eGpORk1DRXQrTzBhSFhSb2o4YmZuSFFuYzFoLzI2ekpodmpnWVlSZVhzTkhxakNsMUx1ek9LeGdsSCtCYzZMeVlSUHJJQm9vbEM3dnMvb1FwQW8xdzRZOHJZNnlWdlE4VHdhTkh1NFMyM1JaY3VEWmN6NFFPM3VMSGZweU1jT3JMS0hCRWFzZTlFZlArZUhRN2dET253VTd1cGd1alZkMVNDcXZScnJRUStRSUU4MWFhcHlpaVNQcXJQOCtKakE4Nlh6cHBKaXZ3dU52WjVicGkxNUM5a3cvVHdObXNPNXk3NE83bXpiZ3BONU0wWnBPbGdtQWpzUlo2YkRQdXgwbWNHbVFscUZReDhidXZRSWFJUU51UUlkNDljU3pXWkhSR2VyS1VaWktkajhSSzRucE5BNmdSUGttUWtSaGw1TnpNSmgySmtybzgyZFh2SVdzRzN6UlJvMG8vNU15MTBaUllDeE5CaUVnUjFrS3ZCcTJUeUpSQUk3T3FFWWpaWEU5U3djazc4WUx6MWlpby8rNkg0RDBBTTJjN001bXJsVUVsV2RSWlU0bVpsU2JYY3RZWHdrZWpaTDMzYWhrRUpHeUR4RjVGbW5WNFlWSUsvdTIxeTQ1akVhVmdaeDkxWitvSUJuWDNCamZHQTVzOU40Y0VlRUNYWll1eEJFY2tkcUV1N1UwaVVYcUxNMkJDSXp5T2RmYmhucTZoejEwQzA4bW01RmRhSlMrUUtxVDZISk5pTGcyd3g1SWg5SEpQZlVPazBlMWtIZVkwUEpPenJQTFN3STU0TzRleC91TW5qdTY0M1lrMTh4Z1F2Y2RXTEhYVzRLUExQVVIrVjExaFZDSGFkOWJkTGRDdnZRUzEyZEhmSjlsTE1YdXpScGlvcXNqVW1EUFZBSkp2MEFxV0c2ZDNKdGVlaFo4dFM2Y09zYWZmTGVqOGhiS0NIOXVRZjd1YnUzMURQaFRvT25heTA2MERRaUVPWE13aDN0S3dvNlZ3MzJaOUtEUFgvYU9PL0R6dENtKzA3aUhySitkSHZZQXl4L2pwNm1UMVhsaEZTNXl3ajBxTEZBWHJ4bFpVS1J4UWN2SnE5OVNVdjAzcWUyZVc4UGVmTXI1eDFGT0kvbjd3cDN4Sm1BeDVvanNBdmpURjJlbHAxaitjOVlJL2ZwdS9LOVZSQll2QS9CSDE2QUFNMkt2RCtyM2NyUWZ6MXoyT204UHdTZGRBNFNUWWxJenlmUXFZbEtSN2p1WGIvbE9qMjJyR3haYVlFUmxERFlaQ05JdGtMZVV6NTVpeVBuUFl5QTUrM1BaUDRPN3FTL0F6d3IzMUZtNFpOcTBnSStVc0J6KzFla29oZHRPNkN2ckh0WXlBeVdBbGpIL3FGOU9pejMrdlBZaEdidU0yc3VMOEhNVUt6d2JIZzlvZE9ZRFZQRS9ja2tlYmJHZ3ROVHJSSUJlVlRpcWp5UCtUejJiUzZLbkhjYkF0NSt1QnNMN2pyODNSanVPSVE3MW9KSG0xUzFzdUJ6WjM1cUN5N2lxeWdyS2dFT1dJaGJyT2lGN0JrT2paNWhDNmZlU2swSU5Lc2dDTTN4OGlBMktTOG94RHUyM2NSYlZyUk9IdWQ1Z2Fnd1R2WlB5SnRIVVNFV0VpeDNSVWZZcWNFRE84RmR2ZXZQemNWSitlRE92M1hiYmFWM3dzeHE2TVc1SDdXdVBKaHRZM2JBTHRhdlFXNmYxaHRHM3FqZzA2eVdQMVh2RHhBVUl4aDFuMDlJSG5oeDNLQmtid2JDNlVsUnRnYU4wTWY0UEZ5ZUl1OTFUVjRzNTgyZnFQQkNwNUFnOWp5MDNFMHRJVFgydUNQQXFQVThWSjhrcGNyK0ZjQUxib2lWd3E4YWVvRzc5QzhNUlQxUmxjZVZJRnA3Vm80RmJ3ZGlxbFZUUlk4NFJrc2Voay9qUHhYeVJQY1A1eXdtbWtpaHRCcXhROTdCYitVdHQ3aThSSlFLWXlpcFNmQWdqM2l6a0NlMlFYU0pDdk5WMm1RU3FKZTdSNmI5bVNUSytmbTU3azRQd3Bvb1UzR0hqRnVZTTN0QXNrVTdJc0d1Z0NycktWTDFpNGVCclBHN0VIZWdobFlPT1hoa0RBNmpFcVl3TmpxWVIwVWhVNGFjK1pBZjZEc1NkRmNtVmducGN2OEFKb1BOa242VXZzMUhQUExtZjBibzZDRHU3c3B6cjUrSU5GbWxkNUdVYnNaRW5ENXBzQ3RrRVJGVm00L29sTmJZRVZ3cDd2ZzUzMURGMjVBR1NhRDdGOHliTWxmdTFocms4VUpSN0xGUDAyblVMSTlkZDJteXlaYUtDaGlaZlVaQ3JaUGpDUUNud1JQRjhFOHllWGNOSWUvQjBmellNMkZCay91QVd1Nk9INnNqQnUzdjBoSCt6bHZCZ3VJRFc0emp1VXZjNHdVc21CRDg0STVHS3VBMTNLR25SOGdkUEhQeHhTWld1ZXZxa1piazJaeVc1eVhZSTZjcmNPSDFBSzlwS1lvM2lWVU5tRlEzTFhuNjlkeGFQajkyL01pVG1UeTJ1MGVselRsYTdmNDhCVTIvTVRyZlM1TDNpYjM4SHZWTW5oemdEZU51eStIT3UreVhJN0krL0tLa1RpVitVZmVLRGVGODVJQnVFREQvVXVocFpYNkRIdk8vanQ4elJlQWczUFF2SnlFZEtKRDJrOGViRmZMS0FlZ1ZmNGZQKytEbHZJY2wzMmlTRzZibnZyVDVMQVZOUnpoUEF3bmxYcEk5N2w3NkNPNlN3VjM2aytMT2FEczFpSXE3cVFGWHc1MDdIUzJ4d3c4cXdLeUlicHlINjFnbzV1OG5VRHhnRk5tdll0ZkgzQWpXanZuWkhqL3h1dTBtM3BZVitpL3RxZ2M3Y1c0cUtzTG44VHNtenlOayttaTZBU25mcTVCR0ZXSWgvZEY1NmRxa3NHSUZQQm8wMC8wSWU5dzlYUWNMQk9rVU9HbGg2ZVJPU25vNnYrTllVbGRJcFJBbnZ6N2VkVGlZS3JtckJrZmJycmx2aVVBZmRXZ0orM0I5Z0ZlSkRZSTdSSFc1Ylp1bVRxbXkySFhBcGNLcHlPUER3K2Q1c2psT3Ivd0M1UEVybXIyeElDL3ZIa3YzS3VTMlRlUzh1UzJ3UkIyYWxydkhuemhTdUxQZ0pYT2xkREdvRlhOSGJ3cWI0NXk3dTlMZk9DVzFjNHAzd2E1Yi96WnhOWnN3SExPWUpzY0xLa3RIZmZDMUFhZHAxRVIyaEs5bzBXaWhza2F2ZDh1S0lFODJ0bk5KZ3NXcWttbTNnbC9aY2NnNzhzVGpMWGtMVUdEWlcvVVFja2VEWnJrUDZHdkJIUlhNd2x5dHBLc2IwdVRseks2L3l3WjNVUU9MT3kwazZweHg5d3JjNmF1SmdTN216ZVdHUC8xeVpuMXpjKzNxdGRYVjFUL09OL2JIM3ArdVhWM2IzRncvODRzRkQ0aTc0WU0rY01JSU9WVWYzVjhTUGIwb2tWY1g5V01ldDUxNWphWmVGVmRDU3Q5V0Y5bkUwZWJYNVM2aHUrL3BLMjNPUSs4WW5XSWRRa0lhQk5yajdqWHp5RXFRTVJZZG04R0NUYXZvcVFTZTNVZkczVkVHa0JYT0NkZFAyV2tYM1RDbGt5THBRUEIwL2N6QnpXK1gxMWIvMkRoM1llV2JreWRHZlhiaTVEY3JGODV0L0xHNmR2azN3QlBXWFhBQlBkWDFabXVjbERGQmo0cXdjb3VlMDJzK05Qd2JuMDFFSGtJUzVObHZCRUdTSk8rMVBmTFNrRkFTRmVhN3dFSmhwYmRSTE4wSFpJT0VHa1M0NC9YbWJGZTAyTUZkTmtxY1h1ZDhXV3FMYU9jTjZUVy9yT1BJYXQyWTNQSG54SVd4L1hMeDZxV05jeXMvTEkzK3FTMzlzSEp1NDlMVmk3OTRRQTlLK2JENi8wN2ZOaW1kWHZ1ZTBuMC9QT0o4N2c0QW1USEt5WER5ZG9UWkpwWnlsNUJzSHB2YkFndUZsUUVObXEveXNIenV4aktPMEdVVjFTbXRzQ09Ka0hOaEU3aGo2NE84OFUxakI2cGtkdExFQWxnYllYcHpPUzF4MTg0di8vVERGNk9Ec2k5KytHbjUvRFg0NjJFUDlMdytUVm5GRkZQREtKcUVsZGJuNlZVQTNnU1E0dEhONG5qVnh1VFpqR1hyVmR1Mk9aOEZGanBXZkNHaEZjN1RRQUxQaXJxS3l4MDZPb2lGZDFYYTVnaStGSnlMeGJaZ3AwdVp0RDRWN2p6bzlCSUkrUzBQQjJFdlh2djlsYk80dUlPMXBXOWUrUjM4ZXRpeitpUysydzByOVZpUWZLQ0F5dnNOa1ZXUnAxcWtnMFJ2MnlOdnl5VVA5TXFvUWhMU2k1eDNlMGplVEEvblBkeFhXRUU0YnhvMHg2b1lGZnM3dUF2aVREd2lmS21xU2puRjIyRjhlV3lWcnRyZ0tvbFQzSG0xRkRldzNGeGRYdmx1OU8vYmlaWGwxYzJhUHE4NDJneWxOOVdTbUR3aklZQmU5Q3JEZUJzNis0MEtSWTdUQTBocWFZZ01tQk0rNWJaTmhQVHVBc3NNYi94N2tWMStzWkJRaFBQanh6UjN4WWpUdGNOVGMxam1GU200NDlod0ozYVFHU0FuZW9lQnpHN0NBVmp5dWxvaXNKN3U0dW95YnU0L3NhV3p5NnNYdzdRUDltNEFuaWViUTU1Qkx5RW1icG52V25BMGJOZUQ0RXFSaDBrNkhmS09IWisyc0ZoUllaNUdoRjdvTDZ3Z25MODlmVTVqNWU4QXorRU9UY2RUOU9BTzhQaklGWGN4ZGtoMzFSVW5BKzdMeTlqMVZGQytYL3Y5Mng5SC80LzkrTzN2YTkvM3dYYzlBeE52TmtRMzErakorQjJETXdhRG5IRFRrbWV3NGtUM3JGUm50bS96YllSMGtlYk4wWWdReW5tSGdQZEFFYzd4ZDd1N3UyMU03bkNuSGpYcEhhRm5lUmVDSWY1T1hoRUxYaDUxcld1czZuajJoZzc2cENWMlZQUGRRc3FwcXhzclM2UC8xNVpXTnE2ZWt1Z1Yra0JQWm50eUpDTmVjRVJLUjNFSzhrVHluVDRJdlUyVDROSW5EOUxFVzdoNVY4ZmtJYVEvb09XOHVkSFJVYzU3QmJ3aW5DZnFFbmNGUEIxbnBpUEZIUStmbEsrQXQ0MUo3RVN4UllBSGpFWG95K0pDK1ZGMmVITG9reGUvb2k3ZUp2YlYyc2JwcGRIaHNLWFRHOXJ6NmZpNGJreFJkNVl4RzJ3MnVJdUZtb0k4czl6YldXU3J5TXRuUG5ub1RQbHZHTDhneVBzNmtQUG1SRWNQUmhKS1FiTk1BaUhnbFFlVXVDUERJKzZVVlN1Qm5lQ09ZOFVkSDNYUjBkMmhoUlpkY0lSSW5kdFIvQU04c0F2QXUvekh0eWRHaDh0T2ZIdCswNWZ2aXhYaDNNNUswYklDWHNHOTU5Ym5tUjJva1lyUUhEbGNzV2Vja1R5aVRjQ0RQQ0hucFJtaFZOb01kUFRuUjdObUpIZ2RCYzBpSkx4VGh3UWhkNnBiazhldWgwU29aOGFTWG5YTUJZb2NGM2RYNjFXaXdpbjJ0NmV6UWRSOWYvWHpIMGFIMDA1K2Z0VTZ2dnFGSWJyRnBNRG4zWWZIU0o1QmI2TElDeFM5ZkJUMkowSGVtTzlBc2tCVHlHLzBWczRiVXRwOGRBYlRQQks4cm9KbUVoSmVGNkY0eEIyci9nQ1BRRU54aDd2alZCYzR5ekhnaVJtaWdoZzhta1lWWWt5NE0xdnpxbzNxNjVjdUhEWlhweHpmaFV2ckhlOE5PUkVyeWkxcUowYTJoanczajBidUtYT1Q5VXlyUmMvWkpDYXl1UFRYamhkdDhrVnFjNWpwRnBZa0t1VFM1bnlsZWMvMEZsWVFFdDYxUWdKUHEzM0NuQm51eG0zK3pjaEl5SjFWYmN2bHIrM096ZnhsRUxLdjZwR21paWtxRHQ1YTUzSzJmdjcwRjZQRGIxK2NQcStGaHNqcmFmS0FqUHNUYkxqcFhVU3BiZ1VDTThqVDAzZG1OMEgrTXlmS3lHSXluKzhlTDlONXZRV1dHWnRIZjVFRUx5eXM1SUptRVJLc3Z5UHExQlA5cXFSbENsOElDWEFIZUJ6QkhjYzB0bERLcEgrbDg3bzg4elZ0d2J0ODVleG9kdXpzbGN2OTZBR1IzdldRRGZRNEswVk1OQVQ1eVJnSFYwejJ2a3ZRWkFXbEV6d0tkMWxVU0tYTjNnTEx3N09sNWoxM3h4MUh3OElLSFpxcG9QbDB4ZDB1NEtFckFKbnFsRFliV1BqY1hPNVNXZExuTGgxU2Y1R1RzYWg1TVhmeDVTSHJWNzRaelpwOWMyV2QyMDRNZW9BbnljUHA4UkE1eThiZHNLQW5uSjdiQytGY3h6YUdLb0dpYkc5U0x1L216WnNOZVU5VDJtd0tMSE9nNWgzdENUUlRoMll1YUw2SmNHNGNYbjVJdHRGY1BWcTlWcEhQekw1VlNkRzkxTjdiN0E5MzRlQzV3YTY5QytITXBaVlppREN0ZmJGeTZVeTBPejZoSjh3dU9KS2JIaUN2cEhUbDJKSm43eHNGUnZWbnF4cFk1WnhmYXNCcnYxUnZUa3VicVd0emZ0SThXalI3T2pUTFJFTHlkYmc3T1pBWGNLY3FMUW83akE0V3dhTEJqZ09qcE9lamdkaGR4NzY2ZHVHd3FIWC94Sll1WFBzSzhCejBKaTU2K0RlTEhrODVuNEplVzJKaGlTTUNIdVNwRnNFS05mNEVpWXE4M1pzSnZIU2NTNXREdWpZZm5wMm16V2RwMGV3cXJOQVo3ZXQzY01hUmVNd1JkN3daSVFyc1duTnlQaTJrNCs4QzZncDJVSWR0THY4NG1uWDdjWG16SjljRFFERWg3S05uTCtlVnFRQ0RDYnhoRFhubUVpbk1BWTlmU0I1dmx6eXY5RXYzRjFpZW1aWFp2T2NlQ2hNOENpdTVRL1BsWTRtNzhqTHl1ZU9JUnJMcXFVcnE4SGRXRnZKdUcxWGN1WU94azM3c29LNE5NVStQNXNQT1hxS3B6SG85MjZtcDltalU4aDNoQjVmaHVic2VDQk9SRVNES1g2cGkrNk1OZVFXOG00M1BPL1p5N3Rxa3dCS2tlVE15bS9kb21PQ2xFVHc2eFhKaFpUeTFIQVdNaFk3Z2M2ZHVFYXF4VTJWb0M1NDhtc2pWQWsyTEdDR1FzK2pQWWdkMTJLL25EcmRndHo4N2NlNVhDaTJCc0VlOGFVSUd3SE5YY2RTbmRRNUhkTU1aN0xtVG05bWcwSktYMDd4TW5pNnczSGxubk9iTlJPdlk4MnlON2k2c2xCVXJMWGk3QlR6NkROUUF1bjJaMllWald0SFQyQUZuV2EwRGQxdHdKK2VIekxJNmhkMTFZYWRXNThYWllhZFh2L2V2ZlpZMzVSV2psa2xZNlhacHFuWXhYVDNwSTQ4S1hCSFByWmxGQmxQdUtHMitSb0dsTzgyYmdkYXg1MmdWaXpwV1pHRkYxSnVnTEdIb2NtZjB2SGpkQ2lkeXh6Um5Sa2ovaXpLQXpPNzB1OTNIYnYzbjcwYnphTi85dkE1NjEydjBLdUZGNUhzWlBTSFA4S2JMUkZMY0l1cW9uWjY1bm1ac3lDdmcwYU9pd010V1I1dFQwd1VXM2NFeWk2MWp2cEpnTzFaS1lhVlFCbmM3OUd1NmpXTm1Zc0VyUUxNS1FKd0FaMzBvQmIxSmt3dUtxb3JacStVSG1XdEhacm1NMlNNd0hGbTdqc2xjTDVETzFUV1Vva2MyUFdGQm52b0VoVExYSHBsb3N5N0tiWFdRaHpaTWFUUDFqdWtPbGhsZEJIRmJoNUtnT2xhT01ZSFh1bi9pZHArNy9nazl1SE5JaER2T2F1ejRpVlFSR0xRR3UyTHNmUDFxZFpiNlUvNkpuVjM5eXFJM3ZWd0I4R3J5L29LOFNXdCs5NndWNjVnNkVSdWo1ZlZSN3FJUVpBVlZwNE84M1YwS0xLS0RKUTQyRC9tK3Z4ZDZBczB5Q2tSaHBYQTNyVGY1M1BGbktJTTdad2padHZ5bGt5Z1liYkZyTDVXUzNTdFF0MmRnVnk2YVpNdjVxZk1uUi9Odko4K2ZjdEZERzFCTm1kdDJ5NG9pandxTGppd2xlZVVFOHB3TzMzTGlremNHdlFRZUJaWXlJblJmbDZad3lJTk5aaExDQksrTUFuMUpZV1gzWm5rU1pNdUdPeVBQYVBESTFmQnR0Sko1dCtqeFczQkg2dStza2k1NnVaUFozZmh0WS9aRnU0SEozc1p2bHJ5RW5sM1hCbzVUYnB6OVJ1Q29SNEFzWjdKTDB4Y1ZjSUtTdkdKVnR6VEI1bWRwUk1pa2ViUFZ3QksxckZqbC9DMFlvcEZuaDgwUGJvd3V1RXZPQ3FLd2JUTkpzbDArSUhaRGtBT3FCcFlNNXlTOFFlaEdkbmZTMXBmblNUN29zeE9mcjBQZTlmWjUvSm51TUF2Snc3L1pkZEU4ZkdSeWI5NGMwcEp6cytTSkhxY2U4dHI2M0Z1dWpqNVRXOGRvV2VsSThMSnkvbTd6Y3RxMTNPMWFmNGZwdWdyNU5pYkwwTlc5enVJSXVUMUp1U3h6Rk56eGJXcmF3NjVyN003TmIwWEZ0NlZ6TFhwY205NTJUeGVXUEFHUFd5Z0ZlWVNmZGdTb0dPUGxJZ0tTNkxtbFRGR0NnVHlDeloyOUVhRWhhZDRoYm1EWnEvME1UUEErRkFsZTVpNDlJTVlWUGU3R1draW5UeHFUSFN6Q0swcWxBU1ZkdllTVnMyc0dGUDZjN3NtOGhWMUc3NktIbnQxSWFxVnpNNFNGbVp1MUFjL21kWW84MGpoTFhuNmJoK1I5T0N6Tk8zcG9nODBvMExRSjNwdUp1OHhaelIxdkpsZFlpTjUyY0dkcVl6NTNOWm9UdVRaY0x5bGdUUmJZY1RmSnhZWEV6a1d2dVQzV0owL0pwUTFXaWp3ZHNIQU5rQ2FQZ1RIdnRnME5IdVRKTkc5Nm1BY1YyalJ2Qm9QTlp6dUdYMldDOTM3YkdYMnpBWThIMHJ5WDlNTmtOdGErL0NSMy9vNXBlWUtLb0tlSC9QRUU3ZTZTZ1BEYjhxSmlsOUQ3bkRJTEpnWVV6QUFRenh6eVlNOU9uTHNYSTA1QlVnUFJMRlZ4ZFhPTUYzeTIvRzk1NThoaklzMmJyV0N6TzlDc0VyempMWGRaU0Jncmh5ZjZ4cXkvRzZTa2wra0V6dnpBMDI0eWhqdStETFc3UTdjN3M3RklKUlhQVG15Y1VkamxWTStNQm5uTjBKeW9VN0ZhekIwQWN6NTN2anpaZXNtVHczbDFtamRyd2ViRFljc0tMWm9rZU5uZjBiOHpwdjFuTE1JRDc2cXVuVERZNXpPRHNySUh4L1dBMEtodmlKM1U5d3I5S2JGTHV0MlYrZXdOMjZlNGNPV1VqeDZQRHczQmdVeTBEbms5Um56UWR1S0gyTWQrWDFEdnhrRmxzMHpuN1pMbTBiUVpOckFjd21DVGltYW9KSlFFNzdQRTNlNHU0RFdtU2svcFIzRG5QT3lZTzNXUEhsVXlUbFF4amFscHN2OXlkTU53OStmcUlzamxRK3prYXJrNHp5RlA3TkEzWGs5b0NCNTVpRU9RRjB5bkFKNG1yd0VQWXh5OThYbW9lWldtTUN1amVWM1NPVE40elRLL3h0Y3pEWlN3cTRQMDlHTmZTZGYremlycE52UlVMODhjWjZwRkVQVXlFRmFIU0hlWGJHM2VtOFAyWTJmWDhsTVI2TFhrc2NCUEJKenBpR3VCdkpWKzZPWXl6VkI2THRHblE1NUxJbCt2UkI1Tm04em16WTZNVG85bXFDVFFvcmxGbkluRDQ2bnhZSFozWTBYUEZEaTNQTzRJTXhGWFJjT21TZSs0SVQxeWQ1Y3ZqRzVaYmQ5ZXR1UUZ0eVFram5pOFdyeXo1S2wwdnFDbjRoMUE0enZVY2dkNHhKOHEwOW1pYVZOcENvZTlza21QWnFna2xCbThwMG53WktDcDNsYVp1MGpSNi9kM0xFTWl6R1F2cDV2YzQrL0k5Nnk3Ty9QeklwY3lmVnRhUGdONXd1bnAxNW9nYitKUXB0SzhRREdRRVkvWW5ZbWVsLzdra2tkclBzSG0wMlUyRDAxaEZubzJHUWJxVkJJZU8vS3B6eDJac2Vvaml5UlJ5UjFLdXZKMkhuZFVPTTMrRmVwdm1UczBoQnZYYjJTN2xkeTU5dU1xOThDVDZjbWRLa0dOUlZFbXpxeFdCM2kyTlV5R20vVU5PR01MSHQvQkVteCtqS1pRQlp1SGUwRG8rWjVBczFVUzNpREJVOXp0cFhNS1BDUExXR0ZCendycFZ5VGN3YVk0VXQ4SzFra244TUN1c2IvWk83Y2ZwNm9vRHRjSEV4SWZmRk5JdkJBVDc0b2dSc1FMd1N1SzZCZ1ZvNkNpR0pWTGdxZ0VrcG1XWnRwTS8yNVA5OTduZkh0ZFRzK0EwL2FNN3FVeHMyY2dwbWY2ZFYxK2E2Mzl4Mzl2dW55djdOcy9FbmxiMHVubG1DMG1iOU8vbmtTTXZaTHArZVRSL3p6SlR6bDR4RmlBRjVjZk5ackNvbUN6VDlQb0x4eHNDVFRaNWhlVmhHUHZCKzZVdzJNZ3p6Ni8zWE1YVE8yNm5WQ1NSb2RWaTZ2Z1R0MmlaN203OFBQK1hKSzVHanY3OHdYcjlGcjZvWk1SOGljblpud2U1T24yRkw0aHdJTTE2UURKQWhWNG95Yk5lLytZMFJUOGFmVGVyRDU2ZkJlQkpxMWlEbmN6dUdOU2lHODQzTG5kZWdKRXZCdmNTUmNZVERYTlUxZ1o4dllwVWVadTQwMVRaQmxxRjVlQnArYVVnVXozYVhha2VacThOR1UyRlp6eFkwMGVhZDZKb0Nub1lMTy9xNC9jWGpIVHNwS1VoSWtOTk5tNUpqNjJPQkpodUlJZUlvSG1ialBuYm1LNmJ5MTNDT25HM2YxK2RWQ3N5NjcrYnB5ZVZoRWE5Snk3czkzUkJOL25iVUtlbWtNZ2ZLejU2aUp2cGpRRkdsajZmWjBDZXpUOVFETmRrM0Q0eUtucVdjMHF5K3RKNmxua3o0WkpJYXVrd3htK0xCNnpJWFZWMzJ4UVRLSnNQQ1htVUhQRGZNSVdKWlZnRzdmKzcvMWh1N1BUdHpZVWVsdEQwS09XS1lZbU84a0xuRms1bCtOQzhtU1daOGxEelR0MTVIQzE3MC9QS1RoN05nZDlzRU1MS2l1MHJDUWxJVzY4d04veEpEQVNQTTdhNGFValdKbTRrek5HZmtlNnh4UXNlOG1HcHFpeS95NGVXWmQ5bDRvc3NEZlVrbDVnRC9LODRxYTloTkxWbGRySlM3UUJYdmphZ05lUVYxblNGR2hnNmJlWTk5TENYakZhVnNKTVF2TktBVTlud3hsM1BLcDJZV0dUWW1YSGhVMWk5ejc5SzN3RUo2dkRUTGk3VktTN2V4SDFybC9hYWl5Rm16TFI0NUlFTThLRmVSK2JEbWtXUFBJWWEvYjl0dDFVV0diek5PK2RMTmpzdVppSGhMY2cwSHo2eVRCMFBvMWg1bWlVYzBmTUtSYXd5QkdGTm1WQkMzaGFWeURJTkIwczR2YktMTnNmNit6dWl4OEd4ZTdGZnZnZThwTFRjMG9zYlF1bzNLNC9wZDZoa3B2aUcxMll3Q1loTkM1dlZGbG9YYXorQjZHQkpRODIreXJtdlhodmdlWXN2c3dSM01FZzB4cmt3bkRuWW1lYlpUMWhYWEtIUUFSMW1ic2JLbjkzNlZ6UkVPN1Z6cDQ3cjhqYmtpM1NPN0xDSlZzYTNBNGt5RE9rY2JiOXorUjFMVDR2dmlHVEs2Q0JKUVdiUFJiemtQQVdCWnBQSEhnekJKckJyWS91QUY3dTc2aDN5bHo0bnJpTHByY0M1S05DUWxZZzBVL2NrWnFrN0s2NHUvdHllbjlVdytneTNJUXNQSnd6eUdWNmJrVmZyaFAyMkdTRXFqbCtUWUVIZXJNSVhndzI0MUJzZDdENStOcnZNVG0wMjBCek13U2FrYnM3ODFkSm9LbTRZNWM3NE5WUGxDc1ZESGgyVG1zcXpsbitUcGpKTndrem85WEZ6SkxkM1dlbTkvb0c1R1hoSnBScDh2QjVoanhQcnVNN3RrT0Y4cDM2ZU9kWVdYT0F2UG4vMVEwMit6YVpSMlZsOTRIbW5lcWZtanY1ZU1SbSt6eEF6eVlXbEd6amMxZVpHVkZ2SFlObExHVm5xSXFaMTBxSDJQM2J0OWUyc09qMDNGWHR5ZHhlTVRpVXV2bE1rQWRaa3J6TXE1bGdNLzRVOEZLYXQ5dks1cUYxMWxlNkt5dE9SYk4raWVseHFNSUtqd3R2SjdockVSYXN2NXNxN3Z4YkZ0aklUeldUZDh1Vm90MzlHenQ5ZktqQ1RVb3FIbmwzMlcvVVNoNnl1U1F2cWVDUUo0c0hnTVk1L1lYbVRlbFVObnRiWDNtWks3bVV3MlBiUXhqQ2F5cWF2RUxsNzl6SVBIKzROWmFtWmROMWdKeDk3b2d6bTltaHNkTE1MeHdZRlB0M2R2akNVTlpZeHI2S29PNG04Y2hETmFwSDdlU25jcmdGZ0RQdFQzVk9BM2h3bVpOSFpmT3RJeUhZcEdmVGRYa0gxOWUvNGxkV2JJOG1nV1pUMHB6aDMweUNCNGY2UTQyQ3ArYk9jT1pGb2gzY2JVbDM5LzNsUWJGL2E1ZTFzRkJGbTVJOFVFTTNsOUtkYUh1WG8zZUN2TXAweFNXeEI0YU44ZTVUZ1JqQkpqMmJiZldWd2NxTnNmT3V5b3FXenVQcml5ODk2cFkyd2VQSmdCYVJac2NLdDN3aFR2ZzNsL1RNWnkwZExNTTZ6aXhWbGIyMFYyOXRTUEtHNmJFVGJZcUdkU09iMjg0SXhzc3o4dENsMUwxQXBIS3lQeXErKzNBQmphUkFzSm5WVi9yVnY4SWRsRzVsSlUyZHB3dTVJbGpwMVpyQTBpWjRLREYyKzIrMlVxUCtYTXpLbjBKSGw4c1gxU2R0SnFTSE53YmMzU3dkMFh0bFgvMWE3WWJLOHJ3dDh1cUtNM2ZxRmZKa0M1SVc3d0kxK1JJVnM2WE82UWdHUEhJZXlKdUZ5dWJSS3RoTTAraFpmYVUzL1N1UEw2cXNNQXdVQTgybUg1WFEybkludTFkcDBaVFBUYTJRNGpFbjdzU3lkOXZSd3Vkcyt0WTh6SlQyZlJrQTJqdjc1Uzk4WHZoa0k5R3oxNmhKOHZScU1hUGVBVnN1VFNraEhmSnNRWUh5ZWdDUllKTUJvZUR5K2pRZjVFMEQyZlZHYVJob1czSEhRd2tIaWFHS0s5TlpjR2ZpVExqTHgwZmdMcHgwZk9Oek43eFJ3c3k5dExPM0tMRnNRVjZ3THZMRUNtbExIbWwvT0tJcEFCZTZRVzM4TE9hRlZGaFM4QmtIaE96cW81NXNsbjZHYVNDL3NwS216azlXVDJ3N3M1bndjT25BMGMrRjBmY1FVQ1YzRkRUWk1DVTNvQ0lXU2U2R2tyc0xaWW5ZWHR2RkMxc1k1RTBXK2p6Vjc1Y2lGS1hla1pEa1BvMzlJWUk4ck4zbEpSbjlaSnhHcDc3U244M1NsWlRRSWVIRjlVWWZWRStzN2dFZjZVQ1RWMjBxbkFhOHBuV2F3Qkx1U1BDbW16bVlxdlZCcVVlS3U2QTYvVm1xbVh0dmwvOVVRWVVTOUh5Zlp5YStCSG04Y1RSNTAzQlNjS0dicDVCTFlCbWxya2hlR0JENk5Ldys2aER6MWlBcE1QNXFKVHg2eGRKRkNST3dNNEVtdlFOVzc3U2lDNFVXc1hyRFcvWnV1WXNuM1MvQm15RndkNmFJNXN1dzAyZkNFd2E5WEZiWWRGYzl5RjBDbkJSNXphUUw1QVV6d1NhdzRmSlVDSlozUzM5NCtLbTZjd3d4cndjanNROHNxS3dnNFlXTEVxYkpqd09YU1BDUTFkMUEwK2R1WmlRYnY1T001bmJuTXEvYTM4SGR4dlV5aXJBa3U3NHhyQXowZGhyVWhNdXpmWm9zZXZESUE3d2dLcGhlS0VnVDUyQUNQSHhlRERZLzEyS2VYMTk1WUxBeVEwcm9sdkRDVUFMY0tZYzNzZklsM0RuMVRyZ1REejlJT3NTZGdydVlTbkRVM09Idkt0dTZjSEZRYksrTlJNOGpqd1g3Z2p5MUxnNlRNMEM1UjZPNEhZNkdOSEVXMGFZYVU2Z3NqQ2w0WXQ3YVY0NHhsZUJXVnBEd0NEU0J5M1Y0T2dlMmpXU0JvY2lkMUJuc2NCYWdpWUYwdlU1Z1owc0VtdGZLQ05BeTdZZHJrRWVKUlF2bmZwZWZUNTZLSlJONWV0QVY4TUtCWUJNUEFIaVJ2RnJNbzc3U2t5a0ZwaElXVlZhaWhDZTVxMTVycWxIaTRlRXVQUXpOSGVBUnh6TnVIRTRhUFBKeDVlN1lONmE1KzZ0Y3ZMVmMrL0d2TnZLU2tjYmg4NEJScC9BQ3JPWmJYTG9ZRE5hQ2lWTyt4ajN2YUV6MWxXZWIrc3JEMGVYMVlFcWhYVHZQS3lzSFhvK1ZGVjVRODlMaGpHcG43ZTE0YnZMQmVoZFR3S1JvNG1OQ1lhTEF5OFNoc2VUdVNsSHZsbTJ2SG5mSVUraEZvSlJ1YnNFVEZRREdWbXduQm0rNGJjaWp0aWx6UGx4ZUV2T29yL1JDUlgrZXFZUzJucFZ3UThuN1FjSnp3ZU9GNDlKb2xQWW5GaEFTR3ZmSHZMcTRkVUZPd3ZvN1djWWl2OXM0TWlpMmZEc25TeXpEdkUxZC9vSnNyeGprQ1JOVG5PbG9nODFVVWdkRE1oMmc1STBhZ3MzM3d4b0l2MytGS1lWVnF1alBkRWtKVkZZMGR6aDN4ZDNNTkVyYkJrN05uZlI0S0JIVldjayt4dC9sOGwxbDUwdFpaVFYyOGFnazcyNjk4YzAwMVJyNVR0MU80cEdINXN2UGM1MUFrQ2YrY2cwZTVGRmY2WkFVVmpTWWg4UHJycXdJaHlkZk4rQUo3cUl0bXRDanZza1EvelFZdzBUbUppZTdjMU55ZDdQY05Ma3ErK21tSXM4MmhzbU5qZjRPUDhpaTdYZkdTYm04a1NWdmxxbklPWGxVK25aWlgxbWh5NnVtYisrN3NsSWJHcVp1WitHb0hGN2l6TjVlcVhlLys1ZFhUdkYzbXJ0cnBWdGxkWGI1bW80MmRVTTd1amtuZ1Y1MnUwWVRYZUxsT05tdEtoUFFZd0lkSnJYTGU5YnJYMWx4NDFoM3N4alRRS0ZuNVVNa1BJYzcwbG5sL3l4M3VtTVRmOGNNRnY2T2hLL2h6djQ2K2JYUDdZdGZCc1ZXWjc5OHI2Tk45NUkxVjBVQXZKb3NidCtRNFNOL1FKWXJwYXpPWnova21mNFY1b1BXMnpqMjZBTHRQT3RaK1R3RW1yeG1EZDQyamFtQWhqZmNEWGYyVGlaeDE1ZTVVc2puN2tUcEVsdXRuVDdoa2tkYTEwa2V2MjEzakZxSWR4SW5uZGNaOG1CMFcvV3Z0S3JvSzNKNUx5NlNFcGdHZXNPcHJFQVdYNCswaDhQOTJRb25keW9vN3RBUm9uRlVTK0l5N29iUnJwUXVzVlhiMlN1U1BKSUFzWW5ZQlkrVFRmTndlUVNUMm84cDhOaHRUZ3lXaTNudk1CL1VMaW1zWnIzdHdRVU9qMm1nOTA0RkNXOUVaVVdCVjBOcFNweFNabERjOGFqQmpucG1UTzlRK09BTzhEUjNOd3AzYTdBYkFUeklDNWhKOGlZdElnSW4wQ05UVXh3MjRhUURIdTlFeUFPODFEbDI2ajNtZzNCNXExKy80anM4TFNXa2FhRHdJcUxCR3ErV29RVHI0a0RVanVSRjRWMVdPRk43ck1xK20vNFZTbU9hdSt1RFl1dXc2OE5veHVkMWswZHREVkZCcXdUMXFmcVhSQzdRTkQ4cTh1amhZT1h5S1B6eGVEVzZrQlRXMFN1TncrdVdFa0xQQ3QxdlBuanA1YWtvbmJBOGQzaG1BeG0zeHFidndSME5uYVlpTGJuYitIbFFiRDMyODRZa2J4UFFySG9IYW53UFdkZXRpSE9Xbi9PZ0dJMHNMeDRpZUhjQ2U2RlpXa2dLNjNONWJCYnpIUjVTd25UYkI4ODhDQnBXYVJ5ekV3czIzYXNzVi9UcTB5WkJTYjdyZHVad2QrbllvTmk2N01DbFlUU2lUY0R6eVp2TmFKRHZJRStRWlRJYlA5aE00RUhlOXZZVVNXR1J5enZvdWJ6Vk9yeTR3ZmIxS0NXTWt2RzVJc0dqMm9sbVo3WSs0UTl4ZUVEcU83ejBvNXE4OUoycDVxNHNlVmluL2FiSmk1eDE2T2FtZ2laU0ZkNURqRjZMRVhQd011RFI0Z0Y0c3lBcGhQMjI2M0Y1M1E0UDdSd3BBZkRFc2lQRG5SY25aTGx3azhIQlhUREZIU0VJM0FXei9TckQwaWJXQTd0NHZ0WG5lZlVVUkFSOEhwL0hxaUFuNDBmVk9jYTdFVDlBWUliSGl5N3YzVXBTUUVWZnRjdkQ0WFZvNTBGS1VBNFB3L01UYUtZajNLa05uTkcyVGVlMHZGU0lVOHp2RkhiVzM1MHZ1elBYYlZkcjhvYUNQS3lWdk9wTHdMUEJKaWZqOHZ4V0R2eUFBbTg3VENtZ29xL2U1WFU3dk9veXZLU2RuelFPTDV4c1NWTzRlbFFZdUpPY3FkVklBalhSTithTWthUTVvT0hXTUhIMzFhRFl1dTJyb3psNTR6cmFuRmp5OUlKVnNlTFBJeSt3eEZrR202MHVyN0ttdkRLcVhkN0pwS0tId2J5VnU3eHVoNWUwODJZcVlhVEF3OEhKeG1rY25Bbld3eG1WM1o5WVVHV1c1QXBsWmxCenQxVzQ2NVhOeVlPOU1adUljL0xNZ2gzYUtFeXd5WUpvMDZFQmVNb2dqL2RxbEJTU3kzdXpWdEhYNC9MOGU1ZnRHTjZ4b0oxTGg1ZU9ranRWY21JbVQ2ODhGSGMzODBjTmVKUG1xclNwM25WYnVPdW5mWFYrT0I0M1RtK25mUkpoYXNpVDlXNHJRMVVIanBxOFdYWEEwTzhBTC9xOHFLSWZVNE41M2JjenI4N2hNWWIza2V2d2VNVitaU1dkZEtCSmVZbzRWQXA4Y0JlUHd1T0I1VGhTVi9LN250blY4K1B4T0hFSGVZRFhTRVZTcEZYa1FSWXlsSkFKV3JNOHlKdXpocGNRV2Q0SERPYXR3K1hSdEdJZEh0cjVlMGZSenJYREM0WjBMcmd6SitILzRJNFR3cnJzbkJiZ2hUOGNCbDhCNzFLcFovYkhMcjQxSHBQbzNXMFZFWHo1amxrRTVkTkUwcUl6SEplOFVVQXRuRkFVb3FUdzFzZUhaZVBZU2pvMnU4Y1NSTFBZcHpnOGp6dE9YZHpSVnVmM1VRT2lsQlhnTG9FNTV5NzhXb2RGdit1aE5YcmVFRGxQN3EreTRQRVdnTHhaN2RPaUFyZVlQRVIwd0l0NW5ldnl6dEE0dG5xWDkvS3VITjRubTU3RFV3d1NhSG82ZzFFV09LbktTanA2L2c3d1p2T0dsY3cyU3I5S3YrekFSZ05lOVo5Tm95R1lOQzkrMmdLZXQ3REk3QlpwZDNtNEF3VWVXZDdtSjd0d2VVdVl5MlB3dk5QaG5YQ2xCQmM4cjF0Vk5Xa0NtcWwyeWxGWXpSMmRaSnE3OFNlRFl2MnlqOGZEekRaVklkTzRQSHVKTnh1TGhFK3JmeEtPMjJBcHlKUHZVa1ZlUEZXU3dnbmg4bFk2aXY1eVYwblRka2ZER2w4RG52VjMvRmdXT0pFVmdOSTBrdG5mRDQxaXdjbzhRbS90K2pDM0taS0JGTzlVQ1UyUXA5YzMxUFBVa0FXWGRGUDU1S0VveENPOTByaTgxWTJpUDlQdDhGSjN0QTAwZHcwZVQ4MEdtdmFPQmJnRE94d2VBdDR3c3h1RFl2MnpHeUlteVlvbnh1ZFpFYUhCUzVQSHh6WGdDYnc0cVFPU1FqaUdYbW5sOGxhMmNPejVYVG04VithVmxaSERuZi9pTU9udlVtMUZPRHgzWWtIckNqb3BueDhGZDhjSHhmcG94NE9jQjNuaDk0blBzeG9DNUtIMVFwNzY4RWE3eXQrQitEL1g1UkZzaHZyS0s4cmxyV3JoMk9PN2RuaHd0OGpoQ1dzVjF1MGxDK0ZzbnoxWEN1bWQwanM1ZDMrWGVmTisydG0veHhsNWR6czBCTFdRSU4rYmtpZ0V3d1RleUJSWUlHOWhsaGRzc2p1WHQ0UzEwaTl4OFhLSHc4TkpLL0E2dU9NeDJBMmNSSnFBR01HVCtiVlRDcnViYy9kRjJXdlVWenY5aFNRUHlVQ29lVGw1VVZnMzNVNXExaUFZbitieVBkaEZYbzJlNS9KV2M1UENjMmdKaXgzZVpEVENTYmVWVmpqcElJQ3oxZEVWZDU2dU1OR2RScUt3OG52WjQ5ZGYrK1diY1liZXB0enR3UjNuamFuTHZBRlBYVCt5N2NhYUZqMC95N3VkMWtBc3p2SlFGSjRiN0syOWdNT1Q0UGtaWHUyaU94MGVNUUdFdHErY0hubFh5dkp6NzdiS25MdWI1UnF1UHR2WEozUHlZa2pEZUhNZ3pTd1cwejZQK1hJdEdvaFNndlFNN1M3dnpnS1g1OTZrc09mMzVUMXd6dzdQNDg0SEQ5QU1kM2FlR0E2enhtbTRpNFd2SmpDaHNGSjljZUc3UWJFKzIzZW5NdkxHZGIwTThMaUFpNFZHNlJzemRlZWtTbHF3V1VaVWw4c2JaYkZtbTh0Yjl0cWpnLzU5ZUZyRHcrRkZEMDJCMCtlT0UwY1NQbHJIUFBCQVRhMit6Uks4Y1UxZDljVkdhUlRydTEzY3lNamJFUjByWnRGY29vdHZ5TnpFdUx4NDBzTUhIYkhtUGJ1ODUrZ2JXMEo3ZEZkSms4OFRNNFRleloxeGVMWnpHc0VVaHljRlZWRllTYi9NYzROaWZiZFB4c0Vvc0tqTnFYSVFNOUprOGp3UmE4cStEQU5lTzNralFzMklhTGZMbzFWNmllM1JESjRyaDJmQnV3TmNMb1Z1d3VlRGwyM0RsK1ZObFhhTHdzcDRia1hBMnhkMkhQTG9IZFAxbEJrbnErdnF4S1cxa3RucThwSTFnTjVPaU5yMkZYK2YrOUxGY3diUGJZYVhhS1B4cGpQUUhJR2RPNWV2L1oxeWVIWTBjbDVZZ2J6UGlvQzNIK3pzYXpsNVdrUXdMZktBcDFmNnFRbFFlT29pajdkcyt2SjJCZDRkbytVeGltNUY5R1dMNXppOHgrSllRbko0b0JhT2NHZkE0OUM5ZTAxV05QMnVzZ3pFK2VockJ0NDM1WDd6L1dFL2ZwT1JONTVPZEZjZ2w5cEFubmFCbFNtWEIzaTVDMmgxZVZRb0FubFpsbmN1dVR5MnJ5eFRSRWM4OXgwZVl3bEt3K1BGZGp1OGFPNmtFRlVYbnE4dHMrZ096cVk4Vm9GM3FnZ0orOFYrZUR0emVUdTZIemVCeDBYSzB1VUJYa2JleEhkNWdNZElFQWxnNEM2NXZHeXY5QW5oOHBZdG9oK2l0T0x0MG93Tzc3MzVTaisvc2lJT1lPVzNEN1E0UEI0d1BzN2Z3Skk0M016aXpJMHljYjUvN0dwZTJyeWJTTlBrRWUvb1c0THkvbnNsb3B2b3k3cThKck5MWjRMTjVQTENLUHBqRDdGajB5bXZIRnFXbGtDM1dGZ2UvVWpZcGZscDVmRGdqdHlVY0prNmk4K2QzOERaMWpnTmhQWWpFZVY4UExjeUNiU3Y3TWc0STIrcXlRTTI5Mm8zdXNQc1c0d2txRFVOQXJ4MGpPQlY1Q1V0NzB6Y3ZzSmFhVWRSZUhBcHU4V3NsaEIzYVI1Rnc0TTFjY0NidzEwSGVINGpHYWhwOEdoaEdVZnNBbmxuQnNYMmszMmFrVGRtWjYzVzY1cGpsQlRVQWdOTG5rc2FSMDZpOHlxQWw4aWJiMTg1Rm5ac2hyWFNyZVdWRjVlcEpTQ2VCNGQzdkhKNGdDY2RudlRzM1EyYzlQZTBYK1djNURwT01zSGJpZHdGKzZaMFJ1OHZPLzJsU1BPYzY5cEdBcnh3c2h1aDdaZ1BSK3Z5MGdHUHdkZTNjNWYzVVZ3ckhWd2VyZExMVUJTZTczQjQ4YmFFdDAyR0I0UjgzTFEyVHB1amlqU0YvN1AzRCtZVnpVdzVEM2JxOHFEWS9yTExlWUZsTXdXYjdwNXgzZ01vdmdJOG04ZlpXSk1ETG8vQ1p1M3g3a1JGNGUxNGt3SWl1cXNvTEZOTG9GdXNjbmp2NkpLbWRYaVNydnR1NE5TYmJNaXNVZlNtR1hmajBpbTIvK3ppVHE3bVpaZTdDcGNuTm8xYjRad1AvOFhrY2NMbDhkZm1IZytYOXc5NzUvTGJSaFhGWWJOandSWUJFaUFFVW5rSTZBdEtRMElnS1pTMjBOSkNRU0JFUWVxS0ZidGFzaFNQNG1UTXY4MzQzanZ6K1R6R04zSE5JcDU3Qk1JSEIwaUR2NTdINzV3emk3UFNoTHk4b3JENXZRU214WnJuNGIzejRxMUZ3QU04bTFMNytUU3VBVTlES1RNSm5lekRJUVZldEhMcTRTTGFEVkhtTGZYYW5CUC9jOTBEYUYyOWhnQnFlQlJ6SXY2Tm5aQjNGS3U4V3lIa01UZTI4UjBGOWhKeTAyTHhlWGp4VitGcUNYU1V6c3NkSHR3RkNxMTJ6aHpEZEltN1IyVmk1U0xhdmZ2TFpSN3BKQ0tDdWZGdkI2SUJEMStDSjZzNXlKTnovaEc4THVUZDhPYkdOcitqUUdzbFB5M0dMRGZjZFJUMlJuekxIYStQOVFsT290OU1jVGR2OWRMSkVuYzdqMGZGTHFJOTNhbUNVZVloS05GakM5N2MyNmVHTkFXZTNuUlY0QVZqTFlHK1p0RFI3ZHhZcnIyeStkWUs0am5UWW9DSFVlTHhHZzkvVlo0SmQ1UjdKSnFBRjdQUUN1NStLTThtdWFqMjAzU0p2Qm4vNnlOcmRyVEpDcjkwR3Z3K0h1c0hSQWRzT1lhTUtmUFNxSFI4aEFraXVtMnYvRit0bFNTZXg4ZVVmSVo0dmpEMjhQTGdIVm53Y0hqSDlEYzFkenpjY2dwMzFZMVJzWXRxMzFTUVY2ZW94bVYvelJxZXhNdXZhM2hMZ1Fkc050blVJUTlGSWROZTJYQnJCZkg4Nmk0QnowYTh4SmFxOExSM3BrR3lua3RJWW9SaFVncTg3YkI3ajViSW0xQmwwTXEwS2hNWTZsNm1EeDU4cWYxWWtrMDBkRUxlWVJEUi81LzJDcTJWdkhoK093YThzUUJQOFpjSHorZXVZdzN1Z3FFclNFbnZCT3lxdmFMZ1hXUjd2SmZBcTBnMmFXWHE5VTM1MlJqbndDUEdVZVRoTVI3ZHdwbkFpeUw2MXlnSy8xZDdwVG1ibE5FU29uaCtiTGhqNmthdFBtVzU4M3N3QXJ6Wm5PZGNTa212aHJ2cXJWR3hpMnp2MU1TODJvcEhmQVQwdVdnaW5pV1BLSUJnSjhrelZSNUYzc0tmQnhFOW95ZzBSL2syM1ZxeFdzTE5Wa3RveFE3S1BianpXNXJFUmw5V3gzY25wN1cwTXhjRlh0azV2K2dXOXRFVGVoUEk0L3dWQXE4RnIxOURGakdoYjdxWXlvbVl0M0NEb25EelJkYnlOdHBlNFpybXBieVc4RUJyQ2NIeHdiUGxudTMyYXU2UUZ1eDRRclIyTlZra21nZGxSUE9pMjFmdlZ0SFlVM0RHTWx2dzFBNXNQM2txeGtXanBjTHJCalhBR3krMVZ4NWtGWVZMejNkaHM3KzFncGJ3ZlFwNERuaTRoRGo3UTVDdytRR3Y1emgrTkRvdE5kejk4T3VvMkVXM1gvK3M2cm9tMllROFdJdXVTaWlSRVhCNERYazZSa0FsYjBCZWNObEVEMnQ1L2UyVnpTNEUyZGJLSjZLMTRuR25qdHZpNldDNE11Q1JXOEtkQW0vYWNGZVVoRzJ5YndBdkpadnBVWGRKUGtKRVlIRThXbkp4S092c0pEOUZrcHUyQVY0YjhqNFI3WldOTHdkZHNsTXJkaTloVjdkV2NQQTBlR0pXTGdOZXh5aGFBaEFTQVdWSDg1OXJvMklYMzY0OURPQkY4bVp5aENKWXlpNnA2OUNseE1jT1IrMnVkU0pkNDByMEFJLytTaHZ5ZHRsUjZKMWV1ZlE4dDFieWV3blh2WUJudmQ2QTV6WTQvWXFZSEY0R3ZPUXZKNW8vbHlNcjIyRi9YSkdkVGIwVEhieEFubW9YU0Y5UFEwTWU0S2xoTVE0ZDBWNUJVYmplaEx6VkE1dmNYdG5FclJYYldybmxhZ2s0L0NvMVhLYXo0bS9pMjF2M2V2VXhjVGlwQUs5Y3I5MFd1MXRCM2dUd21LbEk2RVh5K2xJbTJlVWtxdW50Zy9DRkswTmVPcjV5UzdWWE5uTjdoVnNyMmRiS1pWb3JHZTRhbzZmcDNNREEwN011ZGhMQkEyOVdWVlVaV2RrK1k0QWxMQWgxbndsL0lCclBYcWJGRXlPYUVHVXJPMDlSaURzS2wyVjdaWlBYM04vUHRWYllTekFCRDA5QVNJeURPM2pDYzdTL0pXZXNDcno0enJTcVNxSzVoZmJIYnRYWk5IS213TlA1cEFzZTcwRWVHQ0ljbUJqQzZ3UWVBNXU1OXNyN214YnhhSzFjbmVReVRjMmRuUkp3Zmt4MmYxRkZScXZtVENyczhxalk5dGpIRlRaSjVBR2VWZ3FVcEdCQ0h1REpHQmVRd3BYZ0VmSlFGSzdTWHNsSWVSc1M4WmhhU1dPYVZyWHpBeDRlTEZsOWozalhYKzh4TjkzODJTNERZUTlMb3JsTmR1OWhoYzA1OWhnL0FWS1Fnc0xreG9KRmR0ZWpnMHNhNmNVTlJIVElhNjhlTWIyeVFTbnZJei9UTksyVitYa0NYbklOZVBqOFhIenVoRU4vT1FhOG9QcnNsdWZnYlpjdGtzMjZEWGtCTmY3L20vTGZOamJsbm8rVnpWRVVESGsyMTB3Y3puVjd4WitVL21oVG0zaTBWbDZpdGVKeTU0T0gweGZ4VmdjOHVNT0NjMUsxNEJYcGZQdnNCdUJWTXdFZUtvSzNmQ2UyV1hIa1k0QlkrOG1CUjhTanZjS0ZUVS9LZTJQdFRiejgxTXBzUE01b0NTYmdTVk96MGtlQTV5M0s2alB3U1VxWUF0NjdaVVp6Mnl6TWJOSmZJY0l0TEQrVkNXdklXb2tpaUFwSTRlZjZtdm5wRmJieTFuOFdwYjhRbE01SHc1Mmx5OHMwaFdOdkliVWFwZzJGY0ljRlQzUlc2cjlIeGJiTi9xNlgraXV0TkdXUDlQazNWVkRHWmVKcFlseUdQS1M4eHByMnlwWE1jaEJQcWR6WXVGaGFDQXJYTk9rSnlVd3p6NTEvQ1pDZkZtOTVBUTlYZGxhK0hoWGJQdnRhOVZmc05HSHlkU2ExS3Rla253SjUrWkRYV0dxdmZORXVCMjFrYkl4TU0zTnJKWXA0ODNFMC9VdklCN3hvUm1YUjIvalJ0eFVldmdoNGUwOUh4YmJQbnU1Vk5mMFZ1MHdXWERxWlNwZUNOUndZY2pzVFBvU0V2RVY3NVVEY1hubmVYSk9iRDdsYksyL2RXYlJXRW5iUitzVHpyRWZBazQrblZyVnpQdURkR1JYYlJydFQxeDE1TTJnUzNVczlsUWxzSnVRQmtSL3lQUENBTmZ5TjhNd3VmWHZGWG9EWVVLYUppSmVlekJXNWV3WjJPUzBoMTJmaEgrSTNNd3NlM01tWmxSK0xoTGVsRnRjVXdsamd4SjZweGJXL2I5dStBcWttSlJJYXVrOWUraExJYTNMTjd6SlNIZ2MyTjVGcEl1THRMS1pXeGhoYlN5dUtPdit0RmluZTBUL1NmdTVPS3F4c3YyNnIvVG8xSVUrUlI2WENlK0s1a3BFY1BwMlpLays5RG4rRnZNWDB5czZTbE5lM292REJCbnVhU2NUN3NnbTJZOHRkWXpud2ZBcjlwZ3RaQkdNSlRzQ0xDNU8zUjhXMjFXNlRiRTc3cXp6S090NUk0UEhJclhPQlJ5eU1GQWRMdWVhWFFjcmJaRi9UenpTdGlPZUNGeHpEWFQ3dEZNZW9BWTk1RmhlOENkTDVmdW1zYks4OTNhK0QwVjh4KytZRU9Sd1o1Z0RQVXhSODhQaE1oNWVuTFhsR3l0dEFYNU5NMDQ2TGRTTGVmbXl0VU9JbDUxbDY3WUdINDN1OHR1dUwvZ1hPZVNlZDEyVUxiNnZ0KzdydTBzMVZqYzBFSG50b0NUeFc3eURQcU9hS1F6R3dFbCtlQnZLaWxMY2ZwRHpHeHRiUE5jazBzNXQ0bnlZUmoya2JNR3lnQTZITUNJc3Ztamozb0pSNlk2V0VkOHU1aDIyMmE3L1UwNGE4SkNub2ZYTzFZTWZuaG9oSGR1bExYOGFGdGpHNVpyTFlYdm1VcmJ4TXJybXBURE51NG9scWM0emgrYWhsd1V0c09XbW5KeVdVUjFBT3duNFBJUytwNlBJZ3F6eGdCSGlwc0tQNnNRZU1jTzFhQWdhRWtCZTM4amFUYXpLbm1jMDBrNGozTEdTOWFBbkt6dEZuNFVmQkhCbkhvZlM2dXEzdzdvK0tiYmQ5VWplV1FwNEdEL0xFTGs5dzdXZ1ZyN3dxandRMUduRnlyTnNyTnRlMEd2cUdNczEwUC9xTEpPSUY3bVJySlJtOUlPanFUVHZoenQ0NEpJazM2eDh6Q3J5NmJBTnR1LzAyb2JNNWw1V0hBczhjVlJFVm00MXh4bFc5aTRSYStzQ2ZSaStNamFXblZHNG0xM3dqazJreUxrYkFRMHZBUVhnOE0zZzRwc0t6ejlBbDREVldwSVR0dDlzVklVOWUvemZEWVZSNWhBTTN3OEpUSTFqZ3V0VElpT0NkeHJmbVhJREk1SnFieXpTdmttbEc3bkRNQ0FzdlBlN3diRXJnZzBlZlpVWkw4MHA1OXV2MjIrTXJKSnN6UGtoMk9FelBjVWp3ZXJOTGxBUENuQVl2aGJ4MmJPeHdnMzNOai9LWlpqaW55VGZIZDZmTHZkNkluZ2w0eUphWUJXOFNzVnY4OGVtbzJQYmJEY0NiYXVrSjh0RHJGRkIrSzFQMVBJUHhEd2tJMWR4WU9MQ3BjODMxOTlEZk8yT21LUmNJL1lESGEzK0MwL0twZmdwY3pMRFA3NW94czdMM1pGUnMrKzNKSHVUTklHMWhCanhpM2lyd0VCdFVMWmM4QlI0QjV1eTU1bnRudnFkcHJ4enBUUE13WkpxQWw4MDB3ZkNzRlo2UlhNVGxkd0plM1ZnNUxEWVV1d3g0YVh5RFpGTXc1SU9ueWVNZmdqWFFJK1FaOFB4YzA3OTU5T3JhOXpUOVRITXNPeWc2S2JiZ3lkY3JLMTJ4WGd0cGtydFp5MTFkN1pSN0Q4T3dyM2JxWURIa2RkVUlZNW05SWM4SHp4WHAxQmdXNVBLYXZ1Ym5LdGRjLzc3bWExdzV5dlEwMVpnbTh6Z3F0RnZ3M05ZS2pxWndSY0FMb21wWnd4dU0zYW1ZMkJTVFRrSy9NOE5oL3VGTW1MVDFXL1NBTVAzcmNISzVKdmMxWDF2ajhjdVpUQlB3aUg5aTdqdGI3MlhtZC9EOGxtWWQ3S0FNaXczRnJoMHd2OEtURGdoNXE0YkRlRStub1Q1NFNrVG5xMFN1ZVRXVGEvSlk1cXlZa0ozVC9Mek5ORUVLeWZ3YzRNbFhlUDZ3Z2JxUVB3Rzh3MUd4b2RoaEhjeXI4b0JEWnBlV1BGNUNFUTdLQVJDYWpCUU5QVE92aWFDdzN0aUttdE9jTDJ2N2tNSzNacllxK3ROT0hEY3B0MjNqRXZDR2EwM0lDMGJJWXdkb09iODhBM2pMNFlzK3hTbmdpV0FZVGNFNkYvT2FtZUdWTmNkV3pKeW0vYjR3Qzk3Uk9jQkwvd1ljZFJGWUJyeXFCTHdoMmVGME9rM2tUY1Ftd25FQ2o1Q1hYL29aUTFIblFCNy9QalZQMWpldnVkYndDbzlNeU8yZTM0eVpwa2lIQ1htS0xoZThqRjZ1eU9VTkZMMDUzRDBvQVc5SWR1MEE4bzRwYWt4TFplVWdKanp4T2NiQkJUd2Q4dGdOdXNrZWVsK3V1YzRqRXdDdjJ6Mi9IekpOdmtVTm5oMDJkZXM5ekF0NFBuZXRVeXE4NGRyaHRMRVU4aEpxZ0lmcmowRHpaUW9pdVc5blV6Y1B2TmpYdk4vdG9mY0tDaCt0S1Nha2U1cnh5bEhhUFdjeENXNTg5UnhIVkwrWTIrdk1nQWQzSmVBTnpFTElTNTFOc2tzVDhub09MUU9VcEtpdnIyay95Zkt6SC9iUTQ4MmpjRjl6WFVIaEZYOXNoWHVhelpVak1rMzVtNE05clpsTE96Rnp1MzVWd2lBQzN0MVJzV0haSGNBN2ticUIyMTVKRHFhTHQ3QnYwRG4yVTYzK0JmS0xUc0xOSSs1cnJpa29mSkFiVzJreXpXOG5reG4vZFg0ZFhobWFCdzk5TWhQdzhFVEFLME1yZzdPdmRycGNzMUpTdWV6SzJXdCtnaHpTc0FDZXZPQVhmQlB5bnZHUGMvUG9zM1JmYzMxQkFUSEJqcTF3dWYxQmVGUUozeURmeUlvNVRjdWRCVSsrdGVwS3hFbkFMdGlYbzJKRHM4dGRsVmVuOHlOS0FQWVZCWUNTS2FucHAxZ0JqSDllaDd6ajdsRjVESy9rQllXOG1HREhWdTQySFZTWU42RlhjWU5udWk1MmE1WnduOWtvbW5ZQmI3K3NKUXpQbnV4MzVFMEJ6NUNuUGtqd2RSVFNTMnBCR1RaODhNWUd2T1EyT056TkRLODBWSjEzTThHT3JTd2V2endUcUduSDNUam9CMjlzeGZkZThOTHJXY1J1OGNPL09TbzJQTHM1YlNXRmVzNXYxQkRHWjR4WUVHQkxiM1d2eDdxdjZZSUhiWkRYbllDWUxSN0xySWRYenJ1aDhDRWwzcXF4bFdPWmFGcEhzMllkZ2oydldmRWxUZmNEWGd0ZXZWc1d6NGRvajNlbnFjRlNUOVJ2emdZOGpOWHhvK2ExcWV1RXNOY2I1M2lWVGtBYzU0ZFg4aHNLTC9oaUFvOU1TRWNmZElXSHh4c2k3dnZnZ1pvTjlTdXVBczREZHdHODhqaThZZHJYQ2J6R2p1M3pSbVI3SlZvYjVjSjdLdndSQmZCNkUwd2lYdlRTb0RRUFVYQUZoUmZXT2FpSm1KQU8yWTR6NEkyVnJUcml4T1VtaUNSa3VnRnYwZ1c4NlYrallrTzB2NlpkbFhjaU5BUnhjRVVFTDFjcDk4R2ovN2tDUEQyOHNscFF1SlNiRjh1SUNlR1JDWE1mUEhlSGR5VjQvRUNra05KM21oTXRJVlY0NVpibVVPMStSMTdOT0REZ2tUMTVNeW95dlF5dWpIalJjdUJ4QU9JVExTalk4NXJuWHo1bkJ6YUlDYmVXeDFiNlN6eWNaLzVvcHZ3cXdyNG85M3d0b2VPdWZtZFViSmoyenJSVDBXY1dQTExMbnFrVUhlV1FzOHdYOXIxRVFtc0ZCYlpodlNKdi9SSVBNY0VGejNCM3BqTXMrcXUwTEVHSktMV0VjRWYvb0R5SGNxaDI3NkFqYjBwZjAyc2YyR2Y5U1BBU3E1QW5QOXk4NWFkNXp4QVVNa1hlODVWNDF4RVRxT3EwSTduRGJJUFRCand1VTJNQ3ZCa0JyendlYUxoMmwxenpXQ25sU3E4N3BWRUNlRWN1ZURLYVpZdTgwKzRoQ3RmWExQSllDY3B0Smp4Q1RIQkxQUHNMd05OU3VqK2pTdWVwTVdlQ1lCSURYbU5YaW5nK1hIdXlIOG1yZ3FLZ3BYTEFRME1ZNDRteFRxSWtmTmxRWWw4SHB0UHd5cVBjaGdKRjNybExQTEdaSUpqS2dvZW53RE5hZ3JmeDBOZGFtWmFyN1VPMjY0am8zWXlLWHFOanNSVXBqOEpPZ3VlSFBQV09BYSt4UlpGM0pXNG9yRlhrVWVMNTgyS3ZOeVhlVzVlRG1LQzR5NEhIRzhIeHdQTzJFdjBLNzZUanJtZ0pnN2JmVUJSbTlNL0hSNFlQeWpjUFBHY1BUM25tRGNBTDVBVkI0ZkpiVFpIM09sTmo1eXJ5THZYZEYyTmU3RHRLUEMxb1pFbzhYOS9ybnhyb1c2R2RkdE5pRDBmRmhtd1Bsd1kyb2NqeUFYaThBWGpKOHJIRUIrODBGWG5mdmZnMlUyUCsvWWQxVkR3OUwyWmJLeTVydnVPZnBVZmQwMThreXIzanVvMTNaZk44NEhhNDFGNkJqcmFXaytUeERocENKajNETTI5MDRQMzdienMxZHZEaW03a2liNzBTTHl5ZjUrZkZJTWRFTCtzcDhJRE43T2pobkhUYzdaZEZ2R0hiVjN2dHZHWjlJajVmcEpTd1prT2VTU0p4dk5CaXdXdkkrN2NoTDIwb1hFMXI2UDFGM29mWkVzOFhFMTV1bHMrLzBmTmlPTzQzbjZmUXZ5ZnFSTUlFSGdIdjgxR3hZZHNYRWJ5RnRlS2JBZS9JblhtbThlSi9YSDNZY0FEdnRKMGF1OUdzb2IrOFFsQjRoU0l2czR0blM3eTNVNGszZHJKTEh6eWZ1LzZSYXRxOW9DWldhR2QxUjE1NUF1eC83SjFOanh4RkRJYWJHeGNPSEJBZ1FPSkxFTDREaEVRa0VQR1JaQk5RVUFnb0FpRTR3SWsvMEN1Vk5DM05iTE9ibjAxUFYyMC80N2FyUGJQaGh0OVRGVHRMY3BnbnJ2SnJ1Lzd2R3RNckdiME5QaFI4dFJJODgzZ0plWEs5U0I0aER5ZnZhSHZKZTNicGt2ZUsyNHVIckN1ZU5zYWR2NkhhemJnajlJdG1EVGtpc2V6U3hOM0RKdlIvMTRPSnZLU3NjbEoyVmptWUF4NFZZYlVhVFpiT0pjL3B5V04ydTMvRnE1K05XZG9VVnNERE1HZWp3VHRQclhSWk1lTW9kSStRdDhJcTF5YTZ2T1RWd1ZzS2VmSW5jenE1NU9Ia3VZTlhlQWpXYy9IS2ZMSER3V09wd0xOT3A5cmU1S1JaeUx2eFZ4UDZ2K3V2R3hONUcySVI0TTBiWGtnakNOYlk2SUt3MXI3eFNUeTU1R2tuejM4YTlrV3VlRXN1bmgyK1hQZGM0MlVibGRhN0owUy9ib3A0UjAwbzlQMEVYa2Y4VWhGdnlRL3Z5NUlTc0xLQlF3YzhMbms0ZWQ1MFRYK2lwaXpVNUlybm0rU3R2N0Z0U3pYeENBZ3g4YnJmbWxEb3pXNGlieVV2S3BvOG01eXhBVnVCbHlsbXZ4UnBXdVkvaUV1ZVh5ZE5oYlJYcUpsUzJ2Smd3SEl4OE5xSyt5NUgxaGdtWHZkNWpJOE9EYzFCbjArWHZCUFNJN09aMG5hTzBrNm9TUERPK3Q0WXEyRGNtbG91ZVpSck9zMndqbjFPTDE0dTFLekNZbmZNSDNMRlk2TWFFOVJKTTB5OFVMYnlPR3ZPUjl2NitZWjZ1UXJndGVZWG1GVlJLZGVrSjgrdmsyYVVyZE9MOS9TdGxEYi9FWGlzNWh2Vzh3bSt1eWZOWDVwUWFKaTlRbDV6TFJ3N1RwN2VKVTNiZXBDbndTTW95S3ZnSnFWYlQ5T1Q1NHkxZGUxek9XN2xRVXByQVY3YlFwRWJrUGxMMTByZnp0UnRWdFpIbjB6dStROU5LTFRWMnhONUoySk1Gc2FCRStWNm84TU84UFQvb0d6aExuOXFuZEtEUEhpRlMxN2RRdmR6SzB6VUhNYXRmQzVIU0xNK0NMenFkTEpjK0ZZMjF1aVZib3A0VjV0UWFLdXJtVHZPbXFyKzBEbGFDZGI2TXdtZVFTN2ZZY0RMVHQ0WERGNEJQSEhKZTk2Mno3MXhLM2R6YnNYeTdtR3RQUXc4TnVPUjJqWUVPV2tXOFA3NXZRbUZ0dnFkdkthWmNIZnZjajMvM0IrYjRMWDFjTkcyeE1VVGMvQ0tiNkcvczNERjR5SFlUUjA4MndwM081cm1oVy8xTytGT1R2TlJFd3BsUGVLc2FhZlBaYzlxMlRyZzhTa0Jub3lmYXZES2w2OTZsN3gzbk5ZRVpaOC91NjJRdnBiU2FUc0hyL2ZCczZNZnYxNmZSaTAzWSs0cVRwb2hvZHZrTlcxZkdQQmtMRHZtaHJOWU5TWmgwK0FWQk5iamRNMlhtSzdwZHFHVFcvRXJwRmNLUExVK0pPS0p0WGNYSGpxQ3V0SVJGSTBKSWFORllXV0JSOGhURnp2QU00NWc2bXhuZ3plZFNGZXFUdHJOcnZpNWxhbEMrbGlBNTBHb3VmUE5oRHA0bTZrKyt1MG1GTko1elkxaGd0dmdaWU5PSFM4VnQwVm14S01wTDlPS2hYNVFkc1hOcmJ6NklmYTU1RTVzYXAzekRuaXQzL0tiSnZEaWFhNFErb3plSUdYTUFaNGdUNExIK25qKzIveVNIVmVZLzlEbU41bTk3SXBkdCtLUHNqMEVQSFlIbmpUdGFzN1ZscnR3ejBQYVE2ZGVVM3ZnN1l5OE9XekFLWkhpL3VhRE4xbm9kMVIyeGExZGVhK1dXOEUrdjQ5OXZpOTRyRjN3M0FFU3B4TjQzemFoRVBwaEltK3RQUEM4VnVDVmtRMzFmLzlaOTFYd2NQTEdYUmxydTVoZDBiVXJsNXpjU25tdHBPN2lXZHhWWTVrUG5xNnlPNWtDM3FkTktLVHJOYnN1bGZ5SW1QSW55RHNHUFBONENaNllkRXNudWhhVnQwdVdzeXVYZEc3bDBwNjVGV0Izd2ZNbnBkbk9nbllmeEVuejlTWVVRbjkzVThqVHZhMnRDbm5xWHFmd1pDTTU1R09tVWtyZnlDNTBQN3RDVDVDZFd5bmQ1MDhBbnBQSGRFK2FESDI0SEdQOVFydjY1Q1puVGI1VTBySEQ2Z1pJeXpZNEdEelNOcTNPcnZpZFFlOWZNTGZpTzNxK0d6TEt6Y1ZnSmx4clFxRmRIVTNnaWVZWk9MSy9vYlBrSlJzVkpmVWxyNGg1MG9QMnlxNjg3ODViOFhNcmZzQmIrdnZXSVRUQlM5Tko4MjRUQ3UzcW13bThOTUppZzhkUGpNdWYzU05ETkt0OGtSbHJtN01yOThtdXVITlhLQmp6NjFacTRMRStCRHdkN3Rrc1hQRitia0toWGYyY0p2Sm9vNnUxdk9qd0I1MFhCaS83Z243dENrVmpGSXdkbWx1cGc2ZWp2UTFlTGR0Wk5STmlubWJJMU1PVXVPU0pOaGZBaytUczBza3ZBQjZmVXVuTEtuaXRYN3N5Y09Zbk5XVlAwRlMzMGl2d3ZDQkhzQzh5eXF0dDhGaWZSTmxLYUtGNEpaTzM3VkRJSUlqbWc3TEJBaGlSZWl4aEk4anRCeDcvUGY4Wk9idnlvZXdNMGdPUG5sZEpUU2UzY3IyOHo5WDNqbjN1SlYwQXIyY3RiRThMdkc0QzcrOG1GSko2clV1RnZGVEFFNWtUL1hqeXNIZzhCNDl6cC9pUzluQm5CaGZBMjJaWHJpOW1WMGhya3RUMFhrMjRsbk1yNE9MeXhjWmU0MDJ5cVUyZ1hvV1pFS3JyazhzNTVBMWFaWTRzbHc2b0NJdnFYa2Q5cG5YSjY2dmc5WFFHTVZ5emx0YjBrNXFNMUh5WTYxWjg4Rmo3NFBVYVBNYTQyRmU4SzAwb05OZVZMaFh5MWpnQ1dUS2Z4d0ZSZzRlM3JzRERzalBBNjgvQlc2WDBpTGZRRjlPYUpEVzllU3RmbE55S3ZwbDVySm0vQUhnYVFnTTg2c1UrYWtLaHVUN3N6a1BlaVNoZUFiZVpMVGRHdkx5VXBPcWpadG1qR1hqNENXWHVTZ2J2bVZwYTAwOXE4bHhKbnJmUzJ1RFZNclVPZUdRN0ZYamE2Qnc3WU9QZDgxQzFHN2FvdEtHcjZoTUZYaTdYbE9DeDJlNXE1UEUvQnJ4TVhpNGFlNU9pTVMrdDZTYzF4eGNwVzNmZWlndWVDT0wwYkdqd1dFc1g3K1ozVFNnMDEzZGZURTZlTXB0TjhGam10ZG9vOEZSTTZDVjRKYTE1KzFVdnJTbVRtbDdCMkoyVU5rUThuZFFFb2lxRmxYd3NDZG42QWZZMDZzVkNpN28yaGJ4VFJWV21RcDZzTkhqOXRNSFdhOHZPc0o3blg5K3prdGI4MUUxcml0RitMM2lEanE2a3RPWjRxTUhqM0ZpdndaU3MyZmM5Rzl0TkYxZThrSFBKeXhxZFBBWGVzSk5KdkxMaU00QTNiQVI0dzA0RkJaMWRHZWxrNE5GQ1d2TmQwWDd1SlRVZmtkVGt6K1ZHeXJweUV2YkJXMHJUcEM2YXowTkwrbVVDTDJWY0h2Y1N2T05sOExiaTg1eS94bTJoMk0rdXJGSjZTRnJUYlVMbjJZUjZVdk5tU25UYm12VDNqb0hBVG9FSHQ1VmI1TVRkNVhna0tGUnBEVW9wVWE0NWdNQmxUSUhYenNBcmhnTHJBaDVRK2VENWFVMzlnTUtMRlRlQk41aS9TWUNua1pMaytKYWUwOWFuMXV1dUN4Y3Z0SmVUOTArM0xpUm84RER5T0YycTQyVmV6OERycStDMUFqeDZZZXQrd292U1RmQ1RtaXJpZVZrVDduNGVuVElTcWdNc1Y3emJUU2hrNmZaa29XOUlxUEFkTk5ScjhNcm1iSmRDRHp3eDhNaFBhdzZzT1c2QzZvSVZ1UGhyQXp5VnV2Ui8rL3lLRjRXYUlXLytRd0V2RlZ6YXJiREVwVG5BR3ZBS2JOczFWUzFFdkhGak5pamdSNXpLdEtiakovaHVncDdldnU4YThFcXhnTDdsK3QxRjNhUy9tbERJMGgvODZ5eFNKeUxpbGRCRTBSamc3VVk1RFo3Ym9GRCtqSFZLMTV4WDh2QVRLZzhGcVpmeHFwSFdxUXVUNGJ4ZXFsSk5pYTY2TGtaSWgvekhTNHBXR2p6SU8yT1RzNWZnZFNiQVl6T29kOERMa3Eva1ZjRjcxM1VUYUQvL0lhWFZ4Y0RicDBiTWdaRGN5cDBtRkxKMXA4c1NkZEw1NjFrNGtxa1N3TXY5c2dvODZTNEltUUF3NG05ZlArR0RSVGZodWEyYlFQdjVSY0Vyc3NHejczN1k1ekZ1SmVUcGJ0ZWxiamU3UXVvamsxTWdMSmM1Q1Y3K2pBT2VGL0ZLV3BQbktXdCtndGViUUluMHZiM0JjL29YMktobVBKMGYxZlo1dkJJVXF1blhDYnhVTEFIUVlkUDNlNERYejhHenlxVEJiZ2JlUGNxa25mNkVTNzZic0c5U1UwYzV0VGJCZzlxbDNNcU5zTTlEOVdiWWxBcDVKWU5lQUtQNEpJTlhLQ3hJaWFGSWd6UjRtZUdxbjRDY01tazlUZnF0YW0vQ21OUjhMYzk5cUFSYWl5a24rdGsvVUIySk9yZnlvQW1GYW5xUXpzbGJqYmdNRXFkRjF1S094MmUybkFLZWJOaWV5UVNQTXVuWGhyUm12VC9oTGZVMFh0Vk5PTXBKemQ0ZHVMSnZXT3huNEJIa2RiZzg3ZUxSaEpDdlR5ZndUaVZzaFRaMTRlc1ZlR1ZEak5zZnZQS1IwNVNPbEo5UUcrUHV1QWxEYjhLUEEzaTRqMjUreDArNjlPYXNNdEMyY3l2M21sQ29ubDFKZzhpdURJSXF3T3ZKY1ZiQW81eU1iRHd5ejVwNWVGTHZQQm1Fa2VmWmVLVTNvVHpDM005OWY1ZXZPbmorNkxGb1RRZ2QyS0NRcUYwUlBRWjVJMnRVMm5yRVUyYzd1RFBCeTkwUWcvclJUM2liL29TYWtjZUlzZm9VYVFhdXlJZ24xaTU0YlRYaStaa1pjaXN4WUN4VTExYzNwck1teWNnZDhNUmtJaWZpRFJMSnY3M0JveitCYWRKNjBCZzJuajlGR3RZTThNcG1iL0RzdGIwaHQvS29DWVhxZWtSMnhZeDRzbHhUd2phUGVJREhya2hBTUFmUG55Yk5vTEgzZkJ1dkFsNWZnZkNBWTZmL0llcFdqcHBRcUs3dkovRFdObmp0TGtiR3FCV2lCRWN5Kzd2T3hnRHZYcGttWFRYeTNxdDM0K21uOGNaVG9BSnZDY0tEa3k0MmhkRVRGTnBQdDlPVVhja2xLdmdKUUVoVEF1QVlBNWJGRHg0WHFnYnArMVpaNU9TS1krVFJrZWQyNDczODNHRGpmWm5TUmpCMVFQVHI2N0dzM2VzSEp4TjRUemVoVUYydlR1Q2RqS3dOcXRmbnR4SThkYnBVOTdjS2VPMEVYdjdCSnFVdkJ5UHZ1WmY5anJ5M0RQQ2tqWGNycGJVSFhtME5rSXRqSDlvb0dBczlvWDZmL0lRMGkzamM0QVF1QWpieCtHdkJDUERZMlYvMlBtczA4bTVKSTArRDl4YitlUVc4OG03Q0ZjRHpXV1BYNSs0bjh5Kzg5OTB2Q3NaQ2Urb1QwcG83cHJtQVRSaml3S2FiWkVGdFdOY2lIZ3ozVTZNNjd5Y0FYc1ZCZndIdzZ0MTRLOUhMNUlIbnJVbmpUcHF2STZrWmV1SzBKaTY0QVI3TGpLYTR5RW5VMlBVMmVFeUlXRlU3OGdEdkJRcFhscnZ4dmg3QTgyRFRhdzJlcHBPejlDd0JFMG5OME1FNm1peDAzcWRVQXpYRnR3NmlBQzl2emg1THIrQU04clNmUUJLVloyR1hISFNuY0dVKzI4KzUxckgyd05OdzF2TXNKRFUvYTBLaDVmY3B6N1ZSeFZWOHpRQ0dyQW1HZ0tTUWFPYUN4L3NKTjNIUXE2VXJGSzdVMjJEZmVEcmJlRFo0U3dVdHl4L2kyQW1jMFFVYmVxSmUyS0lUdm5NU3ZJS1lCZDUySnpqUzRObGhocy9nb05NS2E1YXVNUGhocVhEbHJnYXZmeEx3K3JZQ0h0a1l3TU5OZUswSmhaYjBVM2V1Sk1DVElVemMyRGhxL2lmZzlhT1JkN2MrV3BQaEQ0eVIxazkwN1R4LzNqcEh6UXRIdkpHOHNsWXBVZUVtL05tRVFrdjZ1WnRtL0UzZkoyQUR2TE95N0NWNHNHWnRiUEJhRFI0UG9mTlVselg4NFNtM2NPVXE0UFZQREI1TCtOS1pUOEREVFlnSHVrS09May9nSFdlcWdJMDFTVXI0VXF5TmE3NktnS2NNOUY2QU56cm9WNzNTbGFlb0dLc1dydEIvM3JjMllQcS9GMVZzUFA1ckpkSENKdHlFMElFai9rcGVjMFU0Z3piQzNGa05QTWhqalVsbmwyd0JYbkhRcjFPNnNsQXpkbW1md3BWVGs1RjZZQU14aHkvMUErR1hqRzVDdkl3WDJsUFhwdHFWdFloc1VBaGhkcFN6TmowcHkzR2p2dTc1OHpqb2J1bktLNVdKSzNxTTlOcTJ3M1UwOHlLaDl0S3QveXNRQXQ3MUpoUmExdlVKdkZNTUFvSldXV2RwdnFDTGpRRWU0Y1NLZUhxWXREMTFwUTRlajFMZXAvOWNzT01Ic0xhU2pUa1Q0TFVXdGFNbUd5K2xlSkl5NU9wRHBqOU1MTWpzT1RIcmNQRDRpWG1Cb25UbFBvOVRWcDlQcUpkcVVqSDJVQTErdUFpRTBrSVE0UEVodFRrcDNLWHU0eVlVV3RiSDNXNS9nb0tINEhTaGlNZk9qSGlBOTlDckdYdWVVczJsaVN0ZnB6ekV3Z0dQZjFkY09pdmd5VjhHdkRTbys1ZTk4K3AxR2dpaThOSVJSVUtpSXlSNjc3MzNLcHBFRWVLRkYzNkVyelRTdFJSaXhmeHNBbmIyRU1ianM1dUU4akRuQVkwVGg1dUwvREZyNzVtWkxjSGw2dGNXMUNjQVBKRFVrZjJtVTVsTklZNjZMbkhjT1RhZXNhYnJDakZycmdGNGhsWHpoa3dtSDdIbktUZ0hzVTd2K0RmQWgvSDZOS2pTZ3VmYmVDNnVMNzNnSWVVaDVPRGhIYktvQTNnM2tzeWFTVmJOTmxGWjRPbXZxNys2WGxmcmRGbXB4N21UTzd4U3ZDaklsVklZMUpMWHJxdzBlRmc1NW9PSGF4L3ZxS1FqY3A2Yk5lR1JKbFpOTUVJeW52M1ZEZkRxdmoyS3BRamVqZUJ5TVQySzREWGQybWNHcnphV211cmF4OHNBVDlZYlprMkFSenpTay9ublE2dS9BNm92N01jOE91Tlpkb0h4R2IvOWlPVzQwbndYWEM2bWR4Rzg1WG5BdzRFR2p6NC9IRTdtb1BlNXBCdVBOTzB4TmlST1RRTTg1VmJwelg1Z0VIL3Jjc3g0bDRQTHhYUlpnVmRyOEdwd1ZNOEpYdEVKSGdZRzJTNXBHeng0cFBQQUt4Q0NJMzM3MWdjZTRrRUU3M0Z3dVppZVJ2QUdrUmNGSHNLa2pBZVhOTHZnNjdvRjd4eHpTWjlCTzFzeW8ydk9lZ1M5NWFDWG9IVUhlQmhZY2oyNFhFelhCZGFWK2NEVG5yRkt3WVlZMXl4eFNRTzhVN1E0NGZyaXdadmV1bFAvQmxnQ29BejJiSEM1bU02aXRhWUpIcUFDYkRHdXpSMXBISEh3cmpPWDlLa1FWdERpaEVzaUk4WDU3T0NaSnZDdUZmblh1TlI4R0Z3dXBvZTZ0YVo2VEJsbjV3RzhqcnlXQ3g3TUlDT1JTd3k4RlRaNDBTTzlIMTAxRTh0ZzdRTmRMRVQyK29ieHFlYSs0SEl4SGRiZ0ZWM2dJWXlBcWF1eHlnQVB5YVVwVDlnZlhkSUdlQ2pIczRzVFhwcmc2VytZUTZkMm5HbzZKVHJHdGdhWGkrbFRCRThBbnI2YlE2aE14TWIyZEI1NEw4M3lCQlRrN2FibGVOZTZ3VU5ZVS9Cd2pxWVdjY2NINEJqN0hGeXVyR2JTVldXQVZ4aTIvdDRZRnlvSDd4b0ZEM1d3S1gya0M4Nk9FYWVkWkRyR3BDdy9CSmVMNlVNRXIrekllRlVYZURVSHI4Z0FqL1NTUmlYcytBKzdIRzh2eXZIU0g2NXc4SGlzd2ZPaGxDNnUrMlVrYjVMbGNFa3Bld1o0WENCNHZDQ1BneGNIb0N2dzZoUUlwL2ZKWndldmxMSzhGVnd1cnZNbHBzSUNQTDB5NDB0TmxTeVN3V3ZHb0JQd2pBSjBOVG5CK0hHVUhmelMyZUNoeDVoN3BGMkp1dkU3ZU9wNlRBYXZuaDA4VEUrd2V6OXc4TjdOQ0o3YTdEY0FRNnpBUTNIQ3NlQnljWDNNQksrWUY3emk5M09xcGdTZGdzYzdQM3dVV1VvR2ozMVhYYzlreGhVODB1TEZDYTRrdll2Z0xlZUNwK09hZzZkTTBsVzFKUEtSZ2JlVGdOZk1DcG9kUEQ1cW9UWWdySDRENzIxd3ViamU1b05YbStEbEx6WFZ2Q0I3UXQ0dTJ2bmh6Y3pnRlQwbmNmQ0tYOEY3SFZ3dXJzdS9nMWR6OE9yNXdLczBlSThBbnRsMGhZTjNlMWJ3ekwzeGZQQzhuYTByU2Rjd0lnOFp6MDV0Tm5oRkluaDFGM2kzNXdkdkR3RlB4U3ExRS9EcVB2QlFqdmN5dUZ4Y2p3R2U3cmRsZEU0MndNdlpUdERnN1ZrSWVCUTJic05Nc296WjREME5MaGZYVTRDbjlwSVJFL0R3Umo1NEdFMDVOM2puWndlUGZDQUR2RXZCNWVLNnBNRHJYb0hWQ1V2TjJnS3ZZT0NkLzB2ZzRVanhoZGRwYWNQMEV0VEJjODBFWGdud3B1NWVwazNTQ090czhBcWE4WGgvUDlKV014TThuZjF5TnRCVjJ6U0E1eU5MWEdtNkhzRWJnUjBUUEo3eGNNU2ZhZ0s4V3dzQlR3aDRoQ002QVIwZlZ1Q05vbVhzU25DNXVLNlVBdkNtSE5CR2VYbWxZb3ZJS3ZWaUZwRTV3TnU4U1BDVS9ZYWxjd2ZQdFJqd2FnV2VIaWpRR2VlQmh3NEtBRTkxdEtYZ3Jab0R2TnA2dmZ1N09uaXV2d0llWWoxbng1cnEwY1Nna0dlOHZ3d2VRcldPeGh2V2RvS0Q1MXFjcmlabVBNUWNQSDFoR3hudlg0S0hJMzZQeDZ0bzBXVHNTWEM1dU01aE5DVUZENkVCcEFKUDcwdFk0QjM2eStEaFlIN3dxa25HRTg5NHJweU1KenJqZ1F2UVpvQ0gwM25HMDRWRTFaOEdqMWY4RkJ3OC9icUQ1NXBIVndCZWk0SU5uckhVckhBNkEwKzdQc2RLWG1ydUp1RGRFaUZOemRJeUhubGQvNjBPbm1zRzhJeDl2SjVsSkJsd0ZZa2tzN0xhVXpoNHU4ZmdtYzRWZ0hlZWc4ZTcrOWxmRzY4N2VLNEZaanp0d1NkMkZUVjd0VGJCSzR6eUd1VmMyZnpITEdPMnl5WWJQUDJ3YUZBMmN1ZUtLMDNYMjR5bndRTTZySExHM3V6alR1VnF3VjdOaWl3S3lYWWQvMFgxT1FCUFN2ZHF1cEs5bXEwR3ZTWU9idlF3OXN6WjA0NkZnamRVOWJpRndaZFo1V3VXK1pyZ3VVbmF0UUR3VkpZek1nZlNJcjJKSXZIQ3dMdmRCMTZWQzU1TzV3YWNYby9ueXRkVGdHZmUxdVRYdUZXWjROMzlRK0NaY1Q1NGxibnU5Z3AwMXl3VjZLVVk0Tkc1STN4Zm1ZT0hDdlEvQng0T1lrQk0wZ1o0Wm93UjZONXp4WldrYTZqSFkvMkFzclBmWHdYdkNNQWpXVnU5enA1ZTh1Wk5BTSs3akxseXU0ejlVL0I0czZPZEZMeEhHanppMVRSNmZkSXRoTUlFei90cXVsTDdhcGJsWE9CVmM0UEgyL3NaRFcxVlg4MGhtUkJHd1V2ZXU3UEE4MDdTcnNSTzB1Vi9BTjRiRXp4MGt1YXpFejdLY0NrWnZOb0FqeTgxZFU3MTJRbXVYSDJNNEMwdGdxTVp3VHUyL21BREhoMWF3c0hUNWhQTmx3S1B0ZnBEYUlIWHlLY0Z1ZEowZzRDWERXSCtTU216RTQ0MjgvSEl0S0FHdkdsMmlnVHdpdWxHTXhYTmNqb3VHL2w4UEZlYXp2OEtYdlZud0dOUEJERXRpQXltWlBQeFZNWXJXTVpyanhWNHlvaXFxczROOEh3aXJDdHRJbXhVOGNmQXMyUE14K1BnSGFjVFlWL0xjSmtzTlZsUEdGWC8xRlZ0cUQ4TDhId0d1aXR0Qm5wWnloOEdEMkhIQjlKSE1lODJ3ZHZXemtDLzNJQ1gxc1JhTzFIc0NrUEV0dEU3dXFRL0I1ZUw2WFBrVG94cUdZUi9FTHpMUDhEYnUzSER0bTd3anE3Wi9RTzhveVo0bThiZzdWdC9qWUpYWllFMzlVWXllRnVEeThYMHFiMWFOSGhWUWNCRFBPZG0ra0RrMnZwOVkvQTI5WUszZ29MM1VvWURCbDVuQWxzQWVNTzRuN0F2dUZ4TWg4dUpjMldvSHFZbnpOQkJTREllQWU4WkEyK0ZDZDVxZ1BjNEM3emFlT29DOEg1RWRHOUJ0Umw3R0Z3dXBvY0FUM256Vlp6VnU2VElBZTl4QW5pbkxQQTIvd1R2d0w3OWwvTEFxeGg0WStXQTE1SjNOcmhjVEdjamVGOGplRWJIYUhxclZDRE9tamMrRXJtMGY5K0JuK0J0WHJlNkU3eFRJWnhaczdNSHZPMWo4SzZMZk5XNEZLd1NWdkZsZ1ZkVUZuaG91aUxsOWVCeUpjMHNRWk14MWQydk0vc3A4QWlFNUI3dnE4aWRNWGpiYmZCMnJqa1R3b2sxdTJ6d2Rtdy9jSGovVlpHUmNrbmI0QkdYTkdJYzJGMmxCeEc4eDhIbFlub2F3UnV3L3JUR3ZBVGpNazBEcjJqQnU3ci84SUh0TzB6d2R2V0J0M1lDM3FGN0lsK3JWZ3c4czJBSXY2b2V1OW1UOFpaYjdxUzhIRnd1cHNzUnZHVUNuaEhQQVY1VlJQRHVSZkRXZG9OM0lvVFRFVHpWV0xNRjcxVzcxTlNWQnh3OHNEWU5YdWNDUUx1cUFaNlhKN2pTaWhORVNnTGU5RldLV0lQSDIyb1d2OFlOZVVPUlY0Y2E4TnEybWhxODB5R2M3R3NsdldQN2xqMkhub3NNOGFVWWVPcWR5QjNBVXp2b1hkMWI0SktXc2R3bDdVclFqUWplRWdGUDhVWEFTK3VhMElMM2ZOekJmZnNPOUxOVjRKME1JVkR3TG9oSU1uaDFOM2cxd0RPc0swYkplZ1JQTGdhWHExOFhiOFYrdGxQL3d5c0kwOERydkNlazRJbklCWUJuZFhBM2VyaFA5L2VqNE9FM0FraGQ0T210aFdrSU5YZ3lBYS84RWx5dWZuMHB4NUxXdUZLcEdTUUtQTHhPd0NQUEJ1MFI2R1lIOTVSdVJ6ZEVsc2dJTGt4ZVVWKzlpUUFlemtHS3RLZkREaU40NzRQTDFhLzM1VVFDcUpMQXcxRmx3Y1lnUkRuZWpZUmVSeWxOVng0MDRKRzliaE04MEliZkZPRGhKT1UzYThGcmwrMFhnc3ZWcnd0bG85WXhWbjM3OW8zYzQyR05Sdm91RS9Ed3Q0N0JlNURRY3FXckJIMmxxb1NWWlNRbjArck53Y05KNnJiVm1qRHhkYktQVjU0TExoY2JTem5SMTJJc2dEY09weHpDTEJQcWV6d09ubDBIdTFJVm9MZmdzWUs4Qmp6d1FzSERPM2dENUZrUFZ4RGk5VUhEbllpUExYRlIzWXpnallvbTVha3NvQ2R6VmRhVFB1TU5BdDVBNUsxWmpnZndVQWxybENlTXdic21Na0JPVmorZGdvYzNjTkNaNmFzdThGcnl2S1d0aStxYVBUa0JzUjdaVWRoODZiUm9lanQvclFvNkNJKzBVUWViVXBEM1VvT1htZkhxUmxuZ3diclM2R053dVZKN2pDMHZNZkE2SFkvR3JWeE95NkNSeUV0ZWpqZldpb1R5QkJrbGdWZG5nQmRqQTd3bVhFS2ZzZk12Z3N2MW5iMXplNUdqaU1KNEtRang4dUNMSklxWHhBMnVCa2xFczRubXBpVHVibUpVWXBEZ0loSEJwL3dEMDFEUXM4eE05K1RmdGlmVmZUNXJ2enA5ZWhiZjludytXTFU5clRORC8rWlVuVnROYm5Va3Ftend0Smc1SGtaTUxKcVhWSnhRckFyaThnVE9rdDVMT1dNVTY2WXhnd2UrRW5oczVSaThxcW8yczFrQ0w4NlRQSkRuc2p1dUZNSERlSVFYZ0dlWGE1Y2hCSGg3NHpuUzU3dXFvRTVmS09BaFdmTmFCMTVpeHdDdlVjSFQzSnBZZHc2c0pmQkUxV28rNkZKd3VTYUc4UWk4WWF5MDI3UzNiMVBCVzhWNGJjZk9rUjdOa243ekhVbldCRHBLNWdyQU02NDAzQWNpLzNhcWJMeWNEM29ZWEs0eFBVUVlMd2NQUS9vN2dXZldvdHNaWXc5M0xyL2JnZmZtV0k2MGtTWDlka3JXWEVYWUtTdGxEQWFNd01zYi9GVVY3dGEvSFlDM0YxeXVNZTBoakRjWlBHaDc4Q2hFTVRWVjgwcllpTURqRS9KV2NhYURoekhBczNKYTVKTmpzaGtXdnAzRmZOQmhjTG5HZElob2dyclNITHRnZ0dkQW1DWlZkaDZzbWlPTlpFMHJaNnpmakRVRW5yS1ZvMEJlL3ZmTTFzUDN4TitPeHhOY3A0Z21xSHhWT25nWWd5TURQSjdVa2pGbXBHcU9KR3VpaWJ1QUp5QnA0SkhKU3grd0lTQlBncWQrTy9PaHRlWnRMd3h5R1VWQmc2cnRXZU03bUMrcnd5WTFjRmRUTlZQT21OMUxPaTVvRlNuREpBcms1UisyV0tnM0RoN0ZFNDZDeTZYck9aeWEyeGc1dmtEWWJnSGV3dXdqL1ZIS0dCczV0Z1NkTlFVOHhhMlpnWmV0RjJXVXNhWk04cStxT1JsUE9CZGNMbDNueUtuSkdDbDJqUzlnc3QwK2NDMWROWTJNTWM0WjR3Wi9kMk5jSWtpbkJmeGgyYkxQQ0w0MGk0ZFhuVUQxaEZ0elA3aGN1dllMVHMxcUkzcXdpa2hoWW1HcmdtYzM5MFBHR0xlMDVkU1Y3OGZBNHlXbDhpN3poU3BZeXlZQ3JiaGFGdEpNK25Gd3VYUTlobE5UQU11ZXBURmJackNtM00zZ3JXTGNwOFFWYm1kTE9XUGNaK3pkeXp1UFlsd1JlUEwvRjE0U2VOMC91TklObFF4dkNtR20xOU85bFRRYWM3ZW1hNnBUTXprbUJUd1pueHE4OGJ1ckRMeEgxR09NMjlraWRjVnFkd1R3U3VBREhDdzE4VEpFOGs0QkhocU4zZmJES1YyNmZzaWRtcHNIRmh1emwvOHJlQlVlMGV5Q0ZUOUg0b3FldXBKSDBHUEVtbEI5TXdOZ1l0YUp2TUV3SWgxNkRMeCtnbjVIZndTWFM5TWY2SFRVZzVkZ2s2ZXltbXJNdG9jUVYySzh3L0Z6VGx5WmtyclNCZkoyWTZ3eVE2WDdha3ZnOVorOXU1UUJOb3hubERTV2dZZnVENCtDeXpXV3FSbkZ0NUllUkxKNGFXYnM5eW9qeW9BSjNWekh1SHZ1VTRxZlUrTEt4QWo2YnpHbXpyd0dlREI1UmJkbWZ5RXpucG9oeGQvWDgwSGZCSmRMMHpmbysxQmwyUnNZVjlrRjI3QnRiLzFTNDRjcDhYTzkzUkVDZVJjUFkxeW9GZzh5d0VNZEFueWZsTWZDNENGcDdFbHd1VFE5eWNyUFozbDJGS3hmVHFUQjFOWVFydWxVU3FYVkVicXVtRFhvNkRKZkdlazFiTW96SW5PRVplOG5zQUc4ckFqZGs4WmNJL3E2VUg1T0ZrOGduSEdZb1RrOWVKaHcvVG5Ieno4UHZWNHpBM243TVM2Qnk2akpVOEZMVlhneUVmQmVadUM5YkR4cHpIVWFIWTFVd1dhK3ZKZmxNRU5qVzc4SkZ4REdNeG8vR0lHOE54SElzOEZEY3d0aUo4dVR4cWVIeFJOVG1HWEllUzJzNjMrb2dzVmpCZXZINHkyV25Yb3NJc2I0aU1wZ3FmRkRFaDJSUjZXd0g1K0xNY0pLajRFSFBPbE5aK0FsOGdROE1mNEFENU9GRkNnY0JKZXJyQVBrclRBdVRhT0MxNGoxb3lmYVdIWXE0RzJpQ2UrOWpUQmVxZkVEQW5sR1JkNkRHT0VUVVhuUHdPUDBVb21nQzhQeTl4NDhjSmVWNUFsNHU4SGxNdk5XRkZ6Syt6MWNJTzYyZDdyVU1UNmdhandPNHcxNlkwcEZYbDFPeEtROW51TFdwRzdaa2xlQXpaLzJzek1YL1JOY3JwTCs2ajBCYmR2UzAwa3B3R1hycDI3bG1zbmdMYmdhajhFTG92TktQQUVWZVRmVE9laWpGcThhQXVVWmVKSUFUV2ZrQ1hod2Q0cll1NUtDb3krQ3kxWFNpL2tBWGpSeXdSU095Q2Q0bWpERE9zYWJSalFCWVR5N0l1OVZQR0ZKSGt2K2FPaWFpU3NFSGp3dDhET05ndWVWUVM1VCt3TGVVdG1rR1pXdlpGTm9ZbFE1SUpwZ1ZlT0ozcDhTVDFpWmdUendwVnM4Q3Q3QjI2dUR0MmpiZWRMMTRIS1ZkRjNBVzFTZFJqWnBxbUdiRHA0ZFRiQ3I4VkpGM25tanRlYjlHQ1BBMC9zMHdPS2xLWmdDa1dUbEpGU2UvMmN4ckFXOHJ6eUU3aXJwNjN1eXhhc044TFJKTStFT0pIaVVJWXd4M3QvNXdJd20yUEVFcVUrNEYyT0ZWdFkyZVBsYmhmZFMrQUpxWXViSmtNb3c5dUI1Z1lKTExVM0FGcThUaDl0R3dNTktVNjhjb3V3V0pGN2pSVktiWUVRVEVFKzRZTlVuUEJPM3BwRzZ3dUROTXZEUXlRL3FhYzRpZWRuUDFxb0h6NCtuZEpWMWRkNnJYUWwzU1lvdEk5ZW5pbW96VXZuSzBZUm5SbTNDQlVRVDFNSWdIRTZaR28xbENjM2tjaFdJQUY1dWorVUNkK1pFMW9BVTdHZS9XK3RocmVtbjVMbkdUOFpyMXdTZWpJME9ZMXc0eEV2UWJDbEgvWUdHRm1NNGxKSnJFOTRJQVRwdjFpY2N4TGlXSWllaVh3RExTbUU3VVFSZGJmSFg0QTRHcnhhTGQ4OFA2M0t4ZnJvalM4MzZ4RU0wSS9LMjlLMDBwcDhGamJsaVBMaG9SeE00bnFDN05XLzA4WVRCbXZIYkEzaE5CaDVHVGVaZDRaSzhTZ1d2bW92K0RpNFhaMGlMS2dZUFl6WnlkbVU1N2VSSzRCbE9UWW9tR1BVSlNKUGVuQmdFZEJnOExCenhvcE9mdEVFOGdldGZDVHhsazNjMXVGeTh4UnUwS2k4dkp5dzdOYjRJUEJrU2VCdW5KbEtramRvRXF6NEJiVmVxR1J3bk15V2hlUVE4MU1LQ1ZOeXZnWmRtNjNidWtUeVhxdXZaRnErVEJSNHVUSW5pYVRlZ3JJOGFyb3kxR0lPK25PYld4TmtqZ0MzZmp4YWIybUlFM3d4c09QZ2FBUStidksrODFaaUxpMkJwaTBmUEZvR25HRGx6b29Obk96WFJZc3hPazBhMlpqMURHM2ZOUEN2MUNYUVlIbTdtbFRRdVlKYzNUMzVOVDlkMEZYUkpETjY4TXNHYkdlQnAzTmtaTURnM3dYUnFUbmRyM2tJMzZRSTdoRmVhRmRlYTVRNkZCbmdyQWUvYjRITGwyaE9EdDZKSENPUHRJZVFKTjQwQWhNalVOSjJhMDkyYU8xZWxtM1QvZjlTcmNYRzhNbDhCWUF3ZUxveEY4cDRHbHl2WFV3RnZQYnE2MUNqRVNBV1AzU2tNM2lyR3F6dTJVMU54YTVyZHBPbHNuMkozRlVaUzJvc3hYMFFld0tOMHpmbnZ3ZVg2cjM2ZlQ5N2kyVTZYaXNBem5KcDRlSTB1MG5CcVdtNU5PaFlXMlpyNnV4THdHREFFNE9tRG13R0Y2STFYWElydXR3TjRVUTBta0YrQng1aFZwd0tQRG9QVm5acTJXeE5GNkwvRXVFQmFTbUVCekxsaHVYbVg5bUtZNEFvc25ySXFYN1p6enhwekZYWFlvaFl2UFV6S0hzWUV6MTUyVmpwNGl4aC9RZm01NWRUVXN6VzVGbmFkbURMQlM2OWlqcEJaeXVETkRQQVdIbEJ3YVNWQmJjOGRFalV0OEdhVkFWNlNCUjVteWJkeVFPWG43TlMwM1pwOFNCNDZxckFoNWpidTlFbXdKNFdWdzJzVThDaGRzLzB6dUZ6UWk3YmxXanhhU09rV0R5UE0rRVYybUdFVjQvZFp3dGhZKy9hc203VHRYVEhYbW9pVVoyOGZveW5meXNuZm56eWcwUG9SQ3E3LzZsYXIxK0kxNUVhbkNZT25RSmg3NnEwcVdLT0x0RkdFanJPNjBPSVA0Qm1udGRQYnh4VU5QTlhpMWZWU3dIc1FYQzdvZ1JpOFpXMnVOTGNIRHhNQ2oxcjcwUWxkeW1HdzBCZlR2U3ZOVEFHUERCdG1HbmpOZFBEcVZzanpDZ1VYOUhkNkx0cE9pN3A2SlQ0NmttcXNKeTgxNllLU0ltMGVGSVR5Yy9hdTJDVjVUYWtJbmZOUzlTdE5KL2F1Nkp1OHFoL1dkWlNsL0kzZ2NnM2FFNE1YNjFvd3FVc0ZQZzA1OHl3anh4ZllURFRTWWV4SDVLMllQVFhwa0R6VnUzSU5uY2JJek9uZVM3NmloUGd3d1ExMTFRbHJ6WUU4YnlqdGduYXgwc3pCcXhnOGRmTlh3TXNDcitJT1k5TjlLOUJIazd3cmlJNHpkd1JlOFFyUnBvMDNyQUc4YnJ3UThOcm53ZVZLT21xeDBnUjRkUnJTZmsvMXVrd0VqKzRBZUhuZWlwRXdCcjFtNTY3c3hsZ1B6ZGV4emF3TWkwZXIwS2F4d2N1K3ZJRzhlZHQ2WDF2WENlMkxUM05lZDhxNG80amNwT1JnSzdMQXFOcDVLMGdZWSsvS2VhdmgwVTNrcmhnNzBjSDN5WmQwOEdRaXFqZkN6ZlZLVE42ejRISWxQWk9WNWtwb1MrQUpSTU5UTktFNjFuSzA2SGVzcGRHUjZsczVEOThLZE1YMnJud2I0eEpHV3QrS291bGdrY2xPNWR4VUxEQUJIaXhnaGJYbTNOZWFybDdQeGVDbGxhYnNUREpYUVcya2NKSmRveGxHQ25qTEdHK1p2cFVyWVh2dlN1cTdBdmVJdmlSR0x5UGI0dEZyNm8wQVhuWUZhMDMzYTdxU2JzZ1diMTRyNElraHpIQlJ3Q09tQ0R6bGpuUWtwZWxiVWJ3clp0OFZMSStUR0R4czhvcHZ1N0RVRkdGcmw4WWdMODFXWXZKK0RTN1hScnVvZ1pYMUVjQ1RsU1ltYWpFTWMyZURoMGtkNHgwK2tsTDNyZGk1Sy9rcGVRc2tZeHNoUnBnOEN6d1FCdkRFK09HWGErUFhsRjJldDNKM1NmUmNWcHFKTUdHTkhDMXBZbXp4c2xDZnNkdkRIVGdaVDY4SmdtK0ZjbGRHTjNubmZveHhEWk5uT0g2YWx3UmVzYzFEdnB1RHhadGgyUW0vcG9CM0s3aGNJZHh0MnhZK3padzFUUEFFY3BpaElveDRiTGRNZWhVK1IybUNsYmRDRFkvc0VMcGVMYzU4YVlZYXQxZEpBaGpBdzRYaVd2TTdQemJJRmNKUDM3VnRIOFJiTVhpeTBxUm5hMVlOZUUyUEdmQVlFeXBOc0d1Q2JPOUtIa0xQVHlxdnRnY1A0T2EvU3ZnNkNMemhmbGxydHEzWEJyazYvWW5vK1RwYlVBcGVGQTNHcXlyRXFreStyQzBlaGM5TjN3cjB2dVpkUVhQTlRRaGRXU0d6OTFJUFM2YUFRbUtOMXVFQ0c4REwvSnE5RG9QTDlYZ0E3M2llUFVGdzFtVU9UZ0pQMmJEeEpCOHlrWXNZZDQzdytVYzRrcEw3cmhqTk5SOXY4cVI3V1hXRFJqMjl2Z0VHZWRqbElWOXowTzEvZ3V1czY2L2JnOEU3VGl0TnhBL0FHb09IbDRrVUk2ZHY2M2lMZDBndE5ZMStLM1lJZmJQSisvQzlTNTlzcXRCWGxHK3BXenpHazFNeHV3SDR3alNOQ2J4RksvbzV1TTY2SG9sUDgzaVJ3TU5La3hOKytRZWVIRERXaWhKMmc3ZDROeTUrY3VrOThxMXd2eFhXaFpGTjNqdlk1QkZUS25pY0RvY1BpSEZHbnN4MHYyYW5lZmN2NzYvcGVpcmNTWjVteGgzbzZpY2MzMk1mbnIyVXc0UzNlTys4cFc3eExnU0lRK2gybnJTeDFwVEJpWEs3d3BZTnFBRkRUREFjVlBkcnpYbTc0ZThvdU02MmptRHdsdm4yNUNSNFRHRW4ydEJBZW81WWJrOFF4ZU1NNmRlTjhEbjBtcEVuTFpzOElrK3Bqa2RXSnZ0SzhNbjEwTXVRWmxmano0dmozdUMxSHNvNzg3bzd1TGlQanhjYWVCdyt4OEtxS29KWGEvNFU3ZUN1bENGOVNFZkIycVVKZG5QTllaTzNIK05TN2V5QU1jaEw4RXdERHpNYTR6VXhtYnhPZDd6TjM5bldEM2NFdkZoM0luOGNIajUrM25MdzZFbGtnNmYzVDZJdG5oVSt0OXMvWUpQM0ZqWjV0TUZVVFhJbklvcldtclMvSmUrS1REYXo5WEhiNi9oK2NKMWwzVC91d1RzK1hsTk5DMzdiTVlHOXk4VU9CcG1SUWRsNmk4ZHRIMWlmY1hQTjBpWnZITHdxNjZoQ0pndnJBRnlod0FGZzViOGpsUGNrdU02eW5xUmRoN2hXcUlnVEVPb1VnalVlRy9GcFRDWnQ4VDRMaW5CMGlSSEptMlR4YUpWTkpvK3Y4R29jNEltVGMzVThyRFc5MjlpWjFsR2IxQWZ4NmxLU29lWm9ZZitDdXV4VURWN2VRL3J4NUMyZW5TZk5rYnpMaU9UcDhZUnVtbVdpc21FcitUVnIvc1p3QTNKY012ZktRWEQ5eTk2WnZzaFJSVkc4RklRQjhYTlFVWUpLSW02SlJxTmp4akhqRW1OTWpEdHEzRkFVUkhBQnljQ2p1NHRYNWRUZmJkVzhtbnZxem5sMzdoRGJEOTM5RGk3MUhBV251MzUxOTF1YnEwc0FMM0tFUjhXb1h1RHVSUEJvQndKYkV3N3gza1NJNTA2ZnN4NXdLM2xiVk1tVEs2cFQwdENQa2V6dHI3VEZBMjY0d244ZXhPUmQvSzRxMmxSOWQzR005am0xUWdhUDZ1bytlSnp0dEV0Njh4RENsdG9oN1hkSSswRWV0MnRHQmc4Mmo4RHJaWU9IekZJK0dNUWxpR3pxbzhSbVhicFhObGMzUis2b2lJZkFSRk00bkhHMzBpM3B1NTNXbXFQVXFQbUVIK0k1UVo1VlVIandjQ2J2V2dpTlVVOVFqdU0wS0xYeW1oQVFvOStaVFI3U0szczNxcUxOMUkyOWVzU09VeXU5dUY5RElQeEhnVWYzbDAyazFiT0oxd1E5Q0UvVEMvRTR5SE1Xcjd3ZlFxdkFVNzhZMVNBTnUwNUkwbGdDa3llbnRxNlBQdlFucTZMTjFKUENYZDFtd0xQU0Jub3hBdjQ1YzhmZ0laZkl4WVNidkc3RnIrTDVsVHpNNUQyK3RSMkNHc2xEMmtPWDVRZzgwOWZVOCtZK2VCSGczYXFLTmxPM0FGNk1VWU1IZTZjckMzT2VXWERCeS8yQVE3enRyY2N4aStlRWVFYVE5NWdkNUtYRkt5OUxrRGMrTUJnVjdoQzNmVTJLWlYzd1lneTF4Tldsb3JDWitxRVc4RUtNS2lHd3I4SFQ5NkN1SmNnUDhud3hrWWlrQUY3YXFJbDFLMzZJWjdkcit0czFrNGdQQW85cjZMUzBqd0REd2ZoQkE1UDNUbFcwaVhvSEJxL3B3VXVhbURYRDRGRUQ1NGxwVFBzNkhWQk1lQTBiTlowUXo5QnpicENIMFNCdGpjbG01K21TUTQ1Y1BoaSs1a0pNM3BYUHFxTE4wMmRYRGlTMUVnVThzR2FCcDZ2RTdJM1J5UVlQdXlXR2ZqRUs4ZnhaUEg4bUQ5czFkZGNZdWNHNnF4TGdzUVdIRjhxczRXUWhHU2NtNzdXcWFQUDAydENtQ1lNSGpVUnB1b2hDcDNESEJ3WVBoMDYyUG1DanBqK0w1OC9rM1MvYk5WRlE2QVFwOC84VTRQRy9wc0VEVUF3YjRyb0krNmRNM200cG9tK2V2dHZORzd4SW9RLzNSY0hMb3Babytnbm5Wakp6N0NnbXBINHhZeGJQMGJOV2tLY0xDZ0RQc2MxMkRUMFg0cG5wbFVRZURwT0t3cHRWMGFicHd0aThOTlFTd0IzQU16TUcrYWU5SCsveHJuTTBYS1hkN2FsZjdDR3JYK3paeXRFelhrRWh2UXc5cWlndkN4NHZXR0h5NkJsREprK3VkTW80QXJ6dE1wYTNhYnE2bmRwMXBaWXdLbDBhRDNGdTRjUy81NEtISy9JMFl3aHZVekhCZjF1SnYxMlRDd3J2QWJ4QmJMZHpxd3JWNzgwaHNCM2x6VWZ3RkhreEhKRlgxKzlYUlp1bDYvanl3d2plNkFuaFVXM2ZWd3dlRWFYdVRHWnQrQU9MNzBKNDFTa21QTTBiTlZrUHE2NHhMaWhnMTVnRkhpd3l5b3owTERtVnlWTmVSTjdrOVgvN3NDeVYzaXk5OUtGd1YwZDRsdzU0Wm04R0RtWWZGUzQ1M0d0RGVMZWZURGk1bVBCdzVlcDVzNkFnWStoYnV6S0dUaFVGTG4yTXpYRUUzbHdsZW5QZ1JUa204T0prOTloWVJLOEhYYStLTmtsdjFmTGRCKzFkZ2p0Q0tuK2R4T0dlQ1I2N25TSHNic253dVZGTXdFWk5aelRJbVZDNEZVSUVlUzU0S0ZwcThIajJUb1JyQzd5dTd0Vi8rTVhrYlpwZTJoTm5wKzZpd0FhZkNIbVdzU2NGU0RGNGZJQTlNV3NKdXBod3k1NU04UHZGL0lLQ2JsNXBHVHcyNlFEUCtIMHo0R3JGNlhWVVh1aEN5Q3ZMVnpaS0U0TzNrSHVDSE0ySVo3YSszUnp3ektTbVlmMm9iY1V1SnZnRkJhOTVaWmlHblN0ZjB5OG9NRjRxaXJYQTR5aHZYQ21kaXVnSnZMMWk4alpITCswQnZHWnE1WVJCeWJQZ0p4VHZNV281dDlNSEw4M0FvbTNGS1NhNEJRVy9lU1Z5alk1WHNhZExPNVRUNE1GaHNNRkxyc0RoWVpHK2dHTHlOa3R2SWEyMmlOSllvYkp2Nm1TV2gyM3cyTjdkYzlzS2lnbSt6cmpOSzJkZkQ2RVI4S2dSQUFuTDRaSk5YdGI0RTNqN2dBM2dJZkdTVEY3L0ZSU1R0MUZLQnErWEdEeElXenljSW42b3J1eEVDMjVRcXA1cklOc1EzamlMdGhXM21PQ01vWHZOSzIrSnI1bmQyYUNXOUZsOGNsZWQ4QVh3bENMOEJ6RjVKYkc1WWJwZTkxSUdENjRScCtnMGhISlRFV3BPUVhrL24reWtCbW0vbUhBdlkramlhejZTZkUyamxBZWdGSGtFbmg1WmhFQWVUckIvY1VSME5IbWpTdnZLcHVqcU5uSnFNSGk0TlpCbWdWMVRmYjZHeFR2Sit0RTZUaWg1bW8rSXAra01uL3NUQ3Bhdk9ZQTNORXBmQ3FGUjRHbm5HSWQwWlpzOG5DQ3dOb2pBdy9VQzVGMm9palpCRitEbGFJT0gxSnNEbmdQaFhRSlBtdy95TkM4TkRkSTllT1JwMG1TQ3E2YzV5TXY1bXRnM3lQR2Ivc2V1cnlsSHdRdmtDV3V4bHlhdnFlWHh0MU9HRkRaQjMrMEFQR1h3eU9MSmdSdGE5R0c0eE1Fd2Y5UnpmRmM4emJlMHA1a3BKanhkblZMUG45TFhKS1RJVlJieWpKNEJGRFdqQms4ZlVVTW5reWZmd3l0VjBmcnJjaTBpZzBkQkhSczhwTW5KK3RFcHU4b2NpWHJYMCtRWHdmcDY0SlMrcGlybENVUDVUaGJENU0zbEFJRzhPV1NhdklQNlVCZkxLUHI2NjdPTEFLL0pneWZGYytHT2tJUUlQSU5DWUljSzJXazlUYWVZNERXdlNLTzB5bXNpekZORWtjbGpEaW56bEFFUFJ3M2V4QUNHV2xUMnVhKy9yazBNWHRlQk83b3Y3Rko2a2dZU0l1NFVlUFFxQm5pYWFKRDIyMWI4NWhYZjE2UkdhWURINlJXY01Od3FoMm54RG1HZXhqQXFXeGgxWXJPOElYYnQ5ZFh0V3RRUWQrcDBmTUxGU3VINUJnL2cwY29rOGpTOXRoVy9lY1gzTmQrUWZrMWp4QWtubzI4czk4eEpseVo0U1NDMDYyRHl5bzdOdGRldFdoUUdneGR4VnhDRnNISFJCZzgvOGZkczNWVVVTdlY4R1o0bWRNN1BhNkpmMDFtRG1RNGFQT0FGOEFCVURqeU84b1pEMXpVMWRLY3FXbWZkcWFHR3dHUHU1cFRnaE5RdFJzYkMzOXpDZlpyd05HbWg1cEo4VGZScmRqVGJxaTZ0WlRJYVBKQ1gvMWo0WThWSm03enpwWEZzbmZYU0Y5cmc5VG9FaXcyZVVVb2c3c3hkTFF3ZUR1Q3VXYWFuaVVacHIxL3psUkRhZVlhOHVWdFJRSjJBcGpwc002ZkJHejdiZEdwcVVYbDUwRnJyWmoycDRRRzg0ZWxMQmcrTnY3N0JBNTlHaUdlOXRMZ040UlgwYVRvTjBrdjBOWGREaUxTZ3dwcTJFNWMwcGpOK2VkdmtSZXU2bTNBNE5YbTdQMVZGNjZxZmRzRmQ2RWJ3NGlEMk90RldxQk9jQkY3V1RISkxkVGJQRWtPNGVDcFBjNm0rWm5xSlFpZjhzNjBtdjFpNEc4N1p0dWQweWZHeVBuUzlwdVNoY1d4V1NncnJxMnVUK2RldTZ4cUFGODJDVXpvazB3Q2lGSGZVc3VHQkIwOHp2VEpobVo0bSs1bzhoNTUySGdFOGM2WkNnemNLNEVYeVVLMkFXUTRLdkM2MkFPL2d5NnBvUGZYbFFTMXF1OWpGRWJ6eEtsSUtnRG80WlZiV3FCUnJXWk44NkhJTUlieUwyWFBmMDd4M1h4Tno2R25uMFhab0k4Qno4cHBrN3JtcEhNSkh5RkVlbWJ3NE1YbWZsRGRWcnFrK210Yk9ZeWVvZFF6ZVBCZnY4UUlmQXp6ZFlHM2YxVjBJMjJuTEVXYlBEVTl6T2I0bTltdCtFTnJHQlkrTllTU1RkNnl3WjRDSHoxYkFVL21WTXBpM3hycGVpMlpvRm9zQUx4Mm1SRkdleFFJdlI2RTFRcU9Xclh5QWZacEw4alR0R2pyMmF6NTE5anJ5bWp4a1laT254bHdudThQa1FDWXZpalI0bkYrWjdaVDh5anJxcHgxOHhZc21mZjM3R3J5WXd2Kzh3Y05wdms4bWprNlI3bU9tTUlZUXJwOTlDdnMwemVyNTBueE43SEkvUC9pYURubkdWRDVNSHNKZmtLYkJVMGxqQVUrZ1ZDWnZWbDZZdDQ1Nloycndtc1RkSVhnZHdNTTlRdUNOSjU0OHc0Rk85aWJBbzlUS0hqYTNMOFhUaEsvcHQ0MjFqUU1leXBqNDk4U2gxRC9pc3JtaUN3bGtITWErc2FuSnEzK3RpdFpOdjlZeitZSkRNbmo3K3pyRmpRY3l0N0RnbEFUajU4Ujc1TGZoZ0hZeDJxZEpudWJTZkUwcDVWMDBmVTE5c2hJc29CQWZqd21lbUR6WVBQbnNGN1ZvcjJ5QldEZGRQUS91RHBvR0FYN2lUb09Yam9RYVRoRmhuQkh2NFFEdzJOTzhJa1c4SlhpYXptd1FsL0xhemdybHFCMU0vajNhcVJMbkFJL0pnNUZUSitWNXRqWDBkMVcwWHJvTWgyYldDbmlDM1lnaFRsNm5vUUtQREo3WHdHa1U4ZnlKb0h1ZlE0ZXZPWmJ5THFSU1hvNjhxTGJhUjNQbUVORXNmVnBhSFprOC9LUnBKaWJ2K3pJZnRGNzY5dnVaY0xkb0VISjBzSGVUbzNoSUZMZW9neHFVZFV0NjVIYUdFQzZrSWg2M2kvbXo1LzRjdXQwMk5yNHFqOU1yNnZlaFpnQWNrVzJ5d0lPZHcvVWM0QTFua0RkNUtQNVJpbm5ycEJzZmdidFprOENUcngya0ljS0RFMnB3WitSWjZDUTNNRVY0bmJ3VWo5ckYvRmNtK0R1UHpybWx2R3VVWGxHL2dqM1RpMnhUMHJIR2FmVVFFNm5HMktacEJMeitPa3pJKzYwcVdoKzlNQU40SVgzcGsxdWd5NE1ueHM4R0w4bmhUaXdIcFZiZThZcDQ1NXd0Ujg1K1RidVVONlJYWGxTbFBDTFBiQUV3MmpKQkhvTUg4bExWdkpjeWVRdVE5L20zVmRHNjZOdlBCL0FTZHdkTjEwaThrYmliZXBwTlB0Nnp1WXRzOE15eXVrNnRqSHRzalNLZXMwL1QzNi81TklGSEd5QlVlaVhuTHArVTEvVEF3d2VvK3REVHB3eVRsNDQxeVB1bU9KdHJvNC9CM2F4dHhLeU4zQ0hnQTJsYzZjVTFEcm1GZGhaNCtwVW94aVFlYlc0MzkybjZ1OXpQT0ZONVNLOGdzbU9UcC91bTd3NkFBbEZqbEdPOFlQTHd1QU40NlJobUlLOU01cTJMYnM1cVpGWlVoS2RkSHUxb2dzait6ODRDRDlmcTFrdWk1YTZESnFrVmJ4THZqTFc1M2RkejlvZ0NwMWVzWjRZVUtqRlRRYUVjMGt3NEt2Q2dBVHdZT1czeURtYkYyVnczZmZzNTdOM0JOTHpvR0R3cStwTDFNNmVJY2pmdnRLbFl1T3YvVEtrVjlFZWJnd25QVmZlcWMzWXBUOUlybDVCZXNYcHhDRHdoajhCTFo2QkdVUjVPK3BPUC9hR2RnYncveWhxSWRaQmtOR2U5V2ppWFVZY2FTTE5rNnVxYVNXT0ZEMlZXMk5FRWhjTTZUVW10c0tmcHQ0djViV04rZW1YclNtamozUEExZFVrQjNkQms4bFJYM2JSRUI1c25IL0gwa1lmVGNMMlk1TDh1VjBXcnIzY25sWVFGREY1MzdNcy9CaDc1blhZbEhZZDBWS2psS1l4ZDZscHhVaXRvRjF0V0tZOEgwUnNCanhJbDJhMS9CQjdJZzIrUUJQRGtBK2N3YjM2RUlaek4rbmFaaVYxOWZYbDdtdEdFd1R2aXJzTkRWdzFINnp4TE9scmNSUXIzOWxXRXgrQzFidGVLWDhUelMzbHVldVdtVkJRUTJUbXJMRXp5dUNGYU9BUmVuZlJva3MvZlRremUrZEt6dWVxNmVsNWxORFZxdzBuWk94a1ZvanhMSjhQcXhKMEJubkxWRkpHcGx2Q0NrMXBCRVcvcHBUeWtWejRNYmFmSnl3d1Y4b0lWL2dnd1pCVjFKaE01WTlSdTRPZFBQLy9GNUp1NlZCV3R0aTVOdnMyRjVnNEhiZkQwdUNZN1RLYkIwN2wxb01iZ05TRjhpSzZWcFJieG9ETmN5bFBkSzRQSmV5MkVGbmhscXBESGhuNElQSFNIQWJ6TzhqVWI1V3ZTays5Z0VveWZyWXBXV1UvV0NUeGtORUZhTDBxem9QUUx1bUR3Vk82VHkzdTZrNHlXY0VFeERBTkJUenlxdWxiczF5OHZ2NVNINGFEdEVBWmtqSXFDR0VNdVZuS3BQSUZIVWQ3d2h6WjVFZVNwTDZTZFJPTzdQMVpGcTZ2UGRtWUNYc3BvSW9FTjhuUkZWeWN4cVpuZUI0L2Y3SHdjdkM2RUhVcXRjQkh2dnVvLzZablRwRmV1RGVtVk9mbWFWSVpFc29WV2gzVzB0QzlmVXRCeFhjeVl2QUNUVnhwWVZsazNQcDV3dDJqbFcxZU9UaWQzaEVwNzQ3NVM0RG45TEpTYzRMa2h0R2s2cVJWbkVzOVhYNDQ0ZWMvZjJMQVpFZVNaaTBNams2ZExMemdxcVVvNWVSbUt2RTQ3bTJVMGIzVjFlUWJ3NnJadG05elR0bVB1WkNNTFJYaHljQnZKOUlwelBYVXp2cHJyeEsxKzV6Q0p0OFQwQ3U5ZVNhdHRRZDZKMnkwNHZaTHRQWWlVVVFGcnVhY2ZuTTBhenVidFQ2dWkxZFNudDZjWnpWYTVOZkEwMDBGMVZjRGdnVFZxeFZDc0VYZWNaNEg1YTBNNHIzYXRMRGUxQXAzaDdoV3Zvb0IxUnNhQ1VXWHlJc2pUZzR6NHhQRGhncnhtSkswOVRsNGJaaUR2ei9LZTJOWFVUejlQTTVvamVJY3NDWGVBVUJrOEdkR2JkeXBJa1dzNUUzajVEazdVbjFVdEliMmF5K2hhUVdwbCtla1ZWQlR3NWlEeU5XMGJQdjE5Sng5Tkxzb0RlUGh3UjlLNm5NbGJUSnpOajB1WXQ0cTZjV3NTNE5XdGZNRTlTMU43SndkMXAyQTBDQ2xObkxUOTR3alBUck1NSnl3WFF5MWgyYWtWcEZmY2lzTGxqTWx6dkdmMXc4eG5NVnl6ZXdrblg4aWovRXJiMWhQeWZxK0tWaytYWjRlcUQvL1NIb0pIVVQwT2lQbWxvS2ZHRitaczhiUjdsV1NZaXVNRzcvSmc4SmFlV3ZIVEsxeFI2TGU1dngxQ1I2K2NOSzI0Tm5sejhiZzFlZE9wbjBtUkZORzEvQVRvRGFmQjJaeVE5MHRWdEdxNlU4K2cwTGJFWFljQWIxQVVmMmZFU2RmMzBNNUNCbzhyNlF5ZU5uaHZZN25Zc2xNcm5GNXhaeFRld0NRNmdXZTR6L2doZ3pkMmhIVWRPWnY5ai9vRG03d1d3WGJidHRNR2xxOUxOVy9WOU9QT0RGcTByZlpuamxYdzBsSEFvL1MzWHYxSEFWL1c0UEhyOW1Ed1h2ZHFDVWl0TEQrOXdqTUtPOU94UEQ5VHkrMXlBQSt0bUdxM0F4NW1HZklPdjV4Qkkza0hreERocjlLMHVWcTYrc2tNcWx1QU4zQ1hqdDJVdS9FNGR0QnozWWttOUk3M3MxajNxMXhpOHB5SzUwdE9yZkJ3a0Y5RWIySHc3RmcxSFdneisvRTl0Y2hRamNxWDc5SUp6MEdRTjV2WXZQZXFvbFhTZXpQbGFEYTlrRGxEWmFGSmd2M1RUK3FqT3dSbGhUeDQrSm5tVG9PWHppaWVvNWF3eklFZ2YvY0tGZEd4Vk5vemVVa0VIc2d6WnZ2RnhsSDFMbjBmZ2w0SzgyRHl5dGF4MWRKdmlydGs0ZUJvSXNPSmNJL21vbmwrb2V2SXRWTGdlUVl2MVNkQ3VETHNPTUkyeldYdVdtRTliRllVVWhHOU4zbnBuVjNvMTdUSnc2cFJ5K1NSZTVrT1dmTEdnN2dndlNUTTYzVlVSNzlURmEySzd0eWVRUXU0bG9xN2RGUnVFQ2lrMXNMRUpIT0hlTTlieVpLT2JRanZiVDBoeFhObjE4ci9XbEZBRWYxZjlzNnJONVlpaU1MTEE0SW5IZ2tQQklHRUVDTG5JREtJakpFQUFlYkNKZWNNUWt2UHNoWXoydjNkekxqS2ZlYk02YVlOZU5lRDFJVXV1UGY2aGVuOXBxcnJWRlUvSFhES1UvQVl0ZkdTczB1YVVRR0dHUkVCNUExcmp6eDdPeHFSZDFoSHNQeGY3UDFEUHVBNWFuRmJhZFBsK0lGdkN6R3A0Q1h5TEprRUoycXd0c1BOWEdqRTI2V1dBRVdoTEtJL0dMcjJWT0J0ZFlsem5hQ214V0c4R2x3a3lCdFd2Z2hqOHI3K1lGSHQvMkFmL0RUbUxrVHdqRHVBTnl6MTZ5RzE5QWhDVzNpMWJSSzh2NGswNGZEdWczaGUwaEoycGloQVJEZVg5K0t4b3ZBYndNdkZ6Vmh5V1NZNnpKazhMRVRENmFEZTJhYlliemw1dG5sMnpIdTFWckQ4SCt5bG4xY2pBM2N0Z3BwK2hiRFRva1FjNmJMUmtRdy8wc3JwL0RoT09MeFhvbmgrV1VsTDJKMmlvSFZqWGN2WmxUSjVsT21sNkpJUHpLeVVqd0pLbERBTUN4aU9lYXVldk5xUC9qK3hMOGZjclltN2JqREl0VmhBWVVvMnl1S3Z2SUFUb01IZllabE5UYUE4R2c1dmgxb0NicWtzMW8zZEVVTEg2UlhPVjhhRnZFb0V0YmlrdEJXQkIvbnVUNUFIK0NUQlVtZmMvZy9zbFJXczJVeTNjNndaK2FwMU4wWU9qN25EZ2hzV3l1Q3B3N3V6VkMyR3V5ajNveWpBNWVHbVZ6TjROYzVlSm5yeFpISU5Rb2hVOTEwYmRmTThlVWVOb1RmOCs2RFdqczNkeGduTkJnZTh3VG9DRC9sTmNKZWZoTVFsbTFqSjJGWVZGdjdJT0x6ZGF3bm9VU2pVamZrNGQxTEs4MFBXYkFId1dwWU5Sb1ZqOGhCdGljZVBNb1lPdThQSFBLdjhPNnozNXMzYjNqMVVCYzhNZTJ2N2JtdWUrUkcvUW9pTHdKMGs3SXk3L0htUHVDczZQTzFMMksyaW9DNHZ0QW9lK3ArWVBJQ25pV0J5ZVV3ZWw2aVF6d041eVFUTFo3VnFjODcyOFdmTkNyWTJod2ZzS0h2V2FXc3NLS1RYTTdnYkJaNVdtQzl4SjlkemxoemVMclVFMkMzL3dPWGxMM1NWWUJOd0tYaVlVOXRxOXgzQXN4VmNIbTBYa2RkODhjbWkybHp0ZzUrSU93cGU1STBLSVQwL2syQTdWYVJvelQyZmNpY2NYN0IzZW9kM3krS003YmJUdXJ3dHVUeWQwZ2Nta2Q4Vjhrak1rMk1lU2xTa1lrWEpXNC9BYTM2bzlkSnp0U2N2c0w4RFpycXRLU0ZkdUJ1c3BlOFNCWjRFbXNnTXcrcmZPRHhjVkxKN0VUMS95c3ZPZUdMd29zdkRMMXJtMGhiNVRnU1F0NFVMbEdEekNNZThwdm1sM21VeVQ3dm5sNllaSjFaUzRHR1JCdythVTNvd1JKNjdQNmZjOWF1OHd5dUo1N3NVMGNzdVQ4bkRqQlYwS1NTdjNCcFlJdkswRTVJem1UbVhGNHc4czZiNWNsRnRqdmJsaEx2UVlVc1QzSEgyeENuVWlTenB6QXBXY0FXNUljcnM4S2dCZHJmaU9lem1VN3E4NEZVMk5pRmptdzgyVDE0cFlDMVJFRzE4VVlkNWlqemZKa0Z2QUkvSnE2TWc1bWpmUis2YS9xY1FmRWY5M1lrTlpmRGcxY1RoVGFMT2xNT3pSYmFBRTc3QkhONFRwM0I0Tnk5MllMZWYxdVYxdUcrTVh5UGFGR1hnNlRGdjB0K29CZEhEdi9NK3p6Y09DWlptUkY3dEVacWZmUU4vMS8rMFB2WjM0QzRFQ1RTNzQ0Q0lYOHBZMGt0YU94Ynd1NmpxRUJkQnhSOTh3c3M3dk5zWHU3Q3JUdVB5N2pDWHgrVmdPdWlDSmlBbXdWUHl0a1FlS3RhSlBQTnlURjVZaitPWTFVZUxhdk95ajFZajdwcTFCNXFJV2ZxMUh2ZlkzMlVxNTZVNUNHVlE4WFNUT3hUQks3UTIwNi9rOEZBdGR0WXU3NnBUdUx3SG9lWHBpZFVkSU1BekN2T2RDQmFRVHNucituL3k1TmxXSVRZSmdjazd1SHRSYlU1MitVSFRUTGpyV2h3YytEVnFodXdKbi85akRFclpnT2poQU41a0xHQWV2Tk03dkt2RTRlMnNWRnBkbmpVcFpGd2VyN2JjSXdXbE05RnNkZHhrN2t2Uzc5b0VlYkpYL1dyVHJFQmVMUjZibFgxTzNHMzhwY25uaGs3em0rYXpPdkJqV3cvdVpEQkU2cmdIMHJRbnZlVHdkbGdlcmFYU1paZjNQTWhqMWpUeVJOVWNlZi8wd0VRRGk0Sk5rQ1p5YXdqK2dUdkF6ZmdVVVR2U1oyVHZYV1R1c0hQWVNOWHpiRTIzbHhoMzAwbEloWDQ5bmJLcERpK0U4RHc3dk4yV1I2dGRmUnFYOThLaklXei96SUtISlk4ZnhkTlE4c3pMMlRxQ1ozK1NJa0xyR3dZS1F6Z2FrL2ZXVjR0cTg3Q3YzdktOYVFZN3dpbWhzMjIxSlQ1Z2xWWXFDRzJ0bVpWV3dMT0YzS0V1M0Eyek5COTlvZXp3cER6NlRGMWVPYkY1NCtYUFJwZVg4SEtULzErYUtrYnZMeWwxUlJ4aGYwYytUdlU3MjhBdVIxNjl6V1FlOWtiUEhjQXo3bnByc1cralRRMGEyWFF1K0RKNGs2NXA0akE3SndJT3o3bnpVQ3lFOEt3NHZQSnNzVDI2UEd0RnYrbnV4NlBMTTZCQWw1YURFWlFaOGlBVStPbllWaHI2aDdncDhXd3dJbS9ZMmtyZXZHemdiaFc1V3hsb2JpRVFkOUFWNklTQkhDYjBQYTdYbk9RNzVVbzlMQms4WDdVaFBINzNUWFpOeVo0ZEh1d1NjWG5TaXQ0UEhIdGtjSG53ZVdqNTFUNVhqRjBqVVlZMW1WSDZrdHZQUVI1OEhCSXNnNDNKVzFmeTVtWVQ3dFpyY0JlRU8vTi82RW1mNkFxSVBKRjBFWG5Qekg5azdrd3RkK3pBM1hEQ3U3ZWZwY21ONStyd3RCOW81eTRQcmVqRHdERy9tN2xOcGxjQUh0YlVvNmhxS0p3Y25uT3lZdDMzeVU2QklBLzd1R2J5THRaejNubmJWeGNuM0syTnRERjQrbVlGZDR6YUpOOUduYkZhT1oyNDZsUnZVRGNwNGVGaGVQUXdXc3dtcmV6ZDRaVmQzc21NellkQ0NKUFJGVlR5RFBLbVoxenBkRzBwbEVBc3dlQnRCVHhiMnllTzNucEtYczF0bnBOcFB0TzRTM2s4eHc3Y2Nla1kxZ0llWUdMdWVMWTdnK2VPQWFNMEJ5bmhvZVBoMFZkZWNWNE9UMTJlenRqMG14UmVnNlFBN3NEVzFPVnRzZUtTRlc2czRsY2NGNHRCTmg5KzMwQUVlYTI3dkhYVDRCMWI5Ynp6dGM4dllqTjZHN0JUN216RG9jMFd1RE8wc0JMdzhQUGdHV1JRaFArTWUrUzZFSjd5MnhJd1MzTy9EcS9zOHVKTkNqYzhBSmVIWURQcjh1SlNwNnAwd0hCS0d0WjBCckRIYTBzM0k2OERlYjdYdFlibFBPM3lBK1l1ckNXellrdFdabVhuYVVrTjBscU9RZWNYY1hpWU0wSU83N2tiY0Z2Qy9oMWUyZVhoOGlDdmxhYWJxUEVRbUR3R01kZUpnTUtFTkhsQWovT2FidGpNS1htMWJ2Tzg3S09CdXdibk8reFQveC9lT0toRkFFKzVhek1UcHpYUXhQMWQ0RTRHYmZXR1lqRmNEM1FlRHE5Y3ZzSzEwaTFOenFTcWNKN1R6dVRoa0NmazBUUFdKcUI0REJqTFFKSmlhVWJvMVY2Rjg3SnZmQnVhQnR4aGszVGJ1b1NRb0E0UGFSYmhUcnJLa0dZbnNRL0NzaGFMblVIUnlvNWNIZ3JIb0tJN2JkTmdVejFnWXA0UmovQURaL1RJRVlKMEVwNWtmVjRrNy9zNll2b2M3SHZpcmxrelp1c2dnaDY0RS9Da1pOQitsb3dtVXlodWdNR3p2NFIyZnU0T0wxMitJb1ZqTnozOStJbkxZNlZjQjE4d2VCeVFRemRYOHJiczVjWUhPNUEzckcwZlFkN0d3WFAwdnF6VElQWnQ5M3pKM0cwNG5ibGVUMENNNUVGWENzS2Q1Rm0wWStIUGRnSmV1OVhNQ2lxcGhrRHo4YWR2a21LeHZUczg5T1dWQ3Nmc2N1YUFLcHhrZjNtV1BMN3JMaWFvK08yR01rM281cHdNd3o3YXVkMlhJTTkyL3BjNkFXbS85dVF2eHR1RU8xUTZwQVc5anJkY0d4YndRV3BHRHpzOGJod1M3cUxEZTh5MGN4U0w3YlV0b2R5S1Bpa2NjMG1oUlJWT2dyeFd5SXRyZTFaQXozNUQ0d3FrVktLNEIvS0dYM0h3b0JBZHJ6WXJpalpmcjFQLzltbWZYR2pjMk4rQk80QUg3dmlBaC9xVjdFU1d2NzI3V2Vxb0Jid2hnQXJoTmRQTzRmRDIxbmhlbnI2aUtycEpDcy9CNWRFbGs3bGhtVnNJRER4SmpNbnIwZzhlOVNzc0FObUpBZVNGRkhsZjEwbTMrN09Qdnlic1ZwdjFCb0ZtbUx3bnNaOGNaMHFneVF1Z2hheEx1bUtURzJlNWNqaUU4SUJKQ2RET2Q5dDRYaDQ0bHA2eENSVWRrb0tCbDB4bDVpZVM4cDNtUUMvVGlRQVBTT2tVa0lpOURDQnZsTTMrOGNORnRmM1loejlPdUdQS3dKMEs2Y2tMTWhRODBnNndKdENra094UExXWU1KaVZBTzAvUDBpeU1GdHVmeTRPa2NGY0lyWjd5Nkl3cndTYWtjajdtY1pGZTVqVTNlVWZpQTV6ejdPZElYdVBrdlZYTHgvWmo3NzAxeG02NTJ1RDg3YTlJcERSRHhBNm9wYm1UbFhKSFNvTHFlMXkvNllIbVhTSWw3SGkwV05ubDZWaHBrUlM4U3dGU0hqazFyUTBqd1lGMG1mVHd6SURuemNZU0FzZ0xSTjU2dFJ3N3ZZTjZpOWMrN0pXREJIZElleDMvQVltMGtla0VabW9DR2Z6YnBJeGEzdllZZlp0MGVJOWNmcU5JQ1RJOEdnNXZEM1p0VmtWSFkxNmZYM21HSkFYMFI0azBidURaWWpKVmhhNkt3UnFkeVNDUndJdDFtc1lhdGhBK2I5bEFUSyt5d200Tk1rS2V1OTVJKzdFRjkxWGloU3RqclRwMmVNSmR0bVVCaHgxMmVNLzBtUlcwNFdXa2hETWVIbDIrU2VHV3Y1VVVyRXZoZ2NIbDhURnZNSE54K1dDVG5oS1JGMGZjSkVwbXBmUmhEZkpzUFh3QUI3anB5U09uOTNPOUozMjM5c0hQd2wxdko1U3R6Y2JiR0pmWVloUUZnanNHejBHalM0S0JJZWNaSERjVWJWQm01WDdyU3ZnN0tlRVczSmF3SDdzbTYvS3NNUS81RlpCSEE5YVV2STZVekpnSDF1aGRpOVZ0elpJcmRvM1ZvWUJEMytib2hMekdrcHZ2TDZydHp0Ny9lam5HYm5tMDJWQ3kyUXliaUZ3MEtYcjRFZ0E4Y1hqNWpvVlNxeEM0UTJZRmJYanE4SzVaN05WdVJlRllPYjhDOEVBZVBMME9vK0huSnVSTmd3eDAzeEY1ayt4WWZKOEcyMVNRQnp1c0taYmQyWHVIOUt3SDdqYTJJY0J1V0ROM1VQaTZpYUJIbmM0NW1Va0xwNzNwbXVOTXFkenZRbmhVTWl2SllyRmJGL3V3OGhXeG1sK0JtRWV5Q1pPWEhHNlVJOC9BNC9DZXlXUGR2SlZJSmtUeUdyS0Q3MnJsNW83c20yOGJXSStnK3pzemNCZjNDK2t3clJ5RFpOdUpqYm1EVDh0V1RnTThESEhkdHFuTVN1NEMySDFid2VYRitoVUVtOVFMdFpYNkhjeXN6WktIcFlZWlRCNjIwOStZL1Fva2puYjdxRm1TMTN1KzFvL3R3cDU4bnNQTVpoTTVBM2JUaWswb2VMeTliY2ZIZk9iT2pNY1Q0THczblNvQ0NwRlVwNXFWZ3NOYjdObTBjRXdsQmE5Zjhjb3g4bXBtR0dia0JheFVWSjdWU29FYXRvWEkwMkNUVHhFbjVqNlB3RnYrVkt0WXp0NCsvbW01Sk82T05yNFBYajByQnp6cERLSWxqLzZ6NVpRN1dVdDBsZU51MjhYMlY1SVN6cTlZVEZYMGN2M0t5eUYweVpZZlVmUHNyWVEwcHp3OFVlK3dFNjNzVFdTTERnMW1UTjVxY3RDckF5SE8yajQvWk81V2Zad1ovZG5BWGIrVU9qSGlUTmFkZHFFb2Q1YWRJMWtZeGNCMDV1SHFqaERDeTFTek1nUHRuRlgwY243bHByc2ZEb0U2RWFoSUZlMTIzdGFEam8wa2VVRlZISHZnWS9Ld2ZaVGFQQ0dOeWRzSWVjMm5WZEU3VS9YdSsyYktuVHU4d1l5N0RWZXdyQXZjeFJXQ0h3WXZOM09hNmpQQUhjc013MkN4dTI5S1pGYk9RRHZmcllwTy9VSDNXN0Q1cDU1cTZXSmxxV2FoNXdmV1NGZkhmdVE2enEwU3dsZSt5MERQMWtMZWhUY1gxYzdLM3J5d25IQUhHU0ZpNXlBaS84eWNHWWtTMmdBeXFTdVRVd3E0ODdVdkU1ZDBtSVFYdTRGbW9wM0RicjFVOHl2YUgyUmlYdUxtTzRESE5heTJTSkdIUGl4MEJNblkyaUFhN0pySTIwVHk0UEtPamhxMkgrdTAyN095TjM0Y2M5Zi9pSFFtdUJzcDZWd2xqVjBVN29LYzlxV0VCVXVPTE1janFQWHVTcFB3cEJ0SU15dVg3bEZLS0U4Y1EzOFF4RHlRUnhHMWxFUERrdVRaa21OTkpjK1FJdkNBb3UwMCtieWVPeVh2MjE5cnVIa21ZZWF2M3k2WG9NNjRRNzA2dUlNTEJIZzRRUmlXeGwwQ1BDenozS0VKZ1lWMW1lWk94ZEhvQnRyclpMR3lwSEJ6V2N5elp2U1d4a1hIb2sxNUNvUFpPbnZ6dktoM212ekNjV0dTcUk3QjVtWkMzbWJGc3NMeVFzMXVua0UyODhKU3VhTXdrN2lEM0Fxc2pEdWRoUVF5YzVrVjFSVjZZeEpGT2JkQTh6R1M4R1lrSlpDa1VCYnpPTmhFT0VrSDNXa0xFSlp1bW1DUlhVaVF0MWJ5Sms3UGc4MytvTWRua2NQTEY5WCttOTF3aUdmYS80QzBpb08zT2JLTjhLM0FmZ0VyVXRKNXgyR0pTdW5wR3VDUndHY3ZlVXg3OEVDekxPRmRzMThwUVNXRnEvNWV6QnVhMGZ0ZzgxR1F4MFZ5RklIVFdueWVWT1RwKzQrbUc5bm1Fbm4yRVRzOVc2ZklXMzVaeGZUL0pKcC91VHcyNHU3SXNUb0pOVGp1Sis2NGhDVXQ4SVZVMVc0S1BNUlVNcS9Nd0VPZytlaWROMXhmbFBDdTJyZVVvRjBLSlRIUEs4ZVEyU1R3cUYxRFNXeXoxNEsyR2x2SzNzU3lDUEo2UnA3OUdUNEFlZmIxQUhwZnZMT285bS90bmE4bjNEV3JvNmpmeFdkdURnK2ZnVHN6R1JKbmhqVi9PZXhYY2c0UEh3RThIMjQ3Q2pRZkdRYjZSUWx2SmwwSnArcFNZREZQZzAxSFQ0TkxuN2Vpd2FZa3NicG9BWmI0QkM1UHBqLzR0OERYUjhjRzhzd09hbzdsWDJkVkRrNjRXL29QQTJhUnNqWDhIU3FKb09lWi9kM09ZaTNhYmpJK1NxUmFNSUhURElFbVMzaHo2RW9vbG14cWZ1VTQyTHd6ak1ocnpWZzB3RmxYeWROVG5sU3R5LzQ0Wi9CNW13MmlIQ2R0TXdwN0xMbTVBbmxtUDlSV29YOWo3LzhBWDJmdUR0N05HWFB3eGxFbXVKTjZ6YVMwenR4dEkzZWh3QjBYVHJOMEhpelFuSEZtaGNiYlpzVThDemF2czJEVGdta1dMUkZjd3ZRMFhDYlBPR1B3MEhHTzhnZ3pIT3g5R2NtYk9yMkwzOVNHaFg5cUw3MXlNVDVDZDNlV1Z2RW1jL2QzOWxFWTU3eTB1SmE0STJrOVJPUGJNMExXNFhHZWhTZmZlbTEwdURjR21pVGhuZEc5eXp2T3IwamxtQWViclVrS0RCNGVVQ1llMExsaW90NUo5OTFrdkJIcFJXYnhJMWJTTGR5a0pIaDFldi9VM1YwWVBjRUpkL2FrUGM3RUhvMzBWZWJPMXVOZEZ1NVlYb3FkczFudU9uQTM3c1MyUVBPcFNhQTV4OHlLNWxmS3dlWVdMZy9GY25vTmtBWUliZ0NQZkY2MkZZSGpHSzBXUTlYZytnUzkxV29DM3ZMaU4vV2tkM3E3NTV2ZTNiSERXNjE2OEd3L3JDNTlFOTJkRzBrOGt4M1VVYmQ2M2dOM0hWYkNuUnp3ZU9nQkI1b3p6cXlZWFZNT05pR2pJOWc4ZVFEVERxQjhLOTZvQzRRZk9VL3dZLzBPNERsNS9KSzEvU2RaWVJqQXd1VDFUdS9kUmJYVDJicy94UGZXMHQzZGdKMkJaOWdkRytKOExhRmw3clRQUzducnRFVlR3ZE9LRnBwNzEzbjNhem5RUFBmTWl0eWxVTXhzSmtaZWtNdEQzNktDU0xNeWxUelZ5ZFhuSVp3QmViMGh4MjBmTUhuRDR1RFhxdW1kU3J1THlVeGtNMWNPbW5DSE1Sd2NqS2lpUnhzY2duS25sZEswSkJMcE9FTzEwU2FkbHdMTm04OC9zNEwrb0dLd09kUnNQajZSMFZtdFM0YVhKdStwaXFEUkp1OVVDRm1mWjF2TzVLR01aVmdqM0J5cFVGOTh0YWhXc3ErK1dFNXR0V0xzekxTQ3BjeWRKemt4NTVZem5zSWQ2UXpDSFRJcnFJMStmS2pSUktBNXMyNmdYSDlRT2RpOEh5NFBmUW10Vm9adENUd2tZSkthRGtnRVowUWVBa2xEYjlqbHFEU1lyQUQwVHI0YkZtNXkzY1hidFZtb2NCdkoyMVBxZnUvZG5jbm13dDNtaENxdllGSHNRS1o5WlBEWldya1Q0ZHpYeWgzSFU5UU1sQXcwNTlJTlZCZzVwc0VtR29RZUhGd2V5Qk1QcHlFNTlTNW02cUd4ekpOSCtaT05rK2ZIT3FCMy9CdDU5QTQvcXNwQzNsNzY2UEQzQ1hZZVprYnMyTis1OTFwdldNL2pkbVZzTEllWjY5U1hBZHhKSlZrMHJOQXA1Tnc5Nk0xQUNEVG5NVmlzTE9ibGcwM3ZSbjhta3JjdGt1ZDlDT1Arb1pST2pqVzlLRVVjQ3JGZ1JRUThmQm5veFV6azJVOC8xRDY5bkwzend6SVJaa0srTThYY2pkdXlzTzd3ZmtRV2hiRURpWW53Qjl4UnBLa09qd3VFTGRCODJPK2dQQTQwWnkzaEZjVTgxR3hhTi9vTkQ4UmdFektDa0NlSHZHMm0rMDZuMXFxcVFQS2RyVG1uRmptekQvRnlkcCtIdXFjYWIvNWRsTmxNdk4zZzdnYndLTXJNYzhmZXpYWk11T1A1Y2FsalI1azdyS2hjMks3a0dyck92VVp6emhJZWlYbWxZTk5HSHozTDVIVVo4amdnY0V0MklpUjBjeDV3ZE1ROVFIanpzblJ1QnZJRzhIcnJ3NldKSFZaUlQ2VzdWdzZYd3QxcUJZZG5UL2g0TFJXYjRJNkhjK2lCUVk0VXBRNDlPRUFHVDJzUy9iTHpjcUE1RHdrUGRra2gyS1FDRnZUWjR4R2tvazBXUFBrSm93Vkk1MFZQeXgvUTh6V09lY1krendROFRnUDR2WldLM3RkMURCbmJlMTlQb1hOMzU4OFRBaWtlOGFoaUFZYzNIQTVFU0pmSU01ZG5teGJWMjVxNDB3NjljVzAwQjVvemFqdlBpWGthYkVvMytsREFjaGVPZWZUeXlYVXg0cStUNWRCMHM0VnVFd1E4cTVzZzhyaG9kK0x6K3A4ZFBTSHY5d3YxSGt2WWh4Y21UNmUzaGlCajdteDc3RVBqenJhVU40c1RuSkpwMFZZaEhVSkdGOW9vZHhSS1dST2VkSjFyb0huVlltWkdsV01TYkxLbUVEeFZtU1pQZ2dSK2dtNWNEeDNQZlpMSkpQSnN4eW03aHFBbmZoVEJnOVA3bmVIN3ZSNzE0Z3l4dDVmQzNkSzQ4M2ViUCs1aGpUalRZUVIzMFpjaG9hbmM0Wk55N3hDbkNnQWVsV29BdkllZ0pIaWdPZDlhc1ZOWGpxR0FaZEFVbmplWHQwMlRwL0pMS0pObitrNXJTNHdsVnVuY3RUb2xqM1VGV3dLOTQ2OFRzM2Z4KzNxcDExL3NuZG1QREZFVXh2SGswU01KaVVnSUR4SVp1d2RiZ3FCalNaTzJUREJNVzd0dFEySXFIWVRVLzIzS09YMi8rOTN2WG9WWXVwcVRpTlJ0d1ZUVnI4L3luWFB2MnNGYno2K24yRFhjTmVDRmVsVzRrYjdBM0ptY2h5M2dSUCtoQlUzd1N0T1lpSlBnN3lSLzhTNE9VeExRc29KQWMrYW04SXJCWnJ1bVlNY3BvSktyQlphazBjZHJLZDhtVDBVRmZuNTFhSWdXOGd3OWMzTGhTeGdScVIyZTkyNDFSVy8xMXZoZjd5STdPYjZWdzY2eGhqSzdmd2d5aVR0OHlVRWxSMWtsZW00cGlNWFJJTFB5YUt3WFhyUWR2Mm9PU3NncUNiTWZhSHJubUFhYjFNRGltc0lKQ3dSb05JR1ZUeVl4YmtDblJvYjh4bUlGOG56eUZYVk1RbzkxaFVoVThLNXBReTk1elY3Mi91VUM1MEx2WlM3SzlJTStwNzV1NG1ZM1d2d2RLQXNkbTdrVUFkd1plL1N3aFRzNVJBK1RRc1FkMmpKT21KSkFMU3NhYU01T3I1aHVBMUhZK29nMWhXTjJaeXpQWS9Cd28waEVFUEowcDMyS1BsZzRoNEFIN3did0hEM3dTSnBlN2U5T2xyelY0ZEsvaXQ3QzBxTWtBbGdsN3F4eU1pSHVxSU9sT0JnVXJnR2VjSWNuWFlvN2lidEsvWjA3UFB2NG1CMlVnRUJ6UTNjQ1RSMVQwR0F6ekNrY2FBb3NhTU5VOG1qcXRVU2VyZUlhVzFQSlk3UUZmZml3YWNrelNraHFGT1RNdmhiSy82T1h3VzUxaWgwd1E0YnNLNUZFcXR3UlpKU1lFM2I1aVFXdHN4UmFOcEhHRUpjSHdrekN0d0xOWGJNWmFIS3dXZFlVTE0wNzlaVThGaFYwamtxUG5DVHllQWhJVkFVbXp4WXMyaEh5Sms1ZUJSZG5sVys3NXZybWYvUVdsb1orR3hnN1VNYlkrYjBFZDVFREZPN2NNRDNwZVRrTW1KVUtMYWhnNG9yM1pJMjVQR1VKbmlrSjNRczB0YktwbWdMU3ZPWU84Q0VTN1BRb09OQzdTWU92UEJQa0xrL2pGRWN4NS9Rd3FKbVFWK01QT1hsQUQyL2RzUGN2bFZsTzlnUTc0ODZLbWJpbnhCMzV1K0FBUVpRR0tMNmkzS25EcTVRN3RGaWszK0VSZUp6Z1FVbVk1ZW5YbjZoc0lzM2JzZkZJTmUwZFE5Tk9Vc3JFWUxHa2VXbWZabjVzc3M2Uzl5SDJlbUJLeVVNQnZPWWlDNVBuRmM1L1JWeTRNMzRwMUtHV0dYRUhtMkpXaFpzTDd1Z2JVUk0rd0FtRGNpVGM2WWllWDBhWVNSUGlrU2pCNjF4RnM2MW5FMmtlMUx3R1BET0tBbEJyd3ZjV0h3cVUxTE8wZ3oyb3NmS2w2WWtlZFJCK2tDeWs1dXlrRHVnMTRFRmFvQ1RuK3ZLL0lLbGZXNzVld0E0aVFwRzdCaWZFRjlTakRuL0g3cTR4NVk2M0hKT3RJUFJNUFMyUHd3T2Vjd1hQRTd5dTlHaG1lamEzZkUrYVowMmJtRUJuZVlYdUdwSDNpVmU0MlNoNkV2VDhnbnduTTBBb2VkTUVTeFJib2hCdTh3b1Jla2w1WVRTWTkwYXllNFBMMlNEVHVVdXl1MmJCbHZKenNFSFo4V3R3NTdsNEhJeldDWGVTYXhTNUs0K2tXNHZtZHlWNFcyYXZSN050UUVqVFBEUnROcjFqcHFlZzRJVFdzVHg1dENEazhmd0lOYXdFRkZVdmlNc3BkYXJmTmV0Q0hyN3M2UzFjM0RpL2RaWUxHeGZsdXdiWUNYZFlLbkRIMm1tazM5a1NRayswdVpkekN5cHoyNHFBaDZ1SXhIMU5peVluZUIwTU5EbllMS2Q1YU5yRVlBTFhWL0tuNytvQzlMc3NlYzRRbmlvWE13RVpXbmpOUlRhL0JEM0FhRTdQamQ3RDRiUDVUUGJ1UEJ2U0Q2dFJwdDNBQ1c1UmlCYWFtOHdLS1ZyV2VWSkV6MVNRczd6TW9LT0xyaUNLSHJqN0xOelpaZythNEhVdDBQUnA5QzN0YVY2am81L0ZiVkh5cXZ6d1hVSWVPUFBIb1NNay9GeFpPVGZHNGhLTEllWkVHbzBpVFJXY25sL2ZIY3pmU1NjM0JuZmpIM1VWUDNwUXpKMjdDYmdMMzJRaG9BL2NjV2VRVTVad2gydTNCRHM1K0ZmQTQ0b2NjK2QvNUd4VFdHbE44TGJNMXRUNUQyMTlwRTJiVXgyZGdtNk95TnQ5SG9RZGtGZnpOamwxays3VEpHd01YbHc1Y1VNVUtrVUNRZzlmK3dEUDdNWFNQTWtMSjVkZXFMT3pGZUlPOXlybUR0aXhuQmYyazRaM0N6RGFTbVpUUnJNV1FVOVBTVVNDUjl5WmNwNjBhTTc0OWtZdFd4L3RLcWQ1b1duVEN5endlZFF2cmJJTUwrZ3UzNUVTSzRtZVp2T3dHbUpkQU16UkM2c2hYNkVjaGw1Q2R3VytjdjN4dkxpOWU0K3Z4eitnV1ZpQWI0dnVFNWFRRzVzNWQ0NlpqUDBiWkJ5aDFCSm9TbjJ6dUFjTHJzR2RGeFJRV0FrdG1zVUViOWNzYlcvVTFzQlNUUE13bTdkemh4VlllTnRhSjY5NDl6aURqck82aWdmT0hUeG5FZjJZVk50RTNZU0s0THlNNEFtNE5rdUVuamkrVjcwSDY3cHVEM3F2OE5PdGtvVmRvT0R5NGl2a3hWSTJObFBzM0RVS2QyWjU3clJ2cVR5aVJ5TUpYbGpac2RObThDakI2MUxMeXZjMXNLaU9mc2h2aUdzS3NIYnl0S0NDaFJ4NW1IMG14U0JQSHFaWWt1cTRzZW8wbWdsNzA1ZDB0UEt3eTBYT2hZY3JvOVdDR1hMRUdTODRWWFJUb1pvWHVQdkFsUmFyeVVEUmErV3UraDd1a01nYzJyZ2pWczY3MmJMQ3RxczF6WnNXV1BaWDNqc0c4aURYbGFhdG1EeEUvSlV0OEs0ZHNWams3QVduRndJaUNvbFFvSk5hSnFWNlFFOERUbCs2OWJqZnphMDRML1FmMzJMVzJOc0pkckNFT3VhdUhHYld0R1FQVGVKTTBkRlZTZENYQnZNS3hOMytxWEtlSkhpenZhM1lEKzV3V3k2d0hMWllFeWZsYVQyRlVjTW9YbmFyZHBCSDZHRUFqTkNqVklSZFh2Z0lQU3RBTDlRU0VIR1NSZGZENWU0ZGVISnoyZHN4RStJK3Jsa2NaQXAxbkF2TE9KNDBTbjhnN3Z3Yk1HQVhxYTNLWFVWN3E1S3lVTm9LZ3JnN3pJV1Z6aWQ0Wm52OU9BVk44MGhIanp0WWNDWm5ZeXJXOFlLU3A5bDM3WVNTZEY3WEhHNkNQT0lPb2FXN1FvbXRZcjluamk2MXNQam9lWmQ2V3U0OWY0VC9mOElkY2p2Y0o3WWdob2E3dzJPdzZKUE9qdWhGMjNPUVMwVGxUSlJhdkJHMHBDOE1DZ2tvckVBNTl3UlBEMHJZdTY1THRqc2JiR3FCWmUwb2s2TlZkR3FMdEtqSWFhOGw4bUxGd0JlWVBHb1dNeFFweitNa2oxK2pEN2tYek16cm00cWVyZmtiTzF5KzBZV1k4OEtONWVGSHpsY0JuV01IRVFIVlhZNEg0dW56dUgybE5pTWRWYzh5WWZBUzd0Wk1sVnZtemhkeUhTd29yQnhkTzU3a2EyRUZDVjRoME55OXJsdVduMVBRRGhiZkNjTEpvN25YMHZDSFJwdlpvY253RUQ5bnQycXZ5T2ZCdUVMbjVObDZnYndJdlhmTkd5cHZydG5MeHc5blc5NDcrZkR4eS9DZko0ZjNzYkVNZGZqUmdWMklIL3pqcVA4Y2RlS0l1MXE2aVR3cGh3ZGtTUS9jVWR6WnhoM3JWQ2UyVThkS2gxdkZzcTFqYlIwc1c3OFdXQTRHOHZ5K3RKTW42YldJckVRaWthZVpoV1Z0V2ZTeVRTdDQrK0xsaUR5RFQ3T2t1Njk3OTlmTnBsMDcvL3B1b0k0cy9EajUzSTVXUDdnUmR4UG1yc21PRVhtS0M5U3RUM003c0RoanFxU0xCOFRGSnl3ZDFJNlZ6cmFLU2V1WXBubGFZR2xHaEZEYXpIZHBWa3BldHFCTVpXY2xENXh4a0FQVUVxL0g0Wk43dmZSVnd4K0cxd042T1h2Njl2YXNPYjZUdDk4K2JXTEpkdXhpN3VEb3RhamlzVGxDVC9nd3p2aDRDNDZBWXRIZitiVW9TVzNjWVVJUEJVMHByR2lDMTRsV01VM3pObis3d05LTUNGbHA4NXpyTE8za3NXNnU1TlhwZUdWZElBOHpRQm4wSmt3ZXdzcmtoV3MrNEtTUUFzN1NtenhhSE4rWUZZVnY0Y1o0Y1JUb0V1YkN1dk1GOHVENndSMzBBd01QZWlqbjBNa1pGU2wzNGJMRVhVWCt6dDRkRkZZSzNHSGhuQlUwV3dzcm03dlJLdmJqYVI1S20xYzkvUzJUVjVYT1dRYVozRXNyNUVIUWs0QlRoUE9NS0N4TkswWWV6SmZkckFaWWh1LzY2M0gvYjhPMzBCKy92aDcrUndxZFozYUdIU0NMSTJ2TmVNMzh4c0FEMWl5a28xc1Q0TlZSbVlVSEZLS0hxWHNmK1l1ajNGVUY3bERRbkxzRUQybGVXNEhGUzVzYkw3SFAwOE5mUVo3bTFaVFcrYndJb3hodmVZUm5EVmxwQWdzSmlxQ25xWjUvQUFONlNQZnk1RFYyZC9ITnc3L1ZWM2JuNFp2RnUvUy9FK2dRWXBxUnEyUHNrTzdxY0lLanBOelZ5UmxDU1prbEhvVDFTYTNjSnROb2pDNXl4NTFRbCtLQzVyd2xlRkR6V2t1YjNyVjVYSTZaRVBRVVBGdkpiTlFCeWxnSnFxSjJNZHJUVDF3ZVRCc3lvbFZpRDZ1RUh0RW5IdVhSb0hmdno3cStoWHU5d2FPaVE0NnBlMGZVV1FPMGNvZjd4cmNyMzQwWGtJTFdoMW9MY1llMmRtb2JLeW5weXAxZEo5d2Riem8wdmFBNVRmRG1Rc0ZMbWpaYkNpeld0ZG1JQ3Z1WVBEbnRGWGMySVErV0NUZXRUVGY1cWd6Z0pXZlo1T25qSGtUN01LeEhkUlpiWS9Ub1RTNi80Nk5YZzE3L1QwelFudXozQnErUTByRjkxUDhzdUlPbE1PS20wYzBpSHliTlFEVjlZSmlKdndOM3ppcGw2d2wzMGVjQU1STm9udGsrN2REOGRtR2xTeTJhaGFiTjlxNU43NWNHZVI2eFYwWHlCRDJxbitoZUQ2dzBwRHV2c0hRZWtVY3RLL2dVdS8yWjRWTXk2T2N3UlErK2IrWDU2WnUveS9rdDNEejlmT1hSdTQ5dFh3Tk1IZnk2L2ZhT0RJTUlPcDhRU2lXNW1VYmVFOGtmaEhKSGs3R09rVmFzU1hBU0J3anN6QTZaa0NBZG1wMXUwY3cxYlJZTExEYWNGNGtLUjZyRTU3M1hvL0NVUER3aDJqdUhvMDBzNFE4QnZhUlBrN3ZDY2owcnNZQUg5RkpDYVZhMlRKNTlCT2YzYUdWNXFmOExkeXk3Y1AvSitlV1ZSeVArWjlqUmlXT0dmaUN1amxJK1VDWHBNR1pnQlR1WURFVmlSU2JTRFNOd1YwdVZXNDRHMWtEelNDUWtmTE93MHEwV1RiVTk3UVVXRXhVYU9jK1lpbHllREFGeEtaTzZvYzBvMkpSejd5cndLazhkaHlTQVBJQkhGbjlHYnlMa3ZZazJjUWJFMU5Pb2paNitmanhlNnQ5ZitIa1hkNysvTkg3OEdzVHhQMmU4eWI4Ym9FUFZ0a1FkMGw1Z2gyNGY2bjkxSnhnYlhYRXJHWjB1VSthT2l0eXE3SXJEY3dHUGhJUmlZYVU3TTNnbFc5OWVZQWx5M2tYNFBKbmZWeEZCdDRzR2pGaXIwcTM2ZWRZWlFSRXlQYStaQzNqUXpoRnZnanlLd0doS1BlUDNtTHZtVjRuQmwwOFh6NzBkTHozczM3eDJzajJGdTNhei8zQnAvUGJjNHRPWC9KZTFrczR4Sm53YXRBTWlrcFM3Qkx1SklRY29kVWFQZGdzR2RMb0ptWDNDdW5uWXM1RXFiYktGZi9WZXVMdllDSGlibERzdHJNejhibjd0dGcwRmxsWTU3d0JjM3VkMjhtVFAvWGpKWVBKTG9FZFdZeXNRcjIxcllZNjdXQ2lqdzU4Vjh0ejRFMDc0T05Ja0prbzJ1alY4OVdMeDljcGdNSGk3UExXM2ExY3JyeGRmdkJyZUdwV0JhZ2RQdHdybEdETjhyUEtLREFXbDNERjR2Rlh3ZThGT2h2VGtDQXp0SE5PV3pjeVF5d0VYOEVSSVNLMnJ5bmxXUjIrWDg5Ykl1Nkl0TExxWkltT0dTck90MkJybUtYVWJXNVRMa041ektZRExtSGk1dEppWHNJZXhHZWJWN1J1dlByRDR4V1o0eC9ZTkxOOHBkNlc5YTlHbUl0d1ZCcXpra3hCcTJITENIWWdVN2lqSVVlNEtXN2xmV2VNdUsrRE5qWEwraGIzeldMa2lDS0l3Z2dzUkRHREFoYUlJQmdRREdGQk1pTGdTQkIvSGdCdVo5elowMldkT2YxVi9qNzhKcjlaQ2RPYWE3cjNmVkhlZFU5WHpBZ3RGaFJEU3I4UTdSdklnSW9neWtlY1ZGa3o0NkJmakUxdnM2ZXZDUXR2ZmpDVVcwN1NvbkN1YXdVT0JkdG05a3RKMkFHdUVDVjc4aks5V0FMb1dHbHF2Ykk1a1I1UEJVTTU4VCs0d2hzTlVQczdjWEZiNUxpSnJqVzAzWVZocHdqbUVoSjByck13S0xDVHY0b1VicjBCZUpkOE5oNUYwRTUrMUw0czlqZTJQYmJuSTA4TEhocXk4VHhlYzd0aFF1R2RGcjFGZ3UvZG16aDVRbVFYQjFjOFk0bzFuLzlrQ00yNDVkeU4yblIwTVBsSit0Q3VqaXRvd3d5QUlGTTRxSVoxbEZUT3NYSFR1ZHJld2drYUZYRlJvY2w0STZUY2ZnYnpZS0J0NVBPSThXVzBHWmJhbEc0YWxUdVliMVl0S09zWldkSm5SU29FRjU5NnJUc0RZNy9PeVlqdXBsdWM2VzVKQmtBajVkdGhGQ2pCY1pPS0lXTmZ6bkR0ZlpvYVFEaCtTOWg3YWpWQy9lM1R6aTNCKzRtd0llSitkMGJ2VmtwREgxVm1CUlVMNmhhZFBlc2V3YXB0Y1dnek5kMTkrdlF5cnpjVXFaSDFMcHc4ejEzZWxQUTFmSDEweXFDcWZ0QzNkQk96d3BhNlJLTHVMZnU2aWRQam5mUTFnVjgxWmtWRWMzR0gxYVdFOUM3YlRyZzZORFJyaEhOdnJTQVhOWUxuMXVmTzFDK2RIOW5Tcy9IVTk1L3Qzc0VTUFVGaFlYdHhpenNPaVBwa3RIRURwaXM5NmlBdkRtTG5GTFBWZThoNjNMNllUNDhzWVA4Uk40UVg5SzFKaWtzZUtTRkg3QWZCWXhFUmxOazEzRVd1ZmFzZE93aHdrdlJaNTAwSzdvLzJkOGwzRU9IdWZKeDQ2ZDBwNE5sTDY0WXZQby94Q09EOTJaSWNkSzFzS0xCUVZZdVRmdmJjaVQ4WUU5NmR3aTcxeWlsSEEweEVaMnVjSllUOVhDdVNobHBKWUZvTTVWVlM0V0l2d0JXZDNjd3FnWHhyOFJ6bDQ4VURnTEQrRkNrbDBqNHM2RGtQa1c2eHRuNFQwS1hkeElaOWQ3T0RSS1BaVndQc25DaXU5UldnVGVhZU5QUFZaZ1R3ZVpBRW5iVTluUHN4Sy9taU0yUFJ4UGFsbnBTcGlybDhRdlRPY3ZiekdEOW5sbDRNWEcwUDlxK3AvaXFLb0VrVW9wMDI0UzRRRjg4ZmFPVUxDVGd0TkNYckpPaE5LT3JsclJySFRjKzcrM2xhZ0txNnp0Rm1ieCs2K1hhODJpOUdaZFF0UU5tVmxJWGxpejZmVzV1UU5Hem9Ianp1K1l1VGZIeUZ2RFgvOGhkVWpnQ2x4dEgrYlY1T0h1WGl6VUxiTVpLMmxjSTZwanFJaU5TcHFXbWhtTFhvdDd0WkdNWTl6ZjNNcjBCNmx6YXY3SWE4YVdydk15T3VnNFNSS1hhcVNudnN1eWdhZ2hEMEpYQ2lqVk9pMVM3K012Z0l6UmI1NUhPZ0NkWEhETy9GUWd4RmU5bkoyQ2tWa0g0NFp4NHJkaHJpRGtMNmR1NnU3Vk5EYzBKeFhreWRqZVM0aEJIdCtSV2MrRWIzVkZUKzlSaTRXczBnSGpEQ3RRTHJURjNXdExDT2paUlRveXE5QWozczVDMnI2WTlFRjVWcmpFZlZjY3ZjT0NRL2NHWGJ2Uis0V2NHZStDUXJwRHQ3OWhMdGRiTUdyNC9JRzhvNStJKysrekFjRmVYWkVmZjh3M0xEQ2Fha2EzbDZSeDBlNTBPTVVaUjRIM20vUkw2WllYeU1GUDg2Zm5OZUdpMHF1YklFTnFUMDlDZ2pZa2J2cW5uNVpTM3JHbmMxMjU0Qk5uV2FTVFErM2JoYm43dWlVdTkwcWFDcXU3ZUhhREF2TFYvSk9CWGxDcnh6VTNza3pxVWRacjRNbUdTRmVabFl4TnFLUEFwUUlHclFzbmxIcEZjQVdMcHNqa0lIMml4Lys0Q0xFbTJxcWFBbENQYVZtNjUyRFIxVUI2YzY1ODE1MWN1ZjVUdjBKdHArSGNVemNOV08wREN1RlEzTzNDcG9vYmM3Sk8vNkZ2TWZZNSttOFZ5WTk3ZlBZaGlEcFhQMEs1aFhqcEQ4cmsrY2U2Vy9OUThnaWVKbXRPa2RmMXdTOXpRQVdwREVvSHdKV0FFZnNMT3VQay80R0xTWWJxTUdWcHBwRmlpTVYvSEJtN2p5Y3UzYnY4UmZ1am0vajdzeXVGVFROdFRrajc2U1RKemxQb0EzazRlQmViMFB3V3FZbE41RW45cUFzc05XVFprMHVPWFZNc2FxaS9UNmtPemR1UmVnUEFveUEwcGduTGJMUjBNZzVNRWZxREdlckw0M0c4WDRUOWhYSERvdlBSZDJSbHUrV3dzRVNKQTdDcnVxYkdYY25KOXp0amtOekppck15YnV2bExjbXozTmVmQ3dnYndudXZ2MHUwKytXQlM1TkkyOVFvamhEYkFCUGFLWGZZcXhKeTFFc0NTdnd3ZmdyQVE1aWo5U1ovTTZzbXdLanhzYWRMeWh6N2x4Q1NOYWVHbmNMN1FlV3pZSTdtN3RhY3ZkUENRa1FGVGFUeHdvTFR5Y1Jaa0xSejdTbi9VOVBXQ3c0Ulo0OXZ5TlN1MWl5RnlxelNDM2M3WEVFWklLUzIwMEFIM0xpSnVNWXFSdm1yNGc0TDNOU2FhbTVlemZValJtT0hSNnMyN203WDNLMzA4N29RbFN3VGdYS2VTTFA5RHllQ3dRVFMxeGlGUlBrZGFYVzZwaWFaY3lGVXRGNWg2OVlnVUpFM2hFN0REeHkzUzlkT1NJMVdneGtnN284eThva29CUkwrNHF3QW5hdUsrZ3RjZTdRUTZSeGJqNVFHbktydUl2UFh6MmFxOHIybXJ1N3psMGk0SW03SFJVUzFuRnUzK1JwV3lmTU5EMEZGWmFTUEFsSG1FM1FYcCtPRmxQbVE0a1B3UzJad1VKa0puUnNqbzB6SlBCUVlFNW1zUVVXY1FVUEVBSjNuS3FoY045WVlFY2xIY1cwMkg5WW9XVUxkenR6U01LUHlua2tUNnFDZkp2WjBJM1YzS0tsYWpqWGRhRVc2R0hhZjh4MzFIY0VUdnZNcUFrSm9hNkdFRDF0MjM1QUl0LzZVaXVtUU9YTEVtakdGYkdqenA1eWwzUXRvTHJaUHlkYlo0STdEWDV3SVgwRGQvK09nUGZENUNtb25IL0lSSVQ2aWFuUzJialJpL05mSlRhVXgrRkpMaTRlL0V3YmlZc2swZFYrYVJUNHY4TS9aSHhsNFpOak1YTjFVOWdoMitFNlZaM0ZWcDZxVGJkQW93cXdDMTkwNkhkVDduWlh3S3VGOURsNTBaK25FSGo2VEhTTzRZUThTZWV4MlJON2dkYUNwZEVhS3VZODFkdGxLR2FUemFBYXJHOXpBTmx2UXM3N3pWZi9DQWpwNmpYTWtsMjc1MVFDcis0bGNMK21nbW9xN0xUZ1RoditnYnRiTDBydWRyOFRhQ0trejhpVGUrenBrM2hESS9SWUJIbndQS3gxb2Nic2VIekdrbHJsZFEzak5JMHR6SnMwV28yOU9pU3YvWXBBK2hyUndWN1RYUUFLVUR2dS9meHlMNXVnVnFVYm1NQmlCaGJNK1hQdUdvekdYYnY3NUduNHhNamR2eVdjNzVlODZNKzcrVHpJODZUWGlOS1RMMjA1a0RJazhHeDVZNVFSUHB3TEJKOFVsbVcxdk1CU1NCMC9FenhKOHc2UTBpMWRZM28xdVV1OG5MRjJob2dnS3VFK2gzMUZjZzY0ODlGSG1PTG8zRDI0K2JudjlUOTNFd3ZMbkx6UHM4ZWVkZStka2w0REQrU1pTenBjdHp4Nm1ZUnBXMmZYY1J5ZWV0SEZIb3dqaGg3QW8ySHNaNUpIbk5WK1pMbTRmZ2JBVmUyazFza1FhUTNZZ1RzeHBuS21UQTIwdVdOWS85dHhuZm5zUnB1dmtuRDNyeGxXOWtkZTZ4SnE1RjNSKy9weDZFUnd4d3JiWHVsQ21nNDQ0dTZmNGtMRWtOT1VXaXJ5a2lsaVdteW1QSHcvY1VqRUsxcUdZZzdCNitMOE9qWHVBUjV6b0NKM2p0R3VtV08zRkNOWTNMRTVjbmRseGQyeC85d2w1ckhMZTVGMzBNazc5RHJlV1IwVnRHaUZIK2t0QXMvS0lFK0gzUU05Q0x4c1lhbVhuRXdoZTgzMXd4UXh1RTZLbUkzd1E0S0xHTE1WL2p4bVI2MUk3WmtBeEtiZFF2Q3dtQVBQdVhPL3BwUWdIeU5RY3hjL2YzM29HM2VId3hkZGMzZDUxNDFpaFhuczNQZVFkMGZrS2NkWkhYT3B5SXRvSHlROEsxWitHMnNBVFRidm1KcTRZRGdDUGk3VzZsNVhKQ3Frd00xQkV5ZGdMb2hOaDZFcFFGMVNweG1vUzJvcU9BNE5NeC9hQ3p1TDhDRnBmeWNoZmNYZG5lL2c3dHp1RzhXeU9MQW5lVDU3N05MNU9FdUljMWNTQ1VHWWljY3VIN1RBS0JCTGVmV2VCRzNXYXJyYlEzNzJIRkxBVjBKRStrZ1RDU2txT2JWZGs1SDlUM3F0QlY0MlBjUXl4NmFtYm9LN0RsMnZHYSs4N0NOM0doZVhyak5mZmprZndlZUpsZHhkM1lVemdmWkozdFZ0NUxVVFRXNGJlVEtIdWZLcTRKVEdZSzh6T216cU9DZnIzVmpqeERSYk5OMVZDUWhzNXFsbjZOVXpCckFtYlZUeWI1eHNFNmZZb2R5RGFrcHVIbGpCRXptUlJ3cUtTbkdIZXRmQzVZcVBnaWk0dTkzT0pmblAzZHd3dlltOE9Fdm92azZGQlhuTGlCNEg4ZnZKOTJxODdPWHZSU3hXUThpNXEvRWVoVTFlTWZJM3QycnlNbU80TlNuQ1lEUUVjMlZFc2JIelFvdVJoZVlwckVGVnptU2RXY3FDWXVFRUZ1N3Y3c2Q1UUFsMy82WXh1aVJ2Vzg3N2VxTEpWL3ZZdzA1ZU44aFdaenY1U1BCQ0hkSitJNjJ4eUpyaHc4TTh4dEVrR1JIVHhkeVBxUWFiZndjRHNIbndNVU5wb1dPbkI1Y1JDZkRXNmwxNzNDbUVHUE5kbjJzN2N2ZFZWSGo0MVNiMjlWeVMvOXo5akp4M1V1UTlmZFRJMDhodVdGWXd1d05Xc1Q0cFoxQVdxTjJaQXpOMVNHTWFWOTU3U3ZKUWo5bWZZTGQvRDh1bTdXS0puZTY2VXJBSGRub2gzbSs3aU9PZGFNSWREQ3lOdTBkUHhkM0ovOXhONHVwbThyNFlON3VVcnBRM1ZKdTVza1IyMDdIbnBWc3NINXpWOXlmbXRzVDhTYURIOFpac3JmdlZIbW1tT01BMlh4MGJkM1k2cktJY2hSZ3hIemcyNmtCQ1VWbHc0TzZyYkg3endoZWIyRmJ1ZHVwb2tsOUZYcGhZSU9oWjl4MTdsOTM5Z0kyRXltbHhLK2pDa29uS25kTmw1R0ZXU1RYTEZpUjQvRnpvRlBVd00xTEg0UCthTmpwWVdGQXFKbmE2bW0zdmxwRTdNNncwN3E2WVhlVS9kMXNiWTh0NW15VHZFM3ZuMWh0SEZRUmh3ZE1DRW9JbmlJUVJDR0VDNFpJbzVPb0VST0lrb0VCK0Q2eXQrQ0hLLzJabnVyMDFOZFc5UFY1N2JFYytMYTR6SVVDOG43dFBWWGVmRnlSdWhxdWhBMGRQcExQanlTQXFMaU5yQVZoRk4rRmhPSUhsVGNSMDMyMSs4TlJQUkwxYWkwRmFacGF6K2NJZG1Ec0pkMHZ1Mk5ReG9CZUxnTHYzVSs2dXhPRHJ0dVJ4NDZaYjZXb3JxUGlGSjNqSTVJRXZtSHBKWHhQSVMyL0NvKy8vRk5QQlE1d2VRbHBVSzVHTS8vRkxUYzc2RkZOUXVvdkdBeThUOE5ERG9GYTZoOXEwdkU4VE5nTGFNeHQzWjBmZXdORHpmUkMwZG9xK1VQVEZ3NmJpZ0R6NHQrTnRJUGFhZG93b2V1RVNGSHptQ002a08zTHo4c3NZa3N5YXE1UktvSmp2WHRGQjNZMFNaM1NyZ2lZN2VpWlRWem9wNGdFZFpYQWlweTF6OWlIWXV3UDdybTlYYWR5ZEZYa3c5Q0J1WXRPWW9NY3RTSGdvWDI5L1JmdU5DRXl1TE9sOVJGWmVkZ0lnTmQwaThPejNGQ0MxQUpVUHdNWXF6NGxXNFhLMlZMeEU1ejBSZC9ZVWpoNGFXSTZ3Q2tLSHZydy8xd0Y4NEhLbTIzZU51N01qYjJ6b1lWcEJ5QlAwdUk3QmVZNDgzQ0ZoZUtXRnBiWnA1dWdoVTJyUldhUWJGUkpyTE1KbTY5cDEyS3lrVExndFQ3a2IvYklwZHVDT09saU81TXYxbWhyYkNienU4WG9hWVdUZk5lN09nRHkxRlV4aXVlZmtyZGs3RXZTZ2JtTFdrdEhEaTZEQmNJeWVGRmtIbXZZUUEyN3FiYlpDbjVobjhac2lKWmFkSy9uMlRoNFN6QWQ5VVpFcWQzSi9VTHI2Q0JjenE4NFNxR2ZySmNYb2ltWWJvWEYzYWxjaHNSWFdFc3RidXErRXA3bkFHYUdIQjdKb0xpbU8vSVh3SUdzbWkxNnJmQ3dudXNpa2lCaThyYnBYd0oyQ0hPWnhGVytGTUxubXhRdklvVm1ERjJxcGVwR3A5NnpoNlZwV0NXeUU1aU5zMFQxV0czb21zZXdSZWRTeTR1UkJ5K1FGUjN6QzBQb0hrVGVMb1liQ1B4S2g1NW1pTUJrQVJVUml4RUpTdk5iTXNYcXBpQWVLcVBUR2dUczU5MGtkZ0Y5anVxZVNTdzdwWHhrZ1JwWXNIcjZHckJMYmR4clhyM3EvU2tMZVRrVWV4TTFPWXZtbDcySTVHaXh2cDBNZDVoQUNCOEVmb2lrbFdIQlU3ZE5VYVUvSlUxVUNaejVFUnM2c1psNjVYamZHamdWZDdhQUdkc01kVWFLblpQUEc4ZGFIUTEwV3QxekZxMTg2V1FWeVpzSGRUdU11Skk5bTBtdHhjM1hRKzhmY0JFTVBYanJJU3hveXhWb0FlL1pZckNjeDd4RHllZFJVcG0yUDUzc05lbVFIc0RHZVRUbElRcVB1Z2JHRlNZVzNMaHlMRngvWnUwM2NIV29EUzMrOCsyZDF2SE01VTIwRWpkM0dYUnp2WVE5TElXNjZ4UExONHZueUdEMjM5SlM4b0ExWGx6cndLNmszRVJGNncvcEtVQ3ExUTFJOForQnZ1bHNBUU9OTEg4TE9BRDd5SHN1NHcySThuRExPYjZvTXVtNkZPenZlUFY5OFk3SktKR2RxZkhaMTUrK3F1REdOdkdPSnBUL28zZXg0TzFMeS9DdEkzQ2w3b0VtdlRzekpnN2RNNU1WTElPSTZqMGc0WS9LVUpIWEcxVnJNdDVOaFJFcWtWSldhR0ZHZTdNZ2RQUVIxK1NsM2tGVnUza0czaXNtWkJYZFhjOC9EdFBnSjVOWGlwaC8wZWtjUGV6TkhFb3V1elZRL0tka0t3c2Flc0tjcXVneUtsdTFpU1JJNkJZWFQvejJScDc3QksrZFpKZ1pUUFQzSmJGSkVxS0pGQnA3MGF3NjRzMkVFUDk0VmNpYTR1NHA3amFiSDl3VjVrRmh3MEROSGp5b1JrS2REWDhHaG5yOFBDMlBhTFpickxBS2Y4b00wV0ZuWEczeUNEVzZnMHFYZHpkRlBXVXdEU1k4MVh1dnlJekNIbWZPRXUySEpRZjBQNU1tQ09pc3o3NDJPZDh4ZDIrTjNjdkpXTzZhdkZSSUxEbnJtNkQzdXlkUHBrWERja3ROYmZ2U0kyaTgyWnoxdGxFNDhOdnhsQnA1aU9DM1U1RXZYQms3VVBQVTdDRjBYZ2VWSDBqNk5tTlk1aGcybkZpU3FBRHZqN2pFZjd5cFo1ZHBxWDNUanJ0enUvbmxCbm5leEhEdDZxOWJOVjMzT0cweE0rc1hMSXFZd2V5SmlTdFpMQnhUQWxxUVdJby9lTTNoQWJ3cC9hZVU0TnVjVVBFUXRlNGJZcFhSM0VhaTBPRElYM09HOVBRTjQzTUFDcWNWY2hGVnpwcmwzOGZGTzd3TzZXbnZhNXlDUEQzcnU2UG5TVGJ2RlJCWkdFM3NoZWJHS0NmNTBtWUgvMFNMSUNIZ3o4dmVtVGFrQ3hUcTBoSXk4OFBKZ09EM2RWdTFzUTdhZ0E0dllvcHR0aVR1TGNibzdiaEp6OTI1d3ZHdmNuY0V0WGlDdlB1aTVyL0RReWsxYjh1MWZLZVF0VlUxZzBLSGNGUGlHVUJaVEx4dlNRdUR2VGR4Q1ZBY2pmOEp1emNKc0NOVWhQdFdsaTU5UXJyUGV3cFBJa2RSTUJpdC9KL1V5ODZHVm1kbng3Z3JmZjNmcTJLWDJNU0dQRG5ydUszaTVhUXM2bHNhZWtxZnFKaTNVeE1jcFBOQXhlektRbm5VM0JtdmVJeEQ2MzJQNGxBeE9hNGp0eE04cXo0RnM1azVDcWt6eTBsbmtqQjBlNmZBTHlreDNFWEM4SSs2MFRleUszUGQ2RnJGRDdXT1ZvK2ZsNWdzdk45Zk5tekwyR3BLbnJXSzhzZzVvYVVHRlNLOWYxaTVOem4zL0ZYaVVBUS91aE5EeHdUUTJHMEk4eFRRQmtMbnZFdDJya0RZMW9QSWtWY1hVVExnSWVyelQyR2x0MFNlSmE3QVZpb09lK1FwOXVlbG11cE9IRzVVUjR0ZUtvY1F0OVNpWUJEMVZXNUk4RVhrT1pOaDVzcHM3RWlQZnFNazgvSEsvNXZCbHhGMHlwdWVoRFEzS25XTm5telB2OTJXbXVRaDZ2R3Z0S3JNMXNlaEJEK1htMmt3L3d1N1RDcjFoeTRweFNxcElwTXdsNkExZVJidTdVc3RybnR0Z2F3MUhzeHo5TjJjbndIRDRGODhUNmxndWpuMkZzS1cyd3c3cDdydVZhWTR5VTQ1M3JWM2xySnBZU29rRjVhYWI2ZnR1NmVGcWk2eTI5Q2NnejM1c3Vsb3N5WHRNbnBScWxZS1JYakF5STNmRlVBS2tGMk9RbTFoQXJMUnJEcXRIZEd5Q08yQW5OcnBXbWJTdXc3bmJkOU1jWldZbHE3UjJsVzJ0OU9xZ2gzTFR6ZlM3RDVhcmdCZ21ZNjloS3pRZUVrUnFNR3d3aTBjTnhKSkNMUHlseEh6Z2RRVGxUYUxSelNhWlBodklPK3UzK0RXZ2tpSCtCY3hYL2EyZjhpVVkvV2FWdXpieWlqTFRqM2ZOTmovaitKRnNoYkxjN016MFZlL21FN3RIajFkc3l1aGxmQStsNURaY3dGeGt2Y1BpNXZQU0w2QkhCc0lwcjFSSURNTGdTRGRGOEJ5djhKVnV6cUN0UUxEVEMvUENWWCsrNkh2OTFPNjllN0xxemZ6Mms3TE1aQnVoMlhkYkdYcTdJbTVXNVdhbnNkeS8yU2M5OTE1Qm5ocTR3VGsvSkV4RkE1MUdsMGp0QStSQUJrOG9ESlhQd2Y2aWpKaUN2UHhrYVk4SzdDeXl1WE9Wa29BZFJkSlR0RFlSc0laL3VZcWI5N3ZOS2xKbUZuTG1iclB2WmhFM3RkdzBqZVZuMDFob2srMFJrUmVQaUVuRUpoU1R4Zk5CV2VMajJxL3ExS1N5dEFocXVNN3ZwdVNmZCtJVmxYbnpHVjVuZS83cWpXT3NKeVA0cGtyZnoyNnFTbGxtSW5hYmpURERiR3hVYmxydnBta3NENWRkMEVad3BrWnluZ3JjL2xJL1JyUmtSWWJUNnJ5WFhUNk9TT2lSZTgyekZkRlRXcXVGdW1UaldMekdpV3ZNeEZFUFJNNVJ1aHNLWFlCeGdKMzNxcGlxWXIyWldtWTJHd0V4dTdpcDVTWnBMTGFPNWEzZlBzUDFaazRlRWhzYXliS3BPMFRTcUluSTIwc29ZVWtVNEtHbnE3eDdDLyttTkJpbnFsdnpBSkZmWGNiYzhYRVF3Tm1mWW0vaHlDYnZvS3BFWldhVE15bm03cG5XY2hNYVM1ZjBibHZTNi9mRWtiTVE2SmdnWklTZXJoWWJoN0VaQU1QQ0htTVFCcE5KSk9WTXl2dUl3c210TEJMaGhqTUFWTjNNREtpWU8zL0RuUXpnanRQZDdTN2RRVldSTXJOMVJWUE1MYkZvMHZOUm9hNlB4WkxlZDRPazl4YXJ4V2o4U3p0VGdKNHU5WXZiTlRlTnp1aEhjNHRsZkdVbzBoTlRYSTFkVm1LS0FHWHZzb3Z4Mk01ajN5Wll5QUV4OHp0TGQ1LzA2ZTVEVFhkTlZwa3hycGNIUGRaWXpGaFluZlQyN0tRSE0xYU44MEdURXZ0UCt2MmFZNmkyYlB5ZzZtZ2VSMFZmaWcyWUlZRnpXNlJqNnNSN2w3c0FQWkFLaFR2eDBYVW9XVVpqamJ1OTFlbk9UQVJTVllyalhaTlY1dXNmMDNJVEdvc1pDMTNTOHhzVzBPY3U5V2JvSDhqTDdBNWlhdE9zV3pWTDl1WVBoYTRZZGdqRnpzU3dESmRKNng1M09WdmJFOTRtN2JjaWRPbk9UQVJYVmJqTWJGMWlNOGYzZHRDcnlrMU5lbyt0YjlwRmFqbnBZWnN0RTRaWFI0SWVGVnpaYnJHOE5YS2NQYzhUdmp5OTZYNVBKRnYxN1RpTGk2NkVPcFIrTkFhR21MdjFaakgwT3RnYXNjZVM3clRNMU9OZDYxWkJuTVZ3ckJ6MHlxVDNOU2M5OW9ka1h5M0wzbWxHSE8xWGtlWnAzZlVnaG5PUi9zRGdYSm11WEsxVVhDYkUveHNxNTNJVlN0eHBvelFzQkpnK2RickxqM2R0NlBXTVk2Y29OOFZZT0pZMzd6d3drUVZMcEprODVTdDlwVWNhVU5mL1JubEFBeS9PcDFPek5BeTF0YTMvWFVCTjJqWDE3SWNJcDRianRZbDBqWk5iNWcvdW1KaHA2UTRtUWxGbXRydUF6ajdlZzZOWGFDeVU5TDVjM0hwcDNadDBZWkMwNjJKd1dtMDlCSkdsRFI1U2dhVXhkWTNZNlJxankzbHpMUzFWZWRHZDEvNTlKenI2aVJhVlU2Y3JqdFpWNXZMbHJjV1h2WmpwNlU1VWxlYWFGekhqUWE5T2V0Ykk4czNpMlN0TGVnZE8zbXZkc25MSWFncVMyMUIxUzl2RnN1LzRJM3lnUHlZQVZOSkxiUmRzUmoxYlVKYi9CREpLa2U4QjlKaSs2RTgzclhpVitlclo0aHRyVlpGMDE0NTNzMGZ0Nk5WSno3bzNPMmZCUkpZRDNBQXIzV0thM1hSclZyak9sbXF0MHJlakxEVDZLYkpWWVhua3dJWGRtdUt1VDZ4SXcvdi9wbUFIN1VTNGkvYS9IUzNkUS9ET3pDVGROZmR1L3RDbTZaTWt2YTZSeFVZV1RHUXhmVE82RllqT0l0d3VsbFNjV1FxUXp4Kzh0ditvUlpxQlNFZ095Q3VKWktUL3hhS2lJcFZXKzgyMGIwekcwaWttckMvbFhYNHVxblRySGZyT3pEcmRJVDVyVndITkVXamRwSEt6VEhvK3N0Q0pMSGVmRGtVV0dsbElHZ21EbGVUQllGN0lSUDZCSFpuamhmeXlybGdKeUJJOXpxWGJMYlZWNDRPQzgzdCtpVkxPSGMrL2VwWDU5RzRucXZnZ1FwM3VVR2EyNXN5WkF0T3hlYmtwbnA1MWI3cklZdlhtOHEyZjlQQlYxK21mUVd1RlZGTkVIOGlicXB5Y2RIUVZ3Tm5qWlBDbkhodzY2VlZlcFR4TFUrVWlPRkZMaW1DbnJiSTJkdmR3NGFLS2RXYUtkNWVXbVczbWRlN1FCaklsRDU1ZXYyNzZDNjQzbDBkeTc3bm1OaHpuNG8ydGFIc3FiUE5wK01tOUNzR2tUeVNXVk9STk1oazQxOVU1bFZRVDFPVC9aVzFqaEYxY2Z4Nk9xa3diUkREdmpyaHJMc0xGeFEwNjZKVkp6MFVXcnpkZkdYckRpRGJSSWVMRHkvQnpVOXpYdjYxbFIwcS84blJxMjJHNng2SHJOZk1tY1IvSFY0MVk4eDJjZE5jeXJjcDBVV1Y2dXJ2V21zUm1EaTAzNjZUbklvdTNiM1pOWkkrV3krV2IxM2F1RDdOZVl0NHhlYlFzV1puQ1IzWFdmV0piL09Pa29XUzFMWWNlLzNUYmcwenFKY2tPM09GVjc1ai8xaldJZWFlS2l5clQwdDF1S3pObkR5MDM2NlRuSWd2cXpWdjd5eDQ5V1J2T00zbktuc2prd2Nzb0pjMUgzdW13azBoM1RhRHdUUnRVOERyQVRtNklsY1BkY3Y4V3Frd1RWVFRkdFZtRWk0K2ZWbWJwOVJROWtLZjFKbzU2YitXb0IyTkI4OTRHWTFoYWhvdDU4b3NCcjFaZnRWMVQveEhWTWVVOVJKZjBXMWwwdUpNcVU4Vk1qZXROelp3OTFFemZmVytxeUlKNjAvejBaMys0eW9MN2dvYkRkd2ZWVFFCNGZ5RG9LVjRhRnpBWEZBenBwbzZIVjVjS0hoRkgyZzdlMG94czByL0MyUDN4ekJ4elZKa3Fxc1N4MjB6ejg0cmFUSy9yelE2OSt3L1F3S2xtRThPbGlRMnZ3NGdVVFB6TmVRTm92ajJBeTdIREpGQ2lZM293cWVOT3plQ3FhdFNYaXQyRCt4MTIyMVNaMTVwcGZzNkIzazNTV0NxUnhmMTBHNUpkUFB6TkJvYTRYWVdMU3MxNzZoVlBYNm5KRUtLeW00dStZck5tMUV5YWJtSEpsenZKY0tKZ1IvNEJOcnozMlAxMmUyR0hPM1BNYTFFRnNkTjZNeThvZnNDb1VKWDByTjUwUDkyUGVyZjI5d1E5YWhZakJROHFYaUFxQ0hrV09Vc3NLbXFja1g2U3Rwb3hkWGxKT3Q0S0hUU0FoaGQxaG0xakttWHU3ZC95dzUwNTVsWmxWdWtPNWwwck04ODVZT2xOVFhwZWIzN3dzUjMxREwwL1g1cktNdDV5bXlZMUVUTGw0NWN1OVl2aHFLTjJEL0F5Z2d3eHhVY1VwRWdlMGRPcllKZGVJd2pzSUdXKytOT3dzOFBkeHg5WWxUa3gzVFh6N21JQ0dndVNYbzJlMTV1TzNsZUx2KzRaZXA3UXhCY1A2R09wSmRUODBybThaRjlSSGZtUHBPY1ZlTUZGWEJ6cGhyUVFPNmdtU2wzZU4vYXZZL2ZkejJ0TnhhdE1ZRmVtdTZhcVhGUmdQbGFNaGZxb0I1VUYzb0tRVjI1cHBaeEhrUW9SUlhFSUxDYkZpZHdMbWVEVEVCbUZZWXJsRnNVdTZodERrOEloc0lPbVVoenV4RVJvRTY4WEgxMGZ5MjVKSHZSTnFDeU8zaThqOURyNHhEMVFud3JhWGJKNmt0R3I2TVBtaGNua01RMDV1Vk9QaGZrVytvMHFwK3E5WkxZZ2h0bnVkOGR1N2R4Qnl4eHcxM3BWTG5WY28xbWh1dDUwbFVYUWV6M0lldnB0bk5hc2FGdCtQalNUakh6WGtmRGtmMWJ3VHQydUNacGtvNkdjSDdPMEdLeTh4YTlWSjZuWWxscGc5eEd3bTVqdW1vbHdXZUo3U1hxbHltS0d1cUtIb1I5QmoxSUNtbjh6MjV5dTJsRzVSVW5aSHBzejNEbVdaYnBvY2tnUVRTN01PNlpPc0RQRC9NTkNVOUYwMTB5RVN4TmwwdU9qbnFzc2l0NmI1WkZlMThYa0FiMERTWXJNbnk1ak9XV09tcjkzVEdVaEJvOGQrT0xtQkliNE1NTE9OUlVjN2xxNmU4ZUNrbDUxMUhPVkJlaEJabmtUb1RmZXdCNGRoQkRCa0Z2OEFiM0lIbWttamNFRGMyRmZ0ZGgwQWJweU4vWGhhOFVPbWdvT2QxVzZhNTc1cFl0cjVPbVY5YWFpWithQ0Q2bHpwSTM0ZWNlS3Vtb0NIbG5ZNThDZ05tdkdKN1JxSTZHd3BybDlTQjJ3dS9kWGhOM2tLbk9udFloZHl1aVNubmg2cGNyQzZEMTVlYk12T0Y5VEh6MTBPLzI0VmNZNVlueDlaYkdUWlQ3cWlwVm84WDdOa0xkODI5aHdOTUdXR04xOCtZU3dxelFWOWU3YTZlNnl4bnRsMHF2Uld6eC81UE42M0ZHdk1rS2k4R1VLSm9SSlNoc0hnY2MrZDdjbTVpODBUeE4zQXRYRy9acGh1N2o3QjQrZUx3cnNxblRYdkx0TEhEL3VZbVJoTy9SV2pXU0x4MDhOdmFQMVlTV2ZlUVZJNldrdm9tSEcreE5BVFo2V1FobEZXUjNWbFlsNUVoTFhvUTFGNWVuanJoVjZLK3d3aUxEYnZMdExIRGMraDhpeURYcDlEK2ZpbWJrTHl5T2FkZUV1NE1SUnhsL2xtYXdlVEo4T1lkb0Vhb1JwaU1RRGtVZVZsQWxIUU5jdzlhd0xSZVh1b3UvSjNBWTdpQ3F0TS9OeXh3ODdTUTlaalY1bnFWdjc5RmVMdjM5OVl6b0wzWm9POWdROVJvbU1zSG9LSUY4WTVvODNkbGNIandtYU5PcnJnYUlzcnQ5dmRHQVJSN3ZscjM4dnZySlc2TTR1Vit6MGNLY2VRaHRFZUJmaSs4OGhzaFFxaTZMM2FZZGVmOWk3dGYvSVRQV2pjQUZTMXJCQzZrazVvS0M0QkJUSFA2cGV3YWYzYWVvUEw4dGdGWXcwSjQ2NVE0MzVhUDlXZjdUcnNQdTB3QzRWVlpxSDhLNEVuSVV0ME92bTlUcWRaVlZ4M245MVhISGlPbjBzYU5sUUlJN2RnN1RpekFNU1RCMjR2RWNQZFpwTkt3bUdnbWpOMnVMRWNqRkJaZm5xL3FyRzdCU1ZidDV1Uyt4Mm1tWCtEa1V2c2x6ZkFqMGZHdXAwRnE4NDk3eVh6UG9QRFR6TTdPbW5ldUpHemRIWkxGeWxOejBjdVhpR0FMd0ZDUzdqTHBKUjBoVXNqSjJmN1BhOHh1d1VGUi84T1RsMjE1dW84bzdGamMraGI5Ym93VkozbmNVT2U3MjljUHZwT3UzUktIVzg5RWVVZU1RSlJaTTBsTXh5U0s5dUhSdHdtaS9mSmVZMCt1ZWU3SjdlN3UwRE85cTVvZ0s3dk1BT1dtWVRWZjVuNzF4Nm13aUNJS3djTEZsd2d3TVA4VGlBYk1JamlXVkRZaXUyNVhlc3lNak9nZDlpTmdnT0tQK2I2ZTBkMTg3MmJ0cVREWkVTVDRsRENFaGM4bEhWMVRQamU2ZVBsRGRyZTU3b3VUMExyeGZvR0dkaWU3aXF2czNiWXZvNzBpVjFIY25aMytzN2phSmtqSWVRWkc5amNZUFoyWk5odkQ1d0d4VWRPNWt5UTZseTcvUzVwb3g2Q25wMnZVQkZ5M1FrMk1OT0hleGw3SUV6b0tQMEZGWUt2ZkswRmpBSEZYNXFubnpSeURHN0tSVXFkbjFRQXJ1UU11K3J2b2k4cVN3WGdGNHFjWExSY3BCTWV4R1BkNWh0SUtlZ2x3c0RmQ2tXN0hja0oxb2lNVXJtcmkxZThvNm1HdXJzWkhmSWhVb3FZd0k3ZFcvbnBzendWTzI5MVY1RjdOTVY5R3pQa3JhOWw3SHRWYnVEeUxLM3ZnUjk0cEEwMEJPUzZJbks1YjlwaXcrZHpLemtpMnJNZFJZN0d6RUgzV3BzZGkvVFp1ZURIVGJtNFlEWS9WYThUL2RDejAyY2oxK3g3ZkcwZDNiZWpwemxubEFPVWVnUE1WdVZIdnZLVTRmZkZ0MVB5ajF0Sm9mYVpHVVh0Yy9QZUxKanMzdjEyTTJZUHRqUnhqeWt6SHV1ZlZvdHZONFNQWkU0WVh0SnlkbHY5YUxrVEl2ejdHWWhla3F0a2Y5azBXMmdKaVZ4Vno0TFhWeHBFaGN3N0dCMzFPb25OU2JNVG1STVlLY09kMkZqL2dBVWozb2Zib1plMnZaczVQeGFqeVI3akIra1BXY0xBRURlTFJEbzhWbnBCWS84WGZ1SkNjQU8xQm5WdjFhVG5WM2E3RzZFM1ljdzNEMGc3WEhMb3FLSHhDbHRENUdUeGozREhqYnIzZy9hU2lNUzRPbHJPREdXNVI0YXUwR2FMWHd0ellxcHU3TFUwV0NIaUFtekV4bVRzVk03bFREY1BSelJWcTlTQTNyK3RzY2xaeEk1RFh2REp0aTd4STF1dklRa1Q0d1ZHZ3RRVWZ6S1N6bEhvYmZocnVDNnJKT0wxNzgyMURXSDFHSnl4T1FhczlEc2RPeHFsYkM1ZTJqNjdMUXNPbnJvT0lYdE1YdlY2ckN6WWUvUEpTekNlUU5Kd3VkS3dVWjJJZGNjU0N1bTFMdUVRYWpFRnhqcmZsdnFPaHZxaE5uUnlUQ1pNVU9uc29QYXJ3RTluOFFKMjB1eDk1TFpheUJ6bW9GUFhBczFYeXVMc3N5dEhxZE0xT1hhS2xTeWhrRjlLZUxxTDFEWGJUQjFMMVBVT1dZbnNBdWR5bzVxbnlhSTF6cDYwdllRT1YzMmFONDdXZlF3OEcySTJXN1BVS3h0dzJTWklpWVB1WitGYXdPczY2TGU0b1RtT3BjNlJNd2NzOU94Q3krcVBHUjllU1oyQzJyaWhPM1p5R25HUFplOS9teUUwSWswS0o3eEV2U0JnVHVYZzV0NmFoTU5aalNhOVYzcXpHQm5JNmEzMmVIOXNHZWh5bnpRK3ZSY1FVK3hQYkJuNXozdU9lZlRlZ1Q0eENjTTZBZW03MVFPY1RwMFpIV3MrblRPSGFhZDYwQ2R0OW5CN2NJbGhGMFEwUE8yUFVST2h6MnpZNGdIdnErdFVZU3FzL2duVzZ3YjdvdythWFA1N3haaS9ZOENNeHExVHVLeHptd09IT29RTVQzTUR0aUZ1ejg3SXgvMFpPUk1zOGZ6bnRudjJkQTViNjU2R2VlRFpFTlB1bXZ3SE1oeWxuVFFKYURyclpyekpHRFN2bzdudWpSMWJzUU0yQVVwNkpWaDc5R0dQUnM2WS9nT3p6bDFKbzhsTVZFRlIwRWN5ZnVzL3hFNitab1I4TWZTSUZiOS9EQ0d6Z2JNYmFrTDJBWGRLbm91ZTl4emt2R1owSmxNZkkzSmpPQ0Q4emsvL0x4cXo1ZmNwb09jYlRoa2JKaHp5T0ZldTZDd1RrTTNtSDFySkZPZENaaGtkWnNPTTBWZHdDN0lBejBzRjBxekIrUGJwTTVHbjUwUDFwZHZQUEwwOHRyNVJvSDBSd09oNHJWOEJqb1lIYW1lUUVjWGZXQjFwYWlEYXFGUzJWbDlvdjl5YXkvS3NjYzlKNGRPTmo2dVd4aSt3L0h5Rk5abjZGdkxTOTNtRnhoQUhpM3dRQ2szeThvZHVQNW9JTzZ5V3AwdXg0Y01IVmNwYkhVY01MbkQxS2pUc1hzV3NOdFpmU0gwbnZtaEo5bUQ4Ym53Y2V5c3pyc3RzajRrejE5cjVVUExjVlJMRnhDUzcvdmxneWYvYVRxUEF0VmIzWGsxRHpwWW5hVE9CN3NYdGVkaGI3ZnJvb05rdUxuZ3p4N3ZHR3pvNUlrdkJkLzdqZlZORjZNb2kxODhrVUZBUXBDbnFRQmxWbUZFSmVTdW9wUkdpMm0vWVl1VUZIUTgxZG1BeVpzRGYrcHdBNkZTQzlqdHZNenhhZHpYODJRUCt6ME9uYW5VbVlYUDBEZWNUQmZmb3d4K2wrdnN4UUZRbzBpOGdDa1FFMDh3b1VCaGw0TytMNmFUb1dFdUMxMHFYM0xBeEw3T2p6cmN0NnU4RG9mRGdnaTlGNFJlYmMrYnZXem9aUGc0ZGJMemNlRUMrc2o3T3EyTDB5aUh2eHNjMVlSQW5ZTXdsSHlIaUx0eWtUdTlhSFZvb0lQUmNaSENUc2Y1a3FGekFxWWZkU2d5S3gvQ0RZU2dSQi8zbnVzOWk4NmVuZmdBWDJ4OVR4UHJZL3JpdVc4NGFSSitnajhBcUV2U2FiOHIvK1lhd0xuSU5TZkRHRGxtTGpFNm51a3NkSmpxVk9yMDBlNzVYcmh2RjVUcFdaQTQvZG5MaDQvcEkvZ3NmYkgzc2ZrWi9Qck4yV3B3RkZtaC9vd1JYSmM3eTBKTlpZd2JlRU93WEI0Mys4TnFFaTFqbjJQbWtDNDVYZ3JvdktsRHhneU5TbENlOWw5WHNOa3JDZCtUTEh5Z0wwNmV3TS9vck4rWnJlcnNmeEpDUXlHL0dGLzhIaGcyQ1B6Sy9GWGliVktuOWRXc09abFhVOGh4dGdSeldlaWVsSUVPQjZIRGFCZDB6UXNSU0p5bDJJUHo4Y3lYcFEvNG1mQnArV3ZNSjkxeGF6bm9SYmV1M21EWkduY244NFlsemdSTDQzS01uR0NPWnpvNFhSbnFrREhEbXc1QnlsSmRuQ1ZUMk5QZ2cvVXhmU244VFBoay9zai9HRUNqczROdm5mSHg0cUxlTGdIaFVYdHdzVGdlZDc0ZG5GV3JDWEN4eDhVbTV5TEh6TUhvRk9nRWRVcWhFcGJsUWJyMlAxU0U3WldFaittRDk3SDVNWDdNSC9zZkEyZ0lKQVFURGVjSGs1UE8rUHk0dFZndEwzNE1SdTEyKzRnVVB5bi90MGN5M3hvTmZsd3NWNHZXOGZtNGVUSTVtSnY1RGJpUnd6Rnc4U2pIeEJGeWJIT0p6NEc1OHREQjdFTEdETnErNDRUdCtiTUgrRER6dWZTeCtURis0TThDYUFna0JBMkREQ0ZSQ0E1MTBkOSt4N0FaMmhnMzRvMkJZK0tzeTFtYmM1bkRUQWZvdktsRG9SSjZ6Q0NQb2dXMlZ4NCtRUi9qSi9nRGdRWkJZcEFoTkJnU2g2dzNSZUkvZmh1anhyQVoyZ3h1NEkyQUEzRkFUakJYREYwd3U2Qi83ZHJCYnFNd0ZJWGg4VWpaenc3dVNGN014akl4dlAvckRlYmdubFlXaWhTWEJPajV1K2lpNlM2ZnJuMWh0emoyc09Sc3dMZWxyK0lIZnpOQUNNd0VZVEFyQk1Nc0VmMnRXditBVC8yRHRhd04zT0F0ZzZPNFQrUTJ6RFdnbS9POWhwMXF1TzNoeU5tS3I5WlgrTUhmRjRBa0NJUmd1UFpucy9VRG9BWnM1RVp3RkZmSTBWd3pPdTVUNXFLR25YcTJGTllqWnhNK2pqN29Jei82SThBc0VBYUJFQXdoY2J2aUROUXlObWlqdDYvaVNLNDIxNEp1UFdJR3JURlZVNk5iRGsydzE2NnY1Z2QvQUVpQk1FaUZnUGdvUUlNMWFBTTNlSnZCWWNaQlhFV3UwUnpWOVU2dlk2cjJodGp6eU5tdUQvd3Fmd1JJZ2xSSWlSdlIyV3FOM09BTjRDQU81QjZhMHhGVHZibko4N3JYcm8vODZBOEFJUkFFZ1hCVkNJbmIwUm1zQVJ1NHdSdkJVUnpKdFptak9xKzNNZFczZGsrQjl0cjBrUi85RVNBSkFpRVp3bUlkbFpFYXNKRWJ3VkVjeWRGY2s3cVF0TVZVdnc1cGovem9yd0pJZ2xSWVJWNVZzRVp1QkVkeEZUbXBVOGZ0dzU0NTFzNlAvbXFCZFBnNFNxdTlVVnc3T1daU3AxNFE3ZlcwMSs1dm15QVpQcTYyUm01MXJqM3p2ZFNwL2FNOXY5Z0wwYUVkQUlJZ0VEN1YvTStzRXRkZURJczZMM1hxbFUyK3J5NThld21zT2VJSHZ5cGl1M0Zqdmx1ZTEybUhxZDdRWUIwR243bDkrdDJZMnlYRHFPdE16K3ZVdXhyWEN4KzNMWHZYaUt4OWw3SmU2L1J1aW5welV4bDgzbDA3WDBhZERwanFHTjJUNzh1NjVaTFppcTdYTGtVZHJOR0ZHL0I1YzVjcUF0MHQ2TjFuZGN5R2dxKzdDRDd6WFVHblZZbzZkSVB6K0s3TytNNnN6MlowTjZGVFoycE12ai96NlBzWWRMM1g4VktkcXp1Mm5iajF4YlB3czRnMUNyYVhXcVNvY3pZa1gvUjFSOTk0V2d4ZE1lZVRUcGZxNU4wSFIzMkhISDU1ek5HY0d6VG8xR1Vha29WYjRYZWNKdzRnaDRKcHpxbExOazU1K0tGKzhmY3VnR1paM0VJT1kyN1NFa1Zkdk1LUDgrOEZBQWtPTTA3azFNL3NQaVRML2pnQUtYQW5iM25FVVp3bFhlYlVqMjMyNTJJQVFCb013Y2RvWmszV0xFWWZNcmZicC9KeVZlS1UrZ0E0SmVNcGtBcVhVVGhEbkl2UkVFa2Fncks1c0VqRFpFUGM1NlJKNEpUYUpEZ09rN01ZTXNLV2xybHBUdHlVZWtiaE1LVTgyYUxIdVhHdDZGcnJzaklmelZ5V05veXlwcFJTaVAwSHVNczlpWXdjdi9JQUFBQUFTVVZPUks1Q1lJST1cIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/img/dist.png\n");

/***/ }),

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! ../css/app.scss */ \"./src/css/app.scss\");\n\n__webpack_require__(/*! ./app/switchPage.js */ \"./src/js/app/switchPage.js\");\n\n__webpack_require__(/*! ./app/discovery.js */ \"./src/js/app/discovery.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvYXBwLmpzPzkwZTkiXSwibmFtZXMiOlsicmVxdWlyZSJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxtQkFBQUEsQ0FBUSwyQ0FBUjs7QUFDQSxtQkFBQUEsQ0FBUSx1REFBUjs7QUFDQSxtQkFBQUEsQ0FBUSxxREFBUiIsImZpbGUiOiIuL3NyYy9qcy9hcHAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuLi9jc3MvYXBwLnNjc3MnKTtcbnJlcXVpcmUoJy4vYXBwL3N3aXRjaFBhZ2UuanMnKTtcbnJlcXVpcmUoJy4vYXBwL2Rpc2NvdmVyeS5qcycpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/app.js\n");

/***/ }),

/***/ "./src/js/app/app-leancloud.js":
/*!*************************************!*\
  !*** ./src/js/app/app-leancloud.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// 存储服务\nvar AV = __webpack_require__(/*! leancloud-storage */ \"./node_modules/leancloud-storage/dist/av-min.js\");\n\nvar Query = AV.Query,\n    User = AV.User; // 实时消息服务\n\nvar _require = __webpack_require__(/*! leancloud-realtime */ \"./node_modules/leancloud-realtime/dist/realtime.browser.js\"),\n    Realtime = _require.Realtime,\n    TextMessage = _require.TextMessage;\n\nvar APP_ID = 'UKsy38Qp4qAcR5plB0iwPjdQ-gzGzoHsz';\nvar APP_KEY = 'Yj5yGRiqz7DFhswBz2DITdDy';\nAV.init({\n  appId: APP_ID,\n  appKey: APP_KEY\n});\nmodule.exports = AV; // let TestObject = AV.Object.extend('TestAris');\n// let testObject = new TestObject();\n// testObject.save({\n//   words: 'Hello World!'\n// }).then(function(object) {\n//   alert('LeanCloud Rocks!');\n// })//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvYXBwL2FwcC1sZWFuY2xvdWQuanM/NDk1MSJdLCJuYW1lcyI6WyJBViIsInJlcXVpcmUiLCJRdWVyeSIsIlVzZXIiLCJSZWFsdGltZSIsIlRleHRNZXNzYWdlIiwiQVBQX0lEIiwiQVBQX0tFWSIsImluaXQiLCJhcHBJZCIsImFwcEtleSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQSxJQUFJQSxLQUFLLG1CQUFBQyxDQUFRLDBFQUFSLENBQVQ7O0lBQ01DLEssR0FBZ0JGLEUsQ0FBaEJFLEs7SUFBT0MsSSxHQUFTSCxFLENBQVRHLEksRUFDYjs7ZUFDZ0MsbUJBQUFGLENBQVEsc0ZBQVIsQztJQUExQkcsUSxZQUFBQSxRO0lBQVVDLFcsWUFBQUEsVzs7QUFFaEIsSUFBSUMsU0FBUyxtQ0FBYjtBQUNBLElBQUlDLFVBQVUsMEJBQWQ7QUFFQVAsR0FBR1EsSUFBSCxDQUFRO0FBQ05DLFNBQU9ILE1BREQ7QUFFTkksVUFBUUg7QUFGRixDQUFSO0FBS0FJLE9BQU9DLE9BQVAsR0FBaUJaLEVBQWpCLEMsQ0FDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3NyYy9qcy9hcHAvYXBwLWxlYW5jbG91ZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIOWtmOWCqOacjeWKoVxubGV0IEFWID0gcmVxdWlyZSgnbGVhbmNsb3VkLXN0b3JhZ2UnKTtcbmxldCB7IFF1ZXJ5LCBVc2VyIH0gPSBBVjtcbi8vIOWunuaXtua2iOaBr+acjeWKoVxubGV0IHsgUmVhbHRpbWUsIFRleHRNZXNzYWdlIH0gPSByZXF1aXJlKCdsZWFuY2xvdWQtcmVhbHRpbWUnKTtcblxubGV0IEFQUF9JRCA9ICdVS3N5MzhRcDRxQWNSNXBsQjBpd1BqZFEtZ3pHem9Ic3onO1xubGV0IEFQUF9LRVkgPSAnWWo1eUdSaXF6N0RGaHN3QnoyRElUZER5JztcblxuQVYuaW5pdCh7XG4gIGFwcElkOiBBUFBfSUQsXG4gIGFwcEtleTogQVBQX0tFWVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQVY7XG4vLyBsZXQgVGVzdE9iamVjdCA9IEFWLk9iamVjdC5leHRlbmQoJ1Rlc3RBcmlzJyk7XG4vLyBsZXQgdGVzdE9iamVjdCA9IG5ldyBUZXN0T2JqZWN0KCk7XG4vLyB0ZXN0T2JqZWN0LnNhdmUoe1xuLy8gICB3b3JkczogJ0hlbGxvIFdvcmxkISdcbi8vIH0pLnRoZW4oZnVuY3Rpb24ob2JqZWN0KSB7XG4vLyAgIGFsZXJ0KCdMZWFuQ2xvdWQgUm9ja3MhJyk7XG4vLyB9KVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/js/app/app-leancloud.js\n");

/***/ }),

/***/ "./src/js/app/discovery.js":
/*!*********************************!*\
  !*** ./src/js/app/discovery.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nvar AV = __webpack_require__(/*! ./app-leancloud.js */ \"./src/js/app/app-leancloud.js\");\n\nvar $ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n\nvar view = {\n  el: '.discovery-main',\n  template: \"\\n    <div class=\\\"item\\\">\\n        <div class=\\\"itemCover\\\">\\n            <img src=\\\"__src__\\\" alt=\\\"\\\">\\n        </div>\\n        <div class=\\\"itemName\\\">__itemName__</div>\\n    </div>\",\n  render: function render(targetName, data) {\n    var item = this.template.replace(\"__src__\", data.src).replace(\"__itemName__\", data.itemName);\n    var $item = $(item).addClass(data.id);\n    console.log($(item));\n    console.log(data.id);\n    $(targetName).append($item);\n  }\n};\nvar model = {\n  init: function () {\n    var _init = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee() {\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              this.lastestCollection = [];\n              this.lastestSong = [];\n              _context.next = 4;\n              return this.getData();\n\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    return function init() {\n      return _init.apply(this, arguments);\n    };\n  }(),\n  getData: function () {\n    var _getData = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee3() {\n      var queryData, _queryData;\n\n      return regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _queryData = function _ref2() {\n                _queryData = _asyncToGenerator(\n                /*#__PURE__*/\n                regeneratorRuntime.mark(function _callee2(className, num) {\n                  var query, now;\n                  return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          query = new AV.Query(className);\n                          now = new Date();\n                          query.lessThanOrEqualTo('createdAt', now);\n                          query.descending('createdAt');\n                          query.limit(num);\n                          _context2.next = 7;\n                          return query.find().then(function (list) {\n                            return list;\n                          });\n\n                        case 7:\n                          return _context2.abrupt(\"return\", _context2.sent);\n\n                        case 8:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2, this);\n                }));\n                return _queryData.apply(this, arguments);\n              };\n\n              queryData = function _ref(_x, _x2) {\n                return _queryData.apply(this, arguments);\n              };\n\n              _context3.next = 4;\n              return queryData('CollectionList', 6);\n\n            case 4:\n              this.lastestCollection = _context3.sent;\n              _context3.next = 7;\n              return queryData('SongList', 12);\n\n            case 7:\n              this.lastestSong = _context3.sent;\n              console.log(this.lastestSong);\n              console.log(this.lastestCollection);\n\n            case 10:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, this);\n    }));\n\n    return function getData() {\n      return _getData.apply(this, arguments);\n    };\n  }()\n};\nvar controller = {\n  init: function () {\n    var _init2 = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee4(view, model) {\n      return regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              this.view = view;\n              this.model = model;\n              _context4.next = 4;\n              return this.model.init();\n\n            case 4:\n              this.updateView();\n              this.bindEvent();\n\n            case 6:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4, this);\n    }));\n\n    return function init(_x3, _x4) {\n      return _init2.apply(this, arguments);\n    };\n  }(),\n  updateView: function updateView() {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = this.model.lastestCollection[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var item = _step.value;\n        var target = '.discovery-main .recommandList .exhibition';\n        var data = {\n          id: item.id,\n          src: item.attributes.coverLink,\n          itemName: item.attributes.collectionName\n        };\n        if (item.attributes.cover === 'undefined' || !item.attributes.cover) data.src = 'http://pbeu96c1d.bkt.clouddn.com/2.jpg';\n        console.log(item.attributes);\n        this.view.render(target, data);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = this.model.lastestSong[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _item = _step2.value;\n        var _target = '.discovery-main .recommandSongs .exhibition';\n        var _data = {\n          id: _item.id,\n          src: _item.attributes.cover,\n          itemName: _item.attributes.name\n        };\n        if (_item.attributes.cover === 'undefined') _data.src = 'http://pbeu96c1d.bkt.clouddn.com/14.jpg';\n        console.log(_item.attributes);\n        this.view.render(_target, _data);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  },\n  bindEvent: function bindEvent() {\n    this.watchCollection();\n    this.watchSongs();\n  },\n  watchCollection: function watchCollection() {\n    var viewer = $('.collectionViewer');\n    var collection = $(this.view.el).find('.recommandList .exhibition .item');\n    collection.on('click touch', function () {\n      viewer.addClass('show');\n    });\n  },\n  watchSongs: function watchSongs() {}\n};\ncontroller.init(view, model);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvYXBwL2Rpc2NvdmVyeS5qcz82MWZjIl0sIm5hbWVzIjpbIkFWIiwicmVxdWlyZSIsIiQiLCJ2aWV3IiwiZWwiLCJ0ZW1wbGF0ZSIsInJlbmRlciIsInRhcmdldE5hbWUiLCJkYXRhIiwiaXRlbSIsInJlcGxhY2UiLCJzcmMiLCJpdGVtTmFtZSIsIiRpdGVtIiwiYWRkQ2xhc3MiLCJpZCIsImNvbnNvbGUiLCJsb2ciLCJhcHBlbmQiLCJtb2RlbCIsImluaXQiLCJsYXN0ZXN0Q29sbGVjdGlvbiIsImxhc3Rlc3RTb25nIiwiZ2V0RGF0YSIsInF1ZXJ5RGF0YSIsImNsYXNzTmFtZSIsIm51bSIsInF1ZXJ5IiwiUXVlcnkiLCJub3ciLCJEYXRlIiwibGVzc1RoYW5PckVxdWFsVG8iLCJkZXNjZW5kaW5nIiwibGltaXQiLCJmaW5kIiwidGhlbiIsImxpc3QiLCJjb250cm9sbGVyIiwidXBkYXRlVmlldyIsImJpbmRFdmVudCIsInRhcmdldCIsImF0dHJpYnV0ZXMiLCJjb3ZlckxpbmsiLCJjb2xsZWN0aW9uTmFtZSIsImNvdmVyIiwibmFtZSIsIndhdGNoQ29sbGVjdGlvbiIsIndhdGNoU29uZ3MiLCJ2aWV3ZXIiLCJjb2xsZWN0aW9uIiwib24iXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxJQUFJQSxLQUFLLG1CQUFBQyxDQUFRLHlEQUFSLENBQVQ7O0FBQ0EsSUFBSUMsSUFBSSxtQkFBQUQsQ0FBUSxvREFBUixDQUFSOztBQUVBLElBQUlFLE9BQU87QUFDUEMsTUFBSSxpQkFERztBQUVQQyx1TUFGTztBQVVQQyxRQVZPLGtCQVVBQyxVQVZBLEVBVVlDLElBVlosRUFVa0I7QUFDckIsUUFBSUMsT0FBTyxLQUFLSixRQUFMLENBQWNLLE9BQWQsQ0FBc0IsU0FBdEIsRUFBaUNGLEtBQUtHLEdBQXRDLEVBQTJDRCxPQUEzQyxDQUFtRCxjQUFuRCxFQUFtRUYsS0FBS0ksUUFBeEUsQ0FBWDtBQUNBLFFBQUlDLFFBQVFYLEVBQUVPLElB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QUFkLEVBQTZCLFlBQU07QUFDL0JGLGFBQU9sQyxRQUFQLENBQWdCLE1BQWhCO0FBRUgsS0FIRDtBQUlILEdBOUNZO0FBZ0RiaUMsWUFoRGEsd0JBZ0RBLENBRVo7QUFsRFksQ0FBakI7QUFxREFWLFdBQVdqQixJQUFYLENBQWdCakIsSUFBaEIsRUFBc0JnQixLQUF0QiIsImZpbGUiOiIuL3NyYy9qcy9hcHAvZGlzY292ZXJ5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibGV0IEFWID0gcmVxdWlyZSgnLi9hcHAtbGVhbmNsb3VkLmpzJyk7XG5sZXQgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG5sZXQgdmlldyA9IHtcbiAgICBlbDogJy5kaXNjb3ZlcnktbWFpbicsXG4gICAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwiaXRlbVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaXRlbUNvdmVyXCI+XG4gICAgICAgICAgICA8aW1nIHNyYz1cIl9fc3JjX19cIiBhbHQ9XCJcIj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJpdGVtTmFtZVwiPl9faXRlbU5hbWVfXzwvZGl2PlxuICAgIDwvZGl2PmAsXG5cbiAgICByZW5kZXIodGFyZ2V0TmFtZSwgZGF0YSkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMudGVtcGxhdGUucmVwbGFjZShcIl9fc3JjX19cIiwgZGF0YS5zcmMpLnJlcGxhY2UoXCJfX2l0ZW1OYW1lX19cIiwgZGF0YS5pdGVtTmFtZSk7XG4gICAgICAgIGxldCAkaXRlbSA9ICQoaXRlbSkuYWRkQ2xhc3MoZGF0YS5pZCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCQoaXRlbSkpXG4gICAgICAgIGNvbnNvbGUubG9nKGRhdGEuaWQpXG4gICAgICAgICQodGFyZ2V0TmFtZSkuYXBwZW5kKCRpdGVtKTtcbiAgICB9XG59XG5cbmxldCBtb2RlbCA9IHtcbiAgICBhc3luYyBpbml0KCkge1xuICAgICAgICB0aGlzLmxhc3Rlc3RDb2xsZWN0aW9uID0gW107XG4gICAgICAgIHRoaXMubGFzdGVzdFNvbmcgPSBbXTtcbiAgICAgICAgYXdhaXQgdGhpcy5nZXREYXRhKCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGdldERhdGEoKSB7XG4gICAgICAgIHRoaXMubGFzdGVzdENvbGxlY3Rpb24gPSBhd2FpdCBxdWVyeURhdGEoJ0NvbGxlY3Rpb25MaXN0JywgNik7XG4gICAgICAgIHRoaXMubGFzdGVzdFNvbmcgPSBhd2FpdCBxdWVyeURhdGEoJ1NvbmdMaXN0JywgMTIpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmxhc3Rlc3RTb25nKVxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmxhc3Rlc3RDb2xsZWN0aW9uKVxuICAgICAgICBcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gcXVlcnlEYXRhKGNsYXNzTmFtZSwgbnVtKSB7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSBuZXcgQVYuUXVlcnkoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIGxldCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgcXVlcnkubGVzc1RoYW5PckVxdWFsVG8oJ2NyZWF0ZWRBdCcsIG5vdyk7XG4gICAgICAgICAgICBxdWVyeS5kZXNjZW5kaW5nKCdjcmVhdGVkQXQnKTtcbiAgICAgICAgICAgIHF1ZXJ5LmxpbWl0KG51bSk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcXVlcnkuZmluZCgpLnRoZW4oKGxpc3QpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxubGV0IGNvbnRyb2xsZXIgPSB7XG4gICAgYXN5bmMgaW5pdCh2aWV3LCBtb2RlbCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIGF3YWl0IHRoaXMubW9kZWwuaW5pdCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKTtcbiAgICAgICAgdGhpcy5iaW5kRXZlbnQoKTtcbiAgICB9LFxuICAgIFxuICAgIHVwZGF0ZVZpZXcoKSB7XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5tb2RlbC5sYXN0ZXN0Q29sbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9ICcuZGlzY292ZXJ5LW1haW4gLnJlY29tbWFuZExpc3QgLmV4aGliaXRpb24nXG4gICAgICAgICAgICBsZXQgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICBzcmM6IGl0ZW0uYXR0cmlidXRlcy5jb3ZlckxpbmssXG4gICAgICAgICAgICAgICAgaXRlbU5hbWU6IGl0ZW0uYXR0cmlidXRlcy5jb2xsZWN0aW9uTmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0uYXR0cmlidXRlcy5jb3ZlciA9PT0gJ3VuZGVmaW5lZCcgfHwgIWl0ZW0uYXR0cmlidXRlcy5jb3ZlcikgZGF0YS5zcmMgPSAnaHR0cDovL3BiZXU5NmMxZC5ia3QuY2xvdWRkbi5jb20vMi5qcGcnO1xuICAgICAgICAgICAgY29uc29sZS5sb2coaXRlbS5hdHRyaWJ1dGVzKVxuICAgICAgICAgICAgdGhpcy52aWV3LnJlbmRlcih0YXJnZXQsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5tb2RlbC5sYXN0ZXN0U29uZykge1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9ICcuZGlzY292ZXJ5LW1haW4gLnJlY29tbWFuZFNvbmdzIC5leGhpYml0aW9uJztcbiAgICAgICAgICAgIGxldCBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgIHNyYzogaXRlbS5hdHRyaWJ1dGVzLmNvdmVyLFxuICAgICAgICAgICAgICAgIGl0ZW1OYW1lOiBpdGVtLmF0dHJpYnV0ZXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0uYXR0cmlidXRlcy5jb3ZlciA9PT0gJ3VuZGVmaW5lZCcpIGRhdGEuc3JjID0gJ2h0dHA6Ly9wYmV1OTZjMWQuYmt0LmNsb3VkZG4uY29tLzE0LmpwZyc7ICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGl0ZW0uYXR0cmlidXRlcylcbiAgICAgICAgICAgIHRoaXMudmlldy5yZW5kZXIodGFyZ2V0LCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBiaW5kRXZlbnQoKSB7XG4gICAgICAgIHRoaXMud2F0Y2hDb2xsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMud2F0Y2hTb25ncygpO1xuICAgIH0sXG5cbiAgICB3YXRjaENvbGxlY3Rpb24oKSB7XG4gICAgICAgIGxldCB2aWV3ZXIgPSAkKCcuY29sbGVjdGlvblZpZXdlcicpO1xuICAgICAgICBsZXQgY29sbGVjdGlvbiA9ICQodGhpcy52aWV3LmVsKS5maW5kKCcucmVjb21tYW5kTGlzdCAuZXhoaWJpdGlvbiAuaXRlbScpO1xuICAgICAgICBjb2xsZWN0aW9uLm9uKCdjbGljayB0b3VjaCcsICgpID0+IHtcbiAgICAgICAgICAgIHZpZXdlci5hZGRDbGFzcygnc2hvdycpO1xuICAgICAgICAgICAgXG4gICAgICAgIH0pXG4gICAgfSxcblxuICAgIHdhdGNoU29uZ3MoKSB7XG4gICAgICAgIFxuICAgIH1cbn1cblxuY29udHJvbGxlci5pbml0KHZpZXcsIG1vZGVsKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/app/discovery.js\n");

/***/ }),

/***/ "./src/js/app/switchPage.js":
/*!**********************************!*\
  !*** ./src/js/app/switchPage.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar $ = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\n\nwatchTabs();\nwatchToplaylistMenu();\nwatchPlayControllerMenu();\nwatchReturnButton();\n$('body')[0].addEventListener('touchmove', function (e) {\n  e.preventDefault();\n}, {\n  passive: true\n});\n\nfunction watchTabs() {\n  watchClickTabs('.discovery');\n  watchClickTabs('.user');\n  watchClickTabs('.search');\n  watchTouchTabs();\n\n  function watchClickTabs(el) {\n    $('.tabPanel').find(el).on('click', function (e) {\n      $(e.currentTarget).addClass('active').siblings().removeClass('active');\n      $('main').find(el + '-main').addClass('show').siblings().removeClass('show');\n    });\n  }\n\n  function watchTouchTabs() {\n    $('main').find('.discovery-main').on('touchstart', function (e) {\n      e.stopPropagation();\n      var startX = e.originalEvent.changedTouches[0].pageX;\n      var startY = e.originalEvent.changedTouches[0].pageY;\n      $(e.currentTarget).one('touchend', function (ee) {\n        var endX = ee.originalEvent.changedTouches[0].pageX;\n        var endY = ee.originalEvent.changedTouches[0].pageY;\n\n        if (startX - endX > 100 && endY - startY < startX - endX) {\n          $(e.currentTarget).removeClass('show').siblings('.user-main').addClass('show');\n          $('.tabPanel').find('.discovery').removeClass('active').siblings('.user').addClass('active');\n        }\n      });\n    });\n    $('main').find('.user-main').on('touchstart', function (e) {\n      e.stopPropagation();\n      var startX = e.originalEvent.changedTouches[0].pageX;\n      var startY = e.originalEvent.changedTouches[0].pageY;\n      $(e.currentTarget).one('touchend', function (ee) {\n        var endX = ee.originalEvent.changedTouches[0].pageX;\n        var endY = ee.originalEvent.changedTouches[0].pageY;\n\n        if (startX - endX > 100 && endY - startY < startX - endX) {\n          $(e.currentTarget).removeClass('show').siblings('.search-main').addClass('show');\n          $('.tabPanel').find('.user').removeClass('active').siblings('.search').addClass('active');\n        } else if (endX - startX > 100 && startY - endY < endX - startX) {\n          $(e.currentTarget).removeClass('show').siblings('.discovery-main').addClass('show');\n          $('.tabPanel').find('.user').removeClass('active').siblings('.discovery').addClass('active');\n        }\n      });\n    });\n    $('main').find('.search-main').on('touchstart', function (e) {\n      e.stopPropagation();\n      var startX = e.originalEvent.changedTouches[0].pageX;\n      var startY = e.originalEvent.changedTouches[0].pageY;\n      $(e.currentTarget).one('touchend', function (ee) {\n        var endX = ee.originalEvent.changedTouches[0].pageX;\n        var endY = ee.originalEvent.changedTouches[0].pageY;\n\n        if (endX - startX > 100 && startY - endY < endX - startX) {\n          $(e.currentTarget).removeClass('show').siblings('.user-main').addClass('show');\n          $('.tabPanel').find('.search').removeClass('active').siblings('.user').addClass('active');\n        }\n      });\n    });\n  }\n}\n\nfunction watchToplaylistMenu() {\n  $('footer').find('.toplaylistButton').on('click', function () {\n    $('footer .toplaylistWrapper').addClass('show');\n  });\n  $('footer .toplaylistWrapper .shadowArea').on('click', function (e) {\n    $(e.currentTarget).parent().removeClass('show');\n  });\n}\n\nfunction watchPlayControllerMenu() {\n  $('footer .songInformation').on('click', function () {\n    $('.playController').addClass('show');\n  });\n}\n\nfunction watchReturnButton() {\n  $('.playController > .head > .returnButton').on('click', function () {\n    $('.playController').removeClass('show');\n  });\n  $('.collectionViewer .collectionHead > svg').on('click', function () {\n    $('.collectionViewer').removeClass('show');\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvYXBwL3N3aXRjaFBhZ2UuanM/NWQ0MyJdLCJuYW1lcyI6WyIkIiwicmVxdWlyZSIsIndhdGNoVGFicyIsIndhdGNoVG9wbGF5bGlzdE1lbnUiLCJ3YXRjaFBsYXlDb250cm9sbGVyTWVudSIsIndhdGNoUmV0dXJuQnV0dG9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInBhc3NpdmUiLCJ3YXRjaENsaWNrVGFicyIsIndhdGNoVG91Y2hUYWJzIiwiZWwiLCJmaW5kIiwib24iLCJjdXJyZW50VGFyZ2V0IiwiYWRkQ2xhc3MiLCJzaWJsaW5ncyIsInJlbW92ZUNsYXNzIiwic3RvcFByb3BhZ2F0aW9uIiwic3RhcnRYIiwib3JpZ2luYWxFdmVudCIsImNoYW5nZWRUb3VjaGVzIiwicGFnZVgiLCJzdGFydFkiLCJwYWdlWSIsIm9uZSIsImVlIiwiZW5kWCIsImVuZFkiLCJwYXJlbnQiXSwibWFwcGluZ3MiOiI7O0FBQUEsSUFBSUEsSUFBSSxtQkFBQUMsQ0FBUSxvREFBUixDQUFSOztBQUNBQztBQUNBQztBQUNBQztBQUNBQztBQUVBTCxFQUFFLE1BQUYsRUFBVSxDQUFWLEVBQWFNLGdCQUFiLENBQThCLFdBQTlCLEVBQTJDLFVBQUNDLENBQUQsRUFBSztBQUM1Q0EsSUFBRUMsY0FBRjtBQUNILENBRkQsRUFFRTtBQUFDQyxXQUFRO0FBQVQsQ0FGRjs7QUFJQSxTQUFTUCxTQUFULEdBQXFCO0FBQ2pCUSxpQkFBZSxZQUFmO0FBQ0FBLGlCQUFlLE9BQWY7QUFDQUEsaUJBQWUsU0FBZjtBQUNBQzs7QUFFQSxXQUFTRCxjQUFULENBQXdCRSxFQUF4QixFQUE0QjtBQUN4QlosTUFBRSxXQUFGLEVBQWVhLElBQWYsQ0FBb0JELEVBQXBCLEVBQXdCRSxFQUF4QixDQUEyQixPQUEzQixFQUFvQyxVQUFDUCxDQUFELEVBQU87QUFDdkNQLFFBQUVPLEVBQUVRLGFBQUosRUFBbUJDLFFBQW5CLENBQTRCLFFB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QUFyRCxDQUE4RCxPQUE5RCxFQUF1RUQsUUFBdkUsQ0FBZ0YsUUFBaEY7QUFDSDtBQUNKLE9BUEQ7QUFRSCxLQVpEO0FBYUg7QUFDSjs7QUFFRCxTQUFTYixtQkFBVCxHQUErQjtBQUMzQkgsSUFBRSxRQUFGLEVBQVlhLElBQVosQ0FBaUIsbUJBQWpCLEVBQXNDQyxFQUF0QyxDQUF5QyxPQUF6QyxFQUFrRCxZQUFNO0FBQ3BEZCxNQUFFLDJCQUFGLEVBQStCZ0IsUUFBL0IsQ0FBd0MsTUFBeEM7QUFDSCxHQUZEO0FBSUFoQixJQUFFLHVDQUFGLEVBQTJDYyxFQUEzQyxDQUE4QyxPQUE5QyxFQUF1RCxVQUFDUCxDQUFELEVBQU87QUFDMURQLE1BQUVPLEVBQUVRLGFBQUosRUFBbUJlLE1BQW5CLEdBQTRCWixXQUE1QixDQUF3QyxNQUF4QztBQUNILEdBRkQ7QUFHSDs7QUFFRCxTQUFTZCx1QkFBVCxHQUFtQztBQUMvQkosSUFBRSx5QkFBRixFQUE2QmMsRUFBN0IsQ0FBZ0MsT0FBaEMsRUFBeUMsWUFBTTtBQUMzQ2QsTUFBRSxpQkFBRixFQUFxQmdCLFFBQXJCLENBQThCLE1BQTlCO0FBQ0gsR0FGRDtBQUdIOztBQUVELFNBQVNYLGlCQUFULEdBQTZCO0FBQ3pCTCxJQUFFLHlDQUFGLEVBQTZDYyxFQUE3QyxDQUFnRCxPQUFoRCxFQUF5RCxZQUFNO0FBQzNEZCxNQUFFLGlCQUFGLEVBQXFCa0IsV0FBckIsQ0FBaUMsTUFBakM7QUFDSCxHQUZEO0FBR0FsQixJQUFFLHlDQUFGLEVBQTZDYyxFQUE3QyxDQUFnRCxPQUFoRCxFQUF5RCxZQUFNO0FBQzNEZCxNQUFFLG1CQUFGLEVBQXVCa0IsV0FBdkIsQ0FBbUMsTUFBbkM7QUFDSCxHQUZEO0FBR0giLCJmaWxlIjoiLi9zcmMvanMvYXBwL3N3aXRjaFBhZ2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xud2F0Y2hUYWJzKCk7XG53YXRjaFRvcGxheWxpc3RNZW51KCk7XG53YXRjaFBsYXlDb250cm9sbGVyTWVudSgpO1xud2F0Y2hSZXR1cm5CdXR0b24oKTtcblxuJCgnYm9keScpWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIChlKT0+e1xuICAgIGUucHJldmVudERlZmF1bHQoKVxufSx7cGFzc2l2ZTp0cnVlfSk7XG5cbmZ1bmN0aW9uIHdhdGNoVGFicygpIHtcbiAgICB3YXRjaENsaWNrVGFicygnLmRpc2NvdmVyeScpO1xuICAgIHdhdGNoQ2xpY2tUYWJzKCcudXNlcicpO1xuICAgIHdhdGNoQ2xpY2tUYWJzKCcuc2VhcmNoJyk7XG4gICAgd2F0Y2hUb3VjaFRhYnMoKTtcblxuICAgIGZ1bmN0aW9uIHdhdGNoQ2xpY2tUYWJzKGVsKSB7XG4gICAgICAgICQoJy50YWJQYW5lbCcpLmZpbmQoZWwpLm9uKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgICAgICAkKGUuY3VycmVudFRhcmdldCkuYWRkQ2xhc3MoJ2FjdGl2ZScpLnNpYmxpbmdzKCkucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgJCgnbWFpbicpLmZpbmQoZWwgKyAnLW1haW4nKS5hZGRDbGFzcygnc2hvdycpLnNpYmxpbmdzKCkucmVtb3ZlQ2xhc3MoJ3Nob3cnKTtcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YXRjaFRvdWNoVGFicygpIHtcbiAgICAgICAgJCgnbWFpbicpLmZpbmQoJy5kaXNjb3ZlcnktbWFpbicpLm9uKCd0b3VjaHN0YXJ0JywgKGUpID0+IHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBsZXQgc3RhcnRYID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgbGV0IHN0YXJ0WSA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5vbmUoJ3RvdWNoZW5kJywgKGVlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFggPSBlZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgICAgIGxldCBlbmRZID0gZWUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRYIC0gZW5kWCA+IDEwMCAmJiBlbmRZIC0gc3RhcnRZIDwgc3RhcnRYIC0gZW5kWCkge1xuICAgICAgICAgICAgICAgICAgICAkKGUuY3VycmVudFRhcmdldCkucmVtb3ZlQ2xhc3MoJ3Nob3cnKS5zaWJsaW5ncygnLnVzZXItbWFpbicpLmFkZENsYXNzKCdzaG93Jyk7XG4gICAgICAgICAgICAgICAgICAgICQoJy50YWJQYW5lbCcpLmZpbmQoJy5kaXNjb3ZlcnknKS5yZW1vdmVDbGFzcygnYWN0aXZlJykuc2libGluZ3MoJy51c2VyJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgICQoJ21haW4nKS5maW5kKCcudXNlci1tYWluJykub24oJ3RvdWNoc3RhcnQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGxldCBzdGFydFggPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICAgICAgICBsZXQgc3RhcnRZID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLm9uZSgndG91Y2hlbmQnLCAoZWUpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kWCA9IGVlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFkgPSBlZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydFggLSBlbmRYID4gMTAwICYmIGVuZFkgLSBzdGFydFkgPCBzdGFydFggLSBlbmRYKSB7XG4gICAgICAgICAgICAgICAgICAgICQoZS5jdXJyZW50VGFyZ2V0KS5yZW1vdmVDbGFzcygnc2hvdycpLnNpYmxpbmdzKCcuc2VhcmNoLW1haW4nKS5hZGRDbGFzcygnc2hvdycpO1xuICAgICAgICAgICAgICAgICAgICAkKCcudGFiUGFuZWwnKS5maW5kKCcudXNlcicpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKS5zaWJsaW5ncygnLnNlYXJjaCcpLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVuZFggLSBzdGFydFggPiAxMDAgJiYgc3RhcnRZIC0gZW5kWSA8IGVuZFggLSBzdGFydFgpIHtcbiAgICAgICAgICAgICAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLnJlbW92ZUNsYXNzKCdzaG93Jykuc2libGluZ3MoJy5kaXNjb3ZlcnktbWFpbicpLmFkZENsYXNzKCdzaG93Jyk7XG4gICAgICAgICAgICAgICAgICAgICQoJy50YWJQYW5lbCcpLmZpbmQoJy51c2VyJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpLnNpYmxpbmdzKCcuZGlzY292ZXJ5JykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgICQoJ21haW4nKS5maW5kKCcuc2VhcmNoLW1haW4nKS5vbigndG91Y2hzdGFydCcsIChlKSA9PiB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0WCA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgIGxldCBzdGFydFkgPSBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICAgICAgICAkKGUuY3VycmVudFRhcmdldCkub25lKCd0b3VjaGVuZCcsIChlZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBlbmRYID0gZWUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgICAgICBsZXQgZW5kWSA9IGVlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZFggLSBzdGFydFggPiAxMDAgJiYgc3RhcnRZIC0gZW5kWSA8IGVuZFggLSBzdGFydFgpIHtcbiAgICAgICAgICAgICAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLnJlbW92ZUNsYXNzKCdzaG93Jykuc2libGluZ3MoJy51c2VyLW1haW4nKS5hZGRDbGFzcygnc2hvdycpO1xuICAgICAgICAgICAgICAgICAgICAkKCcudGFiUGFuZWwnKS5maW5kKCcuc2VhcmNoJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpLnNpYmxpbmdzKCcudXNlcicpLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHdhdGNoVG9wbGF5bGlzdE1lbnUoKSB7XG4gICAgJCgnZm9vdGVyJykuZmluZCgnLnRvcGxheWxpc3RCdXR0b24nKS5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICQoJ2Zvb3RlciAudG9wbGF5bGlzdFdyYXBwZXInKS5hZGRDbGFzcygnc2hvdycpO1xuICAgIH0pXG5cbiAgICAkKCdmb290ZXIgLnRvcGxheWxpc3RXcmFwcGVyIC5zaGFkb3dBcmVhJykub24oJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgJChlLmN1cnJlbnRUYXJnZXQpLnBhcmVudCgpLnJlbW92ZUNsYXNzKCdzaG93Jyk7XG4gICAgfSlcbn1cblxuZnVuY3Rpb24gd2F0Y2hQbGF5Q29udHJvbGxlck1lbnUoKSB7XG4gICAgJCgnZm9vdGVyIC5zb25nSW5mb3JtYXRpb24nKS5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICQoJy5wbGF5Q29udHJvbGxlcicpLmFkZENsYXNzKCdzaG93Jyk7XG4gICAgfSlcbn1cblxuZnVuY3Rpb24gd2F0Y2hSZXR1cm5CdXR0b24oKSB7XG4gICAgJCgnLnBsYXlDb250cm9sbGVyID4gLmhlYWQgPiAucmV0dXJuQnV0dG9uJykub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAkKCcucGxheUNvbnRyb2xsZXInKS5yZW1vdmVDbGFzcygnc2hvdycpO1xuICAgIH0pXG4gICAgJCgnLmNvbGxlY3Rpb25WaWV3ZXIgLmNvbGxlY3Rpb25IZWFkID4gc3ZnJykub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAkKCcuY29sbGVjdGlvblZpZXdlcicpLnJlbW92ZUNsYXNzKCdzaG93Jyk7XG4gICAgfSlcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/js/app/switchPage.js\n");

/***/ })

/******/ });